name: HumanEval_115_max_fill
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular\
  \ grid of wells. Each row represents a single well,\n// and each 1 in a row represents\
  \ a single unit of water.\n// Each well has a corresponding bucket that can be used\
  \ to extract water from it, \n// and all buckets have the same capacity.\n// Your\
  \ task is to use the buckets to empty the wells.\n// Output the number of times\
  \ you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
  \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,\
  \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,\
  \ (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
  \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
  \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,\
  \ (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),\
  \ (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
  \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})),\
  \ (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <=\
  \ grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0\
  \ | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid,\
  \ long capacity) {\n"
tests: "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
  \ (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1,\
  \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,\
  \ (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
  \ (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0,\
  \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1,\
  \ (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})),\
  \ (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0,\
  \ (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})),\
  \ (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1,\
  \ (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1,\
  \ (long)1, (long)1})})), (9)) == (2));\n}\n"
completions: ["    long rows = grid.size();\n    long cols = grid[0].size();\n   \
    \ long ans = 0;\n    for(long i = 0; i < rows; i++) {\n        for(long j = 0;\
    \ j < cols; j++) {\n            if(grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for(long k = i; k < rows; k++) {\n              \
    \      if(grid[k][j] == 1) {\n                        grid[k][j] = 0;\n      \
    \              } else {\n                        break;\n                    }\n\
    \                }\n            }\n        }\n    }\n    return ans;", "    long\
    \ count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        for(int j = 0;\
    \ j < grid[i].size(); j++){\n            if(grid[i][j] == 1){\n              \
    \  count++;\n            }\n        }\n    }\n    return count / capacity;", " \
    \   // your code here\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for(long i = 0; i < n; i++){\n        long cnt = 0;\n\
    \        for(long j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n    \
    \            cnt++;\n            }\n        }\n        ans += cnt/capacity;\n\
    \        if(cnt%capacity != 0){\n            ans++;\n        }\n    }\n    return\
    \ ans;", "    // your code here\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for(long i = 0; i < n; i++){\n        for(long j = 0;\
    \ j < m; j++){\n            if(grid[i][j] == 1){\n                ans += capacity;\n\
    \            }\n        }\n    }\n    return ans;", "    // your code here\n \
    \   long n = grid.size();\n    long m = grid[0].size();\n    long ans = 0;\n \
    \   for(long i = 0; i < n; i++){\n        for(long j = 0; j < m; j++){\n     \
    \       if(grid[i][j] == 1){\n                ans += capacity;\n            }\n\
    \        }\n    }\n    return ans;", "    long n = grid.size();\n    long m =\
    \ grid[0].size();\n    long ans = 0;\n    for (long i = 0; i < n; i++) {\n   \
    \     long sum = 0;\n        for (long j = 0; j < m; j++) {\n            sum +=\
    \ grid[i][j];\n        }\n        ans += sum / capacity;\n        if (sum % capacity\
    \ != 0) {\n            ans++;\n        }\n    }\n    return ans;", "    // your\
    \ code here\n    long n = grid.size();\n    long m = grid[0].size();\n    long\
    \ ans = 0;\n    for(long i = 0; i < n; i++){\n        for(long j = 0; j < m; j++){\n\
    \            if(grid[i][j] == 1){\n                ans += capacity;\n        \
    \    }\n        }\n    }\n    return ans;", "    long n = grid.size();\n    long\
    \ m = grid[0].size();\n    long ans = 0;\n    for (long i = 0; i < n; i++) {\n\
    \        long sum = 0;\n        for (long j = 0; j < m; j++) {\n            sum\
    \ += grid[i][j];\n        }\n        ans += std::max(0l, capacity - sum);\n  \
    \  }\n    return ans;", "    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j =\
    \ 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans +=\
    \ capacity;\n                for (long k = i; k < n; k++) {\n                \
    \    for (long l = j; l < m; l++) {\n                        if (grid[k][l] ==\
    \ 1) {\n                            grid[k][l] = 0;\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return ans;", "    // your code here\n    long count = 0;\n    for(int i =\
    \ 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size(); j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n            }\n \
    \       }\n    }\n    return count/capacity;", "    long result = 0;\n    for\
    \ (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size();\
    \ j++) {\n            if (grid[i][j] == 1) {\n                result += capacity;\n\
    \                for (int k = i; k < grid.size(); k++) {\n                   \
    \ if (grid[k][j] == 1) {\n                        grid[k][j] = 0;\n          \
    \          } else {\n                        break;\n                    }\n \
    \               }\n            }\n        }\n    }\n    return result;", "   \
    \ // your code here\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j\
    \ < m; j++){\n            if(grid[i][j] == 1){\n                ans += capacity;\n\
    \            }\n        }\n    }\n    return ans;", "    long result = 0;\n  \
    \  int n = grid.size();\n    int m = grid[0].size();\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                result += capacity;\n                for (int k = i;\
    \ k < n; k++) {\n                    for (int l = j; l < m; l++) {\n         \
    \               if (grid[k][l] == 1) {\n                            grid[k][l]\
    \ = 0;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;", "    long count = 0;\n\
    \    for(int i = 0; i < grid.size(); i++){\n        for(int j = 0; j < grid[i].size();\
    \ j++){\n            if(grid[i][j] == 1){\n                count++;\n        \
    \    }\n        }\n    }\n    return count * capacity;", "    long n = grid.size();\n\
    \    long m = grid[0].size();\n    long ans = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n\
    \                ans++;\n                grid[i][j] = 0;\n                if (i\
    \ + 1 < n && grid[i + 1][j] == 1) {\n                    ans++;\n            \
    \        grid[i + 1][j] = 0;\n                }\n                if (j + 1 < m\
    \ && grid[i][j + 1] == 1) {\n                    ans++;\n                    grid[i][j\
    \ + 1] = 0;\n                }\n            }\n        }\n    }\n    return ans;",
  "    long count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        for(int\
    \ j = 0; j < grid[i].size(); j++){\n            if(grid[i][j] == 1){\n       \
    \         count += capacity;\n            }\n        }\n    }\n    return count;",
  "    // your code here\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    long ans = 0;\n    for(long i = 0; i < n; i++){\n        long sum = 0;\n\
    \        for(long j = 0; j < m; j++){\n            sum += grid[i][j];\n      \
    \  }\n        ans += std::ceil((double)sum/capacity);\n    }\n    return ans;",
  "    long rows = grid.size();\n    long cols = grid[0].size();\n    long total =\
    \ 0;\n    for (long i = 0; i < rows; i++) {\n        long sum = 0;\n        for\
    \ (long j = 0; j < cols; j++) {\n            sum += grid[i][j];\n        }\n \
    \       total += std::min(sum, capacity);\n    }\n    return total;", "    long\
    \ count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        for(int j = 0;\
    \ j < grid[i].size(); j++){\n            if(grid[i][j] == 1){\n              \
    \  count++;\n            }\n        }\n    }\n    return count/capacity;", " \
    \   long n = grid.size();\n    long m = grid[0].size();\n    long ans = 0;\n \
    \   for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n \
    \           if (grid[i][j] == 1) {\n                grid[i][j] = 0;\n        \
    \        ans++;\n                std::queue<std::pair<long, long>> q;\n      \
    \          q.push({i, j});\n                while (!q.empty()) {\n           \
    \         auto p = q.front();\n                    q.pop();\n                \
    \    long x = p.first;\n                    long y = p.second;\n             \
    \       if (x > 0 && grid[x - 1][y] == 1) {\n                        grid[x -\
    \ 1][y] = 0;\n                        q.push({x - 1, y});\n                  \
    \  }\n                    if (x < n - 1 && grid[x + 1][y] == 1) {\n          \
    \              grid[x + 1][y] = 0;\n                        q.push({x + 1, y});\n\
    \                    }\n                    if (y > 0 && grid[x][y - 1] == 1)\
    \ {\n                        grid[x][y - 1] = 0;\n                        q.push({x,\
    \ y - 1});\n                    }\n                    if (y < m - 1 && grid[x][y\
    \ + 1] == 1) {\n                        grid[x][y + 1] = 0;\n                \
    \        q.push({x, y + 1});\n                    }\n                }\n     \
    \       }\n        }\n    }\n    return ans;"]
stop_tokens:
- "\n}"
