language: cpp
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool all_lower = true;\n\
    \    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first.size() == 0) return false;\n        if(it->first[0]\
    \ >= 'a' && it->first[0] <= 'z') all_upper = false;\n        if(it->first[0] >=\
    \ 'A' && it->first[0] <= 'Z') all_lower = false;\n    }\n    return all_lower\
    \ || all_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfyid9i7i.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpfyid9i7i.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpfyid9i7i.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpfyid9i7i.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpfyid9i7i.cpp: In function 'int main()':\n/tmp/tmpfyid9i7i.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfyid9i7i.cpp:2:\n/tmp/tmpfyid9i7i.cpp:30:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpfyid9i7i.cpp:30:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpfyid9i7i.cpp:30:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpfyid9i7i.cpp:30:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpfyid9i7i.cpp:30:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpfyid9i7i.cpp:30:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpf"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower=true;\n\
    \    bool is_upper=true;\n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(isupper(it->first[0]))\n            is_lower=false;\n        else\n\
    \            is_upper=false;\n    }\n    return (is_lower || is_upper);\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk1pxanio.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpk1pxanio.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++){\n         \
    \     ^\n/tmp/tmpk1pxanio.cpp:22:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++){\n                              ^\n/tmp/tmpk1pxanio.cpp:22:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmpk1pxanio.cpp: In function\
    \ 'int main()':\n/tmp/tmpk1pxanio.cpp:31:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk1pxanio.cpp:2:\n/tmp/tmpk1pxanio.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpk1pxanio.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpk1pxanio.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpk1pxanio.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpk1pxanio.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpk1pxanio.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpk1pxanio.cpp:32:94"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(isupper(it->first[0]))\n            is_upper\
    \ = true;\n        else if(islower(it->first[0]))\n            is_lower = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps25vukj5.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmps25vukj5.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmps25vukj5.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmps25vukj5.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmps25vukj5.cpp: In function 'int main()':\n/tmp/tmps25vukj5.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps25vukj5.cpp:2:\n/tmp/tmps25vukj5.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmps25vukj5.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmps25vukj5.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmps25vukj5.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmps25vukj5.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmps25vukj5.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmps"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool lower = true;\n  \
    \  bool upper = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(islower(it->first[0])) upper = false;\n        if(isupper(it->first[0]))\
    \ lower = false;\n    }\n    return lower || upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp56o65h1n.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp56o65h1n.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp56o65h1n.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp56o65h1n.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp56o65h1n.cpp: In function 'int main()':\n/tmp/tmp56o65h1n.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp56o65h1n.cpp:2:\n/tmp/tmp56o65h1n.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp56o65h1n.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp56o65h1n.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp56o65h1n.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp56o65h1n.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp56o65h1n.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp5"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        else is_lower\
    \ = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph0lcpkq4.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmph0lcpkq4.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmph0lcpkq4.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmph0lcpkq4.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmph0lcpkq4.cpp: In function 'int main()':\n/tmp/tmph0lcpkq4.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph0lcpkq4.cpp:2:\n/tmp/tmph0lcpkq4.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmph0lcpkq4.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmph0lcpkq4.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph0lcpkq4.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmph0lcpkq4.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmph0lcpkq4.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmph"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(islower(it->first[0])) is_lower = true;\n        if(isupper(it->first[0]))\
    \ is_upper = true;\n    }\n    return is_lower ^ is_upper;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpusdmgjjk.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpusdmgjjk.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpusdmgjjk.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpusdmgjjk.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpusdmgjjk.cpp: In function 'int main()':\n/tmp/tmpusdmgjjk.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpusdmgjjk.cpp:2:\n/tmp/tmpusdmgjjk.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpusdmgjjk.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpusdmgjjk.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpusdmgjjk.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpusdmgjjk.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpusdmgjjk.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpu"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower =\
    \ true;\n    for(auto i:dict){\n        if(isupper(i.first[0])){\n           \
    \ is_lower = false;\n            break;\n        }\n    }\n    for(auto i:dict){\n\
    \        if(is_lower){\n            if(isupper(i.first[0]))\n                return\
    \ false;\n        }\n        else{\n            if(islower(i.first[0]))\n    \
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpykarq2qk.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpykarq2qk.cpp:21:14: error: 'i' does not\
    \ name a type\n     for(auto i:dict){\n              ^\n/tmp/tmpykarq2qk.cpp:27:5:\
    \ error: expected ';' before 'for'\n     for(auto i:dict){\n     ^\n/tmp/tmpykarq2qk.cpp:27:5:\
    \ error: expected primary-expression before 'for'\n/tmp/tmpykarq2qk.cpp:27:5:\
    \ error: expected ';' before 'for'\n/tmp/tmpykarq2qk.cpp:27:5: error: expected\
    \ primary-expression before 'for'\n/tmp/tmpykarq2qk.cpp:27:5: error: expected\
    \ ')' before 'for'\n/tmp/tmpykarq2qk.cpp:27:14: error: 'i' does not name a type\n\
    \     for(auto i:dict){\n              ^\n/tmp/tmpykarq2qk.cpp:37:5: error: expected\
    \ ';' before 'return'\n     return true;\n     ^\n/tmp/tmpykarq2qk.cpp:37:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmpykarq2qk.cpp:37:5: error:\
    \ expected ';' before 'return'\n/tmp/tmpykarq2qk.cpp:37:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpykarq2qk.cpp:37:5: error: expected ')' before 'return'\n\
    /tmp/tmpykarq2qk.cpp: In function 'int main()':\n/tmp/tmpykarq2qk.cpp:40:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpykarq2qk.cpp:2:\n/tmp/tmpykarq2qk.cpp:41:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpykarq2qk.cpp:41:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n  if (dict.size() == 0) {\n    return false;\n  }\n  bool all_lower\
    \ = true;\n  bool all_upper = true;\n  for (auto it = dict.begin(); it != dict.end();\
    \ it++) {\n    if (it->first.length() == 0) {\n      return false;\n    }\n  \
    \  if (it->first[0] < 'a' || it->first[0] > 'z') {\n      all_lower = false;\n\
    \    }\n    if (it->first[0] < 'A' || it->first[0] > 'Z') {\n      all_upper =\
    \ false;\n    }\n  }\n  return all_lower || all_upper;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0mickw8f.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp0mickw8f.cpp:23:13: error: 'it' does not\
    \ name a type\n   for (auto it = dict.begin(); it != dict.end(); it++) {\n   \
    \          ^\n/tmp/tmp0mickw8f.cpp:23:32: error: expected ';' before 'it'\n  \
    \ for (auto it = dict.begin(); it != dict.end(); it++) {\n                   \
    \             ^\n/tmp/tmp0mickw8f.cpp:23:32: error: 'it' was not declared in this\
    \ scope\n/tmp/tmp0mickw8f.cpp: In function 'int main()':\n/tmp/tmp0mickw8f.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0mickw8f.cpp:2:\n/tmp/tmp0mickw8f.cpp:38:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp0mickw8f.cpp:38:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp0mickw8f.cpp:38:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0mickw8f.cpp:38:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp0mickw8f.cpp:38:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp0mickw8f.cpp:38:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp0mick"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool flag=true;\n\
    \    for(auto it=dict.begin();it!=dict.end();it++){\n        if(islower(it->first[0])){\n\
    \            for(int i=0;i<it->first.length();i++){\n                if(!islower(it->first[i])){\n\
    \                    flag=false;\n                    break;\n               \
    \ }\n            }\n        }\n        else if(isupper(it->first[0])){\n     \
    \       for(int i=0;i<it->first.length();i++){\n                if(!isupper(it->first[i])){\n\
    \                    flag=false;\n                    break;\n               \
    \ }\n            }\n        }\n        else{\n            flag=false;\n      \
    \      break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4fxnpd1c.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp4fxnpd1c.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++){\n         \
    \     ^\n/tmp/tmp4fxnpd1c.cpp:21:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++){\n                              ^\n/tmp/tmp4fxnpd1c.cpp:21:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmp4fxnpd1c.cpp: In function\
    \ 'int main()':\n/tmp/tmp4fxnpd1c.cpp:46:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4fxnpd1c.cpp:2:\n/tmp/tmp4fxnpd1c.cpp:47:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp4fxnpd1c.cpp:47:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp4fxnpd1c.cpp:47:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp4fxnpd1c.cpp:47:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp4fxnpd1c.cpp:47:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp4fxnpd1c.cpp:47:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp4fxnpd1c.cpp:47:94"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    bool is_lower =\
    \ true;\n    bool is_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            is_upper = false;\n\
    \        if(!islower(it->first[0]))\n            is_lower = false;\n    }\n  \
    \  return is_lower || is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq2xez1zj.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpq2xez1zj.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpq2xez1zj.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpq2xez1zj.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpq2xez1zj.cpp: In function 'int main()':\n/tmp/tmpq2xez1zj.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq2xez1zj.cpp:2:\n/tmp/tmpq2xez1zj.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpq2xez1zj.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpq2xez1zj.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpq2xez1zj.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpq2xez1zj.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpq2xez1zj.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpq"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = true;\n  \
    \  bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(!isupper(it->first[0])) upper = false;\n        if(!islower(it->first[0]))\
    \ lower = false;\n    }\n    return upper || lower;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbkwuz7aa.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpbkwuz7aa.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpbkwuz7aa.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpbkwuz7aa.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpbkwuz7aa.cpp: In function 'int main()':\n/tmp/tmpbkwuz7aa.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbkwuz7aa.cpp:2:\n/tmp/tmpbkwuz7aa.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpbkwuz7aa.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpbkwuz7aa.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpbkwuz7aa.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpbkwuz7aa.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpbkwuz7aa.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpb"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_upper = false;\n\
    \    bool is_lower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        if(islower(it->first[0]))\
    \ is_lower = true;\n    }\n    return is_upper ^ is_lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3igts6fu.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3igts6fu.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3igts6fu.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3igts6fu.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3igts6fu.cpp: In function 'int main()':\n/tmp/tmp3igts6fu.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3igts6fu.cpp:2:\n/tmp/tmp3igts6fu.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3igts6fu.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3igts6fu.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3igts6fu.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3igts6fu.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3igts6fu.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_upper = false;\n\
    \    bool is_lower = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(isupper(it->first[0])) is_upper = true;\n        if(islower(it->first[0]))\
    \ is_lower = true;\n    }\n    return is_upper ^ is_lower;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3igts6fu.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp3igts6fu.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmp3igts6fu.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmp3igts6fu.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp3igts6fu.cpp: In function 'int main()':\n/tmp/tmp3igts6fu.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3igts6fu.cpp:2:\n/tmp/tmp3igts6fu.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp3igts6fu.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp3igts6fu.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3igts6fu.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp3igts6fu.cpp:29:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp3igts6fu.cpp:29:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmp3"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgzvws4or.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpgzvws4or.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpgzvws4or.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpgzvws4or.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpgzvws4or.cpp: In function 'int main()':\n/tmp/tmpgzvws4or.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgzvws4or.cpp:2:\n/tmp/tmpgzvws4or.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpgzvws4or.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpgzvws4or.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgzvws4or.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgzvws4or.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpgzvws4or.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size()==0)\n        return false;\n    std::map<std::string,std::string>::iterator\
    \ it;\n    bool flag=true;\n    for(it=dict.begin();it!=dict.end();it++){\n  \
    \      if(it->first[0]>='a' && it->first[0]<='z'){\n            for(int i=0;i<it->first.length();i++){\n\
    \                if(it->first[i]<'a' || it->first[i]>'z'){\n                 \
    \   flag=false;\n                    break;\n                }\n            }\n\
    \        }\n        else if(it->first[0]>='A' && it->first[0]<='Z'){\n       \
    \     for(int i=0;i<it->first.length();i++){\n                if(it->first[i]<'A'\
    \ || it->first[i]>'Z'){\n                    flag=false;\n                   \
    \ break;\n                }\n            }\n        }\n        else{\n       \
    \     flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpotczp2tk.cpp: In function 'int main()':\n/tmp/tmpotczp2tk.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpotczp2tk.cpp:2:\n/tmp/tmpotczp2tk.cpp:48:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpotczp2tk.cpp:48:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpotczp2tk.cpp:48:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpotczp2tk.cpp:48:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpotczp2tk.cpp:48:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpotczp2tk.cpp:48:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpotczp2tk.cpp:48:94: note:\
    \ candidates are:\nIn file included from /usr/include/c++/4.8.2/map:61:0,\n  \
    \               from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:80,\n\
    \                 from /tmp/tmpotczp2tk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_map.h:241:9:\
    \ note: template<class _InputIterator> std::map<_Key, _Tp, _Compare, _Alloc>::map(_InputIterator,\
    \ _InputIterator, const _Compare&, const allocator_type&)\n         map(_InputIterator\
    \ __first, _InputIterator __last"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgzvws4or.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpgzvws4or.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpgzvws4or.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpgzvws4or.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpgzvws4or.cpp: In function 'int main()':\n/tmp/tmpgzvws4or.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgzvws4or.cpp:2:\n/tmp/tmpgzvws4or.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpgzvws4or.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpgzvws4or.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgzvws4or.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgzvws4or.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpgzvws4or.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool upper = true;\n  \
    \  bool lower = true;\n    for(auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if(it->first[0] >= 'a' && it->first[0] <= 'z') {\n            upper\
    \ = false;\n        } else if(it->first[0] >= 'A' && it->first[0] <= 'Z') {\n\
    \            lower = false;\n        } else {\n            return false;\n   \
    \     }\n    }\n    return upper || lower;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvy8xjjo3.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpvy8xjjo3.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpvy8xjjo3.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpvy8xjjo3.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpvy8xjjo3.cpp: In function 'int main()':\n/tmp/tmpvy8xjjo3.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvy8xjjo3.cpp:2:\n/tmp/tmpvy8xjjo3.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpvy8xjjo3.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpvy8xjjo3.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpvy8xjjo3.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpvy8xjjo3.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpvy8xjjo3.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpv"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool is_lower\
    \ = false;\n    bool is_upper = false;\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); it++) {\n        if(islower(it->first[0]))\n            is_lower\
    \ = true;\n        else if(isupper(it->first[0]))\n            is_upper = true;\n\
    \        else\n            return false;\n    }\n    return is_lower ^ is_upper;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgzvws4or.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpgzvws4or.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpgzvws4or.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpgzvws4or.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpgzvws4or.cpp: In function 'int main()':\n/tmp/tmpgzvws4or.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgzvws4or.cpp:2:\n/tmp/tmpgzvws4or.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpgzvws4or.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpgzvws4or.cpp:34:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgzvws4or.cpp:34:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgzvws4or.cpp:34:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpgzvws4or.cpp:34:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpg"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0)\n        return false;\n    bool all_lower\
    \ = true;\n    bool all_upper = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(!isupper(it->first[0]))\n            all_upper = false;\n\
    \        if(!islower(it->first[0]))\n            all_lower = false;\n    }\n \
    \   return all_lower || all_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz212gjjm.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpz212gjjm.cpp:22:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpz212gjjm.cpp:22:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpz212gjjm.cpp:22:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpz212gjjm.cpp: In function 'int main()':\n/tmp/tmpz212gjjm.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz212gjjm.cpp:2:\n/tmp/tmpz212gjjm.cpp:32:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpz212gjjm.cpp:32:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpz212gjjm.cpp:32:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpz212gjjm.cpp:32:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpz212gjjm.cpp:32:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpz212gjjm.cpp:32:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpz"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.size() == 0) return false;\n    bool is_lower = false;\n\
    \    bool is_upper = false;\n    for(auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        if(it->first.length() == 0) return false;\n        if(it->first[0]\
    \ >= 'a' && it->first[0] <= 'z') {\n            is_lower = true;\n        } else\
    \ if(it->first[0] >= 'A' && it->first[0] <= 'Z') {\n            is_upper = true;\n\
    \        } else {\n            return false;\n        }\n    }\n    return is_lower\
    \ ^ is_upper;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb66xvq4s.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpb66xvq4s.cpp:21:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); it++) {\n  \
    \            ^\n/tmp/tmpb66xvq4s.cpp:21:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); it++) {\n                \
    \                 ^\n/tmp/tmpb66xvq4s.cpp:21:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpb66xvq4s.cpp: In function 'int main()':\n/tmp/tmpb66xvq4s.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb66xvq4s.cpp:2:\n/tmp/tmpb66xvq4s.cpp:35:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpb66xvq4s.cpp:35:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpb66xvq4s.cpp:35:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpb66xvq4s.cpp:35:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpb66xvq4s.cpp:35:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpb66xvq4s.cpp:35:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpb"
  stdout: ''
