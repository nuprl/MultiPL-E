language: cpp
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ chars;\n        for (auto c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpat8d43o8.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpat8d43o8.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpat8d43o8.cpp: In function 'int main()':\n/tmp/tmpat8d43o8.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpat8d43o8.cpp:2:\n/tmp/tmpat8d43o8.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpat8d43o8.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpat8d43o8.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpat8d43o8.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpat8d43o8.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxpt4hz9i.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxpt4hz9i.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpxpt4hz9i.cpp: In function 'int main()':\n/tmp/tmpxpt4hz9i.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxpt4hz9i.cpp:2:\n/tmp/tmpxpt4hz9i.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxpt4hz9i.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxpt4hz9i.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxpt4hz9i.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxpt4hz9i.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique_char = 0;\n    for (int i = 0; i < words.size(); i++) {\n       \
    \ std::string word = words[i];\n        std::set<char> unique_char;\n        for\
    \ (int j = 0; j < word.size(); j++) {\n            unique_char.insert(word[j]);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2ouwh_y.cpp: In function 'int main()':\n/tmp/tmpt2ouwh_y.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2ouwh_y.cpp:2:\n/tmp/tmpt2ouwh_y.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpt2ouwh_y.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpt2ouwh_y.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpt2ouwh_y.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpt2ouwh_y.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpt2ouwh_y.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_len = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> s;\n      \
    \  for (auto ch : word) {\n            s.insert(ch);\n        }\n        if (s.size()\
    \ > max_len) {\n            max_len = s.size();\n            max_word = word;\n\
    \        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\"\
    , (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkqv2co9q.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpkqv2co9q.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpkqv2co9q.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpkqv2co9q.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpkqv2co9q.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpkqv2co9q.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpkqv2co9q.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpkqv2co9q.cpp: In function 'int main()':\n/tmp/tmpkqv2co9q.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkqv2co9q.cpp:2:\n/tmp/tmpkqv2co9q.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpkqv2co9q.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpkqv2co9q.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpkqv2co9q.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpkqv2co9q.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpql5t2f25.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpql5t2f25.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpql5t2f25.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpql5t2f25.cpp: In function 'int main()':\n/tmp/tmpql5t2f25.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/tmp/tmpql5t2f25.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpql5t2f25.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpql5t2f25.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpql5t2f25.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpql5t2f25.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdhmqppa5.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpdhmqppa5.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpdhmqppa5.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpdhmqppa5.cpp: In function 'int main()':\n/tmp/tmpdhmqppa5.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdhmqppa5.cpp:2:\n/tmp/tmpdhmqppa5.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpdhmqppa5.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpdhmqppa5.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdhmqppa5.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpdhmqppa5.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpdhmqppa5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::string\
    \ word = words[i];\n        std::set<char> unique_chars;\n        for (int j =\
    \ 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n    \
    \    }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy9b0545d.cpp: In function 'int main()':\n/tmp/tmpy9b0545d.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy9b0545d.cpp:2:\n/tmp/tmpy9b0545d.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy9b0545d.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy9b0545d.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy9b0545d.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy9b0545d.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpy9b0545d.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        int unique\
    \ = 0;\n        for (char c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique++;\n            }\n        }\n        if (unique >\
    \ max_unique) {\n            max_unique = unique;\n            result = word;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxq7afi2p.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxq7afi2p.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpxq7afi2p.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpxq7afi2p.cpp: In function 'int main()':\n/tmp/tmpxq7afi2p.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/tmp/tmpxq7afi2p.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxq7afi2p.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxq7afi2p.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxq7afi2p.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxq7afi2p.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_char = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgmqzuzue.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpgmqzuzue.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpgmqzuzue.cpp: In function 'int main()':\n/tmp/tmpgmqzuzue.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgmqzuzue.cpp:2:\n/tmp/tmpgmqzuzue.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpgmqzuzue.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpgmqzuzue.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpgmqzuzue.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpgmqzuzue.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_char = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgmqzuzue.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpgmqzuzue.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpgmqzuzue.cpp: In function 'int main()':\n/tmp/tmpgmqzuzue.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgmqzuzue.cpp:2:\n/tmp/tmpgmqzuzue.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpgmqzuzue.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpgmqzuzue.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpgmqzuzue.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpgmqzuzue.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > max) {\n            max = s.size();\n     \
    \       result = words[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpigu6z6a2.cpp: In function 'int main()':\n/tmp/tmpigu6z6a2.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpigu6z6a2.cpp:2:\n/tmp/tmpigu6z6a2.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpigu6z6a2.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpigu6z6a2.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpigu6z6a2.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpigu6z6a2.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpigu6z6a2.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (auto c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8o1_bfy4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_count = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto ch : word) {\n            unique_chars.insert(ch);\n      \
    \  }\n        if (unique_chars.size() > max_count) {\n            max_count =\
    \ unique_chars.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqum8wjoc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (char c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqm3i83_y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_char = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphikw9fr8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique_char = 0;\n \
    \   std::string max_unique_word;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_unique_word = word;\n        }\n    }\n\
    \    return max_unique_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsd5zzsuc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> chars;\n  \
    \      for (auto c : word) {\n            chars.insert(c);\n        }\n      \
    \  if (chars.size() > max) {\n            max = chars.size();\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd5nk28a5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string ans = \"\";\n  \
    \  int max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n       \
    \ std::string word = words[i];\n        std::set<char> unique_chars;\n       \
    \ for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            ans = word;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5ypq24_v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_char = 0;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        std::string word = words[i];\n        std::set<char> unique_char;\n \
    \       for (int j = 0; j < word.size(); j++) {\n            unique_char.insert(word[j]);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl95qoq65.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8elx0_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique_char = 0;\n \
    \   std::string max_word;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl1bvptsy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> chars;\n  \
    \      for (auto c : word) {\n            chars.insert(c);\n        }\n      \
    \  if (chars.size() > max) {\n            max = chars.size();\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd5nk28a5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ s;\n        for (auto c : word) {\n            s.insert(c);\n        }\n   \
    \     if (s.size() > max_count) {\n            max_count = s.size();\n       \
    \     max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsde0xu20.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  int max_len = 0;\n  std::string\
    \ max_word;\n  for (auto word : words) {\n    std::set<char> chars;\n    for (auto\
    \ c : word) {\n      chars.insert(c);\n    }\n    if (chars.size() > max_len)\
    \ {\n      max_len = chars.size();\n      max_word = word;\n    }\n  }\n  return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbgply14s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto ch : word) {\n            unique_chars.insert(ch);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu4q024ht.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ result;\n    for (int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > max) {\n            max = s.size();\n     \
    \       result = words[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9x2ie9cg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string ans;\n    int max_unique\
    \ = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            ans = word;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvodcw4z3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ set;\n        for (char c : word) {\n            set.insert(c);\n        }\n\
    \        if (set.size() > max_count) {\n            max_count = set.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp8ipz6f6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_count = 0;\n  for (std::string word : words) {\n    std::set<char>\
    \ s;\n    for (char c : word) {\n      s.insert(c);\n    }\n    if (s.size() >\
    \ max_count) {\n      max_count = s.size();\n      max_word = word;\n    }\n \
    \ }\n  return max_word;\n}\nint main() {\n    auto candidate = find_max;\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpphai5t4q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (auto c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8o1_bfy4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_count = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> chars;\n  \
    \      for (auto c : word) {\n            chars.insert(c);\n        }\n      \
    \  if (chars.size() > max_count) {\n            max_count = chars.size();\n  \
    \          max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvd630oed.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ result;\n    for (int i = 0; i < words.size(); i++) {\n        int count = 0;\n\
    \        std::string word = words[i];\n        for (int j = 0; j < word.size();\
    \ j++) {\n            if (word[j] != ' ') {\n                count++;\n      \
    \      }\n        }\n        if (count > max) {\n            max = count;\n  \
    \          result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnfnpfuh8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        std::set<char> chars;\n        for (auto c : word) {\n       \
    \     if (chars.find(c) == chars.end()) {\n                unique_chars++;\n \
    \               chars.insert(c);\n            }\n        }\n        if (unique_chars\
    \ > max_unique_chars) {\n            max_unique_chars = unique_chars;\n      \
    \      max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpox4h4ly5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (std::string word : words) {\n        int count = 0;\n\
    \        std::set<char> chars;\n        for (char c : word) {\n            if\
    \ (chars.find(c) == chars.end()) {\n                count++;\n               \
    \ chars.insert(c);\n            }\n        }\n        if (count > max_count) {\n\
    \            max_count = count;\n            max_word = word;\n        }\n   \
    \ }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpm7i_5aj0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_count = 0;\n    std::string\
    \ max_word;\n    for (std::string word : words) {\n        std::set<char> unique_chars;\n\
    \        for (char c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_count) {\n            max_count = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi6zgqn6b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ju77ucw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  // your code goes here\n  std::string\
    \ max_word = \"\";\n  int max_count = 0;\n  for (int i = 0; i < words.size();\
    \ i++) {\n    std::string word = words[i];\n    std::set<char> unique_chars;\n\
    \    for (int j = 0; j < word.size(); j++) {\n      unique_chars.insert(word[j]);\n\
    \    }\n    if (unique_chars.size() > max_count) {\n      max_count = unique_chars.size();\n\
    \      max_word = word;\n    }\n  }\n  return max_word;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0tsbjz4j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > max) {\n            max = s.size();\n     \
    \       max_word = words[i];\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnc3csf1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique_characters =\
    \ 0;\n    std::string max_word;\n    for (std::string word : words) {\n      \
    \  int unique_characters = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_characters++;\n            }\n \
    \       }\n        if (unique_characters > max_unique_characters) {\n        \
    \    max_unique_characters = unique_characters;\n            max_word = word;\n\
    \        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\"\
    , (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp529yto3i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_count) {\n            max_count = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpo0j4spcf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv7z949w7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ju77ucw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpql5t2f25.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpql5t2f25.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpql5t2f25.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpql5t2f25.cpp: In function 'int main()':\n/tmp/tmpql5t2f25.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/tmp/tmpql5t2f25.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpql5t2f25.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpql5t2f25.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpql5t2f25.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpql5t2f25.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n     \
    \   std::string word = words[i];\n        std::set<char> unique_chars;\n     \
    \   for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxfg1mxr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n      \
    \  std::string word = words[i];\n        std::set<char> chars;\n        for (int\
    \ j = 0; j < word.size(); j++) {\n            chars.insert(word[j]);\n       \
    \ }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfoxdx7tk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max = 0;\n    for (auto it = words.begin(); it != words.end(); it++) {\n   \
    \     std::string word = *it;\n        std::set<char> unique;\n        for (auto\
    \ it2 = word.begin(); it2 != word.end(); it2++) {\n            unique.insert(*it2);\n\
    \        }\n        if (unique.size() > max) {\n            max = unique.size();\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw8203cm6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (int i = 0; i < word.length(); i++) {\n\
    \            if (word.find(word[i]) == i) {\n                unique_chars++;\n\
    \            }\n        }\n        if (unique_chars > max_unique_chars) {\n  \
    \          max_unique_chars = unique_chars;\n            max_word = word;\n  \
    \      }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp71lylg0s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_count = 0;\n  for (auto word : words) {\n    int count = 0;\n    std::set<char>\
    \ chars;\n    for (auto c : word) {\n      if (chars.find(c) == chars.end()) {\n\
    \        count++;\n        chars.insert(c);\n      }\n    }\n    if (count > max_count)\
    \ {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpasnjh4j1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        for (auto c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique_chars++;\n            }\n        }\n        if (unique_chars\
    \ > max_unique_chars) {\n            max_unique_chars = unique_chars;\n      \
    \      max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw2dou3l3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8elx0_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string result;\n  int max\
    \ = 0;\n  for (int i = 0; i < words.size(); i++) {\n    std::set<char> s;\n  \
    \  for (int j = 0; j < words[i].size(); j++) {\n      s.insert(words[i][j]);\n\
    \    }\n    if (s.size() > max) {\n      max = s.size();\n      result = words[i];\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjrnm1aco.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8elx0_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpql5t2f25.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpql5t2f25.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpql5t2f25.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpql5t2f25.cpp: In function 'int main()':\n/tmp/tmpql5t2f25.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/tmp/tmpql5t2f25.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpql5t2f25.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpql5t2f25.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpql5t2f25.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpql5t2f25.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdhmqppa5.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpdhmqppa5.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpdhmqppa5.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpdhmqppa5.cpp: In function 'int main()':\n/tmp/tmpdhmqppa5.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdhmqppa5.cpp:2:\n/tmp/tmpdhmqppa5.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpdhmqppa5.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpdhmqppa5.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdhmqppa5.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpdhmqppa5.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpdhmqppa5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        for (int i = 0; i < word.size(); i++) {\n            if (word.find(word[i])\
    \ == i) {\n                unique_chars++;\n            }\n        }\n       \
    \ if (unique_chars > max_unique_chars) {\n            max_unique_chars = unique_chars;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpchhx8u_u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique_chars = 0;\n\
    \    std::string result;\n    std::set<char> unique_chars;\n    for (auto word\
    \ : words) {\n        unique_chars.clear();\n        for (auto c : word) {\n \
    \           unique_chars.insert(c);\n        }\n        if (unique_chars.size()\
    \ > max_unique_chars) {\n            max_unique_chars = unique_chars.size();\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfnxega08.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (std::string word : words) {\n        int count = 0;\n\
    \        for (char c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                count++;\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpayc2vxf0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        int count = 0;\n        std::set<char>\
    \ s;\n        for (auto c : word) {\n            if (s.find(c) == s.end()) {\n\
    \                s.insert(c);\n                count++;\n            }\n     \
    \   }\n        if (count > max) {\n            max = count;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkbajag8n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxpt4hz9i.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxpt4hz9i.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpxpt4hz9i.cpp: In function 'int main()':\n/tmp/tmpxpt4hz9i.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxpt4hz9i.cpp:2:\n/tmp/tmpxpt4hz9i.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxpt4hz9i.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxpt4hz9i.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxpt4hz9i.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxpt4hz9i.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxpt4hz9i.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxpt4hz9i.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpxpt4hz9i.cpp: In function 'int main()':\n/tmp/tmpxpt4hz9i.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxpt4hz9i.cpp:2:\n/tmp/tmpxpt4hz9i.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxpt4hz9i.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxpt4hz9i.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxpt4hz9i.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxpt4hz9i.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ju77ucw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        std::set<char> unique_char_set;\n        for (auto c : word) {\n\
    \            unique_char_set.insert(c);\n        }\n        unique_chars = unique_char_set.size();\n\
    \        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9bi4ba4i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (auto c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8o1_bfy4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8elx0_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string ans;\n    int max_unique\
    \ = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::string word\
    \ = words[i];\n        std::set<char> unique_chars;\n        for (int j = 0; j\
    \ < word.size(); j++) {\n            unique_chars.insert(word[j]);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            ans = word;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1hz44_pg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8elx0_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  int max_unique_char = 0;\n  std::string\
    \ max_unique_char_word;\n  for (auto word : words) {\n    std::set<char> unique_char;\n\
    \    for (auto ch : word) {\n      unique_char.insert(ch);\n    }\n    if (unique_char.size()\
    \ > max_unique_char) {\n      max_unique_char = unique_char.size();\n      max_unique_char_word\
    \ = word;\n    }\n  }\n  return max_unique_char_word;\n}\nint main() {\n    auto\
    \ candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp10hv8p4z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        std::string word = words[i];\n        std::set<char> unique_chars;\n\
    \        for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0z6z_1bk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ maxUnique = 0;\n    for (auto word : words) {\n        std::set<char> uniqueChars;\n\
    \        for (auto c : word) {\n            uniqueChars.insert(c);\n        }\n\
    \        if (uniqueChars.size() > maxUnique) {\n            maxUnique = uniqueChars.size();\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwxdzkebb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        std::string word = words[i];\n        std::set<char> unique_chars;\n\
    \        for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0z6z_1bk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ chars;\n        for (auto c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpat8d43o8.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpat8d43o8.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpat8d43o8.cpp: In function 'int main()':\n/tmp/tmpat8d43o8.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpat8d43o8.cpp:2:\n/tmp/tmpat8d43o8.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpat8d43o8.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpat8d43o8.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpat8d43o8.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpat8d43o8.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n     \
    \   std::string word = words[i];\n        std::set<char> unique;\n        for\
    \ (int j = 0; j < word.size(); j++) {\n            unique.insert(word[j]);\n \
    \       }\n        if (unique.size() > max_unique) {\n            max_unique =\
    \ unique.size();\n            result = word;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3vpuc__p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_count = 0;\n  for (auto word : words) {\n    std::set<char> unique_chars;\n\
    \    for (auto c : word) {\n      unique_chars.insert(c);\n    }\n    if (unique_chars.size()\
    \ > max_count) {\n      max_count = unique_chars.size();\n      max_word = word;\n\
    \    }\n  }\n  return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpciq5tnw6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n     \
    \   std::string word = words[i];\n        std::set<char> unique_chars;\n     \
    \   for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxfg1mxr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_count = 0;\n  for (std::string word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (char c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_count) {\n      max_count = unique_chars.size();\n\
    \      max_word = word;\n    }\n  }\n  return max_word;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzq5hpsxv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_count) {\n            max_count = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpo0j4spcf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        int count =\
    \ 0;\n        for (auto c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                count++;\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkvpk7hu9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n    \
    \    std::string word = words[i];\n        std::set<char> unique_chars;\n    \
    \    for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq6ye8ydi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto ch : word) {\n            unique_chars.insert(ch);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw25egepu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptdytnhhu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (int i = 0; i < words.size(); i++) {\n        std::string\
    \ word = words[i];\n        std::set<char> s;\n        for (int j = 0; j < word.size();\
    \ j++) {\n            s.insert(word[j]);\n        }\n        if (s.size() > max)\
    \ {\n            max = s.size();\n            max_word = word;\n        }\n  \
    \  }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6w4gueha.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max = 0;\n    for (auto i : words) {\n        std::set<char> s;\n        for\
    \ (auto j : i) {\n            s.insert(j);\n        }\n        if (s.size() >\
    \ max) {\n            max = s.size();\n            result = i;\n        }\n  \
    \  }\n    return result;\n}\nint main() {\n    auto candidate = find_max;\n  \
    \  assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn7qbesux.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        int count =\
    \ 0;\n        std::set<char> chars;\n        for (auto c : word) {\n         \
    \   if (chars.find(c) == chars.end()) {\n                count++;\n          \
    \      chars.insert(c);\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4tsyvmzo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> chars;\n        for (char c : word) {\n            chars.insert(c);\n\
    \        }\n        if (chars.size() > max_unique_chars) {\n            max_unique_chars\
    \ = chars.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzyikd5zv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        std::set<char> chars;\n        for (auto c : word) {\n       \
    \     chars.insert(c);\n        }\n        unique_chars = chars.size();\n    \
    \    if (unique_chars > max_unique_chars) {\n            max_unique_chars = unique_chars;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzm0sow8_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique = 0;\n    std::string\
    \ max_word;\n    for (std::string word : words) {\n        std::set<char> unique_chars;\n\
    \        for (char c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1yuhvw88.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n      \
    \  std::string word = words[i];\n        std::set<char> s;\n        for (int j\
    \ = 0; j < word.size(); j++) {\n            s.insert(word[j]);\n        }\n  \
    \      if (s.size() > max_count) {\n            max_count = s.size();\n      \
    \      result = word;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy4d2zr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique_chars = 0;\n\
    \    std::string max_word;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsy_dzo_c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        for (auto c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique_chars++;\n            }\n        }\n        if (unique_chars\
    \ > max_unique_chars) {\n            max_unique_chars = unique_chars;\n      \
    \      max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn0vlxt3_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique = 0;\n    for (std::string word : words) {\n        int unique =\
    \ 0;\n        for (char c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique++;\n            }\n        }\n        if (unique >\
    \ max_unique) {\n            max_unique = unique;\n            result = word;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnmli_rjs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        std::string word = words[i];\n        std::set<char> unique_chars;\n\
    \        for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0z6z_1bk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzyeczqnq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique = 0;\n    std::string\
    \ max_word;\n    for (std::string word : words) {\n        std::set<char> unique_chars;\n\
    \        for (char c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1yuhvw88.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        int unique\
    \ = 0;\n        for (char c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique++;\n            }\n        }\n        if (unique >\
    \ max_unique) {\n            max_unique = unique;\n            result = word;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxq7afi2p.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxq7afi2p.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpxq7afi2p.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpxq7afi2p.cpp: In function 'int main()':\n/tmp/tmpxq7afi2p.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/tmp/tmpxq7afi2p.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxq7afi2p.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxq7afi2p.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxq7afi2p.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxq7afi2p.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        int unique\
    \ = 0;\n        for (char c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique++;\n            }\n        }\n        if (unique >\
    \ max_unique) {\n            max_unique = unique;\n            result = word;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxq7afi2p.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxq7afi2p.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpxq7afi2p.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpxq7afi2p.cpp: In function 'int main()':\n/tmp/tmpxq7afi2p.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/tmp/tmpxq7afi2p.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxq7afi2p.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxq7afi2p.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxq7afi2p.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxq7afi2p.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8elx0_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ chars;\n        for (auto c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpat8d43o8.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpat8d43o8.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpat8d43o8.cpp: In function 'int main()':\n/tmp/tmpat8d43o8.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpat8d43o8.cpp:2:\n/tmp/tmpat8d43o8.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpat8d43o8.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpat8d43o8.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpat8d43o8.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpat8d43o8.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique_char = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqlt9be8n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ju77ucw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_char = 0;\n  for (auto word : words) {\n    std::set<char> unique_char;\n\
    \    for (auto ch : word) {\n      unique_char.insert(ch);\n    }\n    if (unique_char.size()\
    \ > max_unique_char) {\n      max_unique_char = unique_char.size();\n      max_word\
    \ = word;\n    }\n  }\n  return max_word;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqny0vhj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char ch : word) {\n           \
    \ unique_chars.insert(ch);\n        }\n        if (unique_chars.size() > max_unique_chars)\
    \ {\n            max_unique_chars = unique_chars.size();\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnutwatn3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ju77ucw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv7z949w7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n        int count\
    \ = 0;\n        std::string word = words[i];\n        for (int j = 0; j < word.size();\
    \ j++) {\n            if (word.find(word[j]) == j) {\n                count++;\n\
    \            }\n        }\n        if (count > max_count) {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv0w4e3zk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > max) {\n            max = s.size();\n     \
    \       max_word = words[i];\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnc3csf1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        std::set<char> chars;\n        for (char c\
    \ : word) {\n            chars.insert(c);\n        }\n        unique_chars = chars.size();\n\
    \        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyj169gct.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (std::string word : words) {\n    int unique_chars\
    \ = 0;\n    for (char c : word) {\n      if (word.find(c) == word.rfind(c)) {\n\
    \        unique_chars++;\n      }\n    }\n    if (unique_chars > max_unique_chars)\
    \ {\n      max_unique_chars = unique_chars;\n      max_word = word;\n    }\n \
    \ }\n  return max_word;\n}\nint main() {\n    auto candidate = find_max;\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc2otgxn2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8ju77ucw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp53eazwei.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (std::string word : words) {\n    int unique_chars\
    \ = 0;\n    for (int i = 0; i < word.length(); i++) {\n      if (word.find(word[i])\
    \ == i) {\n        unique_chars++;\n      }\n    }\n    if (unique_chars > max_unique_chars)\
    \ {\n      max_unique_chars = unique_chars;\n      max_word = word;\n    }\n \
    \ }\n  return max_word;\n}\nint main() {\n    auto candidate = find_max;\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz2eg5kf3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (auto word : words) {\n        std::set<char> chars;\n\
    \        for (auto c : word) {\n            chars.insert(c);\n        }\n    \
    \    if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5sdtx8_q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp031ebh84.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string result = \"\";\n \
    \ int max = 0;\n  for (int i = 0; i < words.size(); i++) {\n    std::string word\
    \ = words[i];\n    std::set<char> set;\n    for (int j = 0; j < word.size(); j++)\
    \ {\n      set.insert(word[j]);\n    }\n    if (set.size() > max) {\n      max\
    \ = set.size();\n      result = word;\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1usu9w9s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (int i = 0; i < word.length(); i++) {\n\
    \            if (word.find(word[i]) == i) {\n                unique_chars++;\n\
    \            }\n        }\n        if (unique_chars > max_unique_chars) {\n  \
    \          max_unique_chars = unique_chars;\n            max_word = word;\n  \
    \      }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp71lylg0s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n    \
    \    std::string word = words[i];\n        int count = 0;\n        for (int j\
    \ = 0; j < word.size(); j++) {\n            char c = word[j];\n            if\
    \ (word.find(c) == j) {\n                count++;\n            }\n        }\n\
    \        if (count > max_count) {\n            max_count = count;\n          \
    \  max_word = word;\n        }\n    }\n    return max_word;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6d5_q1s9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> s;\n      \
    \  for (auto c : word) {\n            s.insert(c);\n        }\n        if (s.size()\
    \ > max) {\n            max = s.size();\n            max_word = word;\n      \
    \  }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzsx48bez.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique_char = 0;\n \
    \   std::string result;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto ch : word) {\n            unique_char.insert(ch);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpze8z27a0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::string\
    \ word = words[i];\n        std::set<char> unique_chars;\n        for (int j =\
    \ 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n    \
    \    }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphigy8o9v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n     \
    \   std::string word = words[i];\n        std::set<char> unique_chars;\n     \
    \   for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxfg1mxr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ chars;\n        for (auto c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpat8d43o8.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpat8d43o8.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpat8d43o8.cpp: In function 'int main()':\n/tmp/tmpat8d43o8.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpat8d43o8.cpp:2:\n/tmp/tmpat8d43o8.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpat8d43o8.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpat8d43o8.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpat8d43o8.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpat8d43o8.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_count\
    \ = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars;\n\
    \    for (char c : word) {\n      unique_chars.insert(c);\n    }\n    if (unique_chars.size()\
    \ > max_count) {\n      max_count = unique_chars.size();\n      max_word = word;\n\
    \    }\n  }\n  return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqrovdo0m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique = 0;\n    for (auto word : words) {\n        int unique = 0;\n  \
    \      for (auto c : word) {\n            if (std::find(word.begin(), word.end(),\
    \ c) == word.end()) {\n                unique++;\n            }\n        }\n \
    \       if (unique > max_unique) {\n            max_unique = unique;\n       \
    \     result = word;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpe279bcay.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_char = 0;\n    for (auto word : words) {\n        int unique_char\
    \ = 0;\n        for (int i = 0; i < word.size(); i++) {\n            if (word.find(word[i])\
    \ == i) {\n                unique_char++;\n            }\n        }\n        if\
    \ (unique_char > max_unique_char) {\n            max_unique_char = unique_char;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgwnwezkq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748557
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp53eazwei.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            result = word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzyeczqnq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp031ebh84.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (auto c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8o1_bfy4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string res = \"\";\n  \
    \  int max_count = 0;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_count) {\n            max_count = unique_chars.size();\n\
    \            res = word;\n        }\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1zf1gjpj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748557
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n    \
    \    std::string word = words[i];\n        std::set<char> unique_chars;\n    \
    \    for (int j = 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq6ye8ydi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string ans = \"\";\n  \
    \  int max = 0;\n    for (auto i : words) {\n        std::set<char> s;\n     \
    \   for (auto j : i) {\n            s.insert(j);\n        }\n        if (s.size()\
    \ > max) {\n            max = s.size();\n            ans = i;\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp0ogsnq8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (char c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqm3i83_y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto ch : word) {\n            unique_chars.insert(ch);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu4q024ht.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n\
    \  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (auto c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_word = word;\n    }\n  }\n  return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8o1_bfy4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int\
    \ max_unique_chars = 0;\n    for (auto word : words) {\n        int unique_chars\
    \ = 0;\n        std::set<char> chars;\n        for (auto c : word) {\n       \
    \     if (chars.find(c) == chars.end()) {\n                unique_chars++;\n \
    \               chars.insert(c);\n            }\n        }\n        if (unique_chars\
    \ > max_unique_chars) {\n            max_unique_chars = unique_chars;\n      \
    \      max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxgls1i7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748556
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> chars;\n  \
    \      for (auto c : word) {\n            chars.insert(c);\n        }\n      \
    \  if (chars.size() > max) {\n            max = chars.size();\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd5nk28a5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfcwu7jd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748555
