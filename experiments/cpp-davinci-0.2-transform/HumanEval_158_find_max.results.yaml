language: cpp
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ chars;\n        for (auto c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpat8d43o8.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpat8d43o8.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpat8d43o8.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpat8d43o8.cpp: In function 'int main()':\n/tmp/tmpat8d43o8.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpat8d43o8.cpp:2:\n/tmp/tmpat8d43o8.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpat8d43o8.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpat8d43o8.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpat8d43o8.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpat8d43o8.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_unique = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> unique_chars;\n\
    \        for (auto c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_unique) {\n            max_unique = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxpt4hz9i.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxpt4hz9i.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpxpt4hz9i.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpxpt4hz9i.cpp: In function 'int main()':\n/tmp/tmpxpt4hz9i.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxpt4hz9i.cpp:2:\n/tmp/tmpxpt4hz9i.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxpt4hz9i.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxpt4hz9i.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxpt4hz9i.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxpt4hz9i.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique_char = 0;\n    for (int i = 0; i < words.size(); i++) {\n       \
    \ std::string word = words[i];\n        std::set<char> unique_char;\n        for\
    \ (int j = 0; j < word.size(); j++) {\n            unique_char.insert(word[j]);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2ouwh_y.cpp: In function 'int main()':\n/tmp/tmpt2ouwh_y.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2ouwh_y.cpp:2:\n/tmp/tmpt2ouwh_y.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpt2ouwh_y.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpt2ouwh_y.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpt2ouwh_y.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpt2ouwh_y.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpt2ouwh_y.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max_len = 0;\n    std::string\
    \ max_word;\n    for (auto word : words) {\n        std::set<char> s;\n      \
    \  for (auto ch : word) {\n            s.insert(ch);\n        }\n        if (s.size()\
    \ > max_len) {\n            max_len = s.size();\n            max_word = word;\n\
    \        }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\"\
    , (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkqv2co9q.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpkqv2co9q.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpkqv2co9q.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpkqv2co9q.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpkqv2co9q.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpkqv2co9q.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpkqv2co9q.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpkqv2co9q.cpp: In function 'int main()':\n/tmp/tmpkqv2co9q.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkqv2co9q.cpp:2:\n/tmp/tmpkqv2co9q.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpkqv2co9q.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpkqv2co9q.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpkqv2co9q.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpkqv2co9q.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_count) {\n            max_count = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpql5t2f25.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpql5t2f25.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpql5t2f25.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpql5t2f25.cpp: In function 'int main()':\n/tmp/tmpql5t2f25.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/tmp/tmpql5t2f25.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpql5t2f25.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpql5t2f25.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpql5t2f25.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpql5t2f25.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpql5t2f25.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   std::set<char> unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpca1i39ex.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpca1i39ex.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpca1i39ex.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpca1i39ex.cpp: In function 'int main()':\n/tmp/tmpca1i39ex.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/tmp/tmpca1i39ex.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpca1i39ex.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpca1i39ex.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpca1i39ex.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpca1i39ex.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpca1i39ex.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n     \
    \   int unique_chars = 0;\n        for (char c : word) {\n            if (word.find(c)\
    \ == word.rfind(c)) {\n                unique_chars++;\n            }\n      \
    \  }\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars\
    \ = unique_chars;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp232u98rq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp232u98rq.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmp232u98rq.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmp232u98rq.cpp: In function 'int main()':\n/tmp/tmp232u98rq.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/tmp/tmp232u98rq.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp232u98rq.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp232u98rq.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp232u98rq.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp232u98rq.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp232u98rq.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (char c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdhmqppa5.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpdhmqppa5.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpdhmqppa5.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpdhmqppa5.cpp: In function 'int main()':\n/tmp/tmpdhmqppa5.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdhmqppa5.cpp:2:\n/tmp/tmpdhmqppa5.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpdhmqppa5.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpdhmqppa5.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdhmqppa5.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpdhmqppa5.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpdhmqppa5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max_unique = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::string\
    \ word = words[i];\n        std::set<char> unique_chars;\n        for (int j =\
    \ 0; j < word.size(); j++) {\n            unique_chars.insert(word[j]);\n    \
    \    }\n        if (unique_chars.size() > max_unique) {\n            max_unique\
    \ = unique_chars.size();\n            result = word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy9b0545d.cpp: In function 'int main()':\n/tmp/tmpy9b0545d.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy9b0545d.cpp:2:\n/tmp/tmpy9b0545d.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy9b0545d.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy9b0545d.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy9b0545d.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy9b0545d.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpy9b0545d.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result = \"\";\n\
    \    int max_unique = 0;\n    for (std::string word : words) {\n        int unique\
    \ = 0;\n        for (char c : word) {\n            if (word.find(c) == word.rfind(c))\
    \ {\n                unique++;\n            }\n        }\n        if (unique >\
    \ max_unique) {\n            max_unique = unique;\n            result = word;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxq7afi2p.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpxq7afi2p.cpp:16:29: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (std::string word : words) {\n                     \
    \        ^\n/tmp/tmpxq7afi2p.cpp:18:23: error: range-based 'for' loops are not\
    \ allowed in C++98 mode\n         for (char c : word) {\n                    \
    \   ^\n/tmp/tmpxq7afi2p.cpp: In function 'int main()':\n/tmp/tmpxq7afi2p.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/tmp/tmpxq7afi2p.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpxq7afi2p.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpxq7afi2p.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxq7afi2p.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpxq7afi2p.cpp:32:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpxq7afi2p.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_v"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_char = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgmqzuzue.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpgmqzuzue.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpgmqzuzue.cpp: In function 'int main()':\n/tmp/tmpgmqzuzue.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgmqzuzue.cpp:2:\n/tmp/tmpgmqzuzue.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpgmqzuzue.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpgmqzuzue.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpgmqzuzue.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpgmqzuzue.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_count = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy731r4sw.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy731r4sw.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpy731r4sw.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpy731r4sw.cpp: In function 'int main()':\n/tmp/tmpy731r4sw.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy731r4sw.cpp:2:\n/tmp/tmpy731r4sw.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpy731r4sw.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpy731r4sw.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpy731r4sw.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpy731r4sw.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_char = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_char;\n        for (auto c : word) {\n            unique_char.insert(c);\n\
    \        }\n        if (unique_char.size() > max_unique_char) {\n            max_unique_char\
    \ = unique_char.size();\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgmqzuzue.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpgmqzuzue.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpgmqzuzue.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpgmqzuzue.cpp: In function 'int main()':\n/tmp/tmpgmqzuzue.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgmqzuzue.cpp:2:\n/tmp/tmpgmqzuzue.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpgmqzuzue.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpgmqzuzue.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpgmqzuzue.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpgmqzuzue.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string result;\n    int\
    \ max = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > max) {\n            max = s.size();\n     \
    \       result = words[i];\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpigu6z6a2.cpp: In function 'int main()':\n/tmp/tmpigu6z6a2.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpigu6z6a2.cpp:2:\n/tmp/tmpigu6z6a2.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpigu6z6a2.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpigu6z6a2.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpigu6z6a2.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpigu6z6a2.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpigu6z6a2.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max_word = \"\"\
    ;\n    int max_unique_chars = 0;\n    for (auto word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto c : word) {\n            unique_chars.insert(c);\n\
    \        }\n        if (unique_chars.size() > max_unique_chars) {\n          \
    \  max_unique_chars = unique_chars.size();\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_au0tkb.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq_au0tkb.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return max_word;\n     ^\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpq_au0tkb.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpq_au0tkb.cpp: In function 'int main()':\n/tmp/tmpq_au0tkb.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_au0tkb.cpp:2:\n/tmp/tmpq_au0tkb.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq_au0tkb.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpq_au0tkb.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpq_au0tkb.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq_au0tkb.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/"
  stdout: ''
