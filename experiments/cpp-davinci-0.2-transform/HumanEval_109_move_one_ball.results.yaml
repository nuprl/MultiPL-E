language: cpp
name: HumanEval_109_move_one_ball
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n        if(arr[i]\
    \ < max) return false;\n        max = arr[i];\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpeun620kb: /tmp/tmpeun620kb.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(long i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpn749gpck: /tmp/tmpn749gpck.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i +\
    \ 1]) {\n            int j = i + 1;\n            while(j < arr.size() - 1 && arr[j]\
    \ > arr[j + 1])\n                j++;\n            if(j == arr.size() - 1)\n \
    \               return false;\n            i = j;\n        }\n        i++;\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj0tlus3o: /tmp/tmpj0tlus3o.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    int count = 0;\n    for(int i = 1; i < arr.size();\
    \ i++){\n        if(arr[i] < max){\n            count++;\n        }\n        else{\n\
    \            max = arr[i];\n        }\n    }\n    if(count > 1)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpeu10gptx: /tmp/tmpeu10gptx.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] != sorted_arr[i]) {\n            count++;\n     \
    \   }\n    }\n    if (count == 1) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp54lecl8n: /tmp/tmp54lecl8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    long max = arr[0];\n    for\
    \ (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < min) {\n          \
    \  min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n\
    \        }\n    }\n    if (max - min == arr.size() - 1) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_mgjcv6v: /tmp/tmp_mgjcv6v.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0){\n        return true;\n\
    \    }\n    long max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n   \
    \     if(arr[i] < max){\n            return false;\n        }\n        max = arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvlz00vqy: /tmp/tmpvlz00vqy.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n-1) {\n        if(arr[i] > arr[i+1]) {\n\
    \            int j = i+1;\n            while(j < n && arr[j] < arr[j-1]) j++;\n\
    \            if(j == n) return false;\n            else {\n                int\
    \ temp = arr[j];\n                for(int k = j; k > i; k--) {\n             \
    \       arr[k] = arr[k-1];\n                }\n                arr[i] = temp;\n\
    \            }\n        }\n        i++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgsse01lo: /tmp/tmpgsse01lo.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    else\n        return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5826uuro: /tmp/tmp5826uuro.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int count = 0;\n    for(int i = 0; i < n; i++) {\n        if(arr[i]\
    \ == i+1) count++;\n    }\n    if(count == n) return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp188vv13v: /tmp/tmp188vv13v.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    int j = n-1;\n    while(i < j){\n   \
    \     if(arr[i] > arr[j])\n            return false;\n        i++;\n        j--;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7baenn5z: /tmp/tmp7baenn5z.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0) return true;\n    int count = 0;\n    for(int i = 0; i < n - 1; i++) {\n\
    \        if(arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n \
    \   if(count > 1) return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i]\
    \ > arr[i + 1])\n            count++;\n    }\n    if(count > 1)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int i=0;\n    while(i<n-1)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==n-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<n-1)\n    {\n        if(arr[j]>arr[j+1])\n      \
    \      return false;\n        j++;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    long count = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] != sorted_arr[i]) {\n            count++;\n     \
    \   }\n    }\n    if (count == 1) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpaurb093u: /tmp/tmpaurb093u.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n && arr[i] < arr[i+1]) i++;\n    if(i\
    \ == n-1) return true;\n    i++;\n    while(i < n && arr[i] < arr[i+1]) i++;\n\
    \    if(i == n-1) return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpa6mekruw: /tmp/tmpa6mekruw.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int max_index = 0;\n    for\
    \ (int i = 1; i < n; i++) {\n        if (arr[i] > arr[max_index]) {\n        \
    \    max_index = i;\n        }\n    }\n    if (max_index == n - 1) {\n       \
    \ return true;\n    }\n    int min_index = max_index;\n    for (int i = max_index\
    \ + 1; i < n; i++) {\n        if (arr[i] < arr[min_index]) {\n            min_index\
    \ = i;\n        }\n    }\n    if (min_index == max_index + 1) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n - 1 && arr[i] <= arr[i +\
    \ 1])\n        i++;\n    if(i == n - 1)\n        return true;\n    int j = i +\
    \ 1;\n    while(j < n - 1 && arr[j] <= arr[j + 1])\n        j++;\n    if(j ==\
    \ n - 1)\n        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] > arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    std::vector<long>::iterator it;\n    for (it = arr.begin();\
    \ it != arr.end(); it++) {\n        if (*it != sorted_arr[0]) {\n            break;\n\
    \        }\n    }\n    if (it == arr.end()) {\n        return true;\n    }\n \
    \   while (it != arr.end()) {\n        if (*it != sorted_arr[0]) {\n         \
    \   return false;\n        }\n        it++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcc3fkt3o: /tmp/tmpcc3fkt3o.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int\
    \ i = 0;\n    while(i < arr.size() - 1){\n        if(arr[i] > arr[i+1]){\n   \
    \         arr.erase(arr.begin() + i);\n            i = 0;\n        }\n       \
    \ else{\n            i++;\n        }\n    }\n    if(arr.size() == 1) return true;\n\
    \    else return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpl6tm971d: /tmp/tmpl6tm971d.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long max_val = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < max_val) {\n            return false;\n       \
    \ }\n        max_val = std::max(max_val, arr[i]);\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplxvqqg4b: /tmp/tmplxvqqg4b.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count == 0)\n\
    \        return true;\n    if(count == 1)\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> temp = arr;\n    std::sort(temp.begin(),\
    \ temp.end());\n    int count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] != temp[i]) {\n            count++;\n        }\n    }\n  \
    \  if (count > 1) {\n        return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbu3gki11: /tmp/tmpbu3gki11.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n - 1 && arr[i] <= arr[i + 1]) i++;\n \
    \   if(i == n - 1) return true;\n    int j = i + 1;\n    while(j < n - 1 && arr[j]\
    \ <= arr[j + 1]) j++;\n    if(j == n - 1) return true;\n    return false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4its_d2: /tmp/tmpj4its_d2.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        if(arr[i] < arr[i-1])\n         \
    \   min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmmc6h2ul: /tmp/tmpmmc6h2ul.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu0k0m0t_: /tmp/tmpu0k0m0t_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Write your code here\n  // To print\
    \ results to the standard output you can use std::cout\n  // Example: std::cout\
    \ << \"Hello world!\";\n  int n = arr.size();\n  if(n==0)\n    return true;\n\
    \  int count = 0;\n  for(int i=0;i<n-1;i++){\n    if(arr[i]>arr[i+1])\n      count++;\n\
    \  }\n  if(count>1)\n    return false;\n  else\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0)\n    \
    \    return true;\n    int count = 0;\n    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++) {\n  \
    \      if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n  \
    \      return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz0ikzq1d: /tmp/tmpz0ikzq1d.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    for (int i = 0; i < arr.size() - 1; i++) {\n      \
    \  if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy9r5udud: /tmp/tmpy9r5udud.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int i = 0;\n    int j = n-1;\n    while(i < n-1\
    \ && arr[i] < arr[i+1])\n        i++;\n    while(j > 0 && arr[j] > arr[j-1])\n\
    \        j--;\n    if(i == n-1)\n        return true;\n    if(j == 0)\n      \
    \  return false;\n    if(i == j)\n        return true;\n    if(i == j-1)\n   \
    \     return true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    if(n == 1) return true;\n    int i = 0;\n    int j = n-1;\n    while(i\
    \ < j){\n        if(arr[i] > arr[i+1]){\n            break;\n        }\n     \
    \   i++;\n    }\n    while(j > i){\n        if(arr[j] < arr[j-1]){\n         \
    \   break;\n        }\n        j--;\n    }\n    if(i == j) return true;\n    if(i\
    \ == j-1) return true;\n    if(i == 0){\n        if(arr[j] >= arr[i+1]) return\
    \ true;\n        else return false;\n    }\n    if(j == n-1){\n        if(arr[i]\
    \ <= arr[j-1]) return true;\n        else return false;\n    }\n    if(arr[i]\
    \ <= arr[j-1] && arr[j] >= arr[i+1]) return true;\n    else return false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code goes here\n    if(arr.size()==0)\n\
    \        return true;\n    int n=arr.size();\n    int i=0;\n    while(i<n-1){\n\
    \        if(arr[i]>arr[i+1])\n            break;\n        i++;\n    }\n    if(i==n-1)\n\
    \        return true;\n    int j=i+1;\n    while(j<n-1){\n        if(arr[j]<arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbc___evv: /tmp/tmpbc___evv.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr(arr);\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] != sorted_arr[i]) {\n            count++;\n     \
    \   }\n    }\n    if (count == 1) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpaf_92vat: /tmp/tmpaf_92vat.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int min_index = 0;\n    for(int i = 1; i < n; i++) {\n        if(arr[i]\
    \ < arr[min_index]) {\n            min_index = i;\n        }\n    }\n    if(min_index\
    \ == 0) return true;\n    for(int i = 1; i < n; i++) {\n        if(arr[i] < arr[i-1])\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpudghw7vl: /tmp/tmpudghw7vl.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp603sxucs: /tmp/tmp603sxucs.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int min = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < min)\n            return false;\n        min = arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp41g3ma29: /tmp/tmp41g3ma29.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n - 1 && arr[i] < arr[i + 1])\n\
    \        i++;\n    if(i == n - 1)\n        return true;\n    int j = i + 1;\n\
    \    while(j < n - 1 && arr[j] < arr[j + 1])\n        j++;\n    if(j == n - 1)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min_val = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min_val) {\n            return false;\n       \
    \ }\n        min_val = std::min(min_val, arr[i]);\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3tcldmlb: /tmp/tmp3tcldmlb.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4its_d2: /tmp/tmpj4its_d2.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i +\
    \ 1])\n            break;\n        i++;\n    }\n    if(i == arr.size() - 1)\n\
    \        return true;\n    int j = i + 1;\n    while(j < arr.size() - 1) {\n \
    \       if(arr[j] > arr[j + 1])\n            return false;\n        j++;\n   \
    \ }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    long max = arr[0];\n    for\
    \ (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < min) {\n          \
    \  min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n\
    \        }\n    }\n    if (max == min) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0ox9k8o2: /tmp/tmp0ox9k8o2.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    int min_index = 0;\n    for(int i = 1; i < arr.size();\
    \ i++) {\n        if(arr[i] < min) {\n            min = arr[i];\n            min_index\
    \ = i;\n        }\n    }\n    if(min_index == 0)\n        return true;\n    for(int\
    \ i = min_index; i < arr.size(); i++) {\n        if(arr[i] > min)\n          \
    \  return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3s8qq5k_: /tmp/tmp3s8qq5k_.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu0k0m0t_: /tmp/tmpu0k0m0t_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] > arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0)\n    \
    \    return true;\n    int count = 0;\n    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int count=0;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count==arr.size()-1)\n        return false;\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpw6ynb_wl: /tmp/tmpw6ynb_wl.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr(arr);\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] != sorted_arr[i]) {\n            count++;\n     \
    \   }\n    }\n    if (count == 1) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpaf_92vat: /tmp/tmpaf_92vat.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb374vk8n: /tmp/tmpb374vk8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1 && arr[i] <= arr[i+1])\n\
    \        i++;\n    if(i == n-1)\n        return true;\n    int j = i+1;\n    while(j\
    \ < n-1 && arr[j] <= arr[j+1])\n        j++;\n    if(j == n-1)\n        return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int i = 0;\n    while (i < arr.size() - 1) {\n    \
    \    if (arr[i] > arr[i + 1]) {\n            break;\n        }\n        i++;\n\
    \    }\n    if (i == arr.size() - 1) {\n        return true;\n    }\n    int j\
    \ = i + 1;\n    while (j < arr.size() - 1) {\n        if (arr[j] < arr[j + 1])\
    \ {\n            break;\n        }\n        j++;\n    }\n    if (j == arr.size()\
    \ - 1) {\n        return true;\n    }\n    return false;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpaj_ow2lw: /tmp/tmpaj_ow2lw.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    int min = arr[n-1];\n    int max_index\
    \ = 0;\n    int min_index = n-1;\n    for(int i = 1; i < n; i++){\n        if(arr[i]\
    \ > max){\n            max = arr[i];\n            max_index = i;\n        }\n\
    \    }\n    for(int i = n-2; i >= 0; i--){\n        if(arr[i] < min){\n      \
    \      min = arr[i];\n            min_index = i;\n        }\n    }\n    if(max_index\
    \ == n-1 && min_index == 0)\n        return true;\n    if(max_index < min_index)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpsuuei20d: /tmp/tmpsuuei20d.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        else\n            min=arr[i];\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzbfikclj: /tmp/tmpzbfikclj.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6e6qby7q: /tmp/tmp6e6qby7q.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4its_d2: /tmp/tmpj4its_d2.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n        if(arr[i]\
    \ < max) return false;\n        if(arr[i] > max) max = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvo582r47: /tmp/tmpvo582r47.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int\
    \ i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i + 1]) {\n\
    \            int j = i + 1;\n            while(j < arr.size() - 1 && arr[j] >\
    \ arr[j + 1]) {\n                j++;\n            }\n            if(j == arr.size()\
    \ - 1) return false;\n            else {\n                int temp = arr[j];\n\
    \                for(int k = j; k > i; k--) {\n                    arr[k] = arr[k\
    \ - 1];\n                }\n                arr[i] = temp;\n            }\n  \
    \      }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1_h3bb9o: /tmp/tmp1_h3bb9o.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int i = 0;\n    while (i <\
    \ n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            break;\n        }\n\
    \        i++;\n    }\n    if (i == n - 1) {\n        return true;\n    }\n   \
    \ int j = i + 1;\n    while (j < n - 1) {\n        if (arr[j] > arr[j + 1]) {\n\
    \            return false;\n        }\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0) return true;\n    int count = 0;\n    for(int i = 0; i < n; i++) {\n    \
    \    if(arr[i] != i+1) count++;\n    }\n    if(count == 0) return true;\n    if(count\
    \ == 1) return true;\n    return false;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphlz2podd: /tmp/tmphlz2podd.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = arr[i];\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwgupm32y: /tmp/tmpwgupm32y.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0) return\
    \ true;\n    int i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1]){\n     \
    \       if(i==0) return false;\n            else{\n                if(arr[i-1]>arr[i+1])\
    \ return false;\n                else{\n                    i++;\n           \
    \     }\n            }\n        }\n        else i++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_achy0xg: /tmp/tmp_achy0xg.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb374vk8n: /tmp/tmpb374vk8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // Write your code here\n  // To print\
    \ results to the standard output you can use std::cout\n  // Example: std::cout\
    \ << \"Hello world!\";\n  if(arr.size() == 0)\n    return true;\n  int i = 0;\n\
    \  int j = arr.size() - 1;\n  while(i < j) {\n    if(arr[i] > arr[i+1]) {\n  \
    \    std::swap(arr[i], arr[i+1]);\n      i++;\n    }\n    else {\n      std::swap(arr[j],\
    \ arr[j-1]);\n      j--;\n    }\n  }\n  for(int i = 0; i < arr.size() - 1; i++)\
    \ {\n    if(arr[i] > arr[i+1])\n      return false;\n  }\n  return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7g9chh0n: /tmp/tmp7g9chh0n.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    int count = 0;\n    while(i < n - 1)\
    \ {\n        if(arr[i] > arr[i + 1]) {\n            count++;\n            if(count\
    \ > 1)\n                return false;\n        }\n        i++;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int max_index = 0;\n    for(int i = 1; i < n; i++)\n\
    \    {\n        if(arr[i] > arr[max_index])\n            max_index = i;\n    }\n\
    \    if(max_index == n-1)\n        return true;\n    if(max_index == 0)\n    \
    \    return false;\n    for(int i = max_index+1; i < n; i++)\n    {\n        if(arr[i]\
    \ < arr[i-1])\n            return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpek364mo_: /tmp/tmpek364mo_.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    int j=arr.size()-1;\n    while(i<j){\n        if(arr[i]>arr[j])\n\
    \            return false;\n        i++;\n        j--;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcium9dhy: /tmp/tmpcium9dhy.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6e6qby7q: /tmp/tmp6e6qby7q.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu0k0m0t_: /tmp/tmpu0k0m0t_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int i = 0;\n    for(i = 0; i < n - 1; i++)\n   \
    \ {\n        if(arr[i] > arr[i + 1])\n            break;\n    }\n    if(i == n\
    \ - 1)\n        return true;\n    for(int j = i + 1; j < n - 1; j++)\n    {\n\
    \        if(arr[j] < arr[j + 1])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpahornvet: /tmp/tmpahornvet.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i +\
    \ 1]) {\n            std::rotate(arr.begin(), arr.begin() + i + 1, arr.end());\n\
    \            break;\n        }\n        i++;\n    }\n    for(int i = 0; i < arr.size()\
    \ - 1; i++) {\n        if(arr[i] > arr[i + 1])\n            return false;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i]\
    \ > arr[i + 1])\n            count++;\n    }\n    if(count > 1)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1 && arr[i] <= arr[i+1])\n\
    \        i++;\n    if(i == n-1)\n        return true;\n    int j = i+1;\n    while(j\
    \ < n-1 && arr[j] <= arr[j+1])\n        j++;\n    if(j == n-1)\n        return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    // Write your code here\n    // To print results to\
    \ the standard output you can use std::cout\n    // Example: std::cout << \"Hello\
    \ world!\";\n    int n = arr.size();\n    int min = arr[0];\n    int min_index\
    \ = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < min) {\n     \
    \       min = arr[i];\n            min_index = i;\n        }\n    }\n    if (min_index\
    \ == 0) {\n        return true;\n    }\n    for (int i = 1; i < min_index; i++)\
    \ {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n\
    \    }\n    for (int i = min_index + 1; i < n; i++) {\n        if (arr[i] < arr[i\
    \ - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0) return true;\n    int\
    \ count=0;\n    for(int i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\
    \ count++;\n    }\n    if(count>1) return false;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int min = arr[0];\n    for(int i = 1; i < n; i++){\n        if(arr[i]\
    \ < min) return false;\n        if(arr[i] < arr[i-1]) min = arr[i];\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzqoq1iaf: /tmp/tmpzqoq1iaf.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmst4sf29.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpmst4sf29.cpp:34:35: error: no matching function for call\
    \ to \u2018min(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   34 |         min = std::min(min, arr[i]);\n   \
    \   |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmst4sf29.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpmst4sf29.cpp:34:35: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   34 |         min = std::min(min, arr[i]);\n\
    \      |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmst4sf29.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpmst4sf29.cpp:34:35:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   34 |         min = std::min(min, arr[i]);\n\
    \      |                        "
  stdout: ''
  timestamp: 1660111260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] < arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptspu_bcv: /tmp/tmptspu_bcv.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n) {\n        if(arr[i] ==\
    \ i+1)\n            i++;\n        else {\n            if(arr[i] > i+1)\n     \
    \           return false;\n            else {\n                int j = i+1;\n\
    \                while(j < n && arr[j] < i+1)\n                    j++;\n    \
    \            if(j == n)\n                    return false;\n                else\
    \ {\n                    int temp = arr[j];\n                    for(int k = j;\
    \ k > i; k--)\n                        arr[k] = arr[k-1];\n                  \
    \  arr[i] = temp;\n                    i++;\n                }\n            }\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpv6ugq1m5: /tmp/tmpv6ugq1m5.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    std::vector<long> arr_copy = arr;\n    std::sort(arr_copy.begin(), arr_copy.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != arr_copy[i])\n            count++;\n    }\n    if(count > 2)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjl319arf: /tmp/tmpjl319arf.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i=1;i<arr.size();i++){\n        if(arr[i]<min)\n\
    \            return false;\n        min = arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpr7alhd09: /tmp/tmpr7alhd09.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1){\n        if(arr[i] > arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i == arr.size() - 1)\n      \
    \  return true;\n    int j = i + 1;\n    while(j < arr.size() - 1){\n        if(arr[j]\
    \ < arr[j+1])\n            return false;\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpr7g6_nrh: /tmp/tmpr7g6_nrh.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int max_val = arr[0];\n    for(int i = 1; i < n; i++) {\n       \
    \ if(arr[i] < max_val) return false;\n        max_val = std::max(max_val, arr[i]);\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgjhr4o7r.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpgjhr4o7r.cpp:33:43: error: no matching function for call\
    \ to \u2018max(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   33 |         max_val = std::max(max_val, arr[i]);\n\
    \      |                                           ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpgjhr4o7r.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpgjhr4o7r.cpp:33:43: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   33 |         max_val = std::max(max_val, arr[i]);\n\
    \      |                                           ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpgjhr4o7r.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpgjhr4o7r.cpp:33:43:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   33 |         max_val = std::max(max_val, "
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0) return\
    \ true;\n    int max = arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]<max)\
    \ return false;\n        if(arr[i]>max) max = arr[i];\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbto1dd87: /tmp/tmpbto1dd87.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    if(n == 1)\n        return true;\n    int count = 0;\n\
    \    for(int i = 0; i < n; i++)\n    {\n        if(arr[i] == i+1)\n          \
    \  count++;\n    }\n    if(count == n)\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1o95g66y: /tmp/tmp1o95g66y.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int i = 0;\n    int j = arr.size() - 1;\n    while (i\
    \ < arr.size() && j >= 0) {\n        if (arr[i] == sorted_arr[j]) {\n        \
    \    i++;\n            j--;\n        } else {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvh24nk_p: /tmp/tmpvh24nk_p.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        max = std::max(max, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwkvw0zyf: /tmp/tmpwkvw0zyf.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111262
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=std::min(min,arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdm3ykw08: /tmp/tmpdm3ykw08.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min_val = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min_val) {\n            return false;\n       \
    \ }\n        min_val = std::min(min_val, arr[i]);\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnrd9ncvc: /tmp/tmpnrd9ncvc.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111262
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int count = 0;\n    for(int i = 0; i < n; i++) {\n        if(arr[i]\
    \ == i+1) count++;\n    }\n    if(count == n) return true;\n    else return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpf8fwo2rp: /tmp/tmpf8fwo2rp.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n - 1 && arr[i] < arr[i + 1]) i++;\n  \
    \  if(i == n - 1) return true;\n    int j = i + 1;\n    while(j < n - 1 && arr[j]\
    \ < arr[j + 1]) j++;\n    if(j == n - 1) return true;\n    return false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    int count = 0;\n    for(int i\
    \ = 1; i < n; i++){\n        if(arr[i] < max){\n            count++;\n       \
    \ }\n        else{\n            max = arr[i];\n        }\n    }\n    if(count\
    \ == 0 || count == 1)\n        return true;\n    else\n        return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpefptevmo: /tmp/tmpefptevmo.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111262
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=std::min(min,arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5hmm7gvs.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5hmm7gvs.cpp:35:32: error: no matching function for call\
    \ to \u2018min(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   35 |         min=std::min(min,arr[i]);\n      |\
    \                                ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5hmm7gvs.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp5hmm7gvs.cpp:35:32: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   35 |         min=std::min(min,arr[i]);\n   \
    \   |                                ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5hmm7gvs.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp5hmm7gvs.cpp:35:32:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   35 |         min=std::min(min,arr[i]);\n   \
    \   |                                ^\nIn fi"
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    else\n        return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n        if(arr[i]\
    \ < max) return false;\n        if(arr[i] > max) max = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvo582r47: /tmp/tmpvo582r47.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int count=0;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    else\n\
    \        return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int count = 0;\n    for(int i = 0; i < n; i++)\n\
    \    {\n        if(arr[i] == i+1)\n            count++;\n    }\n    if(count ==\
    \ n)\n        return true;\n    else\n        return false;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpknmg5n5h: /tmp/tmpknmg5n5h.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111262
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int count = 0;\n    for(int i=0;i<arr.size()-1;i++){\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        max = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp20e27uwz: /tmp/tmp20e27uwz.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int max=arr[0];\n    for(int i=1;i<arr.size();i++){\n        if(arr[i]<max)\n\
    \            return false;\n        else\n            max=arr[i];\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqpo62g7u: /tmp/tmpqpo62g7u.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0) return true;\n    if(n == 1) return true;\n    int i = 0;\n    while(i <\
    \ n-1) {\n        if(arr[i] > arr[i+1]) {\n            int j = i+1;\n        \
    \    while(j < n-1 && arr[j] > arr[j+1]) j++;\n            if(j == n-1) return\
    \ false;\n            else {\n                int k = j+1;\n                while(k\
    \ < n-1 && arr[k] < arr[k+1]) k++;\n                if(k == n-1) return true;\n\
    \                else return false;\n            }\n        }\n        i++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcl9xtv3k: /tmp/tmpcl9xtv3k.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu0k0m0t_: /tmp/tmpu0k0m0t_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int i = 0;\n    while (i <\
    \ n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            break;\n        }\n\
    \        i++;\n    }\n    if (i == n - 1) {\n        return true;\n    }\n   \
    \ int j = i + 1;\n    while (j < n - 1) {\n        if (arr[j] < arr[j + 1]) {\n\
    \            break;\n        }\n        j++;\n    }\n    if (j == n - 1) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpplsq0l6l: /tmp/tmpplsq0l6l.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4its_d2: /tmp/tmpj4its_d2.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i=1;i<arr.size();i++){\n        if(arr[i]<min)\n\
    \            return false;\n        if(arr[i]<arr[i-1])\n            min = arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplgdo6eoi: /tmp/tmplgdo6eoi.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n-1; i++){\n \
    \       if(arr[i] > arr[i+1])\n            count++;\n    }\n    if(count > 1)\n\
    \        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int i = 0;\n    while (i <\
    \ n) {\n        if (arr[i] == i + 1) {\n            i++;\n        } else {\n \
    \           if (arr[i] == n) {\n                return false;\n            }\n\
    \            std::swap(arr[i], arr[arr[i] - 1]);\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkfauacs5: /tmp/tmpkfauacs5.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp23cvezox: /tmp/tmp23cvezox.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0)\n    \
    \    return true;\n    int count = 0;\n    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    long max = arr[0];\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < min) {\n         \
    \   min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n\
    \        }\n    }\n    if (max - min == arr.size() - 1) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkmoy6i9f: /tmp/tmpkmoy6i9f.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int\
    \ i = 0;\n    while(i < arr.size() - 1){\n        if(arr[i] > arr[i+1]){\n   \
    \         break;\n        }\n        i++;\n    }\n    if(i == arr.size() - 1)\
    \ return true;\n    int j = i + 1;\n    while(j < arr.size() - 1){\n        if(arr[j]\
    \ > arr[j+1]){\n            return false;\n        }\n        j++;\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int count=0;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    else\n\
    \        return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int count = 0;\n    for(int i = 0; i < n; i++)\n\
    \    {\n        if(arr[i] != i+1)\n            count++;\n    }\n    if(count >\
    \ 1)\n        return false;\n    else\n        return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprjmfrhg6: /tmp/tmprjmfrhg6.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i +\
    \ 1]) {\n            int j = i + 1;\n            while(j < arr.size() - 1 && arr[j]\
    \ > arr[j + 1])\n                j++;\n            if(j == arr.size() - 1)\n \
    \               return false;\n            else {\n                std::swap(arr[i],\
    \ arr[j]);\n                i++;\n            }\n        }\n        else\n   \
    \         i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvzv79x6p: /tmp/tmpvzv79x6p.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3gxf8ums: /tmp/tmp3gxf8ums.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n - 1){\n        if(arr[i]\
    \ > arr[i + 1])\n            break;\n        i++;\n    }\n    if(i == n - 1)\n\
    \        return true;\n    int j = i + 1;\n    while(j < n - 1){\n        if(arr[j]\
    \ < arr[j + 1])\n            return false;\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpc3qa7wqr: /tmp/tmpc3qa7wqr.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu0k0m0t_: /tmp/tmpu0k0m0t_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] > arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpz3jk8oi_: /tmp/tmpz3jk8oi_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] != i+1)\n            count++;\n    }\n    if(count == 1)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqxmb35au: /tmp/tmpqxmb35au.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb374vk8n: /tmp/tmpb374vk8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp603sxucs: /tmp/tmp603sxucs.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int min_index = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (arr[i] < arr[min_index]) {\n        \
    \    min_index = i;\n        }\n    }\n    int max_index = 0;\n    for (int i\
    \ = 0; i < n; i++) {\n        if (arr[i] > arr[max_index]) {\n            max_index\
    \ = i;\n        }\n    }\n    if (min_index == max_index) {\n        return true;\n\
    \    }\n    if (min_index == n - 1) {\n        return false;\n    }\n    if (max_index\
    \ == 0) {\n        return false;\n    }\n    if (min_index < max_index) {\n  \
    \      return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1kzbe5k2: /tmp/tmp1kzbe5k2.cpp:60: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)4, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int\
    \ n = arr.size();\n    int max = arr[0];\n    for(int i = 1; i < n; i++) {\n \
    \       if(arr[i] < max) return false;\n        max = std::max(max, arr[i]);\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbf683u21.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpbf683u21.cpp:33:35: error: no matching function for call\
    \ to \u2018max(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   33 |         max = std::max(max, arr[i]);\n   \
    \   |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbf683u21.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpbf683u21.cpp:33:35: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   33 |         max = std::max(max, arr[i]);\n\
    \      |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbf683u21.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpbf683u21.cpp:33:35:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   33 |         max = std::max(max, arr[i]);\n\
    \      |                        "
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] < arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptspu_bcv: /tmp/tmptspu_bcv.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4its_d2: /tmp/tmpj4its_d2.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1 && arr[i] <= arr[i+1])\n\
    \        i++;\n    if(i == n-1)\n        return true;\n    int j = i+1;\n    while(j\
    \ < n-1 && arr[j] <= arr[j+1])\n        j++;\n    if(j == n-1)\n        return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0) return\
    \ true;\n    int i=0;\n    while(i<n-1){\n        if(arr[i]<arr[i+1]){\n     \
    \       i++;\n        }\n        else{\n            break;\n        }\n    }\n\
    \    if(i==n-1) return true;\n    int j=n-1;\n    while(j>0){\n        if(arr[j]>arr[j-1]){\n\
    \            j--;\n        }\n        else{\n            break;\n        }\n \
    \   }\n    if(j==0) return true;\n    if(i==j) return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9x7j27zm: /tmp/tmp9x7j27zm.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] < arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptspu_bcv: /tmp/tmptspu_bcv.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] > arr[i+1]){\n\
    \            return false;\n        }\n        i++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp35l3qzw8: /tmp/tmp35l3qzw8.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] < arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    if(arr[0] < arr[j])\n   \
    \     return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpd8vl1v41: /tmp/tmpd8vl1v41.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int min = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < min)\n            return false;\n        min = std::min(min,\
    \ arr[i]);\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppbto40et.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppbto40et.cpp:35:35: error: no matching function for call\
    \ to \u2018min(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   35 |         min = std::min(min, arr[i]);\n   \
    \   |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmppbto40et.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmppbto40et.cpp:35:35: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   35 |         min = std::min(min, arr[i]);\n\
    \      |                                   ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmppbto40et.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmppbto40et.cpp:35:35:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   35 |         min = std::min(min, arr[i]);\n\
    \      |                        "
  stdout: ''
  timestamp: 1660111263
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int i = 0;\n    while (i <\
    \ n - 1) {\n        if (arr[i] > arr[i + 1]) {\n            break;\n        }\n\
    \        i++;\n    }\n    if (i == n - 1) {\n        return true;\n    }\n   \
    \ int j = i + 1;\n    while (j < n - 1) {\n        if (arr[j] > arr[j + 1]) {\n\
    \            return false;\n        }\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int i = 0;\n    int j = 0;\n    while (i < arr.size()\
    \ && j < arr.size()) {\n        if (arr[i] == sorted_arr[j]) {\n            i++;\n\
    \            j++;\n        } else {\n            i++;\n        }\n    }\n    if\
    \ (j == arr.size()) {\n        return true;\n    } else {\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb__i88gf: /tmp/tmpb__i88gf.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    std::vector<long> arr_copy = arr;\n    std::sort(arr_copy.begin(), arr_copy.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != arr_copy[i])\n            count++;\n    }\n    if(count > 2)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjl319arf: /tmp/tmpjl319arf.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb374vk8n: /tmp/tmpb374vk8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int count=0;\n    for(int i=0;i<arr.size()-1;i++)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count==arr.size()-1)\n        return false;\n\
    \    else\n        return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpw1p89w4m: /tmp/tmpw1p89w4m.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqy_i7ff1: /tmp/tmpqy_i7ff1.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(long i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min)\n            return false;\n        min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2700q9cx: /tmp/tmp2700q9cx.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int\
    \ i = 0;\n    while(i < arr.size() - 1){\n        if(arr[i] > arr[i+1]){\n   \
    \         break;\n        }\n        i++;\n    }\n    if(i == arr.size() - 1)\
    \ return true;\n    int j = i + 1;\n    while(j < arr.size() - 1){\n        if(arr[j]\
    \ > arr[j+1]){\n            return false;\n        }\n        j++;\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int min = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < min)\n            return false;\n        if(arr[i] > min)\n\
    \            min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpts3qc2hx: /tmp/tmpts3qc2hx.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        max = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp20e27uwz: /tmp/tmp20e27uwz.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int max_idx = 0;\n    for(int i = 1; i < n; i++) {\n        if(arr[i]\
    \ > arr[max_idx]) {\n            max_idx = i;\n        }\n    }\n    if(max_idx\
    \ == 0) return true;\n    for(int i = max_idx; i < n; i++) {\n        if(arr[i]\
    \ < arr[i-1]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp33mgqr7e: /tmp/tmp33mgqr7e.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i] >\
    \ arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n     \
    \   return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] > arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n  // your code goes here\n  if(arr.size()\
    \ == 0)\n    return true;\n  int n = arr.size();\n  int count = 0;\n  for(int\
    \ i = 0; i < n-1; i++)\n  {\n    if(arr[i] > arr[i+1])\n      count++;\n  }\n\
    \  if(count > 1)\n    return false;\n  return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111263
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n-1 && arr[i] < arr[i+1]) {\n        i++;\n\
    \    }\n    int j = i+1;\n    while(j < n-1 && arr[j] < arr[j+1]) {\n        j++;\n\
    \    }\n    if(j == n-1) return true;\n    return false;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int min_index = 0;\n    for(int i = 1; i < n; i++)\n\
    \    {\n        if(arr[i] < arr[min_index])\n            min_index = i;\n    }\n\
    \    if(min_index == 0)\n        return true;\n    for(int i = 1; i < n; i++)\n\
    \    {\n        if(arr[i] < arr[i-1])\n            return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3ijbpo9h: /tmp/tmp3ijbpo9h.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    int j = n-1;\n    while(i < j)\n    {\n\
    \        if(arr[i] > arr[j])\n            return false;\n        i++;\n      \
    \  j--;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9w6441yn: /tmp/tmp9w6441yn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n\
    \        return true;\n    int i = 0;\n    while(i < n-1){\n        if(arr[i]\
    \ > arr[i+1])\n            break;\n        i++;\n    }\n    if(i == n-1)\n   \
    \     return true;\n    int j = i+1;\n    while(j < n-1){\n        if(arr[j] >\
    \ arr[j+1])\n            return false;\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int i = 0;\n    int j = n\
    \ - 1;\n    while (i < j) {\n        if (arr[i] > arr[j]) {\n            return\
    \ false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpk5_6tok9: /tmp/tmpk5_6tok9.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n        return\
    \ true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if(arr[i]\
    \ != i+1)\n            count++;\n    }\n    if(count == 0 || count == 2)\n   \
    \     return true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplv2le__p: /tmp/tmplv2le__p.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    int j = n-1;\n    while(i < j)\n    {\n\
    \        if(arr[i] > arr[j])\n            return false;\n        i++;\n      \
    \  j--;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9w6441yn: /tmp/tmp9w6441yn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int i = 0;\n    while (i < arr.size() && arr[i] == sorted_arr[i])\
    \ {\n        i++;\n    }\n    if (i == arr.size()) {\n        return true;\n \
    \   }\n    int j = i + 1;\n    while (j < arr.size() && arr[j] == sorted_arr[j])\
    \ {\n        j++;\n    }\n    if (j == arr.size()) {\n        return true;\n \
    \   }\n    if (arr[i] == sorted_arr[j] && arr[j] == sorted_arr[i]) {\n       \
    \ return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8xuwns6c: /tmp/tmp8xuwns6c.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n     \
    \       break;\n        i++;\n    }\n    if(i==arr.size()-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<arr.size()-1){\n        if(arr[j]<arr[j+1])\n   \
    \         return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpw0n50q_1: /tmp/tmpw0n50q_1.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int max_index = 0;\n    for\
    \ (int i = 1; i < n; i++) {\n        if (arr[i] > arr[max_index]) {\n        \
    \    max_index = i;\n        }\n    }\n    int max_value = arr[max_index];\n \
    \   int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == max_value)\
    \ {\n            count++;\n        }\n    }\n    if (count > 1) {\n        return\
    \ false;\n    }\n    if (max_index == n - 1) {\n        return true;\n    }\n\
    \    for (int i = max_index + 1; i < n; i++) {\n        if (arr[i] < max_value)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwzo93ftd: /tmp/tmpwzo93ftd.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111263
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n\
    \        if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9njvhqpv: /tmp/tmp9njvhqpv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    long min = arr[0];\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            return false;\n        }\n\
    \        min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpu0k0m0t_: /tmp/tmpu0k0m0t_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    int n = arr.size();\n\
    \    if(n == 0)\n        return true;\n    int i = 0;\n    while(i < n-1)\n  \
    \  {\n        if(arr[i] > arr[i+1])\n            break;\n        i++;\n    }\n\
    \    if(i == n-1)\n        return true;\n    int j = i+1;\n    while(j < n-1)\n\
    \    {\n        if(arr[j] > arr[j+1])\n            return false;\n        j++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111263
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0)\n        return true;\n    int count = 0;\n    for(int i = 0; i < n - 1;\
    \ i++) {\n        if(arr[i] > arr[i + 1])\n            count++;\n    }\n    if(count\
    \ > 1)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111264
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int n = arr.size();\n    int count = 0;\n    for (int\
    \ i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n\
    \        }\n    }\n    if (count > 1) {\n        return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n    int i=0;\n\
    \    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n            break;\n\
    \        i++;\n    }\n    if(i==arr.size()-1)\n        return true;\n    int j=i+1;\n\
    \    while(j<arr.size()-1){\n        if(arr[j]<arr[j+1])\n            return false;\n\
    \        j++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdhrarb2e: /tmp/tmpdhrarb2e.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy9vsvn: /tmp/tmpoqy9vsvn.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb374vk8n: /tmp/tmpb374vk8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb374vk8n: /tmp/tmpb374vk8n.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111261
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0) {\n       \
    \ return true;\n    }\n    int i = 0;\n    int j = 1;\n    int count = 0;\n  \
    \  while (j < arr.size()) {\n        if (arr[i] <= arr[j]) {\n            i++;\n\
    \            j++;\n        } else {\n            count++;\n            j++;\n\
    \        }\n    }\n    if (count > 1) {\n        return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpd4awguxx: /tmp/tmpd4awguxx.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int i = 0;\n    while(i < n - 1){\n        if(arr[i]\
    \ > arr[i + 1])\n            break;\n        i++;\n    }\n    if(i == n - 1)\n\
    \        return true;\n    int j = i + 1;\n    while(j < n - 1){\n        if(arr[j]\
    \ < arr[j + 1])\n            return false;\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpc3qa7wqr: /tmp/tmpc3qa7wqr.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660111264
