name: HumanEval_116_sort_array
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to\
  \ sort an array of non-negative integers according to\n// number of ones in their\
  \ binary representation in ascending order.\n// For similar number of ones, sort\
  \ based on decimal value.\n// It must be implemented like this:\n// >>> sort_array([1,\
  \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> sort_array([-2, -3, -4, -5, -6]) == [-6,\
  \ -5, -4, -3, -2]\n// >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nstd::vector<long>\
  \ sort_array(std::vector<long> arr) {\n"
tests: "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({1,\
  \ 5, 2, 3, 4}))) == (std::vector<long>({1, 2, 4, 3, 5})));\n    assert(candidate((std::vector<long>({-2,\
  \ -3, -4, -5, -6}))) == (std::vector<long>({-4, -2, -6, -5, -3})));\n    assert(candidate((std::vector<long>({1,\
  \ 0, 2, 3, 4}))) == (std::vector<long>({0, 1, 2, 4, 3})));\n    assert(candidate((std::vector<long>()))\
  \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({2, 5, 77,\
  \ 4, 5, 3, 5, 7, 2, 3, 4}))) == (std::vector<long>({2, 2, 4, 4, 3, 3, 5, 5, 5, 7,\
  \ 77})));\n    assert(candidate((std::vector<long>({3, 6, 44, 12, 32, 5}))) == (std::vector<long>({32,\
  \ 3, 5, 6, 12, 44})));\n    assert(candidate((std::vector<long>({2, 4, 8, 16, 32})))\
  \ == (std::vector<long>({2, 4, 8, 16, 32})));\n    assert(candidate((std::vector<long>({2,\
  \ 4, 8, 16, 32}))) == (std::vector<long>({2, 4, 8, 16, 32})));\n}\n"
completions: ["    std::sort(arr.begin(), arr.end(), [](long a, long b) -> bool {\n\
    \        if (count_ones(a) < count_ones(b)) {\n            return true;\n    \
    \    } else if (count_ones(a) > count_ones(b)) {\n            return false;\n\
    \        } else {\n            return a < b;\n        }\n    });\n    return arr;",
  "    std::vector<long> result;\n    int N = arr.size();\n    std::pair<long, long>*\
    \ arr_pair = new std::pair<long, long>[N];\n    for (int i = 0; i < N; i++) {\n\
    \        int count = 0;\n        long num = arr[i];\n        while (num) {\n \
    \           if (num & 1) {\n                count++;\n            }\n        \
    \    num >>= 1;\n        }\n        arr_pair[i] = std::make_pair(count, arr[i]);\n\
    \    }\n    std::sort(arr_pair, arr_pair + N);\n    for (int i = 0; i < N; i++)\
    \ {\n        result.push_back(arr_pair[i].second);\n    }\n    return result;",
  '    return arr;', "  using Pair = std::pair<long, long>;\n  std::vector<Pair> nums;\n\
    \  for (auto i : arr) {\n    nums.push_back(std::make_pair(i, countBits(i)));\n\
    \  }\n  std::sort(nums.begin(), nums.end(),\n            [](const Pair &a, const\
    \ Pair &b) {\n              if (a.second == b.second) {\n                return\
    \ a.first < b.first;\n              }\n              return a.second < b.second;\n\
    \            });\n  std::vector<long> res;\n  for (auto i : nums) {\n    res.push_back(i.first);\n\
    \  }\n  return res;", "  std::vector<std::pair<long, int>> nums;\n  for (int i\
    \ = 0; i < arr.size(); i++) {\n    int count_one = 0;\n    for (int j = 0; j <\
    \ 32; j++) {\n      if (arr[i] & (1 << j))\n        count_one++;\n    }\n    nums.push_back(std::make_pair(arr[i],\
    \ count_one));\n  }\n  std::sort(nums.begin(), nums.end(),\n            [](const\
    \ std::pair<long, int> &a, const std::pair<long, int> &b) {\n              if\
    \ (a.second == b.second)\n                return a.first < b.first;\n        \
    \      return a.second < b.second;\n            });\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    arr[i] = nums[i].first;\n  }\n  return arr;", "  std::vector<long>\
    \ ones;\n  std::vector<long> zeros;\n  for (long x : arr) {\n    std::bitset<32>\
    \ b = x;\n    if (b.count() % 2 == 0) {\n      zeros.push_back(x);\n    } else\
    \ {\n      ones.push_back(x);\n    }\n  }\n  std::sort(zeros.begin(), zeros.end());\n\
    \  std::sort(ones.begin(), ones.end());\n  std::vector<long> result;\n  result.insert(result.end(),\
    \ zeros.begin(), zeros.end());\n  result.insert(result.end(), ones.begin(), ones.end());\n\
    \  return result;", "    std::vector<std::vector<long>> temp;\n    std::vector<long>\
    \ res;\n    for (int i = 0; i < arr.size(); i++) {\n        temp.push_back({arr[i],\
    \ ones(arr[i])});\n    }\n    sort(temp.begin(), temp.end(), [](std::vector<long>\
    \ v1, std::vector<long> v2) {\n        if (v1[1] == v2[1])\n            return\
    \ v1[0] < v2[0];\n        return v1[1] < v2[1];\n    });\n    for (int i = 0;\
    \ i < temp.size(); i++) {\n        res.push_back(temp[i][0]);\n    }\n    return\
    \ res;", "  std::vector<std::pair<int, long>> v;\n  for (auto x : arr) {\n   \
    \ long temp = x;\n    int count = 0;\n    while (temp > 0) {\n      if (temp %\
    \ 2 == 1) {\n        count++;\n      }\n      temp /= 2;\n    }\n    v.push_back(std::make_pair(count,\
    \ x));\n  }\n  std::sort(v.begin(), v.end());\n  std::vector<long> ans;\n  for\
    \ (auto x : v) {\n    ans.push_back(x.second);\n  }\n  return ans;", "  // your\
    \ code here\n  return arr;", "  std::vector<long> res;\n  std::map<int, std::vector<long>>\
    \ res_map;\n  for (auto it : arr) {\n    res_map[to_bin(it)].push_back(it);\n\
    \  }\n  for (auto it : res_map) {\n    for (auto itt : it.second) {\n      res.push_back(itt);\n\
    \    }\n  }\n  return res;", "  std::vector<std::pair<int, long>> v;\n  for (auto\
    \ i : arr) {\n    int num_ones = 0;\n    for (long n = i; n > 0; n >>= 1) {\n\
    \      if (n & 1) num_ones++;\n    }\n    v.push_back(std::make_pair(num_ones,\
    \ i));\n  }\n  std::sort(v.begin(), v.end());\n  std::vector<long> answer;\n \
    \ for (auto p : v) {\n    answer.push_back(p.second);\n  }\n  return answer;",
  "\tint n = arr.size();\n\tstd::vector<std::pair<int, long> > a(n);\n\tfor (int i\
    \ = 0; i < n; i++) {\n\t\tint ones = 0;\n\t\tfor (int j = 0; j < 32; j++) {\n\t\
    \t\tif (arr[i] & (1 << j)) {\n\t\t\t\tones++;\n\t\t\t}\n\t\t}\n\t\ta[i] = std::make_pair(ones,\
    \ arr[i]);\n\t}\n\tstd::sort(a.begin(), a.end());\n\tstd::vector<long> result(n);\n\
    \tfor (int i = 0; i < n; i++) {\n\t\tresult[i] = a[i].second;\n\t}\n\treturn result;",
  "  // your code here\n  std::sort(arr.begin(), arr.end(), [](const long& a, const\
    \ long& b) -> bool\n  {\n    std::string binary_a = std::bitset<8>(a).to_string();\n\
    \    std::string binary_b = std::bitset<8>(b).to_string();\n    int num_ones_a\
    \ = std::count(binary_a.begin(), binary_a.end(), '1');\n    int num_ones_b = std::count(binary_b.begin(),\
    \ binary_b.end(), '1');\n    if (num_ones_a < num_ones_b) {\n      return true;\n\
    \    } else if (num_ones_a > num_ones_b) {\n      return false;\n    } else {\n\
    \      return a < b;\n    }\n  });\n  return arr;", "  struct Data{\n    int ones;\n\
    \    int decimal;\n  };\n  auto cmp = [](Data d1, Data d2){\n    if(d1.ones ==\
    \ d2.ones){\n      return d1.decimal < d2.decimal;\n    }\n    return d1.ones\
    \ < d2.ones;\n  };\n  std::vector<Data> data;\n  for(long i : arr){\n    data.push_back({__builtin_popcount(i),i});\n\
    \  }\n  std::sort(data.begin(), data.end(), cmp);\n  std::vector<long> answer;\n\
    \  for(auto i : data){\n    answer.push_back(i.decimal);\n  }\n  return answer;",
  "  std::vector<long> binArr;\n  for (long i = 0; i < arr.size(); i++) {\n    long\
    \ tmp = arr[i];\n    std::vector<long> tmpBin;\n    for (long j = 0; j < 30; j++)\
    \ {\n      if (tmp % 2 == 1) {\n        tmpBin.push_back(1);\n      } else {\n\
    \        tmpBin.push_back(0);\n      }\n      tmp /= 2;\n    }\n    long tmpCnt\
    \ = 0;\n    for (long j = 0; j < tmpBin.size(); j++) {\n      if (tmpBin[j] ==\
    \ 1) {\n        tmpCnt++;\n      }\n    }\n    binArr.push_back(tmpCnt);\n  }\n\
    \  long tmpCnt = 0;\n  std::sort(binArr.begin(), binArr.end());\n  std::vector<long>\
    \ tmpBin;\n  for (long i = 0; i < binArr.size(); i++) {\n    if (i < binArr.size()\
    \ - 1 && binArr[i] == binArr[i + 1]) {\n      tmpBin.push_back(arr[i]);\n    \
    \  arr.erase(arr.begin() + i);\n      i--;\n    } else {\n      tmpBin.push_back(arr[i]);\n\
    \      arr.erase(arr.begin() + i);\n      i--;\n      std::sort(tmpBin.begin(),\
    \ tmpBin.end());\n      for (long j = 0; j < tmpBin.size(); j++) {\n        arr.insert(arr.begin()\
    \ + tmpCnt, tmpBin[j]);\n        tmpCnt++;\n      }\n      tmpBin.clear();\n \
    \   }\n  }\n  return arr;", "  auto comp = [](long &a, long &b) {\n    auto getOnes\
    \ = [](long v) {\n      int c = 0;\n      while (v) {\n        if (v & 1) {\n\
    \          c++;\n        }\n        v >>= 1;\n      }\n      return c;\n    };\n\
    \    int va = getOnes(a);\n    int vb = getOnes(b);\n    if (va == vb) {\n   \
    \   return a < b;\n    }\n    return va < vb;\n  };\n  std::sort(arr.begin(),\
    \ arr.end(), comp);\n  return arr;", "  //your code here\n  std::vector<long>\
    \ onevec;\n  std::vector<long> zero;\n  std::vector<long> retArr;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    if (arr[i] < 0) {\n      zero.push_back(arr[i]);\n\
    \    } else {\n      onevec.push_back(arr[i]);\n    }\n  }\n  sort(onevec.begin(),\
    \ onevec.end());\n  sort(zero.begin(), zero.end());\n  for (int i = 0; i < onevec.size();\
    \ i++) {\n    for (int j = 0; j < onevec.size(); j++) {\n      if (countOne(onevec[i])\
    \ > countOne(onevec[j])) {\n        long temp = onevec[i];\n        onevec[i]\
    \ = onevec[j];\n        onevec[j] = temp;\n      }\n    }\n  }\n  retArr.insert(retArr.end(),\
    \ onevec.begin(), onevec.end());\n  retArr.insert(retArr.end(), zero.begin(),\
    \ zero.end());\n  return retArr;", "    sort(arr.begin(), arr.end(), [](long a,\
    \ long b) {\n        int c1 = __builtin_popcount(a);\n        int c2 = __builtin_popcount(b);\n\
    \        if (c1 == c2) {\n            return a < b;\n        }\n        return\
    \ c1 < c2;\n    });\n    return arr;", "  std::vector<long> ones;\n  std::vector<long>\
    \ twos;\n  std::vector<long> threes;\n  std::vector<long> fours;\n  std::vector<long>\
    \ fives;\n  std::vector<long> sixes;\n  std::vector<long> sevens;\n  std::vector<long>\
    \ eights;\n  std::vector<long> nines;\n  std::vector<long> tens;\n  std::vector<long>\
    \ elevens;\n  std::vector<long> twelves;\n  std::vector<long> thirteens;\n  std::vector<long>\
    \ fourteens;\n  std::vector<long> fifteens;\n  std::vector<long> sixteen;\n  std::vector<long>\
    \ seventeen;\n  std::vector<long> eighteen;\n  std::vector<long> nineteen;\n \
    \ std::vector<long> twenty;\n  std::vector<long> twentyOne;\n  std::vector<long>\
    \ twentyTwo;\n  std::vector<long> twentyThree;\n  std::vector<long> twentyFour;\n\
    \  std::vector<long> twentyFive;\n  std::vector<long> twentySix;\n  std::vector<long>\
    \ twentySeven;\n  std::vector<long> twentyEight;\n  std::vector<long> twentyNine;\n\
    \  std::vector<long> thirty;\n  std::vector<long> thirtyOne;\n  std::vector<long>\
    \ thirtyTwo;\n  std::vector<long> thirtyThree;\n  std::vector<long> thirtyFour;\n\
    \  std::vector<long> thirtyFive;\n  std::vector<long> thirtySix;\n  std::vector<long>\
    \ thirtySeven;\n  std::vector<long> thirtyEight;\n  std::vector<long> thirtyNine;\n\
    \  std::vector<long> forty;\n  std::vector<long> fortyOne;\n  std::vector<long>\
    \ fortyTwo;\n  std::vector<long> fortyThree;\n  std::vector<long> fortyFour;\n\
    \  std::vector<long> fortyFive;\n  std::vector<long> fortySix;\n  std::vector<long>\
    \ fortySeven", "  std::vector<long> res = arr;\n  std::sort(res.begin(), res.end(),\
    \ [](long a, long b) {\n    int a_ones = std::bitset<std::numeric_limits<long>::digits>(a).count();\n\
    \    int b_ones = std::bitset<std::numeric_limits<long>::digits>(b).count();\n\
    \    return a_ones == b_ones ? a < b : a_ones < b_ones;\n  });\n  return res;",
  "    std::vector<long> dup(arr);\n    std::sort(dup.begin(), dup.end(), [](long&\
    \ a, long& b) {\n        int n1 = __builtin_popcountl(a);\n        int n2 = __builtin_popcountl(b);\n\
    \        if (n1 == n2) return a < b;\n        return n1 < n2;\n    });\n    return\
    \ dup;", "  // your code here\n  // std::sort(arr.begin(), arr.end(), [](int a,\
    \ int b) { return a < b; });\n  // std::cout << \"Hello\" << std::endl;\n  std::vector<std::pair<int,\
    \ int>> bin_dec;\n  for (int i = 0; i < arr.size(); i++) {\n    int num = arr[i];\n\
    \    int ones = 0;\n    int dec = 0;\n    int power = 0;\n    while (num > 0)\
    \ {\n      dec += (num % 10) * pow(2, power);\n      if (num % 10 == 1) {\n  \
    \      ones++;\n      }\n      num /= 10;\n      power++;\n    }\n    std::pair<int,\
    \ int> p;\n    p.first = ones;\n    p.second = dec;\n    bin_dec.push_back(p);\n\
    \  }\n  std::sort(bin_dec.begin(), bin_dec.end(), [](std::pair<int, int> a, std::pair<int,\
    \ int> b) {\n    if (a.first == b.first) {\n      return a.second < b.second;\n\
    \    }\n    return a.first < b.first;\n  });\n  for (int i = 0; i < bin_dec.size();\
    \ i++) {\n    arr[i] = bin_dec[i].second;\n  }\n  return arr;", "  std::sort(arr.begin(),\
    \ arr.end(), [](long& a, long& b) {\n    int c1 = __builtin_popcountl(a);\n  \
    \  int c2 = __builtin_popcountl(b);\n    if (c1 != c2) {\n      return c1 < c2;\n\
    \    }\n    return a < b;\n  });\n  return arr;", "    for (size_t i = 0; i <\
    \ arr.size(); i++) {\n        for (size_t j = i + 1; j < arr.size(); j++) {\n\
    \            long count1 = 0;\n            long count2 = 0;\n            for (size_t\
    \ k = 0; k < 8; k++) {\n                count1 += (arr[i] >> k) & 1;\n       \
    \         count2 += (arr[j] >> k) & 1;\n            }\n            if (count1\
    \ == count2) {\n                if (arr[i] > arr[j]) {\n                    std::swap(arr[i],\
    \ arr[j]);\n                }\n            } else if (count1 > count2) {\n   \
    \             std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n  \
    \  return arr;", "  std::map<int, std::vector<long>> m;\n  for (int i = 0; i <\
    \ arr.size(); i++) {\n    int num = arr[i];\n    int zeros = 0;\n    while (num\
    \ > 0) {\n      if (num % 2 == 0) {\n        zeros++;\n      }\n      num /= 2;\n\
    \    }\n    m[zeros].push_back(arr[i]);\n  }\n  std::vector<long> result;\n  for\
    \ (auto it = m.begin(); it != m.end(); it++) {\n    std::sort(it->second.begin(),\
    \ it->second.end());\n    for (int i = 0; i < it->second.size(); i++) {\n    \
    \  result.push_back(it->second[i]);\n    }\n  }\n  return result;", "    std::vector<long>\
    \ ones;\n    std::vector<long> zeros;\n    std::vector<long> sorted_arr;\n   \
    \ for (auto i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n       \
    \     sorted_arr.push_back(arr[i]);\n        }\n    }\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    for (auto i = 0; i < sorted_arr.size(); i++) {\n   \
    \     if (__builtin_popcount(sorted_arr[i]) == 1) {\n            ones.push_back(sorted_arr[i]);\n\
    \        } else {\n            zeros.push_back(sorted_arr[i]);\n        }\n  \
    \  }\n    std::vector<long> ret_arr;\n    for (auto i = 0; i < ones.size(); i++)\
    \ {\n        ret_arr.push_back(ones[i]);\n    }\n    for (auto i = 0; i < zeros.size();\
    \ i++) {\n        ret_arr.push_back(zeros[i]);\n    }\n    for (auto i = 0; i\
    \ < arr.size(); i++) {\n        if (arr[i] < 0) {\n            ret_arr.push_back(arr[i]);\n\
    \        }\n    }\n    return ret_arr;", "    std::vector<long> output;\n    std::map<long,\
    \ long> mapOnes;\n    for (long i : arr) {\n        long countOnes = 0;\n    \
    \    while (i > 0) {\n            countOnes += i % 2;\n            i /= 2;\n \
    \       }\n        mapOnes[countOnes] = i;\n    }\n    for (auto pair : mapOnes)\
    \ {\n        output.push_back(pair.second);\n    }\n    return output;", "   \
    \ int n = arr.size();\n    std::vector<int> count(n, 0);\n    for (int i = 0;\
    \ i < n; i++) {\n        count[i] = __builtin_popcountll(arr[i]);\n    }\n   \
    \ std::vector<int> tmp(n, 0);\n    std::vector<int> position(n, 0);\n    std::vector<int>\
    \ final_position(n, 0);\n    std::vector<int> new_count(n, 0);\n    for (int j\
    \ = 0; j < 64; j++) {\n        for (int i = 0; i < n; i++) {\n            tmp[i]\
    \ = (arr[i] >> j) & 1;\n        }\n        for (int i = 0; i < n; i++) {\n   \
    \         position[i] = tmp[i] * n + count[i];\n        }\n        std::iota(final_position.begin(),\
    \ final_position.end(), 0);\n        std::sort(final_position.begin(), final_position.end(),\n\
    \                  [&position](int x, int y) { return position[x] < position[y];\
    \ });\n        for (int i = 0; i < n; i++) {\n            new_count[i] = count[final_position[i]];\n\
    \        }\n        count = new_count;\n        std::sort(final_position.begin(),\
    \ final_position.end(),\n                  [&arr](int x, int y) { return arr[x]\
    \ < arr[y]; });\n        std::vector<long> tmp_arr(n, 0);\n        for (int i\
    \ = 0; i < n; i++) {\n            tmp_arr[i] = arr[final_position[i]];\n     \
    \   }\n        arr = tmp_arr;\n    }\n    return arr;", "  // write your code\
    \ here\n  std::vector<long> sorted;\n  std::vector<long> order;\n  std::vector<long>\
    \ tmp;\n  int i = 0;\n  while (i < arr.size()) {\n    long x = arr[i];\n    while\
    \ (x != 0) {\n      order.push_back(x % 2);\n      x /= 2;\n    }\n    i++;\n\
    \  }\n  i = 0;\n  while (i < arr.size()) {\n    long x = arr[i];\n    while (x\
    \ != 0) {\n      tmp.push_back(x % 2);\n      x /= 2;\n    }\n    i++;\n  }\n\
    \  i = 0;\n  while (i < arr.size()) {\n    long counter = 0;\n    while (tmp[i]\
    \ != 0) {\n      if (tmp[i] == order[i])\n        counter++;\n      else\n   \
    \     break;\n      i++;\n    }\n    if (counter == tmp.size())\n      sorted.push_back(arr[i]);\n\
    \    else\n      i++;\n  }\n  return sorted;", "  int n = arr.size();\n  struct\
    \ pair {\n    int num;\n    int index;\n  };\n  struct pair a[n];\n  for (int\
    \ i = 0; i < n; i++) {\n    a[i].num = arr[i];\n    a[i].index = i;\n  }\n  int\
    \ count = 0;\n  for (int i = 0; i < n; i++) {\n    long num = a[i].num;\n    while\
    \ (num > 0) {\n      if (num % 2 == 1) {\n        count++;\n      }\n      num\
    \ /= 2;\n    }\n    a[i].num = count;\n    count = 0;\n  }\n  std::sort(a, a +\
    \ n, [](const pair &a, const pair &b) {\n    if (a.num == b.num) {\n      return\
    \ a.index < b.index;\n    }\n    return a.num < b.num;\n  });\n  for (int i =\
    \ 0; i < n; i++) {\n    arr[i] = a[i].index;\n  }\n  return arr;", "    std::sort(arr.begin(),\
    \ arr.end(), [](long lhs, long rhs) {\n        std::bitset<64> a(lhs);\n     \
    \   std::bitset<64> b(rhs);\n        return a.count() < b.count() ? true : (a.count()\
    \ == b.count() ? lhs < rhs : false);\n    });\n    return arr;", "  std::vector<long>\
    \ rez;\n  std::map<int, std::vector<long>> mp;\n  long n;\n  int b;\n  for (auto\
    \ &e : arr) {\n    n = e;\n    b = 0;\n    while (n > 0) {\n      b += n % 2;\n\
    \      n /= 2;\n    }\n    mp[b].push_back(e);\n  }\n  for (auto &e : mp) {\n\
    \    std::sort(e.second.begin(), e.second.end());\n    rez.insert(rez.end(), e.second.begin(),\
    \ e.second.end());\n  }\n  return rez;", "    std::vector<std::pair<int, int>>\
    \ a;\n    for (auto elem : arr) {\n        int b = 0;\n        int c = elem;\n\
    \        while (c) {\n            b += c%2;\n            c /= 2;\n        }\n\
    \        a.push_back(std::make_pair(b, elem));\n    }\n    std::sort(a.begin(),\
    \ a.end());\n    std::vector<long> ret;\n    for (auto elem : a) {\n        ret.push_back(elem.second);\n\
    \    }\n    return ret;", "    std::vector<long> binary_arr;\n    for (auto x\
    \ : arr) {\n        long bin = 0;\n        long decimal = x;\n        int count\
    \ = 0;\n        long rem;\n        while (decimal != 0) {\n            rem = decimal\
    \ % 2;\n            bin = bin + (rem * pow(10, count));\n            decimal =\
    \ decimal / 2;\n            count++;\n        }\n        binary_arr.push_back(bin);\n\
    \    }\n    for (int i = 0; i < binary_arr.size(); i++) {\n        for (int j\
    \ = i; j < binary_arr.size(); j++) {\n            if (binary_arr[i] > binary_arr[j])\
    \ {\n                std::swap(binary_arr[i], binary_arr[j]);\n              \
    \  std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n    return arr;",
  "\tstd::map<int, std::vector<long>> res;\n\tfor (long& value : arr) {\n\t\tint ones\
    \ = std::bitset<64>(value).count();\n\t\tres[ones].push_back(value);\n\t}\n\t\
    std::vector<long> result;\n\tfor (auto& value : res) {\n\t\tstd::sort(value.second.begin(),\
    \ value.second.end());\n\t\tfor (long& value : value.second) {\n\t\t\tresult.push_back(value);\n\
    \t\t}\n\t}\n\treturn result;", "  std::vector<long> sorted;\n  for (int i = 0;\
    \ i < arr.size(); i++) {\n    sorted.push_back(arr[i]);\n  }\n  std::sort(sorted.begin(),\
    \ sorted.end(),\n            [](const long &a, const long &b) {\n            \
    \  if (std::bitset<64>(a).count() == std::bitset<64>(b).count()) {\n         \
    \       return a < b;\n              }\n              return std::bitset<64>(a).count()\
    \ < std::bitset<64>(b).count();\n            });\n  return sorted;", "    std::vector<std::pair<int,\
    \ int>> binary_counts;\n    binary_counts.reserve(arr.size());\n    for (int i\
    \ = 0; i < arr.size(); i++) {\n        binary_counts.push_back(std::make_pair(std::bitset<32>(arr[i]).count(),\
    \ arr[i]));\n    }\n    std::sort(binary_counts.begin(), binary_counts.end());\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        arr[i] = binary_counts[i].second;\n\
    \    }\n    return arr;", "    std::sort(arr.begin(), arr.end(),\n           \
    \   [](long lhs, long rhs) {\n                  return std::bitset<32>(lhs).count()\
    \ == std::bitset<32>(rhs).count() ? lhs < rhs : std::bitset<32>(lhs).count() <\
    \ std::bitset<32>(rhs).count();\n              });\n    return arr;", "    if\
    \ (arr.size() == 0) return arr;\n    std::sort(arr.begin(), arr.end(), [](long\
    \ a, long b) {\n        int aa = 0, bb = 0;\n        while (a > 0) {\n       \
    \     aa += a % 2;\n            a /= 2;\n        }\n        while (b > 0) {\n\
    \            bb += b % 2;\n            b /= 2;\n        }\n        return (aa\
    \ < bb) || (aa == bb && a < b);\n    });\n    return arr;", "  for (int i = 0;\
    \ i < arr.size(); i++) {\n    for (int j = i + 1; j < arr.size(); j++) {\n   \
    \   if (__builtin_popcount(arr[i]) > __builtin_popcount(arr[j])) {\n        auto\
    \ temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      } else\
    \ if (__builtin_popcount(arr[i]) == __builtin_popcount(arr[j])) {\n        if\
    \ (arr[i] > arr[j]) {\n          auto temp = arr[i];\n          arr[i] = arr[j];\n\
    \          arr[j] = temp;\n        }\n      }\n    }\n  }\n  return arr;", '  return
    arr;', "  assert(arr.size() >= 1);\n  vector<long> sorted;\n  vector<long> zeros;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      zeros.push_back(arr[i]);\n\
    \    } else {\n      long numOnes = countOnes(arr[i]);\n      sorted.push_back(arr[i]);\n\
    \    }\n  }\n  sort(sorted.begin(), sorted.end(), greater<long>());\n  return\
    \ sorted;", "    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n    \
    \  int bits_a = 0;\n      int bits_b = 0;\n      for (int i = 0; i < 32; i++)\
    \ {\n        bits_a += (a >> i) & 1;\n        bits_b += (b >> i) & 1;\n      }\n\
    \      if (bits_a != bits_b) {\n        return bits_a < bits_b;\n      }\n   \
    \   return a < b;\n    });\n    return arr;", "  std::vector<std::pair<long, long>>\
    \ A;\n  for (int i = 0; i < arr.size(); i++) {\n    A.push_back(std::make_pair(arr[i],\
    \ __builtin_popcount(arr[i])));\n  }\n  std::sort(A.begin(), A.end(), [](std::pair<long,\
    \ long> a, std::pair<long, long> b) {\n    if (a.second == b.second) {\n     \
    \ return a.first < b.first;\n    }\n    return a.second < b.second;\n  });\n \
    \ for (int i = 0; i < arr.size(); i++) {\n    arr[i] = A[i].first;\n  }\n  return\
    \ arr;", "  std::vector<long> ret_arr;\n  std::vector<long> temp_arr;\n  std::stringstream\
    \ ss;\n  int max_length = 0;\n  std::cout << \"Original vector\" << std::endl;\n\
    \  for (long i : arr) {\n    std::cout << i << std::endl;\n    ss << std::bitset<8>(i);\n\
    \    max_length = std::max(max_length, (int)ss.str().length());\n    ss.str(\"\
    \");\n  }\n  std::cout << \"max_length = \" << max_length << std::endl;\n  //\
    \ std::cout << \"max_length = \" << max_length << std::endl;\n  std::string bin_str;\n\
    \  int num_1s;\n  std::unordered_map<int, std::vector<long>> groups;\n  for (long\
    \ i : arr) {\n    ss << std::bitset<8>(i);\n    bin_str = ss.str();\n    ss.str(\"\
    \");\n    num_1s = std::count(bin_str.begin(), bin_str.end(), '1');\n    // std::cout\
    \ << \"num_1s = \" << num_1s << std::endl;\n    groups[num_1s].push_back(i);\n\
    \  }\n  std::cout << \"Sorted vector\" << std::endl;\n  for (auto group : groups)\
    \ {\n    std::sort(group.second.begin(), group.second.end());\n    for (long i\
    \ : group.second) {\n      std::cout << i << std::endl;\n    }\n  }\n  return\
    \ ret_arr;", "  // your code here\n  int len = arr.size();\n  std::vector<long>\
    \ res;\n  std::map<long,long> m;\n  std::map<long,long>::iterator itr;\n  for(int\
    \ i=0;i<len;i++){\n    long count = 0;\n    while(arr[i]>0){\n      if(arr[i]%2==1){\n\
    \        count++;\n      }\n      arr[i]/=2;\n    }\n    m.insert(std::pair<long,long>(count,arr[i]));\n\
    \  }\n  for(itr=m.begin();itr!=m.end();itr++){\n    res.push_back(itr->second);\n\
    \  }\n  return res;", "    // sort the array based on number of 1s\n    // sort\
    \ it based on decimal value\n    // sort it by 0s, then 1s, then 2s, then 3s,\
    \ etc\n    // make this a multi step sort\n    std::vector<long> binones;\n  \
    \  std::vector<long> temp;\n    std::vector<long> output;\n    long ones = 0;\n\
    \    // int i = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        // std::cout\
    \ << \"stuff\" << std::endl;\n        // std::cout << arr[i] << std::endl;\n \
    \       long num = arr[i];\n        // std::cout << \"num \" << num << std::endl;\n\
    \        long converted = convertToBinary(num);\n        // std::cout << \"converted\
    \ \" << converted << std::endl;\n        binones.push_back(converted);\n     \
    \   // std::cout << binones[i] << std::endl;\n    }\n    for (int i = 0; i < binones.size();\
    \ i++) {\n        // std::cout << \"binones \" << binones[i] << std::endl;\n \
    \   }\n    std::sort(binones.begin(), binones.end());\n    // std::sort(binones.begin(),\
    \ binones.end(), greater<long>());\n    for (int i = 0; i < binones.size(); i++)\
    \ {\n        // std::cout << \"binones \" << binones[i] << std::endl;\n    }\n\
    \    // std::cout << \"binones \" << binones.size() << std::endl;\n    for (int\
    \ i = 0; i < binones.size(); i++) {\n        long temp = binones[i];\n       \
    \ // std::cout << \"temp \" << temp << std::endl;\n        // std::cout << temp\
    \ << std::endl;\n        for (int j = 0; j < arr.size(); j++) {\n            long\
    \ num = arr[j];\n            // std::cout << \"num \" << num << std::endl;\n \
    \           long converted", "    std::sort(arr.begin(), arr.end(), [](long a,\
    \ long b) {\n        auto count_bits = [](long x) {\n            std::bitset<32>\
    \ b(x);\n            return b.count();\n        };\n        int ones_a = count_bits(a);\n\
    \        int ones_b = count_bits(b);\n        if (ones_a == ones_b) {\n      \
    \      return a < b;\n        }\n        return ones_a < ones_b;\n    });\n  \
    \  return arr;", "  std::vector<long> v;\n  std::map<int,std::vector<long>> m;\n\
    \  for(long i : arr) {\n    std::bitset<64> bit(i);\n    m[bit.count()].push_back(i);\n\
    \  }\n  for(std::pair<int,std::vector<long>> p : m) {\n    std::sort(p.second.begin(),p.second.end());\n\
    \    for(long i : p.second) {\n      v.push_back(i);\n    }\n  }\n  return v;",
  "  // sort based on number of ones\n  std::sort(arr.begin(), arr.end(), [](long\
    \ a, long b) {\n    int c1 = 0, c2 = 0;\n    while (a > 0) {\n      if (a % 2\
    \ == 1)\n        c1++;\n      a /= 2;\n    }\n    while (b > 0) {\n      if (b\
    \ % 2 == 1)\n        c2++;\n      b /= 2;\n    }\n    if (c1 == c2)\n      return\
    \ a < b;\n    return c1 < c2;\n  });\n  return arr;", "    std::map<int, std::pair<int,\
    \ int>> mp;\n    for (int i = 0; i < arr.size(); i++) {\n        long n = arr[i];\n\
    \        int count = 0;\n        while (n) {\n            count += n & 1;\n  \
    \          n >>= 1;\n        }\n        mp[count].first = std::max(mp[count].first,\
    \ arr[i]);\n        mp[count].second = std::min(mp[count].second, arr[i]);\n \
    \   }\n    std::vector<long> ans;\n    for (auto p : mp) {\n        ans.push_back(p.second.second);\n\
    \        ans.push_back(p.second.first);\n    }\n    return ans;", "  // your code\
    \ here\n  std::vector<std::pair<long, long>> r(arr.size());\n  for (auto i = 0;\
    \ i < arr.size(); ++i) {\n    int count = 0;\n    long temp = arr[i];\n    while\
    \ (temp > 0) {\n      count += temp & 1;\n      temp >>= 1;\n    }\n    r[i] =\
    \ std::make_pair(count, arr[i]);\n  }\n  std::sort(r.begin(), r.end());\n  for\
    \ (auto i = 0; i < arr.size(); ++i) {\n    arr[i] = r[i].second;\n  }\n  return\
    \ arr;", "  std::vector<long> res(arr.size());\n  std::multimap<int, long> sorter;\n\
    \  for (long l : arr) {\n    std::bitset<sizeof(long) * 8> binary(l);\n    sorter.insert(std::make_pair(binary.count(),\
    \ l));\n  }\n  auto it = res.begin();\n  for (auto i = sorter.begin(); i != sorter.end();\
    \ ++i) {\n    *it = i->second;\n    ++it;\n  }\n  return res;", "    std::sort(arr.begin(),\
    \ arr.end(), [&](const long & a, const long & b) {\n        int ones_a = std::bitset<64>(a).count();\n\
    \        int ones_b = std::bitset<64>(b).count();\n        if (ones_a != ones_b)\
    \ {\n            return ones_a < ones_b;\n        }\n        return a < b;\n \
    \   });\n    return arr;", "  std::vector<long> newArr;\n  std::set<long>  zerostr,\
    \ set;\n  for (long i = 0; i < arr.size(); i++) {\n    long current = arr[i];\n\
    \    long countOnes = 0;\n    while (current > 0) {\n      if (current % 2 ==\
    \ 1) {\n        countOnes++;\n      }\n      current /= 2;\n    }\n    newArr.push_back(countOnes);\n\
    \    if (countOnes == 0) {\n      zerostr.insert(arr[i]);\n    } else {\n    \
    \  set.insert(arr[i]);\n    }\n  }\n  std::vector<long> answer;\n  for (auto iter\
    \ = zerostr.begin(); iter != zerostr.end(); iter++) {\n    answer.push_back(*iter);\n\
    \  }\n  for (auto iter = set.begin(); iter != set.end(); iter++) {\n    answer.push_back(*iter);\n\
    \  }\n  return answer;", "  //your code here\n  std::vector<long>::iterator it;\n\
    \  std::vector<long> res;\n  std::vector<long> binarr;\n  std::vector<long> sorted\
    \ = arr;\n  std::cout << \"Initial array: \";\n  for (it = arr.begin(); it !=\
    \ arr.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n\
    \  std::sort(sorted.begin(), sorted.end());\n  std::cout << \"Sorted array: \"\
    ;\n  for (it = sorted.begin(); it != sorted.end(); it++) {\n    std::cout << *it\
    \ << \" \";\n  }\n  std::cout << std::endl;\n  for (it = sorted.begin(); it !=\
    \ sorted.end(); it++) {\n    binarr.push_back(std::bitset<8>(*it).count());\n\
    \  }\n  std::cout << \"number of ones: \";\n  for (it = binarr.begin(); it !=\
    \ binarr.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n\
    \  for (it = binarr.begin(); it != binarr.end(); it++) {\n    res.push_back(sorted[it\
    \ - binarr.begin()]);\n  }\n  std::cout << \"sorted array: \";\n  for (it = res.begin();\
    \ it != res.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout <<\
    \ std::endl;\n  return res;", "  std::sort(arr.begin(), arr.end(), [&](auto&&\
    \ a, auto&& b) {\n    // convert a to binary\n    auto a_binary = std::bitset<32>(a).to_string();\n\
    \    // count the number of ones in the string\n    auto n_a_ones = std::count(a_binary.begin(),\
    \ a_binary.end(), '1');\n    // convert b to binary\n    auto b_binary = std::bitset<32>(b).to_string();\n\
    \    // count the number of ones in the string\n    auto n_b_ones = std::count(b_binary.begin(),\
    \ b_binary.end(), '1');\n    // return false if a has more ones\n    if (n_a_ones\
    \ > n_b_ones) {\n      return false;\n    }\n    // return true if b has more\
    \ ones\n    if (n_a_ones < n_b_ones) {\n      return true;\n    }\n    // return\
    \ true if a is less than b\n    return a < b;\n  });\n  return arr;", "    if\
    \ (arr.size() == 0) return arr;\n    std::vector<std::vector<long>> ones;\n  \
    \  for (long i = 0; i < arr.size(); i++) {\n        long num = arr[i];\n     \
    \   long count = 0;\n        while (num > 0) {\n            count += num % 2;\n\
    \            num /= 2;\n        }\n        if (ones.size() <= count) ones.resize(count\
    \ + 1);\n        ones[count].push_back(arr[i]);\n    }\n    arr.clear();\n   \
    \ for (long i = 0; i < ones.size(); i++) {\n        std::sort(ones[i].begin(),\
    \ ones[i].end());\n        arr.insert(arr.end(), ones[i].begin(), ones[i].end());\n\
    \    }\n    return arr;", "  std::sort(arr.begin(), arr.end(), [](const long&\
    \ left, const long& right) {\n    if (std::bitset<32>(left).count() == std::bitset<32>(right).count())\
    \ {\n      return left < right;\n    } else {\n      return std::bitset<32>(left).count()\
    \ < std::bitset<32>(right).count();\n    }\n  });\n  return arr;", "  if (arr.size()\
    \ <= 1) {\n    return arr;\n  }\n  std::sort(arr.begin(), arr.end(), [](const\
    \ long& a, const long& b) {\n    int num_ones_a = std::bitset<32>(a).count();\n\
    \    int num_ones_b = std::bitset<32>(b).count();\n    if (num_ones_a != num_ones_b)\
    \ {\n      return num_ones_a < num_ones_b;\n    }\n    return a < b;\n  });\n\
    \  return arr;", "  using namespace std;\n  int mask = 1;\n  for (int i = 0; i\
    \ < 31; i++) {\n    vector<pair<int,int>> v;\n    for (auto &a : arr) {\n    \
    \  v.push_back(make_pair(a&mask, a));\n    }\n    sort(v.begin(), v.end());\n\
    \    transform(v.begin(), v.end(), arr.begin(), [](pair<int,int> v){return v.second;});\n\
    \    mask <<= 1;\n  }\n  return arr;", "    std::vector<long> binArr;\n    std::vector<long>\
    \ sortArr;\n    int totalOnes = 0;\n    int totalZeros = 0;\n    long copy;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        std::cout << \"i \" << i\
    \ << std::endl;\n        std::cout << \"arr[i] \" << arr[i] << std::endl;\n  \
    \      copy = arr[i];\n        std::cout << \"copy \" << copy << std::endl;\n\
    \        for (int j = 0; copy >= 1; j++) {\n            if (copy % 2 == 0) {\n\
    \                totalZeros++;\n            } else {\n                totalOnes++;\n\
    \            }\n            copy = copy / 2;\n        }\n        binArr.push_back(totalOnes);\n\
    \        binArr.push_back(totalZeros);\n        binArr.push_back(arr[i]);\n  \
    \      std::cout << \"binArr size \" << binArr.size() << std::endl;\n        totalOnes\
    \ = 0;\n        totalZeros = 0;\n    }\n    for (int i = 0; i < binArr.size();\
    \ i++) {\n        std::cout << \"binArr[i] \" << binArr[i] << std::endl;\n   \
    \ }\n    std::cout << \"binArr.size()/3 \" << binArr.size() / 3 << std::endl;\n\
    \    std::sort(binArr.begin(), binArr.end());\n    std::cout << \"binArr sorted\"\
    \ << std::endl;\n    for (int i = 0; i < binArr.size(); i++) {\n        std::cout\
    \ << \"binArr[i] \" << binArr[i] << std::endl;\n    }\n    for (int i = 2; i <\
    \ binArr.size(); i = i + 3) {\n        sortArr.push_back(binArr[i]);\n    }\n\
    \    for (int i = 0; i < sortArr.size(); i++) {", "  std::vector<long> sorted,\
    \ binary_sorted;\n  // sort\n  std::sort(arr.begin(), arr.end());\n  // loop through\n\
    \  for (long i = 0; i < arr.size(); i++) {\n    if (arr[i] >= 0) {\n      std::string\
    \ binary = std::bitset<32>(arr[i]).to_string();\n      binary_sorted.push_back(count(binary.begin(),\
    \ binary.end(), '1'));\n    }\n  }\n  // sort based on binary\n  std::sort(binary_sorted.begin(),\
    \ binary_sorted.end());\n  for (int i = 0; i < binary_sorted.size(); i++) {\n\
    \    for (int j = 0; j < arr.size(); j++) {\n      std::string binary = std::bitset<32>(arr[j]).to_string();\n\
    \      if (binary_sorted[i] == count(binary.begin(), binary.end(), '1')) {\n \
    \       sorted.push_back(arr[j]);\n        arr[j] = -111111;\n        break;\n\
    \      }\n    }\n  }\n  return sorted;", "  if(arr.size() == 0){\n    return arr;\n\
    \  }\n  //first sort them by comparing the binary equivalents\n  std::sort(arr.begin(),\
    \ arr.end(), [](long i, long j){\n    long num1, num2;\n    num1 = i;\n    num2\
    \ = j;\n    //count the number of 1s in the binary equivalent of these two numbers\n\
    \    int count1 = 0, count2 = 0;\n    while(num1 != 0){\n      if(num1 & 1){\n\
    \        count1++;\n      }\n      num1 = num1 >> 1;\n    }\n    while(num2 !=\
    \ 0){\n      if(num2 & 1){\n        count2++;\n      }\n      num2 = num2 >> 1;\n\
    \    }\n    //compare the number of 1s in the binary equivalent\n    if(count1\
    \ == count2){\n      return i < j;\n    }else{\n      return count1 < count2;\n\
    \    }\n  });\n  return arr;", "  std::sort(arr.begin(), arr.end(),\n        \
    \    [](const long lhs, const long rhs) {\n              auto lhsOnes = std::bitset<32>(lhs).count();\n\
    \              auto rhsOnes = std::bitset<32>(rhs).count();\n              return\
    \ lhsOnes == rhsOnes ? lhs < rhs : lhsOnes < rhsOnes;\n            });\n  return\
    \ arr;", "    // your code here\n    std::vector<long> sorted;\n    std::set<long>\
    \ cache;\n    std::set<long>::iterator it;\n    std::vector<long>::iterator itr;\n\
    \    int count = 0;\n    // sort based on number of ones\n    for (itr = arr.begin();\
    \ itr != arr.end(); itr++) {\n        count = 0;\n        while (*itr) {\n   \
    \         count++;\n            *itr = *itr >> 1;\n        }\n        cache.insert(count);\n\
    \    }\n    for (it = cache.begin(); it != cache.end(); it++) {\n        for (itr\
    \ = arr.begin(); itr != arr.end(); itr++) {\n            count = 0;\n        \
    \    while (*itr) {\n                count++;\n                *itr = *itr >>\
    \ 1;\n            }\n            if (count == *it) {\n                sorted.push_back(*itr);\n\
    \            }\n        }\n    }\n    // sort based on decimal value\n    std::sort(sorted.begin(),\
    \ sorted.end());\n    return sorted;", "  std::vector<long> new_arr;\n  std::vector<long>\
    \ binary_arr;\n  long count = 0;\n  for (long i = 0; i < arr.size(); i++) {\n\
    \    long num = arr[i];\n    while (num != 0) {\n      if (num % 2 == 1) {\n \
    \       count++;\n      }\n      num = num / 2;\n    }\n    binary_arr.push_back(count);\n\
    \    count = 0;\n  }\n  for (long i = 0; i < binary_arr.size(); i++) {\n    for\
    \ (long j = 0; j < binary_arr.size(); j++) {\n      if (binary_arr[i] < binary_arr[j])\
    \ {\n        long temp = binary_arr[i];\n        binary_arr[i] = binary_arr[j];\n\
    \        binary_arr[j] = temp;\n        temp = arr[i];\n        arr[i] = arr[j];\n\
    \        arr[j] = temp;\n      }\n    }\n  }\n  for (long i = 0; i < binary_arr.size();\
    \ i++) {\n    for (long j = 0; j < binary_arr.size(); j++) {\n      if (binary_arr[i]\
    \ == binary_arr[j]) {\n        if (arr[i] < arr[j]) {\n          long temp = arr[i];\n\
    \          arr[i] = arr[j];\n          arr[j] = temp;\n        }\n      }\n  \
    \  }\n  }\n  new_arr = arr;\n  return new_arr;", "    int ones[arr.size()],a[arr.size()];\n\
    \    for(int i=0;i<arr.size();i++){\n        std::string str = std::bitset<32>(arr[i]).to_string();\n\
    \        ones[i]=std::count(str.begin(),str.end(),'1');\n        a[i]=arr[i];\n\
    \    }\n    std::sort(a,a+arr.size());\n    std::vector<long> ans;\n    ans.clear();\n\
    \    for(int i=0;i<arr.size();i++){\n        for(int j=0;j<arr.size();j++){\n\
    \            if(ones[j]==i){\n                for(int k=0;k<arr.size();k++){\n\
    \                    if(a[k]==arr[j]){\n                        ans.push_back(arr[j]);\n\
    \                        a[k]=-1;\n                        break;\n          \
    \          }\n                }\n            }\n        }\n    }\n    return ans;",
  "  std::sort(arr.begin(), arr.end(), [] (const long& lhs, const long& rhs) {\n \
    \   unsigned int num_ones_lhs = __builtin_popcount(lhs);\n    unsigned int num_ones_rhs\
    \ = __builtin_popcount(rhs);\n    if (num_ones_lhs == num_ones_rhs)\n      return\
    \ lhs < rhs;\n    return num_ones_lhs < num_ones_rhs;\n  });\n  return arr;",
  "  int z=0;\n  std::vector<long> zero(arr.size());\n  std::vector<long> sorted_arr(arr.size());\n\
    \  for(long i=0;i<arr.size();i++){\n    if(arr[i]==0){\n      zero[z]=arr[i];\n\
    \      z++;\n    }\n  }\n  for(long i=0;i<arr.size();i++){\n    if(arr[i]!=0){\n\
    \      long a=arr[i];\n      int count=0;\n      while(a>0){\n        a=a&(a-1);\n\
    \        count++;\n      }\n      sorted_arr[count]=arr[i];\n    }\n  }\n  for(long\
    \ i=0;i<z;i++){\n    sorted_arr[i]=zero[i];\n  }\n  return sorted_arr;", "  std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b) {\n    if (__builtin_popcount(a) == __builtin_popcount(b))\n\
    \      return a < b;\n    return __builtin_popcount(a) < __builtin_popcount(b);\n\
    \  });\n  return arr;", "  // return arr;\n  std::vector<long> binArr(arr.size());\n\
    \  std::vector<long> oneArr(arr.size());\n  long index = 0;\n  for (auto num :\
    \ arr) {\n    long count = 0;\n    int binNum = num;\n    while (binNum) {\n \
    \     if (binNum & 1)\n        count++;\n      binNum = binNum >> 1;\n    }\n\
    \    oneArr[index] = count;\n    binArr[index] = num;\n    index++;\n  }\n  //\
    \ std::cout << \"\\nbinArr vector is\\n\";\n  // for (auto num : binArr)\n  //\
    \   std::cout << num << \" \";\n  // std::cout << \"\\noneArr vector is\\n\";\n\
    \  // for (auto num : oneArr)\n  //   std::cout << num << \" \";\n  std::vector<long>\
    \ sortedArr(arr.size());\n  for (int i = 0; i < arr.size(); i++) {\n    int minIndex\
    \ = std::min_element(oneArr.begin(), oneArr.end()) - oneArr.begin();\n    // std::cout\
    \ << \"\\nminIndex is: \" << minIndex;\n    sortedArr[i] = binArr[minIndex];\n\
    \    binArr[minIndex] = INT_MAX;\n    oneArr[minIndex] = INT_MAX;\n  }\n  return\
    \ sortedArr;", "  std::vector<std::pair<long, long>> mapped;\n  for (long i =\
    \ 0; i < arr.size(); i++) {\n    mapped.push_back(std::make_pair(__builtin_popcountl(arr[i]),\
    \ arr[i]));\n  }\n  sort(mapped.begin(), mapped.end());\n  for (long i = 0; i\
    \ < arr.size(); i++) {\n    arr[i] = mapped[i].second;\n  }\n  return arr;", " \
    \   int n = arr.size();\n    // std::cout << n << std::endl;\n    std::vector<long>\
    \ sorted(n);\n    std::vector<int> counts(n);\n    int count = 0;\n    for (int\
    \ i = 0; i < n; i++) {\n        long x = arr[i];\n        while (x > 0) {\n  \
    \          if (x % 2 == 1)\n                count++;\n            x /= 2;\n  \
    \      }\n        counts[i] = count;\n        count = 0;\n    }\n    std::vector<std::pair<int,\
    \ int>> v;\n    for (int i = 0; i < n; i++) {\n        v.push_back(std::make_pair(counts[i],\
    \ arr[i]));\n    }\n    std::sort(v.begin(), v.end());\n    for (int i = 0; i\
    \ < n; i++) {\n        sorted[i] = v[i].second;\n    }\n    return sorted;", " \
    \ std::sort(arr.begin(), arr.end(), [](long &n1, long &n2) {\n    if (std::bitset<32>(n1).count()\
    \ == std::bitset<32>(n2).count()) {\n      return n1 < n2;\n    }\n    return\
    \ std::bitset<32>(n1).count() < std::bitset<32>(n2).count();\n  });\n  return\
    \ arr;", "  auto func = [] (long num) {\n    std::string s = std::bitset<32>(num).to_string();\n\
    \    return std::bitset<32>(s).count();\n  };\n  std::sort(arr.begin(), arr.end(),\
    \ [&] (long lhs, long rhs) {\n    long lhs_ones = func(lhs);\n    long rhs_ones\
    \ = func(rhs);\n    if (lhs_ones != rhs_ones) {\n      return lhs_ones < rhs_ones;\n\
    \    }\n    return lhs < rhs;\n  });\n  return arr;", "  // sort in descending\
    \ order of number of ones\n  // return sorted array\n  int n = arr.size();\n \
    \ std::vector<std::pair<long, int>>temp(n);\n  for (int i = 0; i < n; i++) {\n\
    \    long count = 0;\n    int k = arr[i];\n    while (k > 0) {\n      if (k %\
    \ 2 == 1)\n        count++;\n      k /= 2;\n    }\n    temp[i] = std::make_pair(arr[i],\
    \ count);\n  }\n  std::sort(temp.begin(), temp.end(),\n            [](const std::pair<long,\
    \ int> &lhs, const std::pair<long, int> &rhs) {\n              if (lhs.second\
    \ == rhs.second)\n                return lhs.first < rhs.first;\n            \
    \  return lhs.second > rhs.second;\n            });\n  for (int i = 0; i < n;\
    \ i++)\n    arr[i] = temp[i].first;\n  return arr;", "  std::vector<long> result\
    \ = arr;\n  std::sort(result.begin(), result.end(), [&](long a, long b) {\n  \
    \  int a_num_ones = 0;\n    int b_num_ones = 0;\n    while (a > 0) {\n      a_num_ones\
    \ += a % 2;\n      a /= 2;\n    }\n    while (b > 0) {\n      b_num_ones += b\
    \ % 2;\n      b /= 2;\n    }\n    if (a_num_ones != b_num_ones) {\n      return\
    \ a_num_ones < b_num_ones;\n    }\n    return a < b;\n  });\n  return result;",
  "    // int n = arr.size();\n    // long count[n];\n    // long max = 0;\n    //\
    \ long k = 0;\n    // for(int i = 0; i < n; i++) {\n    //     long num = arr[i];\n\
    \    //     //count[i] = 0;\n    //     while(num > 0) {\n    //         if(num\
    \ % 2 == 1)\n    //             count[i]++;\n    //         num /= 2;\n    //\
    \     }\n    //     if(count[i] > max)\n    //         max = count[i];\n    //\
    \ }\n    // for(int i = 0; i < n; i++) {\n    //     if(count[i] == max) {\n \
    \   //         arr[k] = arr[i];\n    //         k++;\n    //     }\n    // }\n\
    \    // int index = k;\n    // for(int i = 0; i < n; i++) {\n    //     if(count[i]\
    \ != max) {\n    //         arr[index] = arr[i];\n    //         index++;\n  \
    \  //     }\n    // }\n    // return arr;\n    // long max = -1;\n    // long\
    \ count = 0;\n    // long size = arr.size();\n    // std::vector<long> temp(size);\n\
    \    // for(int i = 0; i < size; i++) {\n    //     if(arr[i] > max)\n    // \
    \        max = arr[i];\n    // }\n    // for(int i = 0; i < size; i++) {\n   \
    \ //     long num = arr[i];\n    //     long count_1 = 0;\n    //     while(num\
    \ > 0) {\n    //         if(num % 2 == 1)\n    //             count_1++;\n   \
    \ //         num /= 2;\n    //     }\n    //     temp[count] = count_1;\n    //\
    \     count++;\n    // }\n    // std::sort(temp.begin(), temp.end());\n    //\
    \ std::vector<long>::iterator it;\n    // it = std::unique(temp.begin(), temp",
  "    std::vector<long> binarr(arr.size());\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        long num = arr[i];\n        long binnum = 0;\n        while\
    \ (num > 0) {\n            binnum += num & 1;\n            num >>= 1;\n      \
    \  }\n        binarr[i] = binnum;\n    }\n    std::vector<long> sortedarr(arr.size());\n\
    \    std::sort(arr.begin(), arr.end());\n    int i = 0;\n    while (i < arr.size())\
    \ {\n        int count = 0;\n        long element = arr[i];\n        while (i\
    \ < arr.size() && arr[i] == element) {\n            count++;\n            i++;\n\
    \        }\n        for (int j = 0; j < count; j++) {\n            sortedarr[count-j-1]\
    \ = element;\n        }\n    }\n    return sortedarr;", "    std::vector<std::pair<int,int>>\
    \ v;\n    for(int i=0;i<arr.size();i++){\n        int count = __builtin_popcount(arr[i]);\n\
    \        v.push_back(std::make_pair(count,arr[i]));\n    }\n    std::sort(v.begin(),v.end());\n\
    \    std::vector<long> ans;\n    for(int i=0;i<v.size();i++){\n        ans.push_back(v[i].second);\n\
    \    }\n    return ans;", "  std::vector<std::pair<int, long>> vec;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    int k = arr[i];\n    int count = 0;\n   \
    \ while (k) {\n      count += k & 1;\n      k >>= 1;\n    }\n    vec.push_back(std::make_pair(count,\
    \ arr[i]));\n  }\n  std::sort(vec.begin(), vec.end());\n  for (int i = 0; i <\
    \ arr.size(); i++) {\n    arr[i] = vec[i].second;\n  }\n  return arr;", "  //\
    \ 1. Get ones in binary represenation.\n  // 2. Sort using that value.\n  // 3.\
    \ Sort using decimal value if ones count is equal.\n  // 4. Return vector.\n \
    \ std::vector<long> ret;\n  std::vector<long> count_ones;\n  std::vector<long>\
    \ decimal_val;\n  for (int i = 0; i < arr.size(); i++) {\n    int temp = arr[i];\n\
    \    int c = 0;\n    int d = 0;\n    while (temp) {\n      c++;\n      temp =\
    \ temp & (temp - 1);\n    }\n    count_ones.push_back(c);\n    decimal_val.push_back(arr[i]);\n\
    \  }\n  // Sort based on ones count.\n  for (int i = 0; i < count_ones.size();\
    \ i++) {\n    for (int j = i + 1; j < count_ones.size(); j++) {\n      if (count_ones[i]\
    \ > count_ones[j]) {\n        long temp = count_ones[i];\n        count_ones[i]\
    \ = count_ones[j];\n        count_ones[j] = temp;\n        temp = decimal_val[i];\n\
    \        decimal_val[i] = decimal_val[j];\n        decimal_val[j] = temp;\n  \
    \    }\n    }\n  }\n  // Sort based on decimal value if count of ones is equal.\n\
    \  for (int i = 0; i < count_ones.size(); i++) {\n    for (int j = i + 1; j <\
    \ count_ones.size(); j++) {\n      if (count_ones[i] == count_ones[j]) {\n   \
    \     if (decimal_val[i] > decimal_val[j]) {\n          long temp = decimal_val[i];\n\
    \          decimal_val[i] = decimal_val[j];\n          decimal_val[j] = temp;\n\
    \        }\n      }\n    }\n  }\n  return decimal_val;", "  std::vector<long>\
    \ vec;\n  vec.reserve(arr.size());\n  std::map<int,std::vector<long>> myMap;\n\
    \  for(size_t i = 0; i < arr.size(); i++) {\n    int count = 0;\n    long num\
    \ = arr[i];\n    while(num != 0) {\n      if(num % 2 == 1)\n        count++;\n\
    \      num = num/2;\n    }\n    myMap[count].push_back(arr[i]);\n  }\n  for(auto\
    \ &x : myMap) {\n    sort(x.second.begin(), x.second.end());\n    for(size_t i\
    \ = 0; i < x.second.size(); i++) {\n      vec.push_back(x.second[i]);\n    }\n\
    \  }\n  return vec;", "  for (size_t i = 0; i < arr.size(); i++) {\n    for (size_t\
    \ j = i + 1; j < arr.size(); j++) {\n      int a = arr[i];\n      int b = arr[j];\n\
    \      int c = 0;\n      int d = 0;\n      while (a > 0) {\n        if (a % 2\
    \ == 1) {\n          c++;\n        }\n        a /= 2;\n      }\n      while (b\
    \ > 0) {\n        if (b % 2 == 1) {\n          d++;\n        }\n        b /= 2;\n\
    \      }\n      if (c < d) {\n        std::swap(arr[i], arr[j]);\n      } else\
    \ if (c == d) {\n        if (arr[i] > arr[j]) {\n          std::swap(arr[i], arr[j]);\n\
    \        }\n      }\n    }\n  }\n  return arr;", "  std::vector<long> out;\n \
    \ long i;\n  out.resize(arr.size());\n  long ones;\n  std::vector<long> temp;\n\
    \  temp.resize(32);\n  for (i = 0; i < arr.size(); i++) {\n    temp[i] = arr[i];\n\
    \  }\n  sort(temp.begin(), temp.end());\n  std::vector<long>::iterator it;\n \
    \ it = std::unique(temp.begin(), temp.end());\n  temp.resize(std::distance(temp.begin(),\
    \ it));\n  for (i = 0; i < temp.size(); i++) {\n    for (long j = 0; j < arr.size();\
    \ j++) {\n      if (arr[j] == temp[i]) {\n        out[j] = temp[i];\n      }\n\
    \    }\n  }\n  return out;", "  // sorting based on number of ones in their binary\
    \ representation in ascending order.\n  // For similar number of ones, sort based\
    \ on decimal value.\n  std::vector<std::pair<int, long>> vec;\n  for (long num\
    \ : arr) {\n    int i = 0;\n    while (num) {\n      i += num & 1;\n      num\
    \ >>= 1;\n    }\n    vec.push_back(std::make_pair(i, num));\n  }\n  std::sort(vec.begin(),\
    \ vec.end());\n  std::vector<long> sortedArr;\n  for (auto pair : vec) {\n   \
    \ sortedArr.push_back(pair.second);\n  }\n  return sortedArr;", "    // Your code\
    \ here\n    long num_of_1s = 0;\n    long number = 0;\n    std::string binary\
    \ = \"\";\n    std::vector<std::pair<long, long>> zeros_and_ones;\n    for (long\
    \ elem : arr) {\n        number = elem;\n        binary = \"\";\n        num_of_1s\
    \ = 0;\n        while (number > 0) {\n            binary += (number % 2 == 0 ?\
    \ '0' : '1');\n            if (number % 2 == 1) {\n                num_of_1s++;\n\
    \            }\n            number /= 2;\n        }\n        std::reverse(binary.begin(),\
    \ binary.end());\n        zeros_and_ones.push_back(std::make_pair(num_of_1s, elem));\n\
    \    }\n    std::sort(zeros_and_ones.begin(), zeros_and_ones.end());\n    for\
    \ (long i = 0; i < zeros_and_ones.size(); i++) {\n        arr[i] = zeros_and_ones[i].second;\n\
    \    }\n    return arr;", "  // your code here\n  std::vector<long> temp;\n  std::map<int,\
    \ long> numOfOnes;\n  std::map<int, long>::iterator it;\n  std::vector<long>::iterator\
    \ itV;\n  long remainder;\n  int count;\n  for (long num : arr) {\n    remainder\
    \ = num;\n    count = 0;\n    while (remainder > 0) {\n      if (remainder % 2\
    \ == 1) {\n        count++;\n      }\n      remainder /= 2;\n    }\n    numOfOnes.insert(std::pair<int,\
    \ long>(count, num));\n  }\n  for (it = numOfOnes.begin(); it != numOfOnes.end();\
    \ it++) {\n    temp.push_back(it->second);\n  }\n  return temp;", "  // your code\
    \ here...\n  std::map<int, std::vector<long>> map;\n  for (auto val : arr) {\n\
    \    int ones = 0;\n    int x = val;\n    while (x) {\n      ones += x % 2;\n\
    \      x = x / 2;\n    }\n    map[ones].push_back(val);\n  }\n  for (auto vals\
    \ : map) {\n    std::sort(vals.second.begin(), vals.second.end());\n  }\n  std::vector<long>\
    \ sorted;\n  for (auto vals : map) {\n    for (auto val : vals.second) {\n   \
    \   sorted.push_back(val);\n    }\n  }\n  return sorted;", "  std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b) {\n    auto countBits = [](long n) {\n      std::bitset<64>\
    \ bits(n);\n      return bits.count();\n    };\n    int aOnes = countBits(a);\n\
    \    int bOnes = countBits(b);\n    if (aOnes == bOnes) {\n      return a < b;\n\
    \    }\n    return aOnes < bOnes;\n  });\n  return arr;", "  std::vector<long>\
    \ arr_bit;\n  std::vector<long> arr_result;\n  for (auto& i : arr) {\n    int\
    \ bit_sum = 0;\n    while (i != 0) {\n      bit_sum += i & 1;\n      i >>= 1;\n\
    \    }\n    arr_bit.push_back(bit_sum);\n  }\n  while (arr.size() != 0) {\n  \
    \  int min_index = std::distance(arr_bit.begin(),\n                          \
    \        std::min_element(arr_bit.begin(), arr_bit.end()));\n    for (auto it\
    \ = arr.begin(); it != arr.end(); it++) {\n      if (std::count(arr_result.begin(),\
    \ arr_result.end(), *it) == 0 &&\n          std::count(arr.begin(), arr.end(),\
    \ *it) == 1) {\n        arr_result.push_back(*it);\n        arr.erase(it);\n \
    \       arr_bit.erase(arr_bit.begin() + min_index);\n        break;\n      }\n\
    \    }\n  }\n  return arr_result;", "  std::vector<long> binary;\n  std::vector<long>\
    \ final;\n  for (int i = 0; i < arr.size(); i++) {\n    long count = 0;\n    long\
    \ num = arr[i];\n    while (num > 0) {\n      if (num & 1) {\n        count++;\n\
    \      }\n      num = num >> 1;\n    }\n    binary.push_back(count);\n  }\n  std::multimap<long,\
    \ long> combined;\n  for (int i = 0; i < arr.size(); i++) {\n    combined.insert(std::pair<long,\
    \ long>(binary[i], arr[i]));\n  }\n  std::multimap<long, long>::iterator itr;\n\
    \  for (itr = combined.begin(); itr != combined.end(); ++itr) {\n    final.push_back(itr->second);\n\
    \  }\n  return final;", "    std::vector<long> v;\n    int x;\n    std::vector<std::pair<int,\
    \ long>> pairVec;\n    // find all the bits and populate the pair\n    for (auto\
    \ num : arr) {\n        x = 0;\n        while (num) {\n            x += num &\
    \ 1;\n            num >>= 1;\n        }\n        pairVec.push_back(std::make_pair(x,\
    \ num));\n    }\n    // sort the vector based on number of ones and then numbers\n\
    \    sort(pairVec.begin(), pairVec.end());\n    for (auto pair : pairVec) {\n\
    \        v.push_back(pair.second);\n    }\n    return v;", "  int n = arr.size();\n\
    \  std::vector<std::vector<long>> bin(n, std::vector<long>(2));\n  for (int i\
    \ = 0; i < n; i++) {\n    bin[i][0] = arr[i];\n    bin[i][1] = __builtin_popcount(arr[i]);\n\
    \  }\n  for (int i = 0; i < n; i++) {\n    std::cout << bin[i][0] << \" \" <<\
    \ bin[i][1] << std::endl;\n  }\n  std::sort(bin.begin(), bin.end(),\n        \
    \    [](const std::vector<long> &a, const std::vector<long> &b) {\n          \
    \    if (a[1] < b[1])\n                return true;\n              else if (a[1]\
    \ == b[1])\n                return a[0] < b[0];\n              else\n        \
    \        return false;\n            });\n  for (int i = 0; i < n; i++) {\n   \
    \ std::cout << bin[i][0] << \" \" << bin[i][1] << std::endl;\n  }\n  for (int\
    \ i = 0; i < n; i++) {\n    arr[i] = bin[i][0];\n  }\n  return arr;", '  return
    arr;', "  std::vector<std::pair<int, int>> v;\n  int i = 0;\n  for (auto x : arr)\
    \ {\n    int count = 0;\n    while (x) {\n      count += x & 1;\n      x >>= 1;\n\
    \    }\n    v.push_back(std::make_pair(count, i));\n    i++;\n  }\n  std::sort(v.begin(),\
    \ v.end());\n  std::vector<long> result;\n  for (auto x : v) {\n    result.push_back(arr[x.second]);\n\
    \  }\n  return result;", "    std::vector<std::pair<int, long>> sorted_arr;\n\
    \    for (auto x : arr) {\n        int ones = 0;\n        while (x) {\n      \
    \      ones += x & 1;\n            x >>= 1;\n        }\n        sorted_arr.push_back(std::make_pair(ones,\
    \ x));\n    }\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n    arr.clear();\n\
    \    for (auto x : sorted_arr) {\n        arr.push_back(x.second);\n    }\n  \
    \  return arr;", "  std::vector<long> result;\n  for (long item : arr) {\n   \
    \ result.push_back(item);\n  }\n  sort(result.begin(), result.end(), [&](long\
    \ x, long y) {\n    int x_count = 0;\n    int y_count = 0;\n    // Count 1 bits\
    \ in each number\n    while (x > 0) {\n      x_count += x % 2;\n      x = x /\
    \ 2;\n    }\n    while (y > 0) {\n      y_count += y % 2;\n      y = y / 2;\n\
    \    }\n    // If number of 1's are same, then compare decimal value\n    if (x_count\
    \ == y_count)\n      return x < y;\n    return x_count < y_count;\n  });\n  return\
    \ result;", "    for (int i = 0; i < arr.size(); i++) {\n        for (int j =\
    \ i + 1; j < arr.size(); j++) {\n            if (__builtin_popcount(arr[i]) >\
    \ __builtin_popcount(arr[j])) {\n                std::swap(arr[i], arr[j]);\n\
    \            } else if (__builtin_popcount(arr[i]) == __builtin_popcount(arr[j]))\
    \ {\n                if (arr[i] > arr[j])\n                    std::swap(arr[i],\
    \ arr[j]);\n            }\n        }\n    }\n    return arr;", "  for (int i =\
    \ 0; i < arr.size(); i++) {\n    for (int j = i + 1; j < arr.size(); j++) {\n\
    \      if (count_ones(arr[i]) > count_ones(arr[j])) {\n        long temp = arr[i];\n\
    \        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n      else if (count_ones(arr[i])\
    \ == count_ones(arr[j])) {\n        if (arr[i] > arr[j]) {\n          long temp\
    \ = arr[i];\n          arr[i] = arr[j];\n          arr[j] = temp;\n        }\n\
    \      }\n    }\n  }\n  return arr;", "  std::sort(arr.begin(), arr.end(), [](const\
    \ int &a, const int &b) {\n    if (std::bitset<32>(a).count() != std::bitset<32>(b).count())\n\
    \      return std::bitset<32>(a).count() < std::bitset<32>(b).count();\n    return\
    \ a < b;\n  });\n  return arr;", "  std::vector<std::pair<long, long>> v;\n  for\
    \ (auto i : arr) {\n    long count = 0;\n    long temp = i;\n    while (temp)\
    \ {\n      if (temp & 1) {\n        count++;\n      }\n      temp >>= 1;\n   \
    \ }\n    v.push_back(std::make_pair(count, i));\n  }\n  std::sort(v.begin(), v.end());\n\
    \  std::vector<long> result;\n  for (auto i : v) {\n    result.push_back(i.second);\n\
    \  }\n  return result;", "  std::vector<long> v;\n  long max_binary = 0;\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    long binary = 0;\n    long k = arr[i];\n\
    \    while (k > 0) {\n      if (k % 2 == 1) {\n        binary++;\n      }\n  \
    \    k = k / 2;\n    }\n    v.push_back(binary);\n    if (binary > max_binary)\
    \ {\n      max_binary = binary;\n    }\n  }\n  std::vector<long> v1;\n  for (int\
    \ i = 0; i <= max_binary; i++) {\n    for (int j = 0; j < arr.size(); j++) {\n\
    \      if (v[j] == i) {\n        v1.push_back(arr[j]);\n      }\n    }\n  }\n\
    \  return v1;", "  std::vector<long> result;\n  for (auto &e : arr) {\n    if\
    \ (e <= 0) {\n      continue;\n    }\n    std::bitset<32> bits(e);\n    result.push_back(bits.count());\n\
    \  }\n  std::sort(result.begin(), result.end());\n  return result;", "\t// your\
    \ code here\n\tstd::vector<long> a(arr.size());\n\tstd::vector<long> b(arr.size());\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\tlong n = arr[i];\n\t\tint c = 0;\n\
    \t\twhile (n > 0) {\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tn /=\
    \ 2;\n\t\t}\n\t\ta[i] = c;\n\t\tb[i] = arr[i];\n\t}\n\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\tfor (int j = i + 1; j < arr.size(); j++) {\n\t\t\tif (a[i] > a[j])\
    \ {\n\t\t\t\tstd::swap(a[i], a[j]);\n\t\t\t\tstd::swap(b[i], b[j]);\n\t\t\t}\n\
    \t\t\telse if (a[i] == a[j]) {\n\t\t\t\tif (b[i] > b[j]) {\n\t\t\t\t\tstd::swap(b[i],\
    \ b[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn b;", "    int n = arr.size();\n\
    \    std::vector<std::pair<int, int>> count(n);\n    for (int i = 0; i < n; i++)\
    \ {\n        int tmp = arr[i];\n        count[i].first = __builtin_popcount(tmp);\n\
    \        count[i].second = tmp;\n    }\n    std::sort(count.begin(), count.end());\n\
    \    for (int i = 0; i < n; i++) {\n        arr[i] = count[i].second;\n    }\n\
    \    return arr;", "    std::sort(arr.begin(), arr.end(), [&](long a, long b)\
    \ {\n        int a_ones = std::count(std::bitset<32>(a).to_string().begin(), std::bitset<32>(a).to_string().end(),\
    \ '1');\n        int b_ones = std::count(std::bitset<32>(b).to_string().begin(),\
    \ std::bitset<32>(b).to_string().end(), '1');\n        if (a_ones == b_ones)\n\
    \            return a < b;\n        return a_ones < b_ones;\n    });\n    return\
    \ arr;", "  // Implement this function and return the correct array\n  // Write\
    \ your code here\n  std::vector<long> arr_new = arr;\n  // std::sort(arr_new.begin(),\
    \ arr_new.end(), std::greater<long>());\n  std::sort(arr_new.begin(), arr_new.end(),\n\
    \    [&arr](long x, long y) -> bool {\n      std::bitset<32> X(x);\n      std::bitset<32>\
    \ Y(y);\n      if (X.count() == Y.count()) {\n        return x > y;\n      }\n\
    \      return X.count() > Y.count();\n    });\n  return arr_new;", "  // your\
    \ code here\n  std::vector<long> sort_arr;\n  int len = arr.size();\n  for (int\
    \ i = 0; i < len; i++) {\n    int count = 0;\n    int num = arr[i];\n    while\
    \ (num > 0) {\n      if (num % 2 == 1) {\n        count++;\n      }\n      num\
    \ = num / 2;\n    }\n    sort_arr.push_back(count);\n  }\n  std::sort(sort_arr.begin(),\
    \ sort_arr.end());\n  return sort_arr;", "  std::vector<long> results;\n  std::vector<long>\
    \ holder;\n  while (arr.size() > 0) {\n    results.push_back(arr[0]);\n    int\
    \ count = 0;\n    while (count < arr.size()) {\n      if (results[results.size()\
    \ - 1] != arr[count]) {\n        holder.push_back(arr[count]);\n      }\n    \
    \  count++;\n    }\n    arr = holder;\n    holder.clear();\n  }\n  // Now sort\
    \ the results vector\n  // Get the binary value of each element and\n  // sort\
    \ in reverse according to the number of ones\n  // in their binary representation\n\
    \  for (int i = 0; i < results.size(); i++) {\n    for (int j = 0; j < results.size()\
    \ - 1; j++) {\n      std::string str1 = std::bitset<32>(results[j]).to_string();\n\
    \      std::string str2 = std::bitset<32>(results[j + 1]).to_string();\n     \
    \ int counter1 = 0;\n      int counter2 = 0;\n      // Count the number of ones\
    \ in the string\n      for (int k = 0; k < str1.length(); k++) {\n        if (str1[k]\
    \ == '1') {\n          counter1++;\n        }\n      }\n      for (int k = 0;\
    \ k < str2.length(); k++) {\n        if (str2[k] == '1') {\n          counter2++;\n\
    \        }\n      }\n      if (counter1 < counter2) {\n        // Do the swap\n\
    \        long tmp = results[j];\n        results[j] = results[j + 1];\n      \
    \  results[j + 1] = tmp;\n      }\n      else if (counter1 == counter2) {\n  \
    \      // That means we need to sort them in ascending order\n        if (results[j]\
    \ > results[j + 1]) {\n          long tmp = results[j];\n          results[j]\
    \ = results[j + 1];\n          results[j + 1] = tmp;\n        }\n      }\n   \
    \ }\n  }\n  // Now reverse the results vector because the first element\n  //",
  "  std::vector<long> sorted_arr;\n  for (auto number : arr) {\n    int temp = number;\n\
    \    int count = 0;\n    while (temp) {\n      if (temp & 1)\n        count++;\n\
    \      temp = temp >> 1;\n    }\n    sorted_arr.push_back(count);\n  }\n  std::vector<std::pair<long,\
    \ long>> ones_dec_pair;\n  for (int i = 0; i < arr.size(); i++) {\n    ones_dec_pair.push_back(std::make_pair(sorted_arr[i],\
    \ arr[i]));\n  }\n  std::sort(ones_dec_pair.begin(), ones_dec_pair.end());\n \
    \ std::vector<long> result;\n  for (auto pair : ones_dec_pair) {\n    result.push_back(pair.second);\n\
    \  }\n  return result;", "  // your code here\n  int ascii = 0;\n  std::vector<long>\
    \ sorted_arr;\n  std::vector<long> sorted_arr2;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] < 0) {\n      sorted_arr.push_back(arr[i]);\n    } else\
    \ {\n      sorted_arr2.push_back(arr[i]);\n    }\n  }\n  std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n  for (int i = 0; i < sorted_arr.size(); i++) {\n    sorted_arr[i]\
    \ = -sorted_arr[i];\n  }\n  std::sort(sorted_arr2.begin(), sorted_arr2.end());\n\
    \  // std::reverse(sorted_arr2.begin(), sorted_arr2.end());\n  arr.clear();\n\
    \  arr.reserve(sorted_arr.size() + sorted_arr2.size());\n  arr.insert(arr.end(),\
    \ sorted_arr.begin(), sorted_arr.end());\n  arr.insert(arr.end(), sorted_arr2.begin(),\
    \ sorted_arr2.end());\n  return arr;", "  std::vector<std::pair<long, long>> v;\n\
    \  long s = arr.size();\n  std::pair<long, long> p;\n  for (long i = 0; i < s;\
    \ i++) {\n    long num_ones = 0;\n    long n = arr[i];\n    for (long j = 0; j\
    \ < 32; j++) {\n      num_ones += n & 1;\n      n = n >> 1;\n    }\n    p = std::make_pair(num_ones,\
    \ arr[i]);\n    v.push_back(p);\n  }\n  std::sort(v.begin(), v.end());\n  for\
    \ (long i = 0; i < s; i++) {\n    arr[i] = v[i].second;\n  }\n  return arr;",
  "    std::sort(arr.begin(), arr.end(),\n              [](long a, long b) {\n   \
    \               int c = __builtin_popcount(a);\n                  int d = __builtin_popcount(b);\n\
    \                  return c != d ? c < d : a < b;\n              });\n    return\
    \ arr;", "  std::vector<long> zeros, ones, answer;\n  std::vector<long>::iterator\
    \ p;\n  for (p = arr.begin(); p != arr.end(); p++) {\n    int digit = 0;\n   \
    \ while (*p > 0) {\n      digit += *p % 2;\n      *p /= 2;\n    }\n    if (digit\
    \ % 2 == 0)\n      zeros.push_back(*p);\n    else\n      ones.push_back(*p);\n\
    \  }\n  std::sort(zeros.begin(), zeros.end());\n  std::sort(ones.begin(), ones.end());\n\
    \  std::copy(zeros.begin(), zeros.end(), answer.begin());\n  std::copy(ones.begin(),\
    \ ones.end(), answer.begin());\n  return answer;", "  //Your code goes here\n\
    \  int n = arr.size();\n  std::vector<long> sort_arr;\n  std::vector<long> ones_arr;\n\
    \  std::vector<long> zeros_arr;\n  for (auto it = arr.begin(); it != arr.end();\
    \ it++) {\n    if (*it < 0) {\n      sort_arr.push_back(*it);\n    } else {\n\
    \      if (__builtin_popcount(*it) == 0) {\n        zeros_arr.push_back(*it);\n\
    \      } else {\n        ones_arr.push_back(*it);\n      }\n    }\n  }\n  sort(ones_arr.begin(),\
    \ ones_arr.end());\n  sort(zeros_arr.begin(), zeros_arr.end());\n  for (auto it\
    \ = ones_arr.begin(); it != ones_arr.end(); it++) {\n    sort_arr.push_back(*it);\n\
    \  }\n  for (auto it = zeros_arr.begin(); it != zeros_arr.end(); it++) {\n   \
    \ sort_arr.push_back(*it);\n  }\n  return sort_arr;", "    std::sort(arr.begin(),\
    \ arr.end(), [](long& n1, long& n2) {\n        auto n1_bin = std::bitset<64>(n1).to_string();\n\
    \        n1_bin.erase(0, n1_bin.find_first_of('1'));\n        auto n2_bin = std::bitset<64>(n2).to_string();\n\
    \        n2_bin.erase(0, n2_bin.find_first_of('1'));\n        return (n1_bin.size()\
    \ == n2_bin.size()) ? n1 < n2 : n1_bin.size() < n2_bin.size();\n    });\n    return\
    \ arr;", "    std::sort(arr.begin(), arr.end(), [](long x, long y) {\n       \
    \     int cnt_x = std::bitset<32>(x).count();\n            int cnt_y = std::bitset<32>(y).count();\n\
    \            return (cnt_x == cnt_y) ? x < y : cnt_x < cnt_y;\n            });\n\
    \    return arr;", "  std::vector<std::pair<long, int>> arrPair;\n  for (auto&\
    \ i : arr) {\n    int count = 0;\n    for (int j = 0; j < sizeof(long) * 8; j++)\
    \ {\n      if (i & 1 << j) {\n        count++;\n      }\n    }\n    arrPair.push_back(std::make_pair(i,\
    \ count));\n  }\n  std::sort(arrPair.begin(), arrPair.end(),\n            [](std::pair<long,\
    \ int> p1, std::pair<long, int> p2) {\n              if (p1.second == p2.second)\
    \ {\n                return p1.first < p2.first;\n              }\n          \
    \    return p1.second < p2.second;\n            });\n  for (int i = 0; i < arrPair.size();\
    \ i++) {\n    arr[i] = arrPair[i].first;\n  }\n  return arr;", "    // your code\
    \ here\n    // std::cout << arr.size() << std::endl;\n    std::map<int, std::vector<long>>\
    \ map;\n    for (int i = 0; i < arr.size(); i++) {\n        std::string binary_string\
    \ = std::bitset<10>(arr[i]).to_string();\n        int number_of_ones = std::count(binary_string.begin(),\
    \ binary_string.end(), '1');\n        map[number_of_ones].push_back(arr[i]);\n\
    \    }\n    std::vector<long> results;\n    for (auto it = map.begin(); it !=\
    \ map.end(); it++) {\n        std::sort(it->second.begin(), it->second.end());\n\
    \        results.insert(results.end(), it->second.begin(), it->second.end());\n\
    \    }\n    return results;", "    std::vector<std::pair<long, long>> ones;\n\
    \    for (auto i = 0; i < arr.size(); i++) {\n        long temp = arr[i];\n  \
    \      long count = 0;\n        while (temp) {\n            if (temp % 2 == 1)\
    \ {\n                count++;\n            }\n            temp /= 2;\n       \
    \ }\n        ones.push_back(std::make_pair(count, arr[i]));\n    }\n    std::sort(ones.begin(),\
    \ ones.end());\n    for (auto i = 0; i < arr.size(); i++) {\n        arr[i] =\
    \ ones[i].second;\n    }\n    return arr;", "    long n = arr.size();\n    std::vector<long>\
    \ count(32, 0);\n    for (long i = 0; i < n; i++) {\n        long j = 0;\n   \
    \     while (arr[i] > 0) {\n            count[j] += arr[i] & 1;\n            arr[i]\
    \ >>= 1;\n            j++;\n        }\n    }\n    std::vector<long> ans;\n   \
    \ for (long i = 0; i < n; i++) {\n        long j = 0;\n        long num = 0;\n\
    \        while (arr[i] > 0) {\n            num += count[j] * (arr[i] & 1);\n \
    \           arr[i] >>= 1;\n            j++;\n        }\n        ans.push_back(num);\n\
    \    }\n    return ans;", "    std::map<int, std::vector<long>> mymap;\n    for\
    \ (auto e : arr) {\n        int cnt = 0;\n        while (e) {\n            if\
    \ (e & 1) cnt++;\n            e >>= 1;\n        }\n        mymap[cnt].push_back(e);\n\
    \    }\n    std::vector<long> res;\n    for (auto e : mymap) {\n        for (auto\
    \ f : e.second) {\n            res.push_back(f);\n        }\n    }\n    return\
    \ res;", "  //int new_arr[arr.size()];\n  std::vector<long> new_arr(arr.size());\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    long count_one = 0;\n    long temp\
    \ = arr[i];\n    while (temp > 0) {\n      if (temp % 2 == 1)\n        count_one++;\n\
    \      temp /= 2;\n    }\n    new_arr[i] = arr[i];\n    new_arr[i] = (new_arr[i]\
    \ << 32) | count_one;\n  }\n  std::sort(new_arr.begin(), new_arr.end());\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    new_arr[i] = new_arr[i] & 0x00000000ffffffff;\n\
    \  }\n  return new_arr;", "    // your code here\n    vector<int> one_count(arr.size());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        int count = 0;\n        long\
    \ num = arr[i];\n        while(num > 0) {\n            num &= (num - 1);\n   \
    \         count++;\n        }\n        one_count[i] = count;\n    }\n    vector<pair<int,\
    \ long>> vec(arr.size());\n    for(int i = 0; i < arr.size(); i++) {\n       \
    \ vec[i] = make_pair(one_count[i], arr[i]);\n    }\n    sort(vec.begin(), vec.end());\n\
    \    vector<long> res(arr.size());\n    for(int i = 0; i < arr.size(); i++) {\n\
    \        res[i] = vec[i].second;\n    }\n    return res;", "    std::vector<long>\
    \ copy = arr;\n    long count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        for (int j = 0; j < 32; j++) {\n            if (arr[i] & (1 << j)) {\n\
    \                count++;\n            }\n        }\n        arr[i] = count;\n\
    \        count = 0;\n    }\n    std::vector<long> copy2 = arr;\n    // std::sort(arr.begin(),\
    \ arr.end());\n    std::vector<std::pair<long, long>> pair(arr.size());\n    for\
    \ (int i = 0; i < arr.size(); i++) {\n        pair[i] = std::make_pair(arr[i],\
    \ copy[i]);\n    }\n    std::sort(pair.begin(), pair.end());\n    for (int i =\
    \ 0; i < arr.size(); i++) {\n        arr[i] = pair[i].second;\n    }\n    return\
    \ arr;", "    std::vector<long> cnt(arr.size(), 0);\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        while (arr[i] > 0) {\n            cnt[i] += arr[i] % 2;\n  \
    \          arr[i] /= 2;\n        }\n    }\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (cnt[i]\
    \ == cnt[j]) {\n                if (arr[i] > arr[j]) {\n                    int\
    \ temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j]\
    \ = temp;\n                }\n            } else if (cnt[i] > cnt[j]) {\n    \
    \            int temp = arr[i];\n                arr[i] = arr[j];\n          \
    \      arr[j] = temp;\n                temp = cnt[i];\n                cnt[i]\
    \ = cnt[j];\n                cnt[j] = temp;\n            }\n        }\n    }\n\
    \    return arr;", "  for (long i=0; i<arr.size(); i++) {\n    for (long j=i+1;\
    \ j<arr.size(); j++) {\n      if (__builtin_popcount(arr[i]) > __builtin_popcount(arr[j]))\
    \ {\n        long temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n\
    \      }\n      else if (__builtin_popcount(arr[i]) == __builtin_popcount(arr[j]))\
    \ {\n        if (arr[i] > arr[j]) {\n          long temp = arr[i];\n         \
    \ arr[i] = arr[j];\n          arr[j] = temp;\n        }\n      }\n    }\n  }\n\
    \  return arr;", "  std::vector<long> sorted = arr;\n  std::sort(sorted.begin(),\
    \ sorted.end(), [](long a, long b) {\n    int aones = std::bitset<32>(a).count();\n\
    \    int bones = std::bitset<32>(b).count();\n    if (aones == bones) {\n    \
    \  return a < b;\n    }\n    return aones < bones;\n  });\n  return sorted;",
  "  // your code here\n  std::vector<std::pair<int,int>> ones;\n  for(auto i = 0;\
    \ i < arr.size(); i++) {\n    int c = 0;\n    int num = arr[i];\n    while(num\
    \ > 0) {\n      c++;\n      num = num & (num - 1);\n    }\n    ones.push_back(std::make_pair(c,\
    \ arr[i]));\n  }\n  std::sort(ones.begin(), ones.end());\n  std::vector<long>\
    \ result;\n  for(auto i = 0; i < ones.size(); i++) {\n    result.push_back(ones[i].second);\n\
    \  }\n  return result;", "    std::vector<std::pair<int, int>> nums;\n    for\
    \ (auto i : arr) {\n        std::bitset<32> t(i);\n        nums.push_back(std::make_pair(t.count(),\
    \ i));\n    }\n    std::sort(nums.begin(), nums.end());\n    std::vector<long>\
    \ res;\n    for (auto i : nums) {\n        res.push_back(i.second);\n    }\n \
    \   return res;", "\t// If there is only one number in the array\n\tif (arr.size()\
    \ == 1)\n\t\treturn arr;\n\t// If there are more than one number in the array\n\
    \telse {\n\t\t// Sorting the vector\n\t\tstd::sort(arr.begin(), arr.end());\n\t\
    \t// Converting each number of the array to its binary representation\n\t\tfor\
    \ (int i = 0; i < arr.size(); i++) {\n\t\t\tstd::bitset<64> b(arr[i]);\n\t\t\t\
    arr[i] = b.count();\n\t\t}\n\t\t// Sorting the array according to the number of\
    \ ones\n\t\tstd::sort(arr.begin(), arr.end());\n\t\t// Converting each number\
    \ of the array to its decimal representation\n\t\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\t\t// Converting each number of the array to its binary representation\n\
    \t\t\tstd::bitset<64> b(arr[i]);\n\t\t\tarr[i] = b.to_ulong();\n\t\t}\n\t\t//\
    \ Returning the array\n\t\treturn arr;\n\t}", "    //insert elements into a map\
    \ with key as num of ones\n    std::map<long, std::vector<long>> bucket;\n   \
    \ for (long & val : arr) {\n        long key = 0;\n        while (val > 0) {\n\
    \            if (val % 2 == 1)\n                key++;\n            val /= 2;\n\
    \        }\n        bucket[key].push_back(val);\n    }\n    //sort each bucket\
    \ then insert into res\n    std::vector<long> res;\n    for (auto it = bucket.begin();\
    \ it != bucket.end(); it++) {\n        std::sort(it->second.begin(), it->second.end());\n\
    \        res.insert(res.end(), it->second.begin(), it->second.end());\n    }\n\
    \    return res;", "  std::vector<long> ret;\n  while (arr.size() > 0) {\n   \
    \ // Find lowest decimal value\n    auto low = arr.begin();\n    for (auto it\
    \ = arr.begin(); it != arr.end(); ++it) {\n      if (*it < *low) {\n        low\
    \ = it;\n      }\n    }\n    long val = *low;\n    arr.erase(low);\n    // Find\
    \ all other numbers with that binary representation\n    for (auto it = arr.begin();\
    \ it != arr.end();) {\n      int cnt = 0;\n      while (*it) {\n        if (*it\
    \ & 1) {\n          cnt++;\n        }\n        *it >>= 1;\n      }\n      if (cnt\
    \ == val) {\n        ret.push_back(*it);\n        it = arr.erase(it);\n      }\
    \ else {\n        ++it;\n      }\n    }\n    ret.push_back(val);\n  }\n  return\
    \ ret;", "    // Method 1:\n    std::stable_sort(arr.begin(), arr.end(),\n   \
    \     [](long x, long y) {\n            auto x_ones = std::bitset<64>(x).count();\n\
    \            auto y_ones = std::bitset<64>(y).count();\n            return (x_ones\
    \ == y_ones) ? x < y : x_ones < y_ones;\n        });\n    return arr;", "    std::vector<std::pair<long,\
    \ long>> pairs;\n    std::vector<long> result;\n    for (auto i = 0; i < arr.size();\
    \ i++) {\n        pairs.push_back(std::make_pair(arr[i], i));\n    }\n    std::sort(pairs.begin(),\
    \ pairs.end(), [](std::pair<long, long> a, std::pair<long, long> b) {\n      \
    \  long count1 = 0;\n        long count2 = 0;\n        while (a.first > 0) {\n\
    \            if (a.first % 2 != 0) {\n                count1++;\n            }\n\
    \            a.first /= 2;\n        }\n        while (b.first > 0) {\n       \
    \     if (b.first % 2 != 0) {\n                count2++;\n            }\n    \
    \        b.first /= 2;\n        }\n        if (count1 == count2) {\n         \
    \   return a.second < b.second;\n        }\n        return count1 < count2;\n\
    \    });\n    for (auto i = 0; i < pairs.size(); i++) {\n        result.push_back(pairs[i].first);\n\
    \    }\n    return result;", "  std::vector<long> ans;\n  std::vector<long> zero;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0)\n      zero.push_back(arr[i]);\n\
    \    else\n      ans.push_back(arr[i]);\n  }\n  std::sort(ans.begin(), ans.end(),\
    \ [](int a, int b) {\n    int onesA = __builtin_popcount(a);\n    int onesB =\
    \ __builtin_popcount(b);\n    if (onesA == onesB) {\n      return a < b;\n   \
    \ }\n    return onesA < onesB;\n  });\n  for (int i = 0; i < zero.size(); i++)\
    \ {\n    ans.insert(ans.begin(), zero[i]);\n  }\n  return ans;", "  std::vector<long>\
    \ ret(arr.size());\n  std::map<long, long> map;\n  std::vector<long> sorted;\n\
    \  for (auto &x : arr) {\n    long c = 0;\n    for (; x > 0; x /= 2) {\n     \
    \ c += x % 2;\n    }\n    map[c]++;\n  }\n  for (auto &x : map) {\n    sorted.push_back(x.first);\n\
    \  }\n  std::sort(sorted.begin(), sorted.end());\n  long i = 0;\n  for (auto &x\
    \ : sorted) {\n    for (long j = 0; j < map[x]; j++) {\n      long c = 0;\n  \
    \    for (long y = arr[i]; y > 0; y /= 2) {\n        c += y % 2;\n      }\n  \
    \    if (c == x) {\n        ret[i] = arr[i];\n        i++;\n      } else {\n \
    \       for (long k = i + 1; k < arr.size(); k++) {\n          long c = 0;\n \
    \         for (long y = arr[k]; y > 0; y /= 2) {\n            c += y % 2;\n  \
    \        }\n          if (c == x) {\n            ret[i] = arr[k];\n          \
    \  arr[k] = arr[i];\n            i++;\n            break;\n          }\n     \
    \   }\n      }\n    }\n  }\n  return ret;", "  auto n = arr.size();\n  std::vector<std::pair<long,long>>\
    \ tmp;\n  for(long i = 0; i < n; i++) {\n    long p = arr[i];\n    long count\
    \ = 0;\n    while(p) {\n      if(p & 1) count++;\n      p = p >> 1;\n    }\n \
    \   tmp.push_back(std::make_pair(count, arr[i]));\n  }\n  std::sort(tmp.begin(),\
    \ tmp.end());\n  for(long i = 0; i < n; i++) {\n    arr[i] = tmp[i].second;\n\
    \  }\n  return arr;", "  std::map<int, std::vector<long>> map;\n  std::vector<long>\
    \ ret;\n  for (auto num : arr) {\n    int ones = __builtin_popcountl(num);\n \
    \   if (map.find(ones) == map.end()) {\n      map[ones] = std::vector<long>();\n\
    \    }\n    map[ones].push_back(num);\n  }\n  for (auto it = map.begin(); it !=\
    \ map.end(); ++it) {\n    std::sort(it->second.begin(), it->second.end());\n \
    \   ret.insert(ret.end(), it->second.begin(), it->second.end());\n  }\n  return\
    \ ret;", "  // Implement me!\n  std::vector<long> sorted_arr;\n  std::vector<long>\
    \ ones_arr;\n  std::vector<long> zeros_arr;\n  long i, j, n;\n  n = arr.size();\n\
    \  if (n == 0) {\n    return arr;\n  } else {\n    for (i = 0; i < n; i++) {\n\
    \      if (arr[i] == 0) {\n        continue;\n      } else {\n        j = arr[i];\n\
    \        while (j != 0) {\n          if (j % 2 == 1) {\n            ones_arr.push_back(arr[i]);\n\
    \            break;\n          } else {\n            j = j / 2;\n          }\n\
    \        }\n      }\n    }\n    for (i = 0; i < n; i++) {\n      if (arr[i] ==\
    \ 0) {\n        continue;\n      } else {\n        j = arr[i];\n        while\
    \ (j != 0) {\n          if (j % 2 == 0) {\n            zeros_arr.push_back(arr[i]);\n\
    \            break;\n          } else {\n            j = j / 2;\n          }\n\
    \        }\n      }\n    }\n    std::sort(ones_arr.begin(), ones_arr.end());\n\
    \    std::sort(zeros_arr.begin(), zeros_arr.end());\n    sorted_arr.reserve(ones_arr.size()\
    \ + zeros_arr.size());\n    sorted_arr.insert(sorted_arr.end(), ones_arr.begin(),\
    \ ones_arr.end());\n    sorted_arr.insert(sorted_arr.end(), zeros_arr.begin(),\
    \ zeros_arr.end());\n    return sorted_arr;\n  }", "  // your code here\n  //\n\
    \  // Return a vector of non-negative integers sorted according to their number\
    \ of\n  // ones in their binary representation.\n  // If two numbers have the\
    \ same number of ones, sort according to their decimal\n  // representation.\n\
    \  std::map<int, int> mymap;\n\n  for (int i = 0; i < arr.size(); i++) {\n   \
    \ // binary representation\n    unsigned long n = arr[i];\n    unsigned long count\
    \ = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    mymap[count]\
    \ = arr[i];\n  }\n\n  // print map\n  std::map<int, int>::iterator it;\n  std::vector<long>\
    \ answer;\n  for (it = mymap.begin(); it != mymap.end(); it++) {\n    answer.push_back(it->second);\n\
    \  }\n  return answer;", "    std::vector<long> one_count;\n    for (long long\
    \ x : arr) {\n        long count = 0;\n        while (x) {\n            count\
    \ += x&1;\n            x >>= 1;\n        }\n        one_count.push_back(count);\n\
    \    }\n    std::sort(arr.begin(), arr.end(), [&](long lhs, long rhs) {\n    \
    \    int lhs_count = std::find(one_count.begin(), one_count.end(), lhs) - one_count.begin();\n\
    \        int rhs_count = std::find(one_count.begin(), one_count.end(), rhs) -\
    \ one_count.begin();\n        if (one_count[lhs_count] == one_count[rhs_count])\n\
    \            return lhs < rhs;\n        return one_count[lhs_count] < one_count[rhs_count];\n\
    \    });\n    return arr;", "  std::vector<long> binary(arr.size());\n  std::vector<int>\
    \ count(arr.size());\n  std::vector<long> output(arr.size());\n  for (int i =\
    \ 0; i < arr.size(); i++) {\n    binary[i] = arr[i];\n    count[i] = 0;\n    while\
    \ (binary[i] > 0) {\n      count[i] += binary[i] % 2;\n      binary[i] /= 2;\n\
    \    }\n  }\n  int n = arr.size();\n  while (n > 0) {\n    int max = *std::max_element(count.begin(),\
    \ count.end());\n    std::vector<int>::iterator it;\n    it = std::find(count.begin(),\
    \ count.end(), max);\n    int pos = std::distance(count.begin(), it);\n    output[arr.size()\
    \ - n] = arr[pos];\n    count[pos] = -1;\n    n--;\n  }\n  return output;", " \
    \   for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size();\
    \ j++) {\n            long num_i = arr[i];\n            long num_j = arr[j];\n\
    \            std::bitset<64> bi(num_i);\n            std::bitset<64> bj(num_j);\n\
    \            long count_i = bi.count();\n            long count_j = bj.count();\n\
    \            if (count_i > count_j) {\n                std::swap(arr[i], arr[j]);\n\
    \            } else if (count_i == count_j) {\n                if (num_i > num_j)\
    \ {\n                    std::swap(arr[i], arr[j]);\n                }\n     \
    \       }\n        }\n    }\n    return arr;", "    std::vector<long> new_array\
    \ = arr;\n    std::sort(new_array.begin(), new_array.end(), [](long x, long y)\
    \ {\n        int count_bits_x = __builtin_popcount(x);\n        int count_bits_y\
    \ = __builtin_popcount(y);\n        return (count_bits_x != count_bits_y) ? count_bits_x\
    \ < count_bits_y : x < y;\n    });\n    return new_array;", "  std::sort(arr.begin(),\
    \ arr.end(), [](long i, long j) {\n    int ii = __builtin_popcount(i);\n    int\
    \ jj = __builtin_popcount(j);\n    return ii == jj ? i < j : ii < jj;\n  });\n\
    \  return arr;", "    for (int i = 0; i < arr.size(); i++) {\n        // count\
    \ 1\n        std::bitset<64> set(arr[i]);\n        long count1 = set.count();\n\
    \        std::vector<long> count_vec;\n        count_vec.push_back(count1);\n\
    \        // decimal value\n        long decimal = arr[i];\n        std::vector<long>\
    \ decimal_vec;\n        decimal_vec.push_back(decimal);\n        // insert sorted\
    \ vector\n        count_vec.insert(count_vec.end(), decimal_vec.begin(), decimal_vec.end());\n\
    \        arr[i] = count_vec[0];\n    }\n    // sort array\n    for (int i = 0;\
    \ i < arr.size(); i++) {\n        for (int j = 0; j < arr.size() - 1; j++) {\n\
    \            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n\
    \                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n  \
    \          }\n        }\n    }\n    return arr;", "  int n = arr.size();\n  std::vector<long>\
    \ result;\n  std::vector<std::pair<int, long>> pair;\n  for (int i = 0; i < n;\
    \ i++) {\n    int ones = 0;\n    int m = arr[i];\n    while (m > 0) {\n      ones\
    \ += m & 1;\n      m >>= 1;\n    }\n    pair.push_back(std::make_pair(ones, arr[i]));\n\
    \  }\n  std::sort(pair.begin(), pair.end());\n  for (int i = 0; i < n; i++) {\n\
    \    result.push_back(pair[i].second);\n  }\n  return result;", "    // sort the\
    \ array here\n    std::map<int, std::vector<long>> a;\n    for (auto i : arr)\
    \ {\n        int ones = __builtin_popcount(i);\n        a[ones].push_back(i);\n\
    \    }\n    int j = 0;\n    for (auto i : a) {\n        std::sort(i.second.begin(),\
    \ i.second.end());\n        for (auto k : i.second) {\n            arr[j++] =\
    \ k;\n        }\n    }\n    return arr;", "  for (int i = 0; i < arr.size(); i++)\
    \ {\n    for (int j = i + 1; j < arr.size(); j++) {\n      int a1 = arr[i];\n\
    \      int a2 = arr[j];\n      if (__builtin_popcount(a1) > __builtin_popcount(a2))\
    \ {\n        arr[i] = a2;\n        arr[j] = a1;\n      } else if (__builtin_popcount(a1)\
    \ == __builtin_popcount(a2)) {\n        if (a1 > a2) {\n          arr[i] = a2;\n\
    \          arr[j] = a1;\n        }\n      }\n    }\n  }\n  return arr;", "   \
    \ for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size();\
    \ j++) {\n            int x = arr[i];\n            int y = arr[j];\n         \
    \   int d = x - y;\n            if (d > 0) {\n                arr[i] = y;\n  \
    \              arr[j] = x;\n            }\n        }\n    }\n    return arr;",
  "  std::multimap<long, long> result;\n  for (auto &&i : arr) {\n    long count =\
    \ 0;\n    long n = i;\n    while (n) {\n      if (n % 2 == 1)\n        count++;\n\
    \      n /= 2;\n    }\n    result.insert(std::make_pair(count, i));\n  }\n  arr.clear();\n\
    \  for (auto it = result.begin(); it != result.end(); it++) {\n    arr.push_back(it->second);\n\
    \  }\n  return arr;", "  std::vector<long> temp;\n  std::vector<int> one_count;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    temp.push_back(arr[i]);\n    one_count.push_back(0);\n\
    \  }\n  std::vector<int> idx(arr.size());\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    idx[i] = i;\n  }\n  for (int i = 0; i < arr.size(); i++) {\n    while\
    \ (arr[i] > 0) {\n      if (arr[i] % 2 == 1) {\n        one_count[i]++;\n    \
    \  }\n      arr[i] /= 2;\n    }\n  }\n  for (int i = 0; i < arr.size(); i++) {\n\
    \    for (int j = i + 1; j < arr.size(); j++) {\n      if (one_count[i] > one_count[j])\
    \ {\n        std::swap(one_count[i], one_count[j]);\n        std::swap(temp[i],\
    \ temp[j]);\n        std::swap(idx[i], idx[j]);\n      }\n    }\n  }\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    for (int j = i + 1; j < arr.size(); j++)\
    \ {\n      if (one_count[i] == one_count[j] && temp[i] > temp[j]) {\n        std::swap(one_count[i],\
    \ one_count[j]);\n        std::swap(temp[i], temp[j]);\n        std::swap(idx[i],\
    \ idx[j]);\n      }\n    }\n  }\n  return temp;", "  std::sort(arr.begin(), arr.end(),\
    \ [](long a, long b) {\n    int count_a = std::bitset<32>(a).count();\n    int\
    \ count_b = std::bitset<32>(b).count();\n    if (count_a == count_b) {\n     \
    \ return a < b;\n    }\n    return count_a < count_b;\n  });\n  return arr;",
  "  // Sort the array according to number of ones in their binary representation\n\
    \  std::sort(arr.begin(), arr.end(), [](const int& i, const int& j) {\n    int\
    \ a = 0, b = 0;\n    for (int k = i; k > 0; k = k >> 1)\n      a += k & 1;\n \
    \   for (int k = j; k > 0; k = k >> 1)\n      b += k & 1;\n    return a == b ?\
    \ i < j : a < b;\n  });\n  return arr;", "  std::vector<long> ans;\n  if(arr.size()\
    \ == 0)\n    return ans;\n  std::map<int,std::set<long>> mymap;\n  for(int i =\
    \ 0; i < arr.size(); i++) {\n    int count = 0;\n    long number = arr[i];\n \
    \   while(number > 0) {\n      if(number%2 == 1)\n        count++;\n      number\
    \ = number/2;\n    }\n    mymap[count].insert(arr[i]);\n  }\n  for(auto it = mymap.begin();\
    \ it != mymap.end(); it++) {\n    for(auto it1 = mymap[it->first].begin(); it1\
    \ != mymap[it->first].end(); it1++) {\n      ans.push_back(*it1);\n    }\n  }\n\
    \  return ans;", "    auto ones_count = [](int n) {\n        int count = 0;\n\
    \        for (; n; n >>= 1) {\n            count += n & 1;\n        }\n      \
    \  return count;\n    };\n    std::sort(arr.begin(), arr.end(), [ones_count](long\
    \ a, long b) {\n        int na = ones_count(a);\n        int nb = ones_count(b);\n\
    \        return na < nb || (na == nb && a < b);\n    });\n    return arr;", " \
    \   std::sort(arr.begin(), arr.end(), [](long x, long y) {\n        return __builtin_popcount(x)\
    \ < __builtin_popcount(y)\n            || (__builtin_popcount(x) == __builtin_popcount(y)\
    \ && x < y);\n    });\n    return arr;", "\tstd::sort(arr.begin(), arr.end(),\
    \ [](long a, long b) {\n\t\tint n1 = __builtin_popcount(a);\n\t\tint n2 = __builtin_popcount(b);\n\
    \t\tif (n1 == n2) {\n\t\t\treturn a < b;\n\t\t}\n\t\treturn n1 < n2;\n\t});\n\t\
    return arr;", "    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n  \
    \      int cnt_a = 0, cnt_b = 0;\n        while (a > 0) {\n            cnt_a +=\
    \ a % 2;\n            a >>= 1;\n        }\n        while (b > 0) {\n         \
    \   cnt_b += b % 2;\n            b >>= 1;\n        }\n        return cnt_a ==\
    \ cnt_b ? a < b : cnt_a < cnt_b;\n    });\n    return arr;", "\tint n = arr.size();\n\
    \tstd::vector<std::vector<long>> a(arr.size());\n\tstd::cout << \"BEFORE\\n\"\
    ;\n\tfor (auto v : arr) {\n\t\tstd::cout << v << \" \";\n\t}\n\tstd::cout << \"\
    \\n\";\n\tfor (int i = 0; i < n; i++) {\n\t\tint num = arr[i];\n\t\ta[i].push_back(num);\n\
    \t\tstd::string s = std::bitset<64>(num).to_string();\n\t\ta[i].push_back(std::count(s.begin(),\
    \ s.end(), '1'));\n\t}\n\tstd::sort(a.begin(), a.end(), [](const std::vector<long>&\
    \ v1, const std::vector<long>& v2) {\n\t\tif (v1[1] != v2[1]) {\n\t\t\treturn\
    \ v1[1] < v2[1];\n\t\t}\n\t\treturn v1[0] < v2[0];\n\t});\n\tfor (int i = 0; i\
    \ < n; i++) {\n\t\tarr[i] = a[i][0];\n\t}\n\tstd::cout << \"AFTER\\n\";\n\tfor\
    \ (auto v : arr) {\n\t\tstd::cout << v << \" \";\n\t}\n\tstd::cout << \"\\n\"\
    ;\n\treturn arr;", "  std::vector<long> v;\n  std::vector<long> v1;\n  std::vector<long>\
    \ v2;\n  std::vector<long> v3;\n  for (int i = 0; i < arr.size(); i++) {\n   \
    \ v.push_back(arr[i]);\n  }\n  std::sort(v.begin(), v.end());\n  for (int i =\
    \ 0; i < v.size(); i++) {\n    int num = v[i];\n    int count = 0;\n    int temp\
    \ = num;\n    while (temp != 0) {\n      if (temp % 2 == 1) {\n        count++;\n\
    \      }\n      temp = temp / 2;\n    }\n    //std::cout << \"Num: \" << num <<\
    \ \" Count: \" << count << std::endl;\n    v1.push_back(count);\n  }\n  std::vector<long>\
    \ v_new;\n  for (int i = 0; i < v1.size(); i++) {\n    v_new.push_back(v1[i]);\n\
    \  }\n  std::sort(v_new.begin(), v_new.end());\n  for (int i = 0; i < v_new.size();\
    \ i++) {\n    for (int j = 0; j < v1.size(); j++) {\n      if (v_new[i] == v1[j])\
    \ {\n        v2.push_back(v[j]);\n        v1[j] = -1;\n      }\n    }\n  }\n \
    \ for (int i = 0; i < v2.size(); i++) {\n    if (v2[i] < 0) {\n      v3.push_back(v2[i]);\n\
    \    }\n  }\n  v2.erase(v2.begin(), v2.begin() + v3.size());\n  return v2;", " \
    \ std::vector<std::pair<int, long>> pairs;\n  for (auto it = arr.begin(); it !=\
    \ arr.end(); ++it) {\n    int n1s = 0;\n    long n = *it;\n    while (n > 0) {\n\
    \      n1s += n & 1;\n      n >>= 1;\n    }\n    pairs.push_back(std::make_pair(n1s,\
    \ *it));\n  }\n  std::sort(pairs.begin(), pairs.end());\n  std::vector<long> result;\n\
    \  for (auto it = pairs.begin(); it != pairs.end(); ++it) {\n    result.push_back(it->second);\n\
    \  }\n  return result;", "    std::vector<std::pair<long, int>> temp;\n    for\
    \ (auto elem : arr) {\n        int cnt = 0;\n        long x = elem;\n        while\
    \ (x > 0) {\n            cnt += x % 2;\n            x /= 2;\n        }\n     \
    \   temp.push_back(std::make_pair(elem, cnt));\n    }\n    std::sort(temp.begin(),\
    \ temp.end(), [](std::pair<long, int> a, std::pair<long, int> b) {\n        if\
    \ (a.second == b.second) {\n            return a.first < b.first;\n        }\n\
    \        return a.second < b.second;\n    });\n    std::vector<long> res;\n  \
    \  for (auto elem : temp) {\n        res.push_back(elem.first);\n    }\n    return\
    \ res;", "\tstd::vector<long> sorted_array;\n\tstd::unordered_map<int, int> map;\n\
    \tint binary_num;\n\tfor (auto &i : arr) {\n\t\tbinary_num = get_binary_representation(i);\n\
    \t\tstd::cout << \"binary num = \" << binary_num << std::endl;\n\t\tmap[binary_num]\
    \ = i;\n\t}\n\tstd::map<int, int> ordered_map(map.begin(), map.end());\n\tfor\
    \ (auto &i : ordered_map) {\n\t\tsorted_array.push_back(i.second);\n\t}\n\treturn\
    \ sorted_array;", "  std::cout << \"Here\" << std::endl;\n  long max = *std::max_element(arr.begin(),\
    \ arr.end());\n  std::cout << \"Max element is \" << max << std::endl;\n  std::vector<long>\
    \ dec2bin(max+1, 0);\n  std::cout << \"Size of dec2bin is \" << dec2bin.size()\
    \ << std::endl;\n  for (long i=0; i<max+1; i++) {\n    long tmp = i;\n    std::cout\
    \ << \"Calculating for \" << i << std::endl;\n    long count = 0;\n    while (tmp)\
    \ {\n      count += tmp&1;\n      tmp = tmp>>1;\n    }\n    dec2bin[i] = count;\n\
    \  }\n  std::sort(arr.begin(), arr.end(), [&dec2bin](long x, long y) {\n    if\
    \ (dec2bin[x] == dec2bin[y]) return x < y;\n    return dec2bin[x] < dec2bin[y];\n\
    \  });\n  return arr;", "  std::unordered_map<long, long> onesMap;\n  // std::vector<long>\
    \ sortedArr;\n  long maxNumOfOnes = -1;\n  for (long i = 0; i < arr.size(); i++)\
    \ {\n    long num = arr[i];\n    long numOfOnes = 0;\n    while (num > 0) {\n\
    \      if (num % 2 == 1)\n        numOfOnes++;\n      num /= 2;\n    }\n    onesMap[arr[i]]\
    \ = numOfOnes;\n    maxNumOfOnes = std::max(maxNumOfOnes, numOfOnes);\n  }\n \
    \ std::vector<std::vector<long>> buckets(maxNumOfOnes + 1);\n  for (long i = 0;\
    \ i < arr.size(); i++) {\n    buckets[onesMap[arr[i]]].push_back(arr[i]);\n  }\n\
    \  std::vector<long> sortedArr;\n  for (long i = 0; i < buckets.size(); i++) {\n\
    \    if (buckets[i].size() > 0) {\n      std::sort(buckets[i].begin(), buckets[i].end());\n\
    \      sortedArr.insert(sortedArr.end(), buckets[i].begin(), buckets[i].end());\n\
    \    }\n  }\n  return sortedArr;", "  auto cmp = [](long first, long second) {\n\
    \    int firstOnes = __builtin_popcountl(first);\n    int secondOnes = __builtin_popcountl(second);\n\
    \    if (firstOnes == secondOnes) {\n      return first < second;\n    }\n   \
    \ return firstOnes < secondOnes;\n  };\n  std::sort(arr.begin(), arr.end(), cmp);\n\
    \  return arr;", "  // first, we need to store the number of ones for each number\n\
    \  std::map<int, int> map;\n  for (auto i : arr) {\n    int numOnes = 0;\n   \
    \ int num = i;\n    while (num != 0) {\n      if (num & 1) {\n        numOnes++;\n\
    \      }\n      num = num >> 1;\n    }\n    map[i] = numOnes;\n  }\n  // now we\
    \ sort the array according to the num of ones\n  std::sort(arr.begin(), arr.end(),\n\
    \            [&map](int i, int j) { return map[i] < map[j]; });\n  return arr;",
  "    std::sort(arr.begin(), arr.end(), [](long a, long b) -> bool {\n        int\
    \ s1 = std::bitset<32>(a).count();\n        int s2 = std::bitset<32>(b).count();\n\
    \        return (s1 == s2) ? a < b : s1 < s2;\n    });\n    return arr;", "  //your\
    \ code here\n  std::vector<std::pair<long, long>> bits(arr.size());\n  for (size_t\
    \ i = 0; i < arr.size(); i++) {\n    bits[i].first = arr[i];\n    bits[i].second\
    \ = arr[i] == 0 ? 0 : int(log2(arr[i])) + 1;\n  }\n  sort(bits.begin(), bits.end(),\
    \ [](std::pair<long, long> &a, std::pair<long, long> &b) {\n    return a.second\
    \ == b.second ? a.first < b.first : a.second < b.second;\n  });\n  std::vector<long>\
    \ res(arr.size());\n  for (size_t i = 0; i < arr.size(); i++) {\n    res[i] =\
    \ bits[i].first;\n  }\n  return res;", "  vector<vector<long>> myMap;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    int count = 0;\n    for (int j = 0; j < 32;\
    \ j++) {\n      if (arr[i] & (1 << j)) {\n        count++;\n      }\n    }\n \
    \   myMap.push_back({count, arr[i]});\n  }\n  sort(myMap.begin(), myMap.end());\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    arr[i] = myMap[i][1];\n  }\n  return\
    \ arr;", "  for (int i = 0; i < arr.size(); i++) {\n    for (int j = i + 1; j\
    \ < arr.size(); j++) {\n      int count1 = 0;\n      int count2 = 0;\n      long\
    \ num1 = arr[i];\n      long num2 = arr[j];\n      while (num1 != 0) {\n     \
    \   count1++;\n        num1 /= 2;\n      }\n      while (num2 != 0) {\n      \
    \  count2++;\n        num2 /= 2;\n      }\n      if (count1 < count2) {\n    \
    \    long tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n   \
    \   } else if (count1 == count2) {\n        if (arr[i] > arr[j]) {\n         \
    \ long tmp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = tmp;\n  \
    \      }\n      }\n    }\n  }\n  return arr;", "  long countOnes[arr.size()];\n\
    \  long index[arr.size()];\n  for (int i = 0; i < arr.size(); i++) {\n    long\
    \ val = arr[i];\n    index[i] = i;\n    int ones = 0;\n    while (val > 0) {\n\
    \      int digit = val % 2;\n      val /= 2;\n      if (digit == 1) {\n      \
    \  ones++;\n      }\n    }\n    countOnes[i] = ones;\n  }\n  for (int i = 0; i\
    \ < arr.size(); i++) {\n    for (int j = i; j < arr.size(); j++) {\n      if (countOnes[i]\
    \ > countOnes[j]) {\n        std::swap(countOnes[i], countOnes[j]);\n        std::swap(index[i],\
    \ index[j]);\n      } else if (countOnes[i] == countOnes[j]) {\n        if (arr[index[i]]\
    \ > arr[index[j]]) {\n          std::swap(countOnes[i], countOnes[j]);\n     \
    \     std::swap(index[i], index[j]);\n        }\n      }\n    }\n  }\n  std::vector<long>\
    \ res;\n  for (int i = 0; i < arr.size(); i++) {\n    res.push_back(arr[index[i]]);\n\
    \  }\n  return res;", "  std::vector<std::vector<long>> decomposed;\n  decomposed.reserve(arr.size());\n\
    \  std::transform(arr.begin(), arr.end(), std::back_inserter(decomposed), [](auto\
    \ v) {\n    std::vector<long> r;\n    r.reserve(32);\n    for (int i = 0; i <\
    \ 32; ++i) {\n      r.push_back(v & 0x1);\n      v >>= 1;\n    }\n    r.resize(std::distance(r.begin(),\
    \ std::find_if(r.rbegin(), r.rend(), [](auto v) { return v == 1; }).base()));\n\
    \    return r;\n  });\n  std::stable_sort(\n      decomposed.begin(), decomposed.end(),\
    \ [](const auto& lhs, const auto& rhs) {\n        auto len = std::min(lhs.size(),\
    \ rhs.size());\n        for (int i = 0; i < len; ++i) {\n          if (lhs[i]\
    \ != rhs[i]) {\n            return lhs[i] < rhs[i];\n          }\n        }\n\
    \        return lhs.size() < rhs.size();\n      });\n  std::vector<long> result;\n\
    \  std::transform(decomposed.begin(), decomposed.end(), std::back_inserter(result),\
    \ [](const auto& v) {\n    long sum = 0;\n    for (int i = 0; i < v.size(); ++i)\
    \ {\n      sum = (sum << 1) + v[i];\n    }\n    return sum;\n  });\n  return result;",
  "    std::vector<std::pair<long, long>> nums;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        long count = 0;\n        long num = arr[i];\n        while (num)\
    \ {\n            if (num & 1) count++;\n            num >>= 1;\n        }\n  \
    \      nums.push_back(std::make_pair(count, arr[i]));\n    }\n    std::sort(nums.begin(),\
    \ nums.end());\n    std::vector<long> ret;\n    for (int i = 0; i < nums.size();\
    \ i++) {\n        ret.push_back(nums[i].second);\n    }\n    return ret;", " \
    \ int n = arr.size();\n  std::vector<std::vector<long>> temp(n);\n  std::vector<long>\
    \ ans;\n  for (int i = 0; i < n; i++) {\n    int val = arr[i];\n    int count\
    \ = 0;\n    while (val > 0) {\n      count += val & 1;\n      val >>= 1;\n   \
    \ }\n    temp[count].push_back(arr[i]);\n  }\n  for (int i = 0; i < n; i++) {\n\
    \    sort(temp[i].begin(), temp[i].end());\n    ans.insert(ans.end(), temp[i].begin(),\
    \ temp[i].end());\n  }\n  return ans;", "    // your code\n    std::vector<std::pair<int,\
    \ long>> binaryOnes;\n    std::vector<long> ans;\n    std::bitset<32> bit;\n \
    \   for (int i = 0; i < arr.size(); i++) {\n        bit = arr[i];\n        binaryOnes.push_back(std::make_pair(bit.count(),\
    \ arr[i]));\n    }\n    std::sort(binaryOnes.begin(), binaryOnes.end());\n   \
    \ for (int i = 0; i < binaryOnes.size(); i++) {\n        ans.push_back(binaryOnes[i].second);\n\
    \    }\n    return ans;", "    std::vector<std::vector<long>> a;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        a.push_back({0, arr[i]});\n    }\n  \
    \  std::vector<long> t;\n    for (int i = 0; i < arr.size(); i++) {\n        t\
    \ = {0, arr[i]};\n        while (arr[i] > 0) {\n            t[0] += (arr[i] %\
    \ 2);\n            arr[i] /= 2;\n        }\n        arr[i] = t[1];\n        a[i]\
    \ = t;\n    }\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j\
    \ = i; j < arr.size(); j++) {\n            if (a[i][0] > a[j][0]) {\n        \
    \        t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n\
    \            }\n            if (a[i][0] == a[j][0] && a[i][1] > a[j][1]) {\n \
    \               t = a[i];\n                a[i] = a[j];\n                a[j]\
    \ = t;\n            }\n        }\n    }\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        arr[i] = a[i][1];\n    }\n    return arr;", "  std::vector<long>\
    \ bin;\n  std::vector<long> ones;\n  std::vector<long> onesAndCount;\n  std::vector<long>\
    \ sorted;\n  long oneCount;\n  long binComp;\n  long binStr;\n  long binOne;\n\
    \  long binTwo;\n  std::string binOneStr;\n  std::string binTwoStr;\n  std::string\
    \ binOneTemp;\n  std::string binTwoTemp;\n  std::string binOneSub;\n  std::string\
    \ binTwoSub;\n  std::string binCompString;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    oneCount = 0;\n    binComp = arr[i];\n    binCompString = std::to_string(binComp);\n\
    \    binStr = std::bitset<32>(arr[i]).to_string();\n    for (int j = 0; j < binStr.size();\
    \ j++) {\n      if (binStr[j] == '1') {\n        oneCount++;\n      }\n    }\n\
    \    ones.push_back(oneCount);\n    onesAndCount.push_back(oneCount);\n    onesAndCount.push_back(binComp);\n\
    \    bin.push_back(binComp);\n  }\n  std::sort(ones.begin(), ones.end());\n  std::sort(bin.begin(),\
    \ bin.end());\n  long min = ones[0];\n  long max = ones[ones.size() - 1];\n  for\
    \ (int i = min; i <= max; i++) {\n    for (int j = 0; j < onesAndCount.size();\
    \ j += 2) {\n      if (onesAndCount[j] == i) {\n        sorted.push_back(onesAndCount[j\
    \ + 1]);\n      }\n    }\n  }\n  return sorted;", '  return std::vector<long>();',
  "  std::vector<std::pair<int, long>> binary_ones;\n  for (auto x : arr) {\n    int\
    \ ones = 0;\n    long y = x;\n    while (y > 0) {\n      ones += y % 2;\n    \
    \  y /= 2;\n    }\n    binary_ones.push_back(std::make_pair(ones, x));\n  }\n\
    \  std::sort(binary_ones.begin(), binary_ones.end());\n  for (int i = 0; i < binary_ones.size();\
    \ i++) {\n    arr[i] = binary_ones[i].second;\n  }\n  return arr;", "  // your\
    \ code here\n  std::map<int,std::vector<long>> map;\n  for(auto &e:arr){\n   \
    \ int ones=0;\n    for(long i=e;i>0;i/=2){\n      if(i%2)ones++;\n    }\n    map[ones].push_back(e);\n\
    \  }\n  std::vector<long> res;\n  for(auto &e:map){\n    std::sort(e.second.begin(),e.second.end());\n\
    \    for(auto &f:e.second){\n      res.push_back(f);\n    }\n  }\n  return res;",
  "    assert(arr.size()>0);\n    // std::vector<long> result;\n    long arr_size\
    \ = arr.size();\n    // long val_size = sizeof(arr[0]);\n    // std::cout<<arr_size<<\"\
    \ size of arr\"<<std::endl;\n    // std::cout<<val_size<<\" size of value\"<<std::endl;\n\
    \    for(long i=0;i<arr_size;i++){\n        // assert(arr[i]>=0);\n        //\
    \ result.push_back(arr[i]);\n        long count = 0;\n        std::string binary\
    \ = \"\";\n        long num = arr[i];\n        if(num>0){\n        while(num){\n\
    \            if(num%2 == 1){\n                count++;\n            }\n      \
    \      num = num/2;\n            binary = std::to_string(num%2) + binary;\n  \
    \      }\n        }else{\n            binary = \"0\";\n        }\n        // std::cout<<binary<<\"\
    \\t\"<<count<<std::endl;\n        arr[i] = std::stol(binary);\n        arr[i]\
    \ = arr[i] + (count*1000000000000000);\n    }\n    // std::sort(arr.begin(),arr.end());\n\
    \    // std::cout<<arr[0]<<std::endl;\n    std::sort(arr.begin(),arr.end());\n\
    \    for(long i=0;i<arr_size;i++){\n        long num = arr[i];\n        long mod\
    \ = num%1000000000000000;\n        arr[i] = mod;\n    }\n    return arr;", " \
    \   std::vector<long> tmp;\n    std::vector<long> res;\n    for (int i = 0; i\
    \ < arr.size(); i++) {\n        tmp.push_back(binary_to_decimal(decimal_to_binary(arr[i])));\n\
    \    }\n    // std::cout << std::endl;\n    sort(tmp.begin(), tmp.end());\n  \
    \  // for (int i = 0; i < tmp.size(); i++) {\n    //     std::cout << tmp[i] <<\
    \ \" \";\n    // }\n    // std::cout << std::endl;\n    int count = 0;\n    while\
    \ (count < tmp.size()) {\n        for (int i = 0; i < arr.size(); i++) {\n   \
    \         if (tmp[count] == arr[i]) {\n                res.push_back(arr[i]);\n\
    \                arr[i] = -1;\n                count++;\n            }\n     \
    \   }\n    }\n    return res;", "  std::sort(arr.begin(), arr.end(), [](const\
    \ auto& lhs, const auto& rhs) {\n    std::bitset<sizeof(long) * 8> left(lhs);\n\
    \    std::bitset<sizeof(long) * 8> right(rhs);\n    if (left.count() == right.count())\
    \ {\n      return lhs < rhs;\n    }\n    return left.count() < right.count();\n\
    \  });\n  return arr;", "  long size = arr.size();\n  std::vector<long> temp;\n\
    \  temp.resize(size);\n  std::copy(arr.begin(), arr.end(), temp.begin());\n  sort(temp.begin(),\
    \ temp.end());\n  std::vector<long> sort;\n  sort.resize(size);\n  for (int i\
    \ = 0; i < size; i++) {\n    int count = 0;\n    int num = temp[i];\n    while\
    \ (num) {\n      count++;\n      num = num & (num - 1);\n    }\n    sort[count\
    \ - 1] = temp[i];\n  }\n  return sort;", "    struct Item {\n        long val;\n\
    \        int ones;\n    };\n    std::vector<Item> items;\n    for (auto it = arr.begin();\
    \ it != arr.end(); ++it) {\n        int num = *it;\n        int count = 0;\n \
    \       while (num > 0) {\n            count += num % 2;\n            num /= 2;\n\
    \        }\n        items.push_back({*it, count});\n    }\n    std::sort(items.begin(),\
    \ items.end(), [](Item a, Item b) {\n        if (a.ones < b.ones) {\n        \
    \    return true;\n        } else if (a.ones == b.ones) {\n            return\
    \ a.val < b.val;\n        } else {\n            return false;\n        }\n   \
    \ });\n    std::vector<long> res;\n    for (auto it = items.begin(); it != items.end();\
    \ ++it) {\n        res.push_back(it->val);\n    }\n    return res;", "    // \
    \ iterate through vector and add a member to each value with the number of 1's\
    \ in its binary representation.\n    //  i.e. 0b10101 --> std::make_pair(long,\
    \ int) <5,3>\n    //  sort vector based on number of 1's and then on value.\n\
    \    std::vector<std::pair<long, int>> converted;\n    std::vector<long> sorted;\n\
    \    for (auto x : arr) {\n        int ones = 0;\n        int value = x;\n   \
    \     while (value > 0) {\n            if (value % 2 == 1)\n                ones++;\n\
    \            value /= 2;\n        }\n        converted.push_back(std::make_pair(x,\
    \ ones));\n    }\n    std::sort(converted.begin(), converted.end(),\n        \
    \      [](std::pair<long, int>& a, std::pair<long, int>& b) {\n              \
    \    if (a.second != b.second)\n                      return a.second < b.second;\n\
    \                  else\n                      return a.first < b.first;\n   \
    \           });\n    for (auto x : converted) {\n        sorted.push_back(x.first);\n\
    \    }\n    return sorted;", "  int i, j;\n  std::vector<long> temp_arr;\n  int\
    \ max_ones = 0;\n  int max_ones_count = 0;\n  int max_zeros = 0;\n  int max_zeros_count\
    \ = 0;\n  // std::cout << \"size \" << arr.size() << std::endl;\n  for (i = 0;\
    \ i < arr.size(); i++) {\n    long temp = arr[i];\n    int ones = 0;\n    int\
    \ zeros = 0;\n    while (temp > 0) {\n      if (temp % 2 == 1) {\n        ones++;\n\
    \      } else {\n        zeros++;\n      }\n      temp = temp / 2;\n    }\n  \
    \  if (ones == max_ones) {\n      max_ones_count++;\n    } else if (ones > max_ones)\
    \ {\n      max_ones = ones;\n      max_ones_count = 1;\n    }\n    if (zeros ==\
    \ max_zeros) {\n      max_zeros_count++;\n    } else if (zeros > max_zeros) {\n\
    \      max_zeros = zeros;\n      max_zeros_count = 1;\n    }\n  }\n  // std::cout\
    \ << \"max_ones: \" << max_ones << \" ones_count: \" << max_ones_count\n  // \
    \          << std::endl;\n  // std::cout << \"max_zeros: \" << max_zeros << \"\
    \ zeros_count: \" <<\n  // max_zeros_count\n  //           << std::endl;\n  int\
    \ z = 0;\n  int o = 0;\n  for (i = 0; i < arr.size(); i++) {\n    long temp =\
    \ arr[i];\n    int ones = 0;\n    int zeros = 0;\n    while (temp > 0) {\n   \
    \   if (temp % 2 == 1) {\n        ones++;\n      } else {\n        zeros++;\n\
    \      }\n      temp = temp / 2;\n    }\n    // std::cout << \"ones: \" << ones\
    \ << \" zeros: \" << zeros << std::endl;\n   ", "\tstd::vector<long> result;\n\
    \tstd::unordered_map<long, long> map;\n\tfor (auto i : arr) {\n\t\tlong count\
    \ = 0;\n\t\tlong n = i;\n\t\twhile (n) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\
    \t\t}\n\t\tmap[i] = count;\n\t}\n\tstd::sort(arr.begin(), arr.end(), [&map](long&\
    \ a, long& b) {\n\t\tif (map[a] == map[b]) {\n\t\t\treturn a < b;\n\t\t}\n\t\t\
    return map[a] < map[b];\n\t});\n\treturn arr;", "    // your code here\n    for(int\
    \ i = 0; i < arr.size(); i++) {\n        for(int j = i+1; j < arr.size(); j++)\
    \ {\n            int num1 = arr[i];\n            int num2 = arr[j];\n        \
    \    int len1 = 0;\n            int len2 = 0;\n            while(num1) {\n   \
    \             if(num1 & 1) {\n                    len1++;\n                }\n\
    \                num1 = num1 >> 1;\n            }\n            while(num2) {\n\
    \                if(num2 & 1) {\n                    len2++;\n               \
    \ }\n                num2 = num2 >> 1;\n            }\n            if(len1 > len2)\
    \ {\n                std::swap(arr[i], arr[j]);\n            } else if(len1 ==\
    \ len2) {\n                if(arr[i] > arr[j]) {\n                    std::swap(arr[i],\
    \ arr[j]);\n                }\n            }\n        }\n    }\n    return arr;",
  "  int n = arr.size();\n  std::vector<int> l;\n  l.resize(n);\n  for (int i = 0;\
    \ i < n; i++) {\n    l[i] = __builtin_popcount(arr[i]);\n  }\n  std::vector<std::pair<int,\
    \ int>> v;\n  for (int i = 0; i < n; i++) {\n    v.push_back(std::make_pair(l[i],\
    \ arr[i]));\n  }\n  std::sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++)\
    \ {\n    arr[i] = v[i].second;\n  }\n  return arr;", "  struct sort_by_ones {\n\
    \    bool operator()(const long& lhs, const long& rhs) {\n      int ll = __builtin_popcountl(lhs);\n\
    \      int rl = __builtin_popcountl(rhs);\n      if (ll != rl) {\n        return\
    \ ll < rl;\n      }\n      return lhs < rhs;\n    }\n  };\n  sort(arr.begin(),\
    \ arr.end(), sort_by_ones());\n  return arr;", "    std::vector<long> res;\n \
    \   std::unordered_map<long,long> mp;\n    std::map<long,long> mp2;\n    for(long\
    \ i = 0; i < arr.size(); i++) {\n        mp[arr[i]] = __builtin_popcount(arr[i]);\n\
    \        mp2[__builtin_popcount(arr[i])] = arr[i];\n    }\n    std::sort(arr.begin(),\
    \ arr.end());\n    for(auto it = arr.begin(); it != arr.end(); it++) {\n     \
    \   res.push_back(mp2[mp[*it]]);\n    }\n    return res;", "  std::sort(arr.begin(),\
    \ arr.end(),\n    [&](int a, int b) {\n      // counting number of 1's in each\
    \ binary representation\n      int num_of_ones_a = std::bitset<64>(a).count();\n\
    \      int num_of_ones_b = std::bitset<64>(b).count();\n      // sorting based\
    \ on number of 1's\n      if (num_of_ones_a != num_of_ones_b) {\n        return\
    \ num_of_ones_a < num_of_ones_b;\n      }\n      // sorting based on decimal value\n\
    \      else {\n        return a < b;\n      }\n    });\n  return arr;", "    assert(arr.size()\
    \ > 0);\n    std::vector<std::pair<int, long>> pairs;\n    for (auto e : arr)\
    \ {\n        int count = 0;\n        while (e) {\n            e &= (e - 1);\n\
    \            count++;\n        }\n        pairs.push_back(std::make_pair(count,\
    \ e));\n    }\n    std::sort(pairs.begin(), pairs.end());\n    for (int i = 0;\
    \ i < pairs.size(); i++)\n        arr[i] = pairs[i].second;\n    return arr;",
  "    std::sort(arr.begin(), arr.end(), [](long l, long r) {\n        auto left =\
    \ std::bitset<64>(l);\n        auto right = std::bitset<64>(r);\n        return\
    \ left.count() == right.count() ? l < r : left.count() < right.count();\n    });\n\
    \    return arr;"]
stop_tokens:
- "\n}"
