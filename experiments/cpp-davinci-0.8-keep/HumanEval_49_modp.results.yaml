name: HumanEval_49_modp
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n==0) return 1;\n    long result = modp(n/2,\
    \ p);\n    result = (result*result)%p;\n    if (n&1) result = (result*2)%p;\n\
    \    return result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // TODO: Implement me!\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp45b7jrec: /tmp/tmp45b7jrec.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long\
    \ t = modp(n / 2, p);\n        return (t * t) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpuaiwz960: /tmp/tmpuaiwz960.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  assert(n < p);\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long\
    \ tmp = modp(n / 2, p);\n        return (tmp * tmp) % p;\n    } else {\n     \
    \   return (2 * modp(n - 1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_hfruvif: /tmp/tmp_hfruvif.cpp:17: long int modp(long int, long int):\
    \ Assertion `n < p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n < 0)\n       \
    \ n += p;\n    long result = 1;\n    while (n > 0) {\n        if (n & 1)\n   \
    \         result = (result * n) % p;\n        n >>= 1;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprc_q2m_1: /tmp/tmprc_q2m_1.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    else if (n ==\
    \ 1) return n % p;\n    else if (n % 2 == 0) {\n        // Square modulo n/2 (the\
    \ latter can be computed using bit shift)\n        long half = modp(n / 2, p);\n\
    \        return (half * half) % p;\n    } else {\n        // n-1 is even, n-1\
    \ = n - 1\n        long half = modp(n - 1, p);\n        return (half * n) % p;\n\
    \    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkxjr3d_p: /tmp/tmpkxjr3d_p.cpp:30: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n <= 1) {\n        return n;\n    }\n\
    \    if (n % 2 == 0) {\n        return (long) pow(modp(n / 2, p), 2) % p;\n  \
    \  }\n    return (long) (modp(n - 1, p) * n) % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4p22w2ka: /tmp/tmp4p22w2ka.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  long res = 1;\n    for (int i = 1; i <= n; i++)\n        res = (res * 2) %\
    \ p;\n    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    assert(p > 0);\n\
    \    long res = modp(n/2, p);\n    if (n % 2 == 0)\n        return res * res %\
    \ p;\n    else\n        return (res * res % p) * n % p;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpz40okptx: /tmp/tmpz40okptx.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long c = 1;\n    for (long i = 0; i < n;\
    \ i++) {\n        c = c * 2 % p;\n    }\n    return c;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong r = modp(n /\
    \ 2, p);\n\tr = (r * r) % p;\n\tif (n % 2 == 1) r = (r * 2) % p;\n\treturn r;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        return modp(-n, p);\n\
    \    }\n    long r = 1;\n    while (n > 0) {\n        if (n % 2 != 0) {\n    \
    \        r = (r * 2) % p;\n        }\n        n /= 2;\n        // this is 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0vr1v24x.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmp0vr1v24x.cpp:26:9: warning: empty parentheses were disambiguated as\
    \ a function declaration [-Wvexing-parse]\n   26 | int main() {\n      |     \
    \    ^~\n/tmp/tmp0vr1v24x.cpp:26:9: note: remove parentheses to default-initialize\
    \ a variable\n   26 | int main() {\n      |         ^~\n      |         --\n/tmp/tmp0vr1v24x.cpp:26:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmp0vr1v24x.cpp:26:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   26 | int main() {\n      |            ^\n/tmp/tmp0vr1v24x.cpp:35:2: error:\
    \ expected \u2018}\u2019 at end of input\n   35 | }\n      |  ^\n/tmp/tmp0vr1v24x.cpp:14:27:\
    \ note: to match this \u2018{\u2019\n   14 | long modp(long n, long p) {\n   \
    \   |                           ^\n/tmp/tmp0vr1v24x.cpp:35:2: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   35 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long y = 1;\n    long x = n;\n    while\
    \ (p > 0) {\n        if (p % 2 == 1) {\n            y = (y * x) % p;\n       \
    \ }\n        x = (x * x) % p;\n        p = p / 2;\n    }\n    return y % p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // assert(p > 1);  // p < 2 is not a prime.\n\
    \    long r = 1;\n    while (n) {\n        if (n & 1) {\n            r = (r *\
    \ 2) % p;\n        }\n        n /= 2;\n        long d = 2 % p;\n        if (d\
    \ == 0) {\n            return 0;\n        }\n        d = (d * d) % p;\n    }\n\
    \    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmh6lutkv: /tmp/tmpmh6lutkv.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        n += (1 - n/p) * p;\n\
    \    }\n    return n % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4t5lldqi: /tmp/tmp4t5lldqi.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 1);\n    if (n == 0) return\
    \ 1;\n    long r = n;\n    if (r < 0) r += p;\n    long ans = 1;\n    while (n\
    \ > 0) {\n        if (n & 1) ans = (ans * r) % p;\n        n >>= 1;\n        r\
    \ = (r * r) % p;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptpzql_30: /tmp/tmptpzql_30.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long res = modp(n\
    \ >> 1, p);\n    res = (res * res) % p;\n    if (n & 1) res = (res * 2) % p;\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) {\n    n = (n\
    \ % p) + p;\n  }\n  long result = 1;\n  long power = n;\n  long b = 2;\n  while\
    \ (b <= power) {\n    if (power & b) {\n      result = (result * n) % p;\n   \
    \   power -= b;\n    }\n    n = (n * n) % p;\n    b = b << 1;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2geo62pp: /tmp/tmp2geo62pp.cpp:35: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n==0) return 1;\n    assert(n<p);\n\
    \    long half = modp(n/2, p);\n    if (n%2==0) {\n        return (half*half)%p;\n\
    \    } else {\n        return (half*half*n)%p;\n    }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfxf30par: /tmp/tmpfxf30par.cpp:16: long int modp(long int, long int):\
    \ Assertion `n<p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n>=0);\n\tassert(p>=2);\n\tlong a =\
    \ 1;\n\tlong b = 2;\n\twhile (n>0) {\n\t\tif (n%2 == 1) {\n\t\t\ta = (a*b)%p;\n\
    \t\t}\n\t\tn /= 2;\n\t\tb = (b*b)%p;\n\t}\n\treturn a;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n// assert(n >= 0);\n// assert(p > 0);\nif (n\
    \ == 0) return 1;\nif (n % 2 == 0) {\nlong tmp = modp(n/2, p);\nreturn (tmp *\
    \ tmp) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6jmi44qy.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmp6jmi44qy.cpp:22:9: warning: empty parentheses were disambiguated as\
    \ a function declaration [-Wvexing-parse]\n   22 | int main() {\n      |     \
    \    ^~\n/tmp/tmp6jmi44qy.cpp:22:9: note: remove parentheses to default-initialize\
    \ a variable\n   22 | int main() {\n      |         ^~\n      |         --\n/tmp/tmp6jmi44qy.cpp:22:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmp6jmi44qy.cpp:22:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   22 | int main() {\n      |            ^\n/tmp/tmp6jmi44qy.cpp:31:2: error:\
    \ expected \u2018}\u2019 at end of input\n   31 | }\n      |  ^\n/tmp/tmp6jmi44qy.cpp:14:27:\
    \ note: to match this \u2018{\u2019\n   14 | long modp(long n, long p) {\n   \
    \   |                           ^\n/tmp/tmp6jmi44qy.cpp:31:2: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   31 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  long ans = 1;\n    for (long i = 1; i <= n; i++)\n        ans = (ans * 2) %\
    \ p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1)\n      r = (r * 2) % p;\n    n = n / 2;\n  }\n  return r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcrtnhnfx: /tmp/tmpcrtnhnfx.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0)\n        return modp(-n, p);\n\
    \    if (n < p)\n        return n;\n    if (n % 2 == 0)\n        return (modp(n\
    \ / 2, p) * modp(n / 2, p)) % p;\n    else\n        return (modp(n / 2, p) * modp(n\
    \ / 2, p) * 2) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpid0pzvs2: /tmp/tmpid0pzvs2.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n % p;\n    if (n % 2 == 0) return modp(n / 2, p) * modp(n / 2, p) % p;\n  \
    \  return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpas8h4enf: /tmp/tmpas8h4enf.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) return 1;\n    long pow = 2;\n    long val = 1;\n    long p2 =\
    \ p * p;\n    while (pow <= n) {\n        if (n & pow) {\n            val = (val\
    \ * pow) % p2;\n        }\n        pow = pow << 1;\n    }\n    val = (val * p)\
    \ % p2;\n    return val;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2_px3di9: /tmp/tmp2_px3di9.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    for (long i = 1; i\
    \ <= n; i++) {\n        result = result * 2 % p;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  for (; n > 0; n >>= 1) {\n\
    \    if (n & 1) {\n      r = (r * 2) % p;\n    }\n  }\n  return r;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6nyandhu: /tmp/tmp6nyandhu.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    for (long i = 0; i <\
    \ n; i++) {\n        res = (res * 2) % p;\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    n %= p;\n    if (n <= 1) return n;\n   \
    \ long ret = 1;\n    for (long i = 1; i <= n; i++)\n        ret = (ret * 2) %\
    \ p;\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpozrxpg6w: /tmp/tmpozrxpg6w.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    n %= p;\n    if (n < 0) n += p;\n    return\
    \ n;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqautwpwc: /tmp/tmpqautwpwc.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  long ans = 1;\n    long pow = n;\n    while (p > 0) {\n        if (p % 2 ==\
    \ 1) {\n            ans = (ans * pow) % p;\n        }\n        pow = (pow * pow)\
    \ % p;\n        p = p / 2;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpo5rs9lek: /tmp/tmpo5rs9lek.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n\
    \    long t = modp(n / 2, p);\n    return (t * t) % p;\n  }\n  return (modp(n\
    \ - 1, p) * n) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpuh4502qg: /tmp/tmpuh4502qg.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 1);\n\tlong long x = 1;\n\tfor\
    \ (; n > 0; n >>= 1) {\n\t\tif (n & 1) {\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\t\
    x = (x * x) % p;\n\t}\n\treturn x;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpady7sfx6: /tmp/tmpady7sfx6.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n==0) return 1;\n    assert(n<p);\n \
    \   if(n<0) n+=p;\n    std::vector<bool> bits;\n    while(n>0) {\n        bits.push_back(n%2);\n\
    \        n/=2;\n    }\n    long res=1;\n    for(int i=bits.size()-1; i>=0; i--)\
    \ {\n        res=res*res%p;\n        if(bits[i]) res=res*2%p;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpswoasp3k: /tmp/tmpswoasp3k.cpp:16: long int modp(long int, long int):\
    \ Assertion `n<p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  if (n\
    \ < p) {\n    return n;\n  }\n  long x = 1;\n  while (n > 0) {\n    if (n % 2\
    \ == 1) {\n      x = (x * 2) % p;\n    }\n    n /= 2;\n    if (n > 0) {\n    \
    \  x = (x * x) % p;\n    }\n  }\n  return x;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprivyw85l: /tmp/tmprivyw85l.cpp:35: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\telse if (n % 2 ==\
    \ 0) {\n\t\tlong half = modp(n / 2, p);\n\t\treturn (half * half) % p;\n\t}\n\t\
    else {\n\t\treturn (modp(n - 1, p) * n) % p;\n\t}\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4kibking: /tmp/tmp4kibking.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  // If\
    \ p is even, 2^n mod p = (2 mod p)^n mod p\n  if (p % 2 == 0) {\n    return modp(n,\
    \ p/2) * modp(n, p/2) % p;\n  }\n  // If n is even, 2^n mod p = (2^(n/2) mod p)^2\
    \ mod p\n  if (n % 2 == 0) {\n    return modp(n/2, p) * modp(n/2, p) % p;\n  }\n\
    \  // If n is odd, 2^n mod p = 2 * (2^(n-1) mod p) mod p\n  return 2 * modp(n-1,\
    \ p) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tif (n == 1) return\
    \ n % p;\n\tassert(p < (1 << 30));\n\tlong res = 1;\n\t// This is more efficient\
    \ than n % p.\n\tlong exp = n % (p - 1);\n\tlong base = n % p;\n\twhile (exp)\
    \ {\n\t\tif (exp & 1) res = (res * base) % p;\n\t\tbase = (base * base) % p;\n\
    \t\texp >>= 1;\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6gwozxqr: /tmp/tmp6gwozxqr.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 2);\n    if (n < p) return n;\n\
    \    long pow_2_modp = 2;\n    long result = pow_2_modp;\n    long pow_2 = 4;\n\
    \    while (n >= pow_2) {\n        if (n & pow_2) {\n            result = (result\
    \ * pow_2_modp) % p;\n            n -= pow_2;\n        }\n        pow_2_modp =\
    \ (pow_2_modp * pow_2_modp) % p;\n        pow_2 *= 2;\n    }\n    result = (result\
    \ * modp(n, p)) % p;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpa7yhwan0: /tmp/tmpa7yhwan0.cpp:34: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n==0) return 1;\n\tlong n_half = modp(n/2,\
    \ p);\n\tlong n_half_sq = (n_half*n_half)%p;\n\tlong ret = n%2==0 ? n_half_sq\
    \ : (n_half_sq*2)%p;\n\tif (ret<0) ret += p;\n\treturn ret;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  if (n\
    \ == 0) return 1;\n  long q = modp(n / 2, p);\n  return n % 2 == 0 ? (q * q) %\
    \ p : (q * q * 2) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n & 1)\n            res = (res * 2) % p;\n        n = n >> 1;\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsrs21coy: /tmp/tmpsrs21coy.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n==0)\n    return 1;\n  long t = modp(n/2,\
    \ p);\n  if(n%2==0)\n    return (t*t)%p;\n  else\n    return (t*t*2)%p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) n = n % p + p;\n    if (n ==\
    \ 0) return 1;\n    if (n == 1) return n;\n    long ret = modp(n / 2, p);\n  \
    \  ret = (ret * ret) % p;\n    if (n % 2 == 1) ret = (ret * n) % p;\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp10zzk2ed: /tmp/tmp10zzk2ed.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n==0) return 1;\n    if (n==1) return\
    \ n%p;\n    long c = modp(n/2, p);\n    if (n%2==0) return (c*c)%p;\n    else\
    \ return (c*c*n)%p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprlie2mcu: /tmp/tmprlie2mcu.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong r = 1;\n\twhile\
    \ (n > 0) {\n\t\tif (n & 1) r = (r * r) % p;\n\t\tn >>= 1;\n\t}\n\treturn r;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpeswsac1a: /tmp/tmpeswsac1a.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    for (long i = 0; i\
    \ < n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long ans = modp(n/2,\
    \ p);\n    ans = (ans * ans) % p;\n    if (n % 2 == 1) ans = (ans * 2) % p;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        return modp(-n, p);\n\
    \    }\n    long res = 1;\n    long b = 2;\n    while (n > 0) {\n        if (n\
    \ % 2 == 1) {\n            res = (res * b) % p;\n        }\n        n /= 2;\n\
    \        b = (b * b) % p;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1)\n      r = (r * 2) % p;\n    n = n / 2;\n  }\n  return r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmplhxadr2q: /tmp/tmplhxadr2q.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  if (n == 0) return 1;\n    if (n == 1) return n % p;\n    if (n % 2 == 0) {\n\
    \        return modp(n / 2, p) * modp(n / 2, p) % p;\n    } else {\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpi5l5hz9v: /tmp/tmpi5l5hz9v.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 2);\n\tif (n % p == 0) return\
    \ 0;\n\tif (n < p) return n;\n\tlong m = 1;\n\tfor (long a = n; a; a /= 2) {\n\
    \t\tif (a % 2) m = (m * 2) % p;\n\t\tlong b = (a + 1) / 2;\n\t\tlong t = b * b;\n\
    \t\tif (t >= p) t %= p;\n\t\tif (n >= t) n -= t;\n\t}\n\treturn m;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2s3qxich: /tmp/tmp2s3qxich.cpp:31: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) return modp((n/2)*(n/2), p);\n    return (modp(n/2, p) * modp(n/2 + 1, p))\
    \ % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long res = modp(n/2,\
    \ p);\n    res = (res * res) % p;\n    if (n % 2 == 1) res = (res * 2) % p;\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n == 0) {\n        return 1;\n    }\n\
    \    if(n == 1) {\n        return n;\n    }\n    // The below function is from\
    \ https://stackoverflow.com/questions/11440263/how-to-compute-in-modulo-p\n  \
    \  long ret = modp(n/2, p);\n    ret = (ret * ret) % p;\n    if(n%2 != 0) {\n\
    \        ret = (ret * n) % p;\n    }\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpzy1qqykp: /tmp/tmpzy1qqykp.cpp:32: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 2);\n    if (n >= p)\n     \
    \   n %= p;\n    long c = 1;\n    while (n > 0) {\n        if (n & 1)\n      \
    \      c = (c * 2) % p;\n        n >>= 1;\n        // cout << c << ' ' << n <<\
    \ endl;\n    }\n    return c;\n}\nint main() {\n    auto candidate = modp;\n \
    \   assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfsv6md2j: /tmp/tmpfsv6md2j.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n == 1) {\n        return n % p;\n    }\n    long ans = modp(n >> 1,\
    \ p);\n    ans = (ans * ans) % p;\n    if (n & 1) {\n        ans = (ans * n) %\
    \ p;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n  \
    \  assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1vnn7sot: /tmp/tmp1vnn7sot.cpp:31: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n == 1) {\n        return n;\n    } else if (n % 2 == 0) {\n      \
    \  long t = modp(n / 2, p);\n        return (t * t) % p;\n    } else {\n     \
    \   return (n * modp(n - 1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpiljw90f2: /tmp/tmpiljw90f2.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n == 0) return 1;\n\
    \  if (n % 2 == 0) {\n    long r = modp(n / 2, p);\n    return (r * r) % p;\n\
    \  } else {\n    return (modp(n - 1, p) * n) % p;\n  }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp9k41mrdj: /tmp/tmp9k41mrdj.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n\
    \ % 2 == 0) {\n\t\tlong m = modp(n / 2, p);\n\t\treturn (m * m) % p;\n\t}\n\t\
    return (2 * modp(n - 1, p)) % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < p) { return n; }\n    long r = 1;\n\
    \    for (long i = 0; i < n; i++) {\n        r = r * 2 % p;\n    }\n    return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3_jwa3re: /tmp/tmp3_jwa3re.cpp:26: int main(): Assertion `candidate((0),\
    \ (101)) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n/2,\
    \ p);\n    x = (x * x) % p;\n    if (n % 2) x = (x * 2) % p;\n    return x;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n >= p) n %= p;\n\tif (n == 0) return\
    \ 1;\n\tif (n == 1) return n;\n\tlong w = n, r = 1;\n\twhile (w > 0) {\n\t\tif\
    \ (w & 1) r = (r * n) % p;\n\t\tw >>= 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvt59ebju: /tmp/tmpvt59ebju.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n <= 0) return 1;\n    long res = 1;\n\
    \    while (n > 0) {\n        if (n % 2 == 1) res = (res * 2) % p;\n        n\
    \ /= 2;\n    }\n    return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5o5p5__e: /tmp/tmp5o5p5__e.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 1);\n\tif (n == 0) return 1;\n\
    \tlong z = modp(n/2, p);\n\tif (n % 2 == 0) return (z*z) % p;\n\telse return (\
    \ (z*z) % p * n ) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1q9x1zq_: /tmp/tmp1q9x1zq_.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long x = 1;\n    long t = n;\n    while\
    \ (t) {\n        if (t & 1) x = (x * n) % p;\n        n = (n * n) % p;\n     \
    \   t >>= 1;\n    }\n    return x;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6di2cm39: /tmp/tmp6di2cm39.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  if (n\
    \ == 0) return 1;\n  if (n == 1) return n % p;\n  return modp(n / 2, p) * modp(n\
    \ - n / 2, p) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkeacqaoq: /tmp/tmpkeacqaoq.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  // Initialize result\n    long res = 1;\n    // Update x if it is more\n  \
    \  // than or equal to p\n    long x = n;\n    while (x > 1) {\n        // If\
    \ x is odd, multiply x\n        // with result\n        if (x & 1) {\n       \
    \     res = (res * x) % p;\n        }\n        // x must be even now\n       \
    \ x = x >> 1; // x = x/2\n        x = (x * x) % p;\n    }\n    if (n == 0) {\n\
    \        return 1;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    long k = 1;\n    while\
    \ (n) {\n        if (n & 1) {\n            k = (k * 2) % p;\n        }\n     \
    \   n >>= 1;\n    }\n    return k;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpk1o7hv93: /tmp/tmpk1o7hv93.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n   // Implement this function.\n\tif(n==0)\n\
    \t\treturn 1;\n\tif(n%2==0)\n\t{\n\t\tlong t=modp(n/2,p);\n\t\treturn (t*t)%p;\n\
    \t}\n\telse\n\t{\n\t\treturn ((2%p)*modp(n-1,p))%p;\n\t}\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        n += (-n/p + 1) *\
    \ p;\n    }\n    long c = 1;\n    while (n > 0) {\n        if (n & 1) {\n    \
    \        c = (c * 2) % p;\n        }\n        n >>= 1;\n        if (n > 0) {\n\
    \            c = (c * 2) % p;\n        }\n    }\n    return c;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8tkz9hhb: /tmp/tmp8tkz9hhb.cpp:33: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) n = n % p + p;\n\
    \  int res = 1;\n  for (long e = n; e > 0; e >>= 1) {\n    if (e & 1) res = res\
    \ * n % p;\n    n = n * n % p;\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1iigcf51: /tmp/tmp1iigcf51.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 1);\n    // Use binary power\
    \ to compute n^p % p.\n    long answer = 1;\n    long multiplier = n;\n    //\
    \ Loop invariant: answer contains the value of n^i % p.\n    while (p != 0) {\n\
    \        // If p is odd, add n^p to the answer.\n        if (p % 2 == 1) {\n \
    \           answer = (answer * multiplier) % MOD;\n        }\n        // Square\
    \ n^p.\n        multiplier = (multiplier * multiplier) % MOD;\n        // Divide\
    \ p by 2.\n        p /= 2;\n    }\n    return answer;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6c39wzqk.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmp6c39wzqk.cpp:23:46: error: \u2018MOD\u2019 was not declared in this\
    \ scope\n   23 |             answer = (answer * multiplier) % MOD;\n      |  \
    \                                            ^~~\n/tmp/tmp6c39wzqk.cpp:26:50:\
    \ error: \u2018MOD\u2019 was not declared in this scope\n   26 |         multiplier\
    \ = (multiplier * multiplier) % MOD;\n      |                                \
    \                  ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  long sq = modp(n/2,\
    \ p);\n  sq = (sq * sq) % p;\n  if (n & 1) sq = (sq * 2) % p;\n  return sq;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // return (n % p + p) % p;\n    assert(n\
    \ >= 0);\n    assert(p > 0);\n    assert(p < 1<<31);\n    if (n == 0) return 1;\n\
    \    long res = 1;\n    while (n) {\n        if (n & 1) res = (res * 2) % p;\n\
    \        n >>= 1;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpz6c35erg: /tmp/tmpz6c35erg.cpp:18: long int modp(long int, long int):\
    \ Assertion `p < 1<<31' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n == 1) return\
    \ n % p;\n  if (n % 2 == 0) {\n    long half = modp(n / 2, p);\n    return (half\
    \ * half) % p;\n  } else {\n    return ((n % p) * modp(n - 1, p)) % p;\n  }\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpk5jhwj0u: /tmp/tmpk5jhwj0u.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ret = 1;\n    while (n) {\n       \
    \ if (n % 2) ret = (ret * p) % 101;\n        p = (p * p) % 101;\n        n /=\
    \ 2;\n    }\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n  \
    \  assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp43u2r7hu: /tmp/tmp43u2r7hu.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  long res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res =\
    \ (res * 2) % p;\n        }\n        n >>= 1;\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8eputfah: /tmp/tmp8eputfah.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n>=0);\n    assert(p>=2);\n    long\
    \ d = 1;\n    while (n) {\n        if (n & 1) d = (d * 2) % p;\n        n >>=\
    \ 1;\n    }\n    return d;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqlr8ly5d: /tmp/tmpqlr8ly5d.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0)\n    n = (n %\
    \ p) + p;\n  if (n < p / 2)\n    return n;\n  else\n    return n - p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2w7nxrq3: /tmp/tmp2w7nxrq3.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = 1;\n  while (n > 0) {\n    ans\
    \ = (ans * (n % 2 == 1 ? 2 : 1)) % p;\n    n /= 2;\n  }\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptrm79exn: /tmp/tmptrm79exn.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) {\n    return 1;\n  }\n  if (n\
    \ == 1) {\n    return n % p;\n  }\n  // n > 1\n  long n_div_2 = n / 2;\n  long\
    \ n_minus_n_div_2 = n - n_div_2;\n  long X = modp(n_div_2, p);\n  long Y = modp(n_minus_n_div_2,\
    \ p);\n  long result = X * Y;\n  return result % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_18vsfw9: /tmp/tmp_18vsfw9.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return\
    \ modp((n / 2) * (n / 2), p);\n\treturn (modp(n - 1, p) * 2) % p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmps2sjok7j: /tmp/tmps2sjok7j.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  long res = 1;\n  while (n\
    \ > 0) {\n    if (n & 1) {\n      res = (res * n) % p;\n    }\n    n >>= 1;\n\
    \    n %= p;\n  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmer231hl: /tmp/tmpmer231hl.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n < 0) {\n    // Negative powers are not\
    \ allowed, so compute the inverse and\n    // fall through to the positive case.\n\
    \    return modp(-n, p);\n  }\n  if (n == 0) return 1;\n\n  if (n % 2 == 0) {\n\
    \    long x = modp(n/2, p);\n    return (x*x) % p;\n  } else {\n    long x = modp(n/2,\
    \ p);\n    long y = modp(n/2 + 1, p);\n    return (x*y) % p;\n  }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n\
    \    long x = modp(n/2, p);\n    return (x*x) % p;\n  } else {\n    return (modp(n-1,\
    \ p) * n) % p;\n  }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphmw742dk: /tmp/tmphmw742dk.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) return modp((n / 2) * (n / 2), p);\n    else return (modp(n / 2, p) * modp(n\
    \ / 2, p)) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0xukns4d: /tmp/tmp0xukns4d.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\
    \t\tlong tmp = modp(n / 2, p);\n\t\treturn (tmp * tmp) % p;\n\t}\n\telse {\n\t\
    \treturn (modp(n - 1, p) * 2) % p;\n\t}\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) { n += 1 - n\
    \ / p * p; }\n  return n % p;\n}\nint main() {\n    auto candidate = modp;\n \
    \   assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpuienc_4n: /tmp/tmpuienc_4n.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long ans = modp(n\
    \ / 2, p);\n    ans = (ans * ans) % p;\n    if (n % 2 == 1) ans = (ans * 2) %\
    \ p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Handle special cases like n == 0\n  if\
    \ (n == 0) return 1;\n  long result = 1;\n  while (n > 0) {\n    if (n & 1) {\
    \ // n is odd\n      result = (result * n) % p;\n    }\n    n = n >> 1;\n    n\
    \ = (n * n) % p;\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) {\n    n = p\
    \ - 1 - ((-n - 1) % (p - 1));\n  }\n  long result = 1;\n  long factor = n;\n \
    \ while (p > 0) {\n    if (p & 1) {\n      result = (result * factor) % n;\n \
    \   }\n    factor = (factor * factor) % n;\n    p /= 2;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpi1rojkfq: /tmp/tmpi1rojkfq.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong x = modp(n /\
    \ 2, p);\n\tx = (x * x) % p;\n\tif (n % 2 == 1) x = (x * 2) % p;\n\treturn x;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tn %= p;\n\tif (n < 0) n += p;\n\tlong result\
    \ = 1;\n\tlong b = n;\n\tlong e = 1;\n\twhile (e <= INT_MAX) {\n\t\tif (e & 1)\
    \ {\n\t\t\tresult = (result * b) % p;\n\t\t}\n\t\te >>= 1;\n\t\tb = (b * b) %\
    \ p;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = modp;\n   \
    \ assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n <= 1)\n    return\
    \ n;\n  long res = 1;\n  while (n > 0) {\n    if (n & 1)\n      res = (res * n)\
    \ % p;\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n  return res % p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    while (n > 0) {\n\
    \        if (n & 1) {\n            result = (result * 2) % p;\n        }\n   \
    \     n >>= 1;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsbxd3g43: /tmp/tmpsbxd3g43.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long r = modp(n / 2, p);\n        return r * r % p;\n    }\n \
    \   return modp(n - 1, p) * n % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_81og4dd: /tmp/tmp_81og4dd.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n==0) return 1;\n  if(n%2==0) return modp((n/2)*(n/2),\
    \ p);\n  else return (modp(n-1, p)*2)%p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4lr1cq59: /tmp/tmp4lr1cq59.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n\
    \ % 2 == 0) {\n\t\tlong t = modp(n / 2, p);\n\t\treturn (t * t) % p;\n\t}\n\t\
    return (modp(n - 1, p) * n) % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpf8aweo2t: /tmp/tmpf8aweo2t.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p > 0);\n\tassert(n >= 0);\n\tassert(n\
    \ < p);\n\tlong res = 1;\n\tlong pp = p;\n\tlong pn = p - 1;\n\tlong pow = n;\n\
    \twhile (pn > 0) {\n\t\tif (pn & 1) {\n\t\t\tres = (res * pow) % pp;\n\t\t}\n\t\
    \tpow = (pow * pow) % pp;\n\t\tpn >>= 1;\n\t}\n\treturn res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpaztoro3o: /tmp/tmpaztoro3o.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n % p;\n    if (n % 2 == 0) {\n        return (modp(n / 2, p) * modp(n / 2,\
    \ p)) % p;\n    } else {\n        return (n * modp(n - 1, p)) % p;\n    }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp9wzyiiez: /tmp/tmp9wzyiiez.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long a=1;\n    long b=2;\n    long exp=n;\n\
    \    while(exp>0) {\n        if(exp%2==1) {\n            a=(a*b)%p;\n        }\n\
    \        b=(b*b)%p;\n        exp/=2;\n    }\n    return a;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n\
    \    long r = modp(n / 2, p);\n    return r * r % p;\n  }\n  return n * modp(n\
    \ - 1, p) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmbu7fagj: /tmp/tmpmbu7fagj.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // this is based on Fermat's little theorem,\
    \ if p is prime then for\n    // any a modp(a, p) = a\n    assert(n >= 0);\n \
    \   assert(p > 0);\n    if (n == 0) {\n        return 1;\n    }\n    // note that\
    \ mod(a^b, p) = mod(a, p)^b mod(p)\n    if (n % 2 == 0) {\n        long half =\
    \ modp(n / 2, p);\n        return (half * half) % p;\n    } else {\n        return\
    \ (modp(n - 1, p) * n) % p;\n    }\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcji79phz: /tmp/tmpcji79phz.cpp:33: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n % 2 == 0) {\n        long tmp = modp(n / 2, p);\n        return (tmp\
    \ * tmp) % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpq2cr8ugr: /tmp/tmpq2cr8ugr.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    while (n > 0) {\n     \
    \   if (n & 1) {\n            r = (r * 2) % p;\n        }\n        n >>= 1;\n\
    \    }\n    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1ywcei0q: /tmp/tmp1ywcei0q.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  // Return 1 if n = 0 or p = 1.\n    if (n == 0 || p == 1) return 1;\n    //\
    \ If n is even then even modulo even is even.\n    if (n % 2 == 0) return modp(n/2,\
    \ p) * modp(n/2, p) % p;\n    // If n is odd then halve the exponent and multiply.\n\
    \    return modp(n/2, p) * modp(n/2, p) * n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkaibhtcs: /tmp/tmpkaibhtcs.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  for (int i = 0; i < n; i++)\
    \ {\n    res = (res*2) % p;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n % 2 == 1) {\n            res = (res * n) % p;\n        }\n       \
    \ n = n / 2;\n        n = (n * n) % p;\n    }\n    return res % p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p > 0);\n\tif (n == 0)\n\t\treturn\
    \ 1;\n\tif (n == 1)\n\t\treturn n % p;\n\tlong t = modp(n / 2, p);\n\tlong res\
    \ = (t * t) % p;\n\tif (n % 2)\n\t\tres = (res * 2) % p;\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpjkts3xll: /tmp/tmpjkts3xll.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong res = 1;\n\twhile (n > 0) {\n\t\tif (n\
    \ & 1)\n\t\t\tres = (res * n) % p;\n\t\tn = n >> 1;\n\t\tn = (n * n) % p;\n\t\
    }\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long a = 1;\n    long b = 2;\n    for (;\
    \ n > 0; n >>= 1) {\n        if (n & 1) {\n            a = (a * b) % p;\n    \
    \    }\n        b = (b * b) % p;\n    }\n    return a;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong r = 1;\n\twhile (n > 0) {\n\t\tif (n\
    \ & 1) {\n\t\t\tr = (r * 2) % p;\n\t\t}\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpe__o8c9e: /tmp/tmpe__o8c9e.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int c = 1;\n    while (n > 0) {\n      \
    \  if (n & 1) {\n            c = (c * n) % p;\n        }\n        n >>= 1;\n \
    \   }\n    return c;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpc4nov69n: /tmp/tmpc4nov69n.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n\
    \ / 2, p);\n    x = (x * x) % p;\n    if (n % 2 == 1) x = (x * 2) % p;\n    return\
    \ x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n == 0) {\n    \
    \    return 1;\n    } else if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p;\n    } else {\n        return modp(n/2, p) * modp(n/2, p) * n % p;\n\
    \    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptvthsewt: /tmp/tmptvthsewt.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    for (int i = 0; i < n;\
    \ i++) {\n        r = (r * 2) % p;\n    }\n    return r;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1) {\n      r = (r * 2) % p;\n    }\n    n = n / 2;\n    if (n > 0) {\n\
    \      r = (r * r) % p;\n    }\n  }\n  return r;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphnjbn59g: /tmp/tmphnjbn59g.cpp:30: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong r = 1;\n\tlong x = n % p;\n\tif (x==0)\n\
    \t\treturn 1;\n\twhile (n > 0) {\n\t\tif (n % 2 != 0) {\n\t\t\tr = (r * x) % p;\n\
    \t\t}\n\t\tx = (x * x) % p;\n\t\tn = n / 2;\n\t}\n\treturn r;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpb98dmbz0: /tmp/tmpb98dmbz0.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long ans = modp(n\
    \ >> 1, p);\n    ans = (ans * ans) % p;\n    if (n & 1)\n        ans = (ans *\
    \ 2) % p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long z = modp(n/2, p);\n        return (z*z) % p;\n    } else\
    \ {\n        return (n*modp(n-1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsw0a0rr3: /tmp/tmpsw0a0rr3.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  for (long i = 1; i <= n;\
    \ i++) {\n    res = (res * 2) % p;\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // The negative powers of two mod p are the\
    \ same as the positive powers.\n  if (n < 0) {\n    n = -n;\n  }\n  // Simple\
    \ cases.\n  if (n == 0) {\n    return 1;\n  }\n  if (n == 1) {\n    return 2 %\
    \ p;\n  }\n  // Find the highest order bit of n.\n  long highest = 0;\n  long\
    \ p2 = 1;\n  while (p2 <= n) {\n    p2 <<= 1;\n    highest++;\n  }\n  p2 >>= 1;\n\
    \  highest--;\n  // Start the exponentiation.\n  long v = 2;\n  // Combine the\
    \ lower order bits of n.\n  long pow2 = 0;\n  long mask = 1;\n  for (long i =\
    \ 0; i < highest; i++) {\n    if (n & mask) {\n      pow2 += 1 << i;\n    }\n\
    \    mask <<= 1;\n  }\n  pow2 = modp(pow2, p);\n  v = (v * pow2) % p;\n  // Combine\
    \ the higher order bits of n.\n  while (p2 > 1) {\n    p2 >>= 1;\n    pow2 = (pow2\
    \ * pow2) % p;\n    if (n & p2) {\n      v = (v * pow2) % p;\n    }\n  }\n  return\
    \ v;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8q23mdff: /tmp/tmp8q23mdff.cpp:60: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // return (1 if n == 0 else pow(2, n, p))\n\
    \    if (n == 0) return 1;\n    assert(n > 0);\n    long result = 1;\n    long\
    \ power = 2;\n    while (n > 0) {\n        if (n & 1) result = (result * power)\
    \ % p;\n        power = (power * power) % p;\n        n >>= 1;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong res = 1;\n\tlong sq = n;\n\twhile (p\
    \ > 0) {\n\t\tif (p % 2 != 0) {\n\t\t\tres = (res * sq) % p;\n\t\t}\n\t\tsq =\
    \ (sq * sq) % p;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptvqvlr05: /tmp/tmptvqvlr05.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n & 1) {\n            res = (res * n) % p;\n        }\n        n = n\
    \ >> 1;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    if (n == 0) return\
    \ 1;\n    long m = modp(n/2, p);\n    if (n % 2 == 0) {\n        return (m*m)\
    \ % p;\n    } else {\n        return (2*m*m) % p;\n    }\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n/2,\
    \ p);\n    x = (x * x) % p;\n    if (n % 2 == 1) x = (x * 2) % p;\n    return\
    \ x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// Implement this function as described in\
    \ the handout, and then delete this comment.\n\t// Do not return any other value,\
    \ and do not change the type of the return value.\n\tif (n == 0)\n\t\treturn 1;\n\
    \tlong y = modp(n / 2, p);\n\tif (n % 2 == 0)\n\t\treturn (y * y) % p;\n\telse\n\
    \t\treturn (y * y * n) % p;\n}\nint main() {\n    auto candidate = modp;\n   \
    \ assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_eqm0wrv: /tmp/tmp_eqm0wrv.cpp:28: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long result =\
    \ 1;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result\
    \ * 10) % p;\n        }\n        n = n / 2;\n        if (n > 0) {\n          \
    \  p = (p * p) % p;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long pow2 = 1;\n    long result = 1;\n \
    \   while (n > 0) {\n        if (n % 2 == 1)\n            result = (result * pow2)\
    \ % p;\n        pow2 = (pow2 * pow2) % p;\n        n /= 2;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpji84mc4i: /tmp/tmpji84mc4i.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    n %= p;\n    while (n\
    \ > 0) {\n        if (n & 1) {\n            res = (res * n) % p;\n        }\n\
    \        n = n >> 1;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\t// Find\
    \ base 2 logarithm of n.\n\tint logn = 0;\n\tfor (long t = n; t; t /= 2)\n\t\t\
    logn++;\n\t// Build table of modp(2^i, p).\n\tlong m[logn];\n\tm[0] = 1;\n\tfor\
    \ (int i = 1; i < logn; i++)\n\t\tm[i] = (m[i - 1] * 2) % p;\n\t// Return modp(n,\
    \ p).\n\tlong result = 1;\n\tfor (int i = 0; n; i++, n /= 2)\n\t\tif (n % 2)\n\
    \t\t\tresult = (result * m[i]) % p;\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6o4h82t1: /tmp/tmp6o4h82t1.cpp:35: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n < 0) {\n\t\tn = n % p + p;\n\t}\n\t\
    long r = 1;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tr = (r * 3) % p;\n\
    \t\t}\n\t\tn /= 2;\n\t\tif (n > 0) {\n\t\t\tr = (r * r) % p;\n\t\t}\n\t}\n\treturn\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5ye5lbu3: /tmp/tmp5ye5lbu3.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2, p) % p;\n    }\n\
    \    return modp(n/2, p) * modp(n/2, p) * n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpnhs2v_ic: /tmp/tmpnhs2v_ic.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n & 1) {\n            res = (res * n) % p;\n        }\n        n = n\
    \ >> 1;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) n = p - ((-n)\
    \ % p);\n  if (n >= p) n %= p;\n  assert(n >= 0);\n  return n;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpyn0uqlko: /tmp/tmpyn0uqlko.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Initially x == 1 (mod p).\n  long x = 1;\n\
    \  while (n > 0) {\n    // Invariant: x == 1 (mod p).\n    if (n % 2 != 0) {\n\
    \      // If n is odd, multiply x with a (mod p).\n      x = (x * 3) % p;\n  \
    \  }\n    // Now n is even.\n    n = n / 2;\n    // Keep x == 1 (mod p).\n   \
    \ if (n > 0) {\n      x = (x * x) % p;\n    }\n  }\n  return x;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp13r67n3d: /tmp/tmp13r67n3d.cpp:34: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n < 0) {\n\t\tprintf(\"Error: n must be\
    \ positive.\\n\");\n\t\texit(1);\n\t}\n\tif (p <= 0) {\n\t\tprintf(\"Error: p\
    \ must be a positive prime.\\n\");\n\t\texit(1);\n\t}\n\tlong res = 1;\n\twhile\
    \ (n > 0) {\n\t\tif (n % 2 == 1)\n\t\t\tres = (res * 2) % p;\n\t\tn /= 2;\n\t\
    }\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptqm37nop: /tmp/tmptqm37nop.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n % 2 == 0) {\n        long half = modp(n / 2, p);\n        return\
    \ (half * half) % p;\n    } else {\n        return (2 * modp(n - 1, p)) % p;\n\
    \    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    // return (n < p) ?\
    \ n : (modp(n / 2, p) * 2) % p;\n    if (n < p) return n;\n    else return (modp(n\
    \ / 2, p) * 2) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp35jj__ck: /tmp/tmp35jj__ck.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long result = 1;\n  for (long i = 1; i <=\
    \ n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n % p;\n    long x = modp(n/2, p);\n    long y = x*x % p;\n    if (n % 2 ==\
    \ 1) y = y*n % p;\n    return y;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpn1s6cyk2: /tmp/tmpn1s6cyk2.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  long t = modp(n/2,\
    \ p);\n  if (n % 2 == 0) return (t*t) % p;\n  else return (t*t*2) % p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n == 0) return 1;\n\
    \    if (n % 2 == 0) {\n        long r = modp(n / 2, p);\n        return (r *\
    \ r) % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpnmfou0p1: /tmp/tmpnmfou0p1.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        long r = modp(n / 2, p);\n        return r * r\
    \ % p;\n    }\n    return modp(n - 1, p) * n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7b6s6rc9: /tmp/tmp7b6s6rc9.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    else if (n == 1) {\n        return n;\n    }\n    else {\n        long result\
    \ = 1;\n        long x = n;\n        while (p > 0) {\n            if (p & 1) {\n\
    \                result = (result * x) % n;\n            }\n            x = (x\
    \ * x) % n;\n            p >>= 1;\n        }\n        return result;\n    }\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpeltumkf1: /tmp/tmpeltumkf1.cpp:36: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) {\n        return 1;\n    }\n    long r = modp(n/2, p);\n    r\
    \ = (r*r) % p;\n    if (n % 2 == 1) {\n        r = (r*2) % p;\n    }\n    return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n == 0) return 1;\n    else if(n % 2\
    \ == 0) {\n        long r = modp(n/2, p);\n        return (r*r) % p;\n    } else\
    \ {\n        return (modp(n-1, p) * 2) % p;\n    }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n == 0) {\n    \
    \    return 1;\n    }\n    else if (n == 1) {\n        return n;\n    }\n    long\
    \ q = modp(n/2, p);\n    long result = q*q % p;\n    if (n % 2 != 0) {\n     \
    \   result = result * n % p;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpk711ffke: /tmp/tmpk711ffke.cpp:32: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1;\n    long x = n % p;\n   \
    \ while (n > 0) {\n        if (n % 2 == 1) {\n            ans = (ans * x) % p;\n\
    \        }\n        x = (x * x) % p;\n        n = n / 2;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmt4paou2: /tmp/tmpmt4paou2.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int i;\n    long a = 1;\n    for (i = 0;\
    \ i < n; i++) {\n        a = a*2 % p;\n    }\n    return a;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long a = 1;\n  long b = 2;\n  while (n) {\n\
    \    if (n % 2) {\n      a = (a * b) % p;\n    }\n    b = (b * b) % p;\n    n\
    \ /= 2;\n  }\n  return a;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n == 1) {\n        return 2 % p;\n    } else if (n % 2 == 0) {\n  \
    \      long k = modp(n / 2, p);\n        return k * k % p;\n    } else {\n   \
    \     long k = modp(n - 1, p);\n        return k * 2 % p;\n    }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  while (n > 0) {\n    if (n\
    \ & 1)\n      res = (res * 2) % p;\n    n = n >> 1;\n  }\n  return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp615xfzy9: /tmp/tmp615xfzy9.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        long t = modp(n / 2, p);\n        return (t *\
    \ t) % p;\n    }\n    return (modp(n - 1, p) * n) % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptzbkdeo4: /tmp/tmptzbkdeo4.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long res = modp(n/2, p);\n        return (res * res) % p;\n  \
    \  }\n    else return (modp(n-1, p) * (n % p)) % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprsz6jz86: /tmp/tmprsz6jz86.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        n = (p - (-n % p))\
    \ % p;\n    }\n    long res = 1;\n    long base = 2;\n    for (; n > 0; n /= 2)\
    \ {\n        if (n % 2 == 1) {\n            res = (res * base) % p;\n        }\n\
    \        base = (base * base) % p;\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // We need a long type because we need to\
    \ hold the result of pow (which may\n  // exceed the boundaries of int).\n  //\
    \ If n is 0, the result should be 1.\n  if (n == 0) {\n    return 1;\n  }\n  long\
    \ res = 1;\n  long pow_mod = 1;\n  long pow_mod_prev = 1;\n  while (n > 0) {\n\
    \    long bit = n & 1;\n    if (bit == 1) {\n      pow_mod = (pow_mod * pow_mod_prev)\
    \ % p;\n      res = (res * pow_mod) % p;\n    }\n    n >>= 1;\n    pow_mod_prev\
    \ = (pow_mod_prev * pow_mod_prev) % p;\n  }\n  return res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7yo0ye4o: /tmp/tmp7yo0ye4o.cpp:37: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  for (int i = 1; i <= n; i++)\
    \ {\n    res = (res * 2) % p;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  n %= p;\n  if (n < 0) n\
    \ += p;\n  if (n < 0) n += p;\n  assert(n >= 0 && n < p);\n  if (n == 0) return\
    \ 1;\n  long q = modp(n >> 1, p);\n  if (n & 1) return (q + q * q) % p;\n  return\
    \ (q + q) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpo0wrf6f3: /tmp/tmpo0wrf6f3.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long m = modp(n\
    \ / 2, p);\n    m = (m * m) % p;\n    if (n % 2 == 1) m = (m * 2) % p;\n    return\
    \ m;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n <= 1) return n;\n    long res = 1;\n\
    \    for (long b = n; b > 0; b >>= 1) {\n        if (b & 1) res = (res * n) %\
    \ p;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpae3m5grh: /tmp/tmpae3m5grh.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// Return n modulo p.\n\treturn n % p;\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7rkt3yh4: /tmp/tmp7rkt3yh4.cpp:21: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  assert(n != 0);\n  assert(p\
    \ != 1);\n  long result = 1;\n  while (n > 0) {\n    if (n & 1) {\n      result\
    \ = (result * (long)result) % p;\n    }\n    n >>= 1;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbw4e_jwk: /tmp/tmpbw4e_jwk.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n\n  long m = 1;\n  for (long\
    \ i = 1; i <= n; i++) {\n    m = (m * 2) % p;\n  }\n  return m;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong a = 1;\n\tlong b = 2;\n\twhile (n > 0)\
    \ {\n\t\tif (n % 2 == 1) {\n\t\t\ta = (a * b) % p;\n\t\t}\n\t\tb = (b * b) % p;\n\
    \t\tn = n / 2;\n\t}\n\treturn a;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n < 0 || p < 0) return modp(n % p + p,\
    \ p);\n    if(!n) return 1;\n    if(n % 2) return (2 * modp(n - 1, p)) % p;\n\
    \    return modp(n / 2, p) * modp(n / 2, p) % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong ans = modp(n\
    \ / 2, p);\n\tans = (ans * ans) % p;\n\tif (n % 2 == 1) ans = (ans * 2) % p;\n\
    \treturn ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n) {\n       \
    \ if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpuj63h09o: /tmp/tmpuj63h09o.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    else if (n == 1) {\n        return n % p;\n    }\n    else {\n        long\
    \ k = modp(n / 2, p);\n        if (n % 2 == 0) {\n            return (k * k) %\
    \ p;\n        }\n        else {\n            return (((k * k) % p) * n) % p;\n\
    \        }\n    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkm0drpla: /tmp/tmpkm0drpla.cpp:34: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n\
    \ / 2, p);\n    long v = x * x % p;\n    if (n % 2) {\n        v = v * 2 % p;\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long r = modp(n\
    \ / 2, p);\n    r = (r * r) % p;\n    if (n % 2 == 1) r = (r * 2) % p;\n    return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        return modp(-n, p);\n\
    \    }\n    assert(n >= 0);\n    long res = 1;\n    while (n) {\n        if (n\
    \ & 1) {\n            res = (res * 2) % p;\n        }\n        n >>= 1;\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpg6d6qdyd: /tmp/tmpg6d6qdyd.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     res = (res * (n % 2 ? p : 1)) % p;\n        n >>= 1;\n        p = (p * p)\
    \ % MOD;\n    }\n    return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprb482b5v.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmprb482b5v.cpp:19:23: error: \u2018MOD\u2019 was not declared in this\
    \ scope\n   19 |         p = (p * p) % MOD;\n      |                       ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1 % p;\n    while (n > 0) {\n\
    \        if (n & 1) res = (res * 2) % p;\n        n >>= 1;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4wysoxga: /tmp/tmp4wysoxga.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // Fill this in.\n    return pow(2,n)%p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfwh7a9gu.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpfwh7a9gu.cpp:16:20: error: invalid operands of types \u2018double\u2019\
    \ and \u2018long int\u2019 to binary \u2018operator%\u2019\n   16 |     return\
    \ pow(2,n)%p;\n      |            ~~~~~~~~^~\n      |               |     |\n\
    \      |               |     long int\n      |               double\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long res = modp(n\
    \ / 2, p);\n    res = (res * res) % p;\n    if (n % 2 == 1) res = (res * 2) %\
    \ p;\n    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Base case: n = 0\n  if (n == 0) return\
    \ 1;\n  // Check for even values of n.\n  if (n % 2 == 0) {\n    // Compute (2^n)^2\
    \ and then reduce that modulo p\n    long b = modp(n / 2, p);\n    return (b *\
    \ b) % p;\n  } else {\n    // Compute (2^n - 1)^2 and then reduce that modulo\
    \ p\n    long a = modp(n - 1, p);\n    return (2 * a * a) % p;\n  }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvcn_pnte: /tmp/tmpvcn_pnte.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// assert(p > 0);\n\tif (n == 0) return 1;\n\
    \tlong x = modp(n/2, p);\n\tx = (x*x) % p;\n\tif (n % 2 == 1) x = (x*2) % p;\n\
    \treturn x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long mask = 1;\n    while(mask <= n) {\n\
    \        mask = mask << 1;\n    }\n    mask = mask >> 1;\n    long res = 1;\n\
    \    while(mask > 0) {\n        if (n & mask) {\n            res = (res * res)\
    \ % p;\n        } else {\n            res = (res * res * 2) % p;\n        }\n\
    \        mask = mask >> 1;\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpzke6m3ob: /tmp/tmpzke6m3ob.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n) {\n    if (n % 2)\
    \ {\n      r = (r * 2) % p;\n    }\n    n /= 2;\n  }\n  return r;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6q8d8xj5: /tmp/tmp6q8d8xj5.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    for (int i = 0; i\
    \ < n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long q = (long) (((double) n) / p);\n  long\
    \ r = n - q * p;\n  if (r < 0)\n    r += p;\n  return r;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpdwwbktnh: /tmp/tmpdwwbktnh.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t} else if\
    \ (n % 2 == 0) {\n\t\tlong t = modp(n / 2, p);\n\t\treturn (t * t) % p;\n\t} else\
    \ {\n\t\treturn (modp(n - 1, p) * n) % p;\n\t}\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1kiy3tl7: /tmp/tmp1kiy3tl7.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    for (int i = 0; i < n;\
    \ i++) {\n        r = (r * 2) % p;\n    }\n    return r;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  else if (n == 1)\
    \ return n % p;\n  else {\n    long x = modp(n / 2, p);\n    long x2 = (x * x)\
    \ % p;\n    if (n % 2 == 0) return x2;\n    else return (x2 * n) % p;\n  }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpms21pl2p: /tmp/tmpms21pl2p.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long\
    \ tmp = modp(n / 2, p);\n        return (tmp * tmp) % p;\n    } else {\n     \
    \   return ((n % p) * modp(n - 1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfcizld8f: /tmp/tmpfcizld8f.cpp:30: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n;\n    long pow;\n    pow = modp(n/2, p);\n    pow = (pow * pow) % p;\n   \
    \ if (n & 1) {\n        pow = (pow * n) % p;\n    }\n    return pow;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgi41kx41: /tmp/tmpgi41kx41.cpp:28: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long t = modp(n/2, p);\n        return (t*t) % p;\n    }\n   \
    \ return ((n % p) * modp(n-1, p)) % p;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpabi81h6p: /tmp/tmpabi81h6p.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n\
    \ % 2 == 0) {\n\t\treturn modp(n / 2, p) * modp(n / 2, p) % p;\n\t}\n\treturn\
    \ modp(n - 1, p) * 2 % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n == 0) {\n    return 1;\n  }\n  long r\
    \ = modp(n/2, p);\n  r = r*r % p;\n  if(n%2) {\n    r = r*2 % p;\n  }\n  return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\tlong\
    \ res = 1;\n\tlong cur = n;\n\twhile (p > 0) {\n\t\tif (p % 2 == 1)\n\t\t\tres\
    \ = (res * cur) % p;\n\t\tcur = (cur * cur) % p;\n\t\tp = p / 2;\n\t}\n\treturn\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvjlmgjyb: /tmp/tmpvjlmgjyb.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n < 0) { n = n % p + p; }\n  if (n < 2)\
    \ { return n; }\n  long tmp = modp(n / 2, p);\n  if (n % 2 == 0) { return (tmp\
    \ * tmp) % p; }\n  else { return (tmp * tmp * 2) % p; }\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpz287b94b: /tmp/tmpz287b94b.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long num = 1;\n    long x = n % p;\n   \
    \ while (n > 0) {\n        if (n % 2 == 1) {\n            num = (num * x) % p;\n\
    \        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    return num;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpntpdw8b3: /tmp/tmpntpdw8b3.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\tif (n\
    \ == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tlong v = modp(n / 2, p);\n\t\treturn\
    \ (v * v) % p;\n\t}\n\treturn (2 * modp(n - 1, p)) % p;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n < p) {\n    return n;\n  }\n  if (n\
    \ == p) {\n    return 0;\n  }\n  long x = 1;\n  while (n > 0) {\n    if (n & 1)\
    \ {\n      x = (x * 2) % p;\n    }\n    n >>= 1;\n    if (n == 0) {\n      break;\n\
    \    }\n    if (x < p - x) {\n      x = (x * 2) % p;\n    } else {\n      x =\
    \ ((x * 2) % p - p) % p;\n    }\n  }\n  return x;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpm95w1vmy: /tmp/tmpm95w1vmy.cpp:41: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1) {\n      r = (r * 2) % p;\n    }\n    n = n / 2;\n    p = (p * p)\
    \ % p;\n  }\n  return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  assert(p <= LONG_MAX / 2);\n    int result = 1;\n    for (int i = 1; i <= n;\
    \ i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
