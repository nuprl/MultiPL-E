name: HumanEval_49_modp
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n==0) return 1;\n    long result = modp(n/2,\
    \ p);\n    result = (result*result)%p;\n    if (n&1) result = (result*2)%p;\n\
    \    return result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // TODO: Implement me!\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpj1jkq4rb: /tmp/tmpj1jkq4rb.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long\
    \ t = modp(n / 2, p);\n        return (t * t) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvxcifr5m: /tmp/tmpvxcifr5m.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  assert(n < p);\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long\
    \ tmp = modp(n / 2, p);\n        return (tmp * tmp) % p;\n    } else {\n     \
    \   return (2 * modp(n - 1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmps21ce65k: /tmp/tmps21ce65k.cpp:17: long int modp(long int, long int):\
    \ Assertion `n < p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n < 0)\n       \
    \ n += p;\n    long result = 1;\n    while (n > 0) {\n        if (n & 1)\n   \
    \         result = (result * n) % p;\n        n >>= 1;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptwdaa5h5: /tmp/tmptwdaa5h5.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    else if (n ==\
    \ 1) return n % p;\n    else if (n % 2 == 0) {\n        // Square modulo n/2 (the\
    \ latter can be computed using bit shift)\n        long half = modp(n / 2, p);\n\
    \        return (half * half) % p;\n    } else {\n        // n-1 is even, n-1\
    \ = n - 1\n        long half = modp(n - 1, p);\n        return (half * n) % p;\n\
    \    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqo9eynic: /tmp/tmpqo9eynic.cpp:30: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n <= 1) {\n        return n;\n    }\n\
    \    if (n % 2 == 0) {\n        return (long) pow(modp(n / 2, p), 2) % p;\n  \
    \  }\n    return (long) (modp(n - 1, p) * n) % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkd9pxn6p: /tmp/tmpkd9pxn6p.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  long res = 1;\n    for (int i = 1; i <= n; i++)\n        res = (res * 2) %\
    \ p;\n    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    assert(p > 0);\n\
    \    long res = modp(n/2, p);\n    if (n % 2 == 0)\n        return res * res %\
    \ p;\n    else\n        return (res * res % p) * n % p;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkel9olf4: /tmp/tmpkel9olf4.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long c = 1;\n    for (long i = 0; i < n;\
    \ i++) {\n        c = c * 2 % p;\n    }\n    return c;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong r = modp(n /\
    \ 2, p);\n\tr = (r * r) % p;\n\tif (n % 2 == 1) r = (r * 2) % p;\n\treturn r;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        return modp(-n, p);\n\
    \    }\n    long r = 1;\n    while (n > 0) {\n        if (n % 2 != 0) {\n    \
    \        r = (r * 2) % p;\n        }\n        n /= 2;\n        // this is 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\
    \ 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpki5_12y1.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpki5_12y1.cpp:26:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   26 | int main() {\n      |            ^\n/tmp/tmpki5_12y1.cpp:35:1:\
    \ error: expected \u2018}\u2019 at end of input\n   35 | }\n      | ^\n/tmp/tmpki5_12y1.cpp:14:27:\
    \ note: to match this \u2018{\u2019\n   14 | long modp(long n, long p) {\n   \
    \   |                           ^\n/tmp/tmpki5_12y1.cpp:35:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   35 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long y = 1;\n    long x = n;\n    while\
    \ (p > 0) {\n        if (p % 2 == 1) {\n            y = (y * x) % p;\n       \
    \ }\n        x = (x * x) % p;\n        p = p / 2;\n    }\n    return y % p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // assert(p > 1);  // p < 2 is not a prime.\n\
    \    long r = 1;\n    while (n) {\n        if (n & 1) {\n            r = (r *\
    \ 2) % p;\n        }\n        n /= 2;\n        long d = 2 % p;\n        if (d\
    \ == 0) {\n            return 0;\n        }\n        d = (d * d) % p;\n    }\n\
    \    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpa87ey4ud: /tmp/tmpa87ey4ud.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        n += (1 - n/p) * p;\n\
    \    }\n    return n % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpoydfhgla: /tmp/tmpoydfhgla.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 1);\n    if (n == 0) return\
    \ 1;\n    long r = n;\n    if (r < 0) r += p;\n    long ans = 1;\n    while (n\
    \ > 0) {\n        if (n & 1) ans = (ans * r) % p;\n        n >>= 1;\n        r\
    \ = (r * r) % p;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpltj0_dog: /tmp/tmpltj0_dog.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long res = modp(n\
    \ >> 1, p);\n    res = (res * res) % p;\n    if (n & 1) res = (res * 2) % p;\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) {\n    n = (n\
    \ % p) + p;\n  }\n  long result = 1;\n  long power = n;\n  long b = 2;\n  while\
    \ (b <= power) {\n    if (power & b) {\n      result = (result * n) % p;\n   \
    \   power -= b;\n    }\n    n = (n * n) % p;\n    b = b << 1;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphexb1vvu: /tmp/tmphexb1vvu.cpp:35: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n==0) return 1;\n    assert(n<p);\n\
    \    long half = modp(n/2, p);\n    if (n%2==0) {\n        return (half*half)%p;\n\
    \    } else {\n        return (half*half*n)%p;\n    }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvn9b1gze: /tmp/tmpvn9b1gze.cpp:16: long int modp(long int, long int):\
    \ Assertion `n<p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n>=0);\n\tassert(p>=2);\n\tlong a =\
    \ 1;\n\tlong b = 2;\n\twhile (n>0) {\n\t\tif (n%2 == 1) {\n\t\t\ta = (a*b)%p;\n\
    \t\t}\n\t\tn /= 2;\n\t\tb = (b*b)%p;\n\t}\n\treturn a;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n// assert(n >= 0);\n// assert(p > 0);\nif (n\
    \ == 0) return 1;\nif (n % 2 == 0) {\nlong tmp = modp(n/2, p);\nreturn (tmp *\
    \ tmp) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb6brfldw.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpb6brfldw.cpp:22:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   22 | int main() {\n      |            ^\n/tmp/tmpb6brfldw.cpp:31:1:\
    \ error: expected \u2018}\u2019 at end of input\n   31 | }\n      | ^\n/tmp/tmpb6brfldw.cpp:14:27:\
    \ note: to match this \u2018{\u2019\n   14 | long modp(long n, long p) {\n   \
    \   |                           ^\n/tmp/tmpb6brfldw.cpp:31:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   31 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  long ans = 1;\n    for (long i = 1; i <= n; i++)\n        ans = (ans * 2) %\
    \ p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1)\n      r = (r * 2) % p;\n    n = n / 2;\n  }\n  return r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpr15gdpvy: /tmp/tmpr15gdpvy.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0)\n        return modp(-n, p);\n\
    \    if (n < p)\n        return n;\n    if (n % 2 == 0)\n        return (modp(n\
    \ / 2, p) * modp(n / 2, p)) % p;\n    else\n        return (modp(n / 2, p) * modp(n\
    \ / 2, p) * 2) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpl5uspbd7: /tmp/tmpl5uspbd7.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n % p;\n    if (n % 2 == 0) return modp(n / 2, p) * modp(n / 2, p) % p;\n  \
    \  return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpffyfg118: /tmp/tmpffyfg118.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) return 1;\n    long pow = 2;\n    long val = 1;\n    long p2 =\
    \ p * p;\n    while (pow <= n) {\n        if (n & pow) {\n            val = (val\
    \ * pow) % p2;\n        }\n        pow = pow << 1;\n    }\n    val = (val * p)\
    \ % p2;\n    return val;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptckgue7d: /tmp/tmptckgue7d.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    for (long i = 1; i\
    \ <= n; i++) {\n        result = result * 2 % p;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  for (; n > 0; n >>= 1) {\n\
    \    if (n & 1) {\n      r = (r * 2) % p;\n    }\n  }\n  return r;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2sr0oai7: /tmp/tmp2sr0oai7.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    for (long i = 0; i <\
    \ n; i++) {\n        res = (res * 2) % p;\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    n %= p;\n    if (n <= 1) return n;\n   \
    \ long ret = 1;\n    for (long i = 1; i <= n; i++)\n        ret = (ret * 2) %\
    \ p;\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7alag_sb: /tmp/tmp7alag_sb.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    n %= p;\n    if (n < 0) n += p;\n    return\
    \ n;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpd_xz24_o: /tmp/tmpd_xz24_o.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  long ans = 1;\n    long pow = n;\n    while (p > 0) {\n        if (p % 2 ==\
    \ 1) {\n            ans = (ans * pow) % p;\n        }\n        pow = (pow * pow)\
    \ % p;\n        p = p / 2;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4jdndern: /tmp/tmp4jdndern.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n\
    \    long t = modp(n / 2, p);\n    return (t * t) % p;\n  }\n  return (modp(n\
    \ - 1, p) * n) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpo1jsw_mj: /tmp/tmpo1jsw_mj.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 1);\n\tlong long x = 1;\n\tfor\
    \ (; n > 0; n >>= 1) {\n\t\tif (n & 1) {\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\t\
    x = (x * x) % p;\n\t}\n\treturn x;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpdvucy14v: /tmp/tmpdvucy14v.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n==0) return 1;\n    assert(n<p);\n \
    \   if(n<0) n+=p;\n    std::vector<bool> bits;\n    while(n>0) {\n        bits.push_back(n%2);\n\
    \        n/=2;\n    }\n    long res=1;\n    for(int i=bits.size()-1; i>=0; i--)\
    \ {\n        res=res*res%p;\n        if(bits[i]) res=res*2%p;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8xpeotd1: /tmp/tmp8xpeotd1.cpp:16: long int modp(long int, long int):\
    \ Assertion `n<p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  if (n\
    \ < p) {\n    return n;\n  }\n  long x = 1;\n  while (n > 0) {\n    if (n % 2\
    \ == 1) {\n      x = (x * 2) % p;\n    }\n    n /= 2;\n    if (n > 0) {\n    \
    \  x = (x * x) % p;\n    }\n  }\n  return x;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpx_yoz2qj: /tmp/tmpx_yoz2qj.cpp:35: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\telse if (n % 2 ==\
    \ 0) {\n\t\tlong half = modp(n / 2, p);\n\t\treturn (half * half) % p;\n\t}\n\t\
    else {\n\t\treturn (modp(n - 1, p) * n) % p;\n\t}\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpruruauek: /tmp/tmpruruauek.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  // If\
    \ p is even, 2^n mod p = (2 mod p)^n mod p\n  if (p % 2 == 0) {\n    return modp(n,\
    \ p/2) * modp(n, p/2) % p;\n  }\n  // If n is even, 2^n mod p = (2^(n/2) mod p)^2\
    \ mod p\n  if (n % 2 == 0) {\n    return modp(n/2, p) * modp(n/2, p) % p;\n  }\n\
    \  // If n is odd, 2^n mod p = 2 * (2^(n-1) mod p) mod p\n  return 2 * modp(n-1,\
    \ p) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tif (n == 1) return\
    \ n % p;\n\tassert(p < (1 << 30));\n\tlong res = 1;\n\t// This is more efficient\
    \ than n % p.\n\tlong exp = n % (p - 1);\n\tlong base = n % p;\n\twhile (exp)\
    \ {\n\t\tif (exp & 1) res = (res * base) % p;\n\t\tbase = (base * base) % p;\n\
    \t\texp >>= 1;\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpo4xjl3na: /tmp/tmpo4xjl3na.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 2);\n    if (n < p) return n;\n\
    \    long pow_2_modp = 2;\n    long result = pow_2_modp;\n    long pow_2 = 4;\n\
    \    while (n >= pow_2) {\n        if (n & pow_2) {\n            result = (result\
    \ * pow_2_modp) % p;\n            n -= pow_2;\n        }\n        pow_2_modp =\
    \ (pow_2_modp * pow_2_modp) % p;\n        pow_2 *= 2;\n    }\n    result = (result\
    \ * modp(n, p)) % p;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmqd81qv7: /tmp/tmpmqd81qv7.cpp:34: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n==0) return 1;\n\tlong n_half = modp(n/2,\
    \ p);\n\tlong n_half_sq = (n_half*n_half)%p;\n\tlong ret = n%2==0 ? n_half_sq\
    \ : (n_half_sq*2)%p;\n\tif (ret<0) ret += p;\n\treturn ret;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  if (n\
    \ == 0) return 1;\n  long q = modp(n / 2, p);\n  return n % 2 == 0 ? (q * q) %\
    \ p : (q * q * 2) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n & 1)\n            res = (res * 2) % p;\n        n = n >> 1;\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpl6iwetk6: /tmp/tmpl6iwetk6.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n==0)\n    return 1;\n  long t = modp(n/2,\
    \ p);\n  if(n%2==0)\n    return (t*t)%p;\n  else\n    return (t*t*2)%p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) n = n % p + p;\n    if (n ==\
    \ 0) return 1;\n    if (n == 1) return n;\n    long ret = modp(n / 2, p);\n  \
    \  ret = (ret * ret) % p;\n    if (n % 2 == 1) ret = (ret * n) % p;\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp71vweh0n: /tmp/tmp71vweh0n.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n==0) return 1;\n    if (n==1) return\
    \ n%p;\n    long c = modp(n/2, p);\n    if (n%2==0) return (c*c)%p;\n    else\
    \ return (c*c*n)%p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp61_ivf8j: /tmp/tmp61_ivf8j.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong r = 1;\n\twhile\
    \ (n > 0) {\n\t\tif (n & 1) r = (r * r) % p;\n\t\tn >>= 1;\n\t}\n\treturn r;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcytvyqcb: /tmp/tmpcytvyqcb.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    for (long i = 0; i\
    \ < n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long ans = modp(n/2,\
    \ p);\n    ans = (ans * ans) % p;\n    if (n % 2 == 1) ans = (ans * 2) % p;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        return modp(-n, p);\n\
    \    }\n    long res = 1;\n    long b = 2;\n    while (n > 0) {\n        if (n\
    \ % 2 == 1) {\n            res = (res * b) % p;\n        }\n        n /= 2;\n\
    \        b = (b * b) % p;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1)\n      r = (r * 2) % p;\n    n = n / 2;\n  }\n  return r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpv5syluek: /tmp/tmpv5syluek.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  if (n == 0) return 1;\n    if (n == 1) return n % p;\n    if (n % 2 == 0) {\n\
    \        return modp(n / 2, p) * modp(n / 2, p) % p;\n    } else {\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp9s_y67l6: /tmp/tmp9s_y67l6.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 2);\n\tif (n % p == 0) return\
    \ 0;\n\tif (n < p) return n;\n\tlong m = 1;\n\tfor (long a = n; a; a /= 2) {\n\
    \t\tif (a % 2) m = (m * 2) % p;\n\t\tlong b = (a + 1) / 2;\n\t\tlong t = b * b;\n\
    \t\tif (t >= p) t %= p;\n\t\tif (n >= t) n -= t;\n\t}\n\treturn m;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsvmt4q1m: /tmp/tmpsvmt4q1m.cpp:31: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) return modp((n/2)*(n/2), p);\n    return (modp(n/2, p) * modp(n/2 + 1, p))\
    \ % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long res = modp(n/2,\
    \ p);\n    res = (res * res) % p;\n    if (n % 2 == 1) res = (res * 2) % p;\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n == 0) {\n        return 1;\n    }\n\
    \    if(n == 1) {\n        return n;\n    }\n    // The below function is from\
    \ https://stackoverflow.com/questions/11440263/how-to-compute-in-modulo-p\n  \
    \  long ret = modp(n/2, p);\n    ret = (ret * ret) % p;\n    if(n%2 != 0) {\n\
    \        ret = (ret * n) % p;\n    }\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmzr2yuzb: /tmp/tmpmzr2yuzb.cpp:32: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 2);\n    if (n >= p)\n     \
    \   n %= p;\n    long c = 1;\n    while (n > 0) {\n        if (n & 1)\n      \
    \      c = (c * 2) % p;\n        n >>= 1;\n        // cout << c << ' ' << n <<\
    \ endl;\n    }\n    return c;\n}\nint main() {\n    auto candidate = modp;\n \
    \   assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxshbmq2u: /tmp/tmpxshbmq2u.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n == 1) {\n        return n % p;\n    }\n    long ans = modp(n >> 1,\
    \ p);\n    ans = (ans * ans) % p;\n    if (n & 1) {\n        ans = (ans * n) %\
    \ p;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n  \
    \  assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpackjh3vg: /tmp/tmpackjh3vg.cpp:31: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n == 1) {\n        return n;\n    } else if (n % 2 == 0) {\n      \
    \  long t = modp(n / 2, p);\n        return (t * t) % p;\n    } else {\n     \
    \   return (n * modp(n - 1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3vzcpipt: /tmp/tmp3vzcpipt.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n == 0) return 1;\n\
    \  if (n % 2 == 0) {\n    long r = modp(n / 2, p);\n    return (r * r) % p;\n\
    \  } else {\n    return (modp(n - 1, p) * n) % p;\n  }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4gaw_87w: /tmp/tmp4gaw_87w.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n\
    \ % 2 == 0) {\n\t\tlong m = modp(n / 2, p);\n\t\treturn (m * m) % p;\n\t}\n\t\
    return (2 * modp(n - 1, p)) % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < p) { return n; }\n    long r = 1;\n\
    \    for (long i = 0; i < n; i++) {\n        r = r * 2 % p;\n    }\n    return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5kuoyshv: /tmp/tmp5kuoyshv.cpp:26: int main(): Assertion `candidate((0),\
    \ (101)) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n/2,\
    \ p);\n    x = (x * x) % p;\n    if (n % 2) x = (x * 2) % p;\n    return x;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n >= p) n %= p;\n\tif (n == 0) return\
    \ 1;\n\tif (n == 1) return n;\n\tlong w = n, r = 1;\n\twhile (w > 0) {\n\t\tif\
    \ (w & 1) r = (r * n) % p;\n\t\tw >>= 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpx1bhi4un: /tmp/tmpx1bhi4un.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n <= 0) return 1;\n    long res = 1;\n\
    \    while (n > 0) {\n        if (n % 2 == 1) res = (res * 2) % p;\n        n\
    \ /= 2;\n    }\n    return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxjracona: /tmp/tmpxjracona.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 1);\n\tif (n == 0) return 1;\n\
    \tlong z = modp(n/2, p);\n\tif (n % 2 == 0) return (z*z) % p;\n\telse return (\
    \ (z*z) % p * n ) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcjysff4r: /tmp/tmpcjysff4r.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long x = 1;\n    long t = n;\n    while\
    \ (t) {\n        if (t & 1) x = (x * n) % p;\n        n = (n * n) % p;\n     \
    \   t >>= 1;\n    }\n    return x;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpshkkxudb: /tmp/tmpshkkxudb.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p > 0);\n  if (n\
    \ == 0) return 1;\n  if (n == 1) return n % p;\n  return modp(n / 2, p) * modp(n\
    \ - n / 2, p) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6lhpvn8g: /tmp/tmp6lhpvn8g.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    assert(n >= 0);\n  \
    \  // Initialize result\n    long res = 1;\n    // Update x if it is more\n  \
    \  // than or equal to p\n    long x = n;\n    while (x > 1) {\n        // If\
    \ x is odd, multiply x\n        // with result\n        if (x & 1) {\n       \
    \     res = (res * x) % p;\n        }\n        // x must be even now\n       \
    \ x = x >> 1; // x = x/2\n        x = (x * x) % p;\n    }\n    if (n == 0) {\n\
    \        return 1;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    long k = 1;\n    while\
    \ (n) {\n        if (n & 1) {\n            k = (k * 2) % p;\n        }\n     \
    \   n >>= 1;\n    }\n    return k;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp38fsowq3: /tmp/tmp38fsowq3.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n   // Implement this function.\n\tif(n==0)\n\
    \t\treturn 1;\n\tif(n%2==0)\n\t{\n\t\tlong t=modp(n/2,p);\n\t\treturn (t*t)%p;\n\
    \t}\n\telse\n\t{\n\t\treturn ((2%p)*modp(n-1,p))%p;\n\t}\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        n += (-n/p + 1) *\
    \ p;\n    }\n    long c = 1;\n    while (n > 0) {\n        if (n & 1) {\n    \
    \        c = (c * 2) % p;\n        }\n        n >>= 1;\n        if (n > 0) {\n\
    \            c = (c * 2) % p;\n        }\n    }\n    return c;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbrgye7jf: /tmp/tmpbrgye7jf.cpp:33: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) n = n % p + p;\n\
    \  int res = 1;\n  for (long e = n; e > 0; e >>= 1) {\n    if (e & 1) res = res\
    \ * n % p;\n    n = n * n % p;\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpt6b_93eu: /tmp/tmpt6b_93eu.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p >= 1);\n    // Use binary power\
    \ to compute n^p % p.\n    long answer = 1;\n    long multiplier = n;\n    //\
    \ Loop invariant: answer contains the value of n^i % p.\n    while (p != 0) {\n\
    \        // If p is odd, add n^p to the answer.\n        if (p % 2 == 1) {\n \
    \           answer = (answer * multiplier) % MOD;\n        }\n        // Square\
    \ n^p.\n        multiplier = (multiplier * multiplier) % MOD;\n        // Divide\
    \ p by 2.\n        p /= 2;\n    }\n    return answer;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppcqq2eh2.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmppcqq2eh2.cpp:23:46: error: \u2018MOD\u2019 was not declared in this\
    \ scope\n   23 |             answer = (answer * multiplier) % MOD;\n      |  \
    \                                            ^~~\n/tmp/tmppcqq2eh2.cpp:26:50:\
    \ error: \u2018MOD\u2019 was not declared in this scope\n   26 |         multiplier\
    \ = (multiplier * multiplier) % MOD;\n      |                                \
    \                  ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  long sq = modp(n/2,\
    \ p);\n  sq = (sq * sq) % p;\n  if (n & 1) sq = (sq * 2) % p;\n  return sq;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // return (n % p + p) % p;\n    assert(n\
    \ >= 0);\n    assert(p > 0);\n    assert(p < 1<<31);\n    if (n == 0) return 1;\n\
    \    long res = 1;\n    while (n) {\n        if (n & 1) res = (res * 2) % p;\n\
    \        n >>= 1;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmm9_wmja: /tmp/tmpmm9_wmja.cpp:18: long int modp(long int, long int):\
    \ Assertion `p < 1<<31' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n == 1) return\
    \ n % p;\n  if (n % 2 == 0) {\n    long half = modp(n / 2, p);\n    return (half\
    \ * half) % p;\n  } else {\n    return ((n % p) * modp(n - 1, p)) % p;\n  }\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2p0dnzmg: /tmp/tmp2p0dnzmg.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ret = 1;\n    while (n) {\n       \
    \ if (n % 2) ret = (ret * p) % 101;\n        p = (p * p) % 101;\n        n /=\
    \ 2;\n    }\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n  \
    \  assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8cvwims2: /tmp/tmp8cvwims2.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  long res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res =\
    \ (res * 2) % p;\n        }\n        n >>= 1;\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpr1ny1rg_: /tmp/tmpr1ny1rg_.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n>=0);\n    assert(p>=2);\n    long\
    \ d = 1;\n    while (n) {\n        if (n & 1) d = (d * 2) % p;\n        n >>=\
    \ 1;\n    }\n    return d;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbc5vqukj: /tmp/tmpbc5vqukj.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0)\n    n = (n %\
    \ p) + p;\n  if (n < p / 2)\n    return n;\n  else\n    return n - p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmplwl6_jfm: /tmp/tmplwl6_jfm.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = 1;\n  while (n > 0) {\n    ans\
    \ = (ans * (n % 2 == 1 ? 2 : 1)) % p;\n    n /= 2;\n  }\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpss4r2djx: /tmp/tmpss4r2djx.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) {\n    return 1;\n  }\n  if (n\
    \ == 1) {\n    return n % p;\n  }\n  // n > 1\n  long n_div_2 = n / 2;\n  long\
    \ n_minus_n_div_2 = n - n_div_2;\n  long X = modp(n_div_2, p);\n  long Y = modp(n_minus_n_div_2,\
    \ p);\n  long result = X * Y;\n  return result % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0zw6darl: /tmp/tmp0zw6darl.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return\
    \ modp((n / 2) * (n / 2), p);\n\treturn (modp(n - 1, p) * 2) % p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpo67pqqo7: /tmp/tmpo67pqqo7.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  long res = 1;\n  while (n\
    \ > 0) {\n    if (n & 1) {\n      res = (res * n) % p;\n    }\n    n >>= 1;\n\
    \    n %= p;\n  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5egh_57o: /tmp/tmp5egh_57o.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n < 0) {\n    // Negative powers are not\
    \ allowed, so compute the inverse and\n    // fall through to the positive case.\n\
    \    return modp(-n, p);\n  }\n  if (n == 0) return 1;\n\n  if (n % 2 == 0) {\n\
    \    long x = modp(n/2, p);\n    return (x*x) % p;\n  } else {\n    long x = modp(n/2,\
    \ p);\n    long y = modp(n/2 + 1, p);\n    return (x*y) % p;\n  }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n\
    \    long x = modp(n/2, p);\n    return (x*x) % p;\n  } else {\n    return (modp(n-1,\
    \ p) * n) % p;\n  }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpnup8xs_h: /tmp/tmpnup8xs_h.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) return modp((n / 2) * (n / 2), p);\n    else return (modp(n / 2, p) * modp(n\
    \ / 2, p)) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqjfkhdy6: /tmp/tmpqjfkhdy6.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\
    \t\tlong tmp = modp(n / 2, p);\n\t\treturn (tmp * tmp) % p;\n\t}\n\telse {\n\t\
    \treturn (modp(n - 1, p) * 2) % p;\n\t}\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) { n += 1 - n\
    \ / p * p; }\n  return n % p;\n}\nint main() {\n    auto candidate = modp;\n \
    \   assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpdcig8vlg: /tmp/tmpdcig8vlg.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long ans = modp(n\
    \ / 2, p);\n    ans = (ans * ans) % p;\n    if (n % 2 == 1) ans = (ans * 2) %\
    \ p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Handle special cases like n == 0\n  if\
    \ (n == 0) return 1;\n  long result = 1;\n  while (n > 0) {\n    if (n & 1) {\
    \ // n is odd\n      result = (result * n) % p;\n    }\n    n = n >> 1;\n    n\
    \ = (n * n) % p;\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) {\n    n = p\
    \ - 1 - ((-n - 1) % (p - 1));\n  }\n  long result = 1;\n  long factor = n;\n \
    \ while (p > 0) {\n    if (p & 1) {\n      result = (result * factor) % n;\n \
    \   }\n    factor = (factor * factor) % n;\n    p /= 2;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7k2mqtmw: /tmp/tmp7k2mqtmw.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong x = modp(n /\
    \ 2, p);\n\tx = (x * x) % p;\n\tif (n % 2 == 1) x = (x * 2) % p;\n\treturn x;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tn %= p;\n\tif (n < 0) n += p;\n\tlong result\
    \ = 1;\n\tlong b = n;\n\tlong e = 1;\n\twhile (e <= INT_MAX) {\n\t\tif (e & 1)\
    \ {\n\t\t\tresult = (result * b) % p;\n\t\t}\n\t\te >>= 1;\n\t\tb = (b * b) %\
    \ p;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = modp;\n   \
    \ assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n <= 1)\n    return\
    \ n;\n  long res = 1;\n  while (n > 0) {\n    if (n & 1)\n      res = (res * n)\
    \ % p;\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n  return res % p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    while (n > 0) {\n\
    \        if (n & 1) {\n            result = (result * 2) % p;\n        }\n   \
    \     n >>= 1;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsi_qm93w: /tmp/tmpsi_qm93w.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long r = modp(n / 2, p);\n        return r * r % p;\n    }\n \
    \   return modp(n - 1, p) * n % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgzslxcfk: /tmp/tmpgzslxcfk.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n==0) return 1;\n  if(n%2==0) return modp((n/2)*(n/2),\
    \ p);\n  else return (modp(n-1, p)*2)%p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmperrcei83: /tmp/tmperrcei83.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n\
    \ % 2 == 0) {\n\t\tlong t = modp(n / 2, p);\n\t\treturn (t * t) % p;\n\t}\n\t\
    return (modp(n - 1, p) * n) % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmlx41hqi: /tmp/tmpmlx41hqi.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p > 0);\n\tassert(n >= 0);\n\tassert(n\
    \ < p);\n\tlong res = 1;\n\tlong pp = p;\n\tlong pn = p - 1;\n\tlong pow = n;\n\
    \twhile (pn > 0) {\n\t\tif (pn & 1) {\n\t\t\tres = (res * pow) % pp;\n\t\t}\n\t\
    \tpow = (pow * pow) % pp;\n\t\tpn >>= 1;\n\t}\n\treturn res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_anb3b6d: /tmp/tmp_anb3b6d.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n % p;\n    if (n % 2 == 0) {\n        return (modp(n / 2, p) * modp(n / 2,\
    \ p)) % p;\n    } else {\n        return (n * modp(n - 1, p)) % p;\n    }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmplww3x073: /tmp/tmplww3x073.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long a=1;\n    long b=2;\n    long exp=n;\n\
    \    while(exp>0) {\n        if(exp%2==1) {\n            a=(a*b)%p;\n        }\n\
    \        b=(b*b)%p;\n        exp/=2;\n    }\n    return a;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n\
    \    long r = modp(n / 2, p);\n    return r * r % p;\n  }\n  return n * modp(n\
    \ - 1, p) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfqgkd_u4: /tmp/tmpfqgkd_u4.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // this is based on Fermat's little theorem,\
    \ if p is prime then for\n    // any a modp(a, p) = a\n    assert(n >= 0);\n \
    \   assert(p > 0);\n    if (n == 0) {\n        return 1;\n    }\n    // note that\
    \ mod(a^b, p) = mod(a, p)^b mod(p)\n    if (n % 2 == 0) {\n        long half =\
    \ modp(n / 2, p);\n        return (half * half) % p;\n    } else {\n        return\
    \ (modp(n - 1, p) * n) % p;\n    }\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpaap94k0s: /tmp/tmpaap94k0s.cpp:33: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n % 2 == 0) {\n        long tmp = modp(n / 2, p);\n        return (tmp\
    \ * tmp) % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp75ks8c88: /tmp/tmp75ks8c88.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    while (n > 0) {\n     \
    \   if (n & 1) {\n            r = (r * 2) % p;\n        }\n        n >>= 1;\n\
    \    }\n    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpt7ix0k7c: /tmp/tmpt7ix0k7c.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  // Return 1 if n = 0 or p = 1.\n    if (n == 0 || p == 1) return 1;\n    //\
    \ If n is even then even modulo even is even.\n    if (n % 2 == 0) return modp(n/2,\
    \ p) * modp(n/2, p) % p;\n    // If n is odd then halve the exponent and multiply.\n\
    \    return modp(n/2, p) * modp(n/2, p) * n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpp01k5kza: /tmp/tmpp01k5kza.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  for (int i = 0; i < n; i++)\
    \ {\n    res = (res*2) % p;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n % 2 == 1) {\n            res = (res * n) % p;\n        }\n       \
    \ n = n / 2;\n        n = (n * n) % p;\n    }\n    return res % p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p > 0);\n\tif (n == 0)\n\t\treturn\
    \ 1;\n\tif (n == 1)\n\t\treturn n % p;\n\tlong t = modp(n / 2, p);\n\tlong res\
    \ = (t * t) % p;\n\tif (n % 2)\n\t\tres = (res * 2) % p;\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5dux0s05: /tmp/tmp5dux0s05.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong res = 1;\n\twhile (n > 0) {\n\t\tif (n\
    \ & 1)\n\t\t\tres = (res * n) % p;\n\t\tn = n >> 1;\n\t\tn = (n * n) % p;\n\t\
    }\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long a = 1;\n    long b = 2;\n    for (;\
    \ n > 0; n >>= 1) {\n        if (n & 1) {\n            a = (a * b) % p;\n    \
    \    }\n        b = (b * b) % p;\n    }\n    return a;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong r = 1;\n\twhile (n > 0) {\n\t\tif (n\
    \ & 1) {\n\t\t\tr = (r * 2) % p;\n\t\t}\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpn920kaie: /tmp/tmpn920kaie.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int c = 1;\n    while (n > 0) {\n      \
    \  if (n & 1) {\n            c = (c * n) % p;\n        }\n        n >>= 1;\n \
    \   }\n    return c;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfxu87b7_: /tmp/tmpfxu87b7_.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n\
    \ / 2, p);\n    x = (x * x) % p;\n    if (n % 2 == 1) x = (x * 2) % p;\n    return\
    \ x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n == 0) {\n    \
    \    return 1;\n    } else if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p;\n    } else {\n        return modp(n/2, p) * modp(n/2, p) * n % p;\n\
    \    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4wzdwu2f: /tmp/tmp4wzdwu2f.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    for (int i = 0; i < n;\
    \ i++) {\n        r = (r * 2) % p;\n    }\n    return r;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1) {\n      r = (r * 2) % p;\n    }\n    n = n / 2;\n    if (n > 0) {\n\
    \      r = (r * r) % p;\n    }\n  }\n  return r;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfdc4gc5b: /tmp/tmpfdc4gc5b.cpp:30: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong r = 1;\n\tlong x = n % p;\n\tif (x==0)\n\
    \t\treturn 1;\n\twhile (n > 0) {\n\t\tif (n % 2 != 0) {\n\t\t\tr = (r * x) % p;\n\
    \t\t}\n\t\tx = (x * x) % p;\n\t\tn = n / 2;\n\t}\n\treturn r;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp61xc2buw: /tmp/tmp61xc2buw.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long ans = modp(n\
    \ >> 1, p);\n    ans = (ans * ans) % p;\n    if (n & 1)\n        ans = (ans *\
    \ 2) % p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long z = modp(n/2, p);\n        return (z*z) % p;\n    } else\
    \ {\n        return (n*modp(n-1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4g6g9wk_: /tmp/tmp4g6g9wk_.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  for (long i = 1; i <= n;\
    \ i++) {\n    res = (res * 2) % p;\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // The negative powers of two mod p are the\
    \ same as the positive powers.\n  if (n < 0) {\n    n = -n;\n  }\n  // Simple\
    \ cases.\n  if (n == 0) {\n    return 1;\n  }\n  if (n == 1) {\n    return 2 %\
    \ p;\n  }\n  // Find the highest order bit of n.\n  long highest = 0;\n  long\
    \ p2 = 1;\n  while (p2 <= n) {\n    p2 <<= 1;\n    highest++;\n  }\n  p2 >>= 1;\n\
    \  highest--;\n  // Start the exponentiation.\n  long v = 2;\n  // Combine the\
    \ lower order bits of n.\n  long pow2 = 0;\n  long mask = 1;\n  for (long i =\
    \ 0; i < highest; i++) {\n    if (n & mask) {\n      pow2 += 1 << i;\n    }\n\
    \    mask <<= 1;\n  }\n  pow2 = modp(pow2, p);\n  v = (v * pow2) % p;\n  // Combine\
    \ the higher order bits of n.\n  while (p2 > 1) {\n    p2 >>= 1;\n    pow2 = (pow2\
    \ * pow2) % p;\n    if (n & p2) {\n      v = (v * pow2) % p;\n    }\n  }\n  return\
    \ v;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfcti_fnt: /tmp/tmpfcti_fnt.cpp:60: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // return (1 if n == 0 else pow(2, n, p))\n\
    \    if (n == 0) return 1;\n    assert(n > 0);\n    long result = 1;\n    long\
    \ power = 2;\n    while (n > 0) {\n        if (n & 1) result = (result * power)\
    \ % p;\n        power = (power * power) % p;\n        n >>= 1;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong res = 1;\n\tlong sq = n;\n\twhile (p\
    \ > 0) {\n\t\tif (p % 2 != 0) {\n\t\t\tres = (res * sq) % p;\n\t\t}\n\t\tsq =\
    \ (sq * sq) % p;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpepk1c6os: /tmp/tmpepk1c6os.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n & 1) {\n            res = (res * n) % p;\n        }\n        n = n\
    \ >> 1;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    if (n == 0) return\
    \ 1;\n    long m = modp(n/2, p);\n    if (n % 2 == 0) {\n        return (m*m)\
    \ % p;\n    } else {\n        return (2*m*m) % p;\n    }\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n/2,\
    \ p);\n    x = (x * x) % p;\n    if (n % 2 == 1) x = (x * 2) % p;\n    return\
    \ x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// Implement this function as described in\
    \ the handout, and then delete this comment.\n\t// Do not return any other value,\
    \ and do not change the type of the return value.\n\tif (n == 0)\n\t\treturn 1;\n\
    \tlong y = modp(n / 2, p);\n\tif (n % 2 == 0)\n\t\treturn (y * y) % p;\n\telse\n\
    \t\treturn (y * y * n) % p;\n}\nint main() {\n    auto candidate = modp;\n   \
    \ assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpx3lkpzin: /tmp/tmpx3lkpzin.cpp:28: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long result =\
    \ 1;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result\
    \ * 10) % p;\n        }\n        n = n / 2;\n        if (n > 0) {\n          \
    \  p = (p * p) % p;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long pow2 = 1;\n    long result = 1;\n \
    \   while (n > 0) {\n        if (n % 2 == 1)\n            result = (result * pow2)\
    \ % p;\n        pow2 = (pow2 * pow2) % p;\n        n /= 2;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpo8c7f_jy: /tmp/tmpo8c7f_jy.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    n %= p;\n    while (n\
    \ > 0) {\n        if (n & 1) {\n            res = (res * n) % p;\n        }\n\
    \        n = n >> 1;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\t// Find\
    \ base 2 logarithm of n.\n\tint logn = 0;\n\tfor (long t = n; t; t /= 2)\n\t\t\
    logn++;\n\t// Build table of modp(2^i, p).\n\tlong m[logn];\n\tm[0] = 1;\n\tfor\
    \ (int i = 1; i < logn; i++)\n\t\tm[i] = (m[i - 1] * 2) % p;\n\t// Return modp(n,\
    \ p).\n\tlong result = 1;\n\tfor (int i = 0; n; i++, n /= 2)\n\t\tif (n % 2)\n\
    \t\t\tresult = (result * m[i]) % p;\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkctuxtj7: /tmp/tmpkctuxtj7.cpp:35: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n < 0) {\n\t\tn = n % p + p;\n\t}\n\t\
    long r = 1;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tr = (r * 3) % p;\n\
    \t\t}\n\t\tn /= 2;\n\t\tif (n > 0) {\n\t\t\tr = (r * r) % p;\n\t\t}\n\t}\n\treturn\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsf90144a: /tmp/tmpsf90144a.cpp:32: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2, p) % p;\n    }\n\
    \    return modp(n/2, p) * modp(n/2, p) * n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcdtzkr2z: /tmp/tmpcdtzkr2z.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     if (n & 1) {\n            res = (res * n) % p;\n        }\n        n = n\
    \ >> 1;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  if (n < 0) n = p - ((-n)\
    \ % p);\n  if (n >= p) n %= p;\n  assert(n >= 0);\n  return n;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpco96_mb7: /tmp/tmpco96_mb7.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Initially x == 1 (mod p).\n  long x = 1;\n\
    \  while (n > 0) {\n    // Invariant: x == 1 (mod p).\n    if (n % 2 != 0) {\n\
    \      // If n is odd, multiply x with a (mod p).\n      x = (x * 3) % p;\n  \
    \  }\n    // Now n is even.\n    n = n / 2;\n    // Keep x == 1 (mod p).\n   \
    \ if (n > 0) {\n      x = (x * x) % p;\n    }\n  }\n  return x;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8kiarshv: /tmp/tmp8kiarshv.cpp:34: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n < 0) {\n\t\tprintf(\"Error: n must be\
    \ positive.\\n\");\n\t\texit(1);\n\t}\n\tif (p <= 0) {\n\t\tprintf(\"Error: p\
    \ must be a positive prime.\\n\");\n\t\texit(1);\n\t}\n\tlong res = 1;\n\twhile\
    \ (n > 0) {\n\t\tif (n % 2 == 1)\n\t\t\tres = (res * 2) % p;\n\t\tn /= 2;\n\t\
    }\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptc9xm_j3: /tmp/tmptc9xm_j3.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n % 2 == 0) {\n        long half = modp(n / 2, p);\n        return\
    \ (half * half) % p;\n    } else {\n        return (2 * modp(n - 1, p)) % p;\n\
    \    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    // return (n < p) ?\
    \ n : (modp(n / 2, p) * 2) % p;\n    if (n < p) return n;\n    else return (modp(n\
    \ / 2, p) * 2) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsaxgbo80: /tmp/tmpsaxgbo80.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long result = 1;\n  for (long i = 1; i <=\
    \ n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n % p;\n    long x = modp(n/2, p);\n    long y = x*x % p;\n    if (n % 2 ==\
    \ 1) y = y*n % p;\n    return y;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7s4wzubm: /tmp/tmp7s4wzubm.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  long t = modp(n/2,\
    \ p);\n  if (n % 2 == 0) return (t*t) % p;\n  else return (t*t*2) % p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n == 0) return 1;\n\
    \    if (n % 2 == 0) {\n        long r = modp(n / 2, p);\n        return (r *\
    \ r) % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1wlukvtu: /tmp/tmp1wlukvtu.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        long r = modp(n / 2, p);\n        return r * r\
    \ % p;\n    }\n    return modp(n - 1, p) * n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpn5_8o2g_: /tmp/tmpn5_8o2g_.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    else if (n == 1) {\n        return n;\n    }\n    else {\n        long result\
    \ = 1;\n        long x = n;\n        while (p > 0) {\n            if (p & 1) {\n\
    \                result = (result * x) % n;\n            }\n            x = (x\
    \ * x) % n;\n            p >>= 1;\n        }\n        return result;\n    }\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbppez_89: /tmp/tmpbppez_89.cpp:36: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) {\n        return 1;\n    }\n    long r = modp(n/2, p);\n    r\
    \ = (r*r) % p;\n    if (n % 2 == 1) {\n        r = (r*2) % p;\n    }\n    return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n == 0) return 1;\n    else if(n % 2\
    \ == 0) {\n        long r = modp(n/2, p);\n        return (r*r) % p;\n    } else\
    \ {\n        return (modp(n-1, p) * 2) % p;\n    }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p > 0);\n    if (n == 0) {\n    \
    \    return 1;\n    }\n    else if (n == 1) {\n        return n;\n    }\n    long\
    \ q = modp(n/2, p);\n    long result = q*q % p;\n    if (n % 2 != 0) {\n     \
    \   result = result * n % p;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpjcjmf223: /tmp/tmpjcjmf223.cpp:32: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1;\n    long x = n % p;\n   \
    \ while (n > 0) {\n        if (n % 2 == 1) {\n            ans = (ans * x) % p;\n\
    \        }\n        x = (x * x) % p;\n        n = n / 2;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqu749v6v: /tmp/tmpqu749v6v.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int i;\n    long a = 1;\n    for (i = 0;\
    \ i < n; i++) {\n        a = a*2 % p;\n    }\n    return a;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long a = 1;\n  long b = 2;\n  while (n) {\n\
    \    if (n % 2) {\n      a = (a * b) % p;\n    }\n    b = (b * b) % p;\n    n\
    \ /= 2;\n  }\n  return a;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\
    \ else if (n == 1) {\n        return 2 % p;\n    } else if (n % 2 == 0) {\n  \
    \      long k = modp(n / 2, p);\n        return k * k % p;\n    } else {\n   \
    \     long k = modp(n - 1, p);\n        return k * 2 % p;\n    }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  while (n > 0) {\n    if (n\
    \ & 1)\n      res = (res * 2) % p;\n    n = n >> 1;\n  }\n  return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3h2jbsoh: /tmp/tmp3h2jbsoh.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        long t = modp(n / 2, p);\n        return (t *\
    \ t) % p;\n    }\n    return (modp(n - 1, p) * n) % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpeqk9niaw: /tmp/tmpeqk9niaw.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long res = modp(n/2, p);\n        return (res * res) % p;\n  \
    \  }\n    else return (modp(n-1, p) * (n % p)) % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmph2rm33tf: /tmp/tmph2rm33tf.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        n = (p - (-n % p))\
    \ % p;\n    }\n    long res = 1;\n    long base = 2;\n    for (; n > 0; n /= 2)\
    \ {\n        if (n % 2 == 1) {\n            res = (res * base) % p;\n        }\n\
    \        base = (base * base) % p;\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // We need a long type because we need to\
    \ hold the result of pow (which may\n  // exceed the boundaries of int).\n  //\
    \ If n is 0, the result should be 1.\n  if (n == 0) {\n    return 1;\n  }\n  long\
    \ res = 1;\n  long pow_mod = 1;\n  long pow_mod_prev = 1;\n  while (n > 0) {\n\
    \    long bit = n & 1;\n    if (bit == 1) {\n      pow_mod = (pow_mod * pow_mod_prev)\
    \ % p;\n      res = (res * pow_mod) % p;\n    }\n    n >>= 1;\n    pow_mod_prev\
    \ = (pow_mod_prev * pow_mod_prev) % p;\n  }\n  return res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgd960bfh: /tmp/tmpgd960bfh.cpp:37: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  for (int i = 1; i <= n; i++)\
    \ {\n    res = (res * 2) % p;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  n %= p;\n  if (n < 0) n\
    \ += p;\n  if (n < 0) n += p;\n  assert(n >= 0 && n < p);\n  if (n == 0) return\
    \ 1;\n  long q = modp(n >> 1, p);\n  if (n & 1) return (q + q * q) % p;\n  return\
    \ (q + q) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpad609v5k: /tmp/tmpad609v5k.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long m = modp(n\
    \ / 2, p);\n    m = (m * m) % p;\n    if (n % 2 == 1) m = (m * 2) % p;\n    return\
    \ m;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n <= 1) return n;\n    long res = 1;\n\
    \    for (long b = n; b > 0; b >>= 1) {\n        if (b & 1) res = (res * n) %\
    \ p;\n        n = (n * n) % p;\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpedsbyerp: /tmp/tmpedsbyerp.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// Return n modulo p.\n\treturn n % p;\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsh3g0lme: /tmp/tmpsh3g0lme.cpp:21: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  assert(n != 0);\n  assert(p\
    \ != 1);\n  long result = 1;\n  while (n > 0) {\n    if (n & 1) {\n      result\
    \ = (result * (long)result) % p;\n    }\n    n >>= 1;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqwsdbp3y: /tmp/tmpqwsdbp3y.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n\n  long m = 1;\n  for (long\
    \ i = 1; i <= n; i++) {\n    m = (m * 2) % p;\n  }\n  return m;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong a = 1;\n\tlong b = 2;\n\twhile (n > 0)\
    \ {\n\t\tif (n % 2 == 1) {\n\t\t\ta = (a * b) % p;\n\t\t}\n\t\tb = (b * b) % p;\n\
    \t\tn = n / 2;\n\t}\n\treturn a;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n < 0 || p < 0) return modp(n % p + p,\
    \ p);\n    if(!n) return 1;\n    if(n % 2) return (2 * modp(n - 1, p)) % p;\n\
    \    return modp(n / 2, p) * modp(n / 2, p) % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong ans = modp(n\
    \ / 2, p);\n\tans = (ans * ans) % p;\n\tif (n % 2 == 1) ans = (ans * 2) % p;\n\
    \treturn ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n) {\n       \
    \ if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfp4n86xn: /tmp/tmpfp4n86xn.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) {\n        return 1;\n    }\n\
    \    else if (n == 1) {\n        return n % p;\n    }\n    else {\n        long\
    \ k = modp(n / 2, p);\n        if (n % 2 == 0) {\n            return (k * k) %\
    \ p;\n        }\n        else {\n            return (((k * k) % p) * n) % p;\n\
    \        }\n    }\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpnrgw3la8: /tmp/tmpnrgw3la8.cpp:34: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long x = modp(n\
    \ / 2, p);\n    long v = x * x % p;\n    if (n % 2) {\n        v = v * 2 % p;\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long r = modp(n\
    \ / 2, p);\n    r = (r * r) % p;\n    if (n % 2 == 1) r = (r * 2) % p;\n    return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) {\n        return modp(-n, p);\n\
    \    }\n    assert(n >= 0);\n    long res = 1;\n    while (n) {\n        if (n\
    \ & 1) {\n            res = (res * 2) % p;\n        }\n        n >>= 1;\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbs_f_cyg: /tmp/tmpbs_f_cyg.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n   \
    \     res = (res * (n % 2 ? p : 1)) % p;\n        n >>= 1;\n        p = (p * p)\
    \ % MOD;\n    }\n    return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvablq70u.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpvablq70u.cpp:19:23: error: \u2018MOD\u2019 was not declared in this\
    \ scope\n   19 |         p = (p * p) % MOD;\n      |                       ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1 % p;\n    while (n > 0) {\n\
    \        if (n & 1) res = (res * 2) % p;\n        n >>= 1;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5w87_1mr: /tmp/tmp5w87_1mr.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // Fill this in.\n    return pow(2,n)%p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjus0yma3.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpjus0yma3.cpp:16:20: error: invalid operands of types \u2018double\u2019\
    \ and \u2018long int\u2019 to binary \u2018operator%\u2019\n   16 |     return\
    \ pow(2,n)%p;\n      |            ~~~~~~~~^~\n      |               |     |\n\
    \      |               |     long int\n      |               double\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    long res = modp(n\
    \ / 2, p);\n    res = (res * res) % p;\n    if (n % 2 == 1) res = (res * 2) %\
    \ p;\n    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Base case: n = 0\n  if (n == 0) return\
    \ 1;\n  // Check for even values of n.\n  if (n % 2 == 0) {\n    // Compute (2^n)^2\
    \ and then reduce that modulo p\n    long b = modp(n / 2, p);\n    return (b *\
    \ b) % p;\n  } else {\n    // Compute (2^n - 1)^2 and then reduce that modulo\
    \ p\n    long a = modp(n - 1, p);\n    return (2 * a * a) % p;\n  }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpdt4uiuf5: /tmp/tmpdt4uiuf5.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// assert(p > 0);\n\tif (n == 0) return 1;\n\
    \tlong x = modp(n/2, p);\n\tx = (x*x) % p;\n\tif (n % 2 == 1) x = (x*2) % p;\n\
    \treturn x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long mask = 1;\n    while(mask <= n) {\n\
    \        mask = mask << 1;\n    }\n    mask = mask >> 1;\n    long res = 1;\n\
    \    while(mask > 0) {\n        if (n & mask) {\n            res = (res * res)\
    \ % p;\n        } else {\n            res = (res * res * 2) % p;\n        }\n\
    \        mask = mask >> 1;\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpdq9_lv9p: /tmp/tmpdq9_lv9p.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n) {\n    if (n % 2)\
    \ {\n      r = (r * 2) % p;\n    }\n    n /= 2;\n  }\n  return r;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2axmsnuf: /tmp/tmp2axmsnuf.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 1;\n    for (int i = 0; i\
    \ < n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long q = (long) (((double) n) / p);\n  long\
    \ r = n - q * p;\n  if (r < 0)\n    r += p;\n  return r;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3ixdqa6y: /tmp/tmp3ixdqa6y.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t} else if\
    \ (n % 2 == 0) {\n\t\tlong t = modp(n / 2, p);\n\t\treturn (t * t) % p;\n\t} else\
    \ {\n\t\treturn (modp(n - 1, p) * n) % p;\n\t}\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsiuh0va9: /tmp/tmpsiuh0va9.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    for (int i = 0; i < n;\
    \ i++) {\n        r = (r * 2) % p;\n    }\n    return r;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  else if (n == 1)\
    \ return n % p;\n  else {\n    long x = modp(n / 2, p);\n    long x2 = (x * x)\
    \ % p;\n    if (n % 2 == 0) return x2;\n    else return (x2 * n) % p;\n  }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp05sedmfs: /tmp/tmp05sedmfs.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long\
    \ tmp = modp(n / 2, p);\n        return (tmp * tmp) % p;\n    } else {\n     \
    \   return ((n % p) * modp(n - 1, p)) % p;\n    }\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvpc7ster: /tmp/tmpvpc7ster.cpp:30: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n;\n    long pow;\n    pow = modp(n/2, p);\n    pow = (pow * pow) % p;\n   \
    \ if (n & 1) {\n        pow = (pow * n) % p;\n    }\n    return pow;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphefaf5fd: /tmp/tmphefaf5fd.cpp:28: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0) return 1;\n    if (n % 2 ==\
    \ 0) {\n        long t = modp(n/2, p);\n        return (t*t) % p;\n    }\n   \
    \ return ((n % p) * modp(n-1, p)) % p;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpwjlcncll: /tmp/tmpwjlcncll.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n\
    \ % 2 == 0) {\n\t\treturn modp(n / 2, p) * modp(n / 2, p) % p;\n\t}\n\treturn\
    \ modp(n - 1, p) * 2 % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n == 0) {\n    return 1;\n  }\n  long r\
    \ = modp(n/2, p);\n  r = r*r % p;\n  if(n%2) {\n    r = r*2 % p;\n  }\n  return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\tlong\
    \ res = 1;\n\tlong cur = n;\n\twhile (p > 0) {\n\t\tif (p % 2 == 1)\n\t\t\tres\
    \ = (res * cur) % p;\n\t\tcur = (cur * cur) % p;\n\t\tp = p / 2;\n\t}\n\treturn\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfvaklyb9: /tmp/tmpfvaklyb9.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n < 0) { n = n % p + p; }\n  if (n < 2)\
    \ { return n; }\n  long tmp = modp(n / 2, p);\n  if (n % 2 == 0) { return (tmp\
    \ * tmp) % p; }\n  else { return (tmp * tmp * 2) % p; }\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpb7lcgb2k: /tmp/tmpb7lcgb2k.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long num = 1;\n    long x = n % p;\n   \
    \ while (n > 0) {\n        if (n % 2 == 1) {\n            num = (num * x) % p;\n\
    \        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    return num;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprzb8zo1t: /tmp/tmprzb8zo1t.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\tif (n\
    \ == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tlong v = modp(n / 2, p);\n\t\treturn\
    \ (v * v) % p;\n\t}\n\treturn (2 * modp(n - 1, p)) % p;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n < p) {\n    return n;\n  }\n  if (n\
    \ == p) {\n    return 0;\n  }\n  long x = 1;\n  while (n > 0) {\n    if (n & 1)\
    \ {\n      x = (x * 2) % p;\n    }\n    n >>= 1;\n    if (n == 0) {\n      break;\n\
    \    }\n    if (x < p - x) {\n      x = (x * 2) % p;\n    } else {\n      x =\
    \ ((x * 2) % p - p) % p;\n    }\n  }\n  return x;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4ynfcrqy: /tmp/tmp4ynfcrqy.cpp:41: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  while (n > 0) {\n    if (n\
    \ % 2 == 1) {\n      r = (r * 2) % p;\n    }\n    n = n / 2;\n    p = (p * p)\
    \ % p;\n  }\n  return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0);\n    assert(p > 0);\n  \
    \  assert(p <= LONG_MAX / 2);\n    int result = 1;\n    for (int i = 1; i <= n;\
    \ i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
