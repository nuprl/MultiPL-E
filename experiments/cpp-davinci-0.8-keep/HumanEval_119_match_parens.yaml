name: HumanEval_119_match_parens
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of two\
  \ strings, both strings consist of open\n// parentheses '(' or close parentheses\
  \ ')' only.\n// Your job is to check if it is possible to concatenate the two strings\
  \ in\n// some order, that the resulting string will be good.\n// A string S is considered\
  \ to be good if and only if all parentheses in S\n// are balanced. For example:\
  \ the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n\
  // match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nstd::string\
  \ match_parens(std::vector<std::string> lst) {\n"
tests: "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
  ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
  )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
  (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
  )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
  (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
  ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
  (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
  ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
  )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
  )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
  (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
  )\", \"(\"}))) == (\"Yes\"));\n}\n"
completions: []
stop_tokens:
- "\n}"
