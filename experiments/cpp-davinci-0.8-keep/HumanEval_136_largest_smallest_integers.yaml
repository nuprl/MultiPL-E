name: HumanEval_136_largest_smallest_integers
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns\
  \ a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is\
  \ the smallest\n// of positive integers in a list.\n// If there is no negative or\
  \ positive integers, return them as None.\n// Examples:\n// largest_smallest_integers([2,\
  \ 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n\
  // largest_smallest_integers([0]) == (None, None)\nstd::tuple<std::optional<long>,\
  \ std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({2,\
  \ 4, 1, 3, 5, 7}))) == std::make_tuple(std::optional<long>({}), std::optional<long>(1)));\n\
  \    assert(candidate((std::vector<long>({2, 4, 1, 3, 5, 7, 0}))) == std::make_tuple(std::optional<long>({}),\
  \ std::optional<long>(1)));\n    assert(candidate((std::vector<long>({1, 3, 2, 4,\
  \ 5, 6, -2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({4,\
  \ 5, 3, 6, 2, 7, -7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({7,\
  \ 3, 8, 4, 9, 2, 5, -9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>()))\
  \ == std::make_tuple(std::optional<long>({}), std::optional<long>({})));\n    assert(candidate((std::vector<long>({0})))\
  \ == std::make_tuple(std::optional<long>({}), std::optional<long>({})));\n    assert(candidate((std::vector<long>({-1,\
  \ -3, -5, -6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>({})));\n\
  \    assert(candidate((std::vector<long>({-1, -3, -5, -6, 0}))) == std::make_tuple(std::optional<long>(-1),\
  \ std::optional<long>({})));\n    assert(candidate((std::vector<long>({-6, -4, -4,\
  \ -3, 1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({-6,\
  \ -4, -4, -3, -100, 1}))) == std::make_tuple(-3, 1));\n}\n"
completions: ["  std::optional<long> smallest;\n  std::optional<long> largest;\n \
    \ for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] < 0) {\n      if (!largest.has_value())\
    \ {\n        largest = lst[i];\n      } else if (lst[i] > largest.value()) {\n\
    \        largest = lst[i];\n      }\n    } else if (lst[i] > 0) {\n      if (!smallest.has_value())\
    \ {\n        smallest = lst[i];\n      } else if (lst[i] < smallest.value()) {\n\
    \        smallest = lst[i];\n      }\n    }\n  }\n  return std::make_tuple(largest,\
    \ smallest);", "\tauto min = std::min_element(lst.begin(), lst.end());\n\tauto\
    \ max = std::max_element(lst.begin(), lst.end());\n\tstd::optional<long> a, b;\n\
    \tif (*min > 0) {\n\t\tb = *min;\n\t}\n\tif (*max < 0) {\n\t\ta = *max;\n\t}\n\
    \treturn std::make_tuple(a, b);", "    std::optional<long> largest;\n    std::optional<long>\
    \ smallest;\n    for (auto item : lst) {\n        if (item > 0) {\n          \
    \  if (!smallest.has_value() || item < smallest.value()) {\n                smallest\
    \ = item;\n            }\n        } else if (item < 0) {\n            if (!largest.has_value()\
    \ || item > largest.value()) {\n                largest = item;\n            }\n\
    \        }\n    }\n    return std::make_tuple(largest, smallest);", "  if (lst.empty())\
    \ return {std::nullopt, std::nullopt};\n  std::sort(lst.begin(), lst.end());\n\
    \  auto it = std::find_if(lst.begin(), lst.end(), [](auto e) { return e > 0; });\n\
    \  if (it == lst.end()) return {lst.back(), std::nullopt};\n  return {lst.back(),\
    \ *it};", "    std::tuple<std::optional<long>, std::optional<long>> ints;\n  \
    \  int pos_min = INT_MAX;\n    int neg_max = INT_MIN;\n    if (lst.size() != 0)\
    \ {\n        for (auto i : lst) {\n            if (i < 0) {\n                if\
    \ (i > neg_max) {\n                    neg_max = i;\n                }\n     \
    \       }\n            if (i > 0) {\n                if (i < pos_min) {\n    \
    \                pos_min = i;\n                }\n            }\n        }\n \
    \       if (neg_max != INT_MIN) {\n            std::get<0>(ints) = neg_max;\n\
    \        }\n        if (pos_min != INT_MAX) {\n            std::get<1>(ints) =\
    \ pos_min;\n        }\n    }\n    return ints;", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> tuple(std::nullopt, std::nullopt);\n    if(lst.size() ==\
    \ 0)\n        return tuple;\n    for(long i : lst) {\n        if(i < 0) {\n  \
    \          if(std::get<0>(tuple) == std::nullopt)\n                std::get<0>(tuple)\
    \ = i;\n            else\n                std::get<0>(tuple) = std::max(std::get<0>(tuple).value(),\
    \ i);\n        }\n        else if(i > 0) {\n            if(std::get<1>(tuple)\
    \ == std::nullopt)\n                std::get<1>(tuple) = i;\n            else\n\
    \                std::get<1>(tuple) = std::min(std::get<1>(tuple).value(), i);\n\
    \        }\n    }\n    return tuple;", "\tstd::sort(lst.begin(), lst.end());\n\
    \treturn std::make_tuple(std::optional<long>{}, std::optional<long>{});", "  \
    \  if(lst.size()==0) return {std::nullopt, std::nullopt};\n    std::sort(lst.begin(),\
    \ lst.end());\n    if(lst[0]>=0) return {std::nullopt, (long)lst[0]};\n    else\
    \ if(lst[lst.size()-1]<=0) return {(long)lst[lst.size()-1], std::nullopt};\n \
    \   else return {(long)lst[lst.size()-1], (long)lst[0]};", "\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> tup;\n\tlong x = 0;\n\tstd::optional<long> myMax = std::nullopt;\n\
    \tstd::optional<long> myMin = std::nullopt;\n\tfor (long i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tif (myMin == std::nullopt) {\n\t\t\t\t\
    myMin = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i] < myMin) {\n\t\t\t\tmyMin = lst[i];\n\
    \t\t\t}\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\tif (myMax == std::nullopt) {\n\
    \t\t\t\tmyMax = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i] > myMax) {\n\t\t\t\tmyMax\
    \ = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tstd::get<0>(tup) = myMax;\n\tstd::get<1>(tup)\
    \ = myMin;\n\treturn tup;", "  if (lst.empty()) return {std::nullopt, std::nullopt};\n\
    \  long min_pos = INT64_MAX;\n  long max_neg = INT64_MIN;\n  for (long x : lst)\
    \ {\n    if (x > 0) {\n      min_pos = std::min(min_pos, x);\n    } else if (x\
    \ < 0) {\n      max_neg = std::max(max_neg, x);\n    }\n  }\n  return {max_neg\
    \ == INT64_MIN ? std::nullopt : max_neg, min_pos == INT64_MAX ? std::nullopt :\
    \ min_pos};", "    std::optional<long> largest_of_negative, smallest_of_positive;\n\
    \    for (long elem : lst) {\n        if (elem >= 0) {\n            if (!smallest_of_positive.has_value()\
    \ || elem < smallest_of_positive.value()) {\n                smallest_of_positive\
    \ = elem;\n            }\n        } else {\n            if (!largest_of_negative.has_value()\
    \ || elem > largest_of_negative.value()) {\n                largest_of_negative\
    \ = elem;\n            }\n        }\n    }\n    return {largest_of_negative, smallest_of_positive};",
  "    // Your code here\n    if(lst.size() == 0) return {std::nullopt, std::nullopt};\n\
    \    long max = lst[0], min = lst[0];\n    int max_ind = 0, min_ind = 0;\n   \
    \ for(int i = 0; i < lst.size(); i++){\n        if(lst[i] < 0){\n            if(lst[i]\
    \ > max){\n                max = lst[i];\n                max_ind = i;\n     \
    \       }\n        }\n        else{\n            if(lst[i] < min){\n         \
    \       min = lst[i];\n                min_ind = i;\n            }\n        }\n\
    \    }\n    if(max_ind != min_ind) return {max, min};\n    if(max > 0) return\
    \ {std::nullopt, min};\n    if(min < 0) return {max, std::nullopt};\n    return\
    \ {std::nullopt, std::nullopt};", "    if(lst.size()==0)\n    {\n        return\
    \ std::make_tuple(std::nullopt,std::nullopt);\n    }\n    long max = 0;\n    long\
    \ min = 0;\n    bool first = true;\n    for(auto x:lst)\n    {\n        if(x>0)\n\
    \        {\n            if(first)\n            {\n                min = x;\n \
    \               first = false;\n            }\n            if(x<min)\n       \
    \     {\n                min = x;\n            }\n        }\n        else if(x<0)\n\
    \        {\n            if(first)\n            {\n                max = x;\n \
    \               first = false;\n            }\n            if(x>max)\n       \
    \     {\n                max = x;\n            }\n        }\n    }\n    if(first)\n\
    \    {\n        return std::make_tuple(std::nullopt,std::nullopt);\n    }\n  \
    \  else\n    {\n        return std::make_tuple(std::optional<long>(max),std::optional<long>(min));\n\
    \    }", "\tstd::optional<long> large;\n\tstd::optional<long> small;\n\tbool numNegative\
    \ = false;\n\tbool numPositive = false;\n\tfor (int i = 0; i < lst.size(); i++)\
    \ {\n\t\t//compare each to the lowest negative so far\n\t\tif (lst[i] < 0) {\n\
    \t\t\tnumNegative = true;\n\t\t\tif (large == NULL) {\n\t\t\t\tlarge = lst[i];\n\
    \t\t\t}\n\t\t\telse if (lst[i] > large) {\n\t\t\t\tlarge = lst[i];\n\t\t\t}\n\t\
    \t}\n\t\telse if (lst[i] > 0) {\n\t\t\tnumPositive = true;\n\t\t\tif (small ==\
    \ NULL) {\n\t\t\t\tsmall = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i] < small) {\n\
    \t\t\t\tsmall = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (!numNegative) {\n\t\tlarge\
    \ = NULL;\n\t}\n\tif (!numPositive) {\n\t\tsmall = NULL;\n\t}\n\treturn std::make_tuple(large,\
    \ small);", "  // your code here\n  return {std::nullopt, std::nullopt};", "\t\
    std::optional<long> large, small;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\
    \tif (lst[i] < 0) {\n\t\t\tif (!large) large = lst[i];\n\t\t\tif (lst[i] > *large)\
    \ large = lst[i];\n\t\t}\n\t\telse if (lst[i] > 0) {\n\t\t\tif (!small) small\
    \ = lst[i];\n\t\t\tif (lst[i] < *small) small = lst[i];\n\t\t}\n\t}\n\treturn\
    \ std::make_tuple(large, small);", "\tstd::optional<long> largest;\n\tstd::optional<long>\
    \ smallest;\n\tfor (auto& x : lst) {\n\t\tif (x < 0) {\n\t\t\tif (!largest.has_value()\
    \ || x > largest.value()) {\n\t\t\t\tlargest = x;\n\t\t\t}\n\t\t}\n\t\telse if\
    \ (x > 0) {\n\t\t\tif (!smallest.has_value() || x < smallest.value()) {\n\t\t\t\
    \tsmallest = x;\n\t\t\t}\n\t\t}\n\t}\n\treturn { largest, smallest };", "    //\
    \ write your code here\n    int pos = 1, neg = 1;\n    long a, b;\n    for(int\
    \ i = 0; i < lst.size(); i++)\n    {\n        if(lst[i] > 0)\n        {\n    \
    \        b = lst[i];\n            pos = 0;\n            break;\n        }\n  \
    \  }\n    for(int i = 0; i < lst.size(); i++)\n    {\n        if(lst[i] < 0)\n\
    \        {\n            a = lst[i];\n            neg = 0;\n            break;\n\
    \        }\n    }\n    if(!pos)\n    {\n        for(int i = 0; i < lst.size();\
    \ i++)\n        {\n            if(lst[i] > 0 && lst[i] < b)\n            {\n \
    \               b = lst[i];\n            }\n        }\n    }\n    if(!neg)\n \
    \   {\n        for(int i = 0; i < lst.size(); i++)\n        {\n            if(lst[i]\
    \ < 0 && lst[i] > a)\n            {\n                a = lst[i];\n           \
    \ }\n        }\n    }\n    if(pos)\n    {\n        b = 0;\n    }\n    if(neg)\n\
    \    {\n        a = 0;\n    }\n    return std::make_tuple(a, b);", "\tlong* max\
    \ = NULL;\n\tlong* min = NULL;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\t\
    if (lst[i] < 0) {\n\t\t\tif (max == NULL) {\n\t\t\t\tmax = &lst[i];\n\t\t\t}\n\
    \t\t\telse if (lst[i] > *max) {\n\t\t\t\tmax = &lst[i];\n\t\t\t}\n\t\t}\n\t\t\
    else if (lst[i] > 0) {\n\t\t\tif (min == NULL) {\n\t\t\t\tmin = &lst[i];\n\t\t\
    \t}\n\t\t\telse if (lst[i] < *min) {\n\t\t\t\tmin = &lst[i];\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn std::make_tuple(max, min);", "    std::optional<long> largest, smallest;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest || *largest\
    \ < i) {\n                largest = i;\n            }\n        } else if (i >\
    \ 0) {\n            if (!smallest || *smallest > i) {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return {largest, smallest};", "\t\
    auto n = lst.size();\n\tif (n == 0)\n\t\treturn {std::nullopt, std::nullopt};\n\
    \tif (n == 1)\n\t\treturn {std::nullopt, std::nullopt};\n\tstd::sort(lst.begin(),\
    \ lst.end());\n\tauto lb = std::lower_bound(lst.begin(), lst.end(), 0);\n\tif\
    \ (lb == lst.end())\n\t\treturn {std::nullopt, std::nullopt};\n\tif (lb == lst.begin())\n\
    \t\treturn {std::nullopt, *lst.begin()};\n\treturn {*std::prev(lb), *lb};", " \
    \ // TODO: create a function that returns a tuple\n  // with the largest of negative\
    \ and smallest of positive\n  // numbers in a vector, if they exist\n  if (lst.size()\
    \ > 0) {\n    bool nflag = false;\n    bool pflag = false;\n    long nmax = 0;\n\
    \    long pmax = 0;\n    for (long i = 0; i < lst.size(); i++) {\n      if (lst[i]\
    \ < 0) {\n        if (nflag == false) {\n          nmax = lst[i];\n          nflag\
    \ = true;\n        } else {\n          if (lst[i] > nmax) {\n            nmax\
    \ = lst[i];\n          }\n        }\n      }\n      if (lst[i] > 0) {\n      \
    \  if (pflag == false) {\n          pmax = lst[i];\n          pflag = true;\n\
    \        } else {\n          if (lst[i] < pmax) {\n            pmax = lst[i];\n\
    \          }\n        }\n      }\n    }\n    if (nflag == false) {\n      nmax\
    \ = NULL;\n    }\n    if (pflag == false) {\n      pmax = NULL;\n    }\n    return\
    \ std::make_tuple(nmax, pmax);\n  } else {\n    return std::make_tuple(NULL, NULL);\n\
    \  }", "  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long>\
    \ smallest_positive = std::nullopt;\n  for (const auto& element : lst) {\n   \
    \ if (element < 0 && largest_negative == std::nullopt) {\n      largest_negative\
    \ = element;\n    }\n    if (element > 0 && smallest_positive == std::nullopt)\
    \ {\n      smallest_positive = element;\n    }\n    if (element < 0 && largest_negative\
    \ != std::nullopt) {\n      if (element > *largest_negative) {\n        largest_negative\
    \ = element;\n      }\n    }\n    if (element > 0 && smallest_positive != std::nullopt)\
    \ {\n      if (element < *smallest_positive) {\n        smallest_positive = element;\n\
    \      }\n    }\n  }\n  return std::make_tuple(largest_negative, smallest_positive);",
  "\tstd::optional<long> a = std::nullopt;\n\tstd::optional<long> b = std::nullopt;\n\
    \tbool contains_negative = false;\n\tbool contains_positive = false;\n\tfor (int\
    \ i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tcontains_negative\
    \ = true;\n\t\t\tif (!a.has_value())\n\t\t\t\ta = lst[i];\n\t\t\telse\n\t\t\t\t\
    a = lst[i] > a.value() ? lst[i] : a.value();\n\t\t}\n\t\telse if (lst[i] > 0)\
    \ {\n\t\t\tcontains_positive = true;\n\t\t\tif (!b.has_value())\n\t\t\t\tb = lst[i];\n\
    \t\t\telse\n\t\t\t\tb = lst[i] < b.value() ? lst[i] : b.value();\n\t\t}\n\t}\n\
    \tif (!contains_negative)\n\t\ta = std::nullopt;\n\tif (!contains_positive)\n\t\
    \tb = std::nullopt;\n\treturn std::make_tuple(a, b);", "    long minVal;\n   \
    \ bool minFlag = false;\n    long maxVal;\n    bool maxFlag = false;\n    if(lst.size()\
    \ == 0) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n    }\n\
    \    for(int i = 0; i < lst.size(); i++) {\n        if(lst[i] > 0) {\n       \
    \     if(!minFlag) {\n                minVal = lst[i];\n                minFlag\
    \ = true;\n            }\n            if(lst[i] < minVal) {\n                minVal\
    \ = lst[i];\n            }\n        }\n        if(lst[i] < 0) {\n            if(!maxFlag)\
    \ {\n                maxVal = lst[i];\n                maxFlag = true;\n     \
    \       }\n            if(lst[i] > maxVal) {\n                maxVal = lst[i];\n\
    \            }\n        }\n    }\n    if(!minFlag) {\n        minVal = std::nullopt;\n\
    \    }\n    if(!maxFlag) {\n        maxVal = std::nullopt;\n    }\n    return\
    \ std::make_tuple(maxVal, minVal);", "\treturn {};", "    long smallest_positive=INT_MAX;\n\
    \    long largest_negative=INT_MIN;\n    for(int i=0;i<lst.size();i++){\n    \
    \    if(lst[i]>0){\n            if(lst[i]<smallest_positive){\n              \
    \  smallest_positive=lst[i];\n            }\n        }\n        else{\n      \
    \      if(lst[i]>largest_negative){\n                largest_negative=lst[i];\n\
    \            }\n        }\n    }\n    if(smallest_positive!=INT_MAX && largest_negative!=INT_MIN){\n\
    \        return std::make_tuple(largest_negative,smallest_positive);\n    }\n\
    \    else if(smallest_positive==INT_MAX && largest_negative!=INT_MIN){\n     \
    \   return std::make_tuple(largest_negative,std::nullopt);\n    }\n    else if(smallest_positive!=INT_MAX\
    \ && largest_negative==INT_MIN){\n        return std::make_tuple(std::nullopt,smallest_positive);\n\
    \    }\n    else{\n        return std::make_tuple(std::nullopt,std::nullopt);\n\
    \    }", "    long largest_negative,smallest_positive;\n    std::tuple<std::optional<long>,\
    \ std::optional<long>>  tup;\n    // your code here\n    if(lst.size()==0)\n \
    \   {\n        std::get<0>(tup)=std::nullopt;\n        std::get<1>(tup)=std::nullopt;\n\
    \        return tup;\n    }\n    bool f=false;\n    int cnt=0;\n    for(int i=0;i<lst.size();i++)\n\
    \    {\n        if(lst[i]<0)\n        {\n            if(f==false)\n          \
    \  {\n                largest_negative=lst[i];\n                f=true;\n    \
    \        }\n            else if(largest_negative<lst[i])\n            {\n    \
    \            largest_negative=lst[i];\n            }\n            cnt++;\n   \
    \     }\n    }\n    if(cnt==0)\n    {\n        std::get<0>(tup)=std::nullopt;\n\
    \    }\n    else\n    {\n        std::get<0>(tup)=largest_negative;\n    }\n \
    \   bool f1=false;\n    int cnt1=0;\n    for(int i=0;i<lst.size();i++)\n    {\n\
    \        if(lst[i]>0)\n        {\n            if(f1==false)\n            {\n \
    \               smallest_positive=lst[i];\n                f1=true;\n        \
    \    }\n            else if(smallest_positive>lst[i])\n            {\n       \
    \         smallest_positive=lst[i];\n            }\n            cnt1++;\n    \
    \    }\n    }\n    if(cnt1==0)\n    {\n        std::get<1>(tup)=std::nullopt;\n\
    \    }\n    else\n    {\n        std::get<1>(tup)=smallest_positive;\n    }\n\
    \    return tup;", '    return {};', "    if(lst.size() == 0) return {std::nullopt,\
    \ std::nullopt};\n    std::optional<long> pos, neg;\n    for(auto i: lst){\n \
    \       if(i >= 0){\n            if(!pos){\n                pos = i;\n       \
    \     }\n            if(i < *pos){\n                pos = i;\n            }\n\
    \        }else{\n            if(!neg){\n                neg = i;\n           \
    \ }\n            if(i > *neg){\n                neg = i;\n            }\n    \
    \    }\n    }\n    return {neg, pos};", "\tif (lst.size() == 0) {\n\t\treturn\
    \ std::make_tuple(std::nullopt, std::nullopt);\n\t}\n\tauto it = std::max_element(lst.begin(),\
    \ lst.end());\n\tauto it1 = std::min_element(lst.begin(), lst.end());\n\tif (std::find_if(lst.begin(),\
    \ lst.end(), [](long x) {return x >= 0; }) == lst.end()) {\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\t}\n\telse if (std::find_if(lst.begin(), lst.end(), [](long\
    \ x) {return x < 0; }) == lst.end()) {\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::make_optional(*it1));\n\t}\n\telse {\n\t\treturn std::make_tuple(std::make_optional(*it),\
    \ std::make_optional(*it1));\n\t}", "    std::optional<long> smallest, largest;\n\
    \    if (lst.size() == 0) {\n        return std::make_tuple(smallest, largest);\n\
    \    }\n    smallest = lst[0];\n    largest = lst[0];\n    for (int i = 0; i <\
    \ lst.size(); i++) {\n        if (lst[i] > 0) {\n            if (lst[i] < smallest)\
    \ {\n                smallest = lst[i];\n            }\n        } else {\n   \
    \         if (lst[i] > largest) {\n                largest = lst[i];\n       \
    \     }\n        }\n    }\n    if (smallest > 0) {\n        smallest = std::nullopt;\n\
    \    }\n    if (largest < 0) {\n        largest = std::nullopt;\n    }\n    return\
    \ std::make_tuple(largest, smallest);", "\tstd::optional<long> neg, pos;\n\tfor\
    \ (auto it = lst.begin(); it != lst.end(); it++) {\n\t\tif (*it > 0) {\n\t\t\t\
    if (!pos.has_value()) {\n\t\t\t\tpos = *it;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpos\
    \ = std::min(*it, pos.value());\n\t\t\t}\n\t\t}\n\t\telse if (*it < 0) {\n\t\t\
    \tif (!neg.has_value()) {\n\t\t\t\tneg = *it;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\
    neg = std::max(*it, neg.value());\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(neg,\
    \ pos);", "  std::optional<long> first;\n  std::optional<long> second;\n  for\
    \ (long num : lst) {\n    if (num < 0) {\n      if (!first.has_value() || num\
    \ > first.value()) {\n        first = num;\n      }\n    } else if (num > 0) {\n\
    \      if (!second.has_value() || num < second.value()) {\n        second = num;\n\
    \      }\n    }\n  }\n  return std::make_tuple(first, second);", "    int maximum,minimum;\n\
    \    maximum=lst[0];\n    minimum=lst[0];\n    int c=0;\n    int d=0;\n    for(int\
    \ i=0;i<lst.size();i++)\n    {\n        if(lst[i]>0)\n        {\n            if(minimum>lst[i])\n\
    \            {\n                minimum=lst[i];\n            }\n            c++;\n\
    \        }\n        if(lst[i]<0)\n        {\n            if(maximum<lst[i])\n\
    \            {\n                maximum=lst[i];\n            }\n            d++;\n\
    \        }\n    }\n    if(c==0)\n    {\n        minimum=NULL;\n    }\n    if(d==0)\n\
    \    {\n        maximum=NULL;\n    }\n    return std::make_tuple(maximum,minimum);",
  "    int maxNeg = -1;\n    int minPos = 1;\n    bool negFlag = false;\n    bool\
    \ posFlag = false;\n    std::tuple<std::optional<long>, std::optional<long>> result;\n\
    \    std::optional<long> neg;\n    std::optional<long> pos;\n    for(auto i :\
    \ lst){\n        if(i < 0 && i > maxNeg){\n            maxNeg = i;\n         \
    \   negFlag = true;\n        }\n        if(i > 0 && i < minPos){\n           \
    \ minPos = i;\n            posFlag = true;\n        }\n    }\n    if(negFlag){\n\
    \        neg = maxNeg;\n    }\n    if(posFlag){\n        pos = minPos;\n    }\n\
    \    result = std::make_tuple(neg, pos);\n    return result;", "\tif (lst.size()\
    \ == 0) {\n\t\treturn { std::nullopt, std::nullopt };\n\t}\n\tlong largest = lst[0];\n\
    \tlong smallest = lst[0];\n\tint count = 0;\n\tfor (auto i : lst) {\n\t\tif (i\
    \ < 0) {\n\t\t\tif (i > largest) {\n\t\t\t\tlargest = i;\n\t\t\t}\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if (i > 0) {\n\t\t\tif (i < smallest) {\n\t\t\t\tsmallest = i;\n\
    \t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn { std::nullopt,\
    \ std::nullopt };\n\t}\n\telse if (count == 1) {\n\t\treturn { std::nullopt, smallest\
    \ };\n\t}\n\telse {\n\t\treturn { largest, smallest };\n\t}", "  \tstd::tuple<std::optional<long>,\
    \ std::optional<long>> t(std::nullopt, std::nullopt);\n\tif (lst.size()==0) return\
    \ t;\n\tstd::optional<long> a, b;\n\tlong min = lst[0], max = lst[0];\n\tfor (auto\
    \ i: lst) {\n\t\tif (i < 0) {\n\t\t\tif (max < i) max = i;\n\t\t}\n\t\telse if\
    \ (i > 0) {\n\t\t\tif (min > i) min = i;\n\t\t}\n\t}\n\tif (max >= 0)\n\t\ta =\
    \ std::nullopt;\n\telse\n\t\ta = max;\n\tif (min <= 0)\n\t\tb = std::nullopt;\n\
    \telse\n\t\tb = min;\n\tt = std::make_tuple(a, b);\n\treturn t;", "    std::optional<long>\
    \ pos;\n    std::optional<long> neg;\n    for (const auto& item : lst) {\n   \
    \     if (item > 0) {\n            if (!pos.has_value() || item < pos.value())\
    \ {\n                pos = item;\n            }\n        } else if (item < 0)\
    \ {\n            if (!neg.has_value() || item > neg.value()) {\n             \
    \   neg = item;\n            }\n        }\n    }\n    return std::make_tuple(neg,\
    \ pos);", "    // no idea how to solve it\n    return {std::nullopt, std::nullopt};",
  "    if(lst.size()==0)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if(lst.size()==1)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    long first=-9999999999, second=9999999999;\n    for(long x:lst)\n    {\n\
    \        if(x<0 && x>first)\n            first=x;\n        if(x>0 && x<second)\n\
    \            second=x;\n    }\n    if(first==-9999999999)\n        first=std::nullopt;\n\
    \    if(second==9999999999)\n        second=std::nullopt;\n    return std::make_tuple(first,\
    \ second);", "    std::optional<long> a, b;\n    if (lst.size() == 0) {\n    \
    \    return {a, b};\n    } else {\n        for (int i = 0; i < lst.size(); i++)\
    \ {\n            if (lst[i] > 0) {\n                if (b) {\n               \
    \     if (lst[i] < *b) {\n                        b = lst[i];\n              \
    \      }\n                } else {\n                    b = lst[i];\n        \
    \        }\n            } else {\n                if (a) {\n                 \
    \   if (lst[i] > *a) {\n                        a = lst[i];\n                \
    \    }\n                } else {\n                    a = lst[i];\n          \
    \      }\n            }\n        }\n        return {a, b};\n    }", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> ans;\n    long largest = lst[0];\n    long smallest = lst[0];\n\
    \    for(auto elem : lst){\n        if(elem >= 0 && elem < smallest){\n      \
    \      smallest = elem;\n        }\n        if(elem < 0 && elem > largest){\n\
    \            largest = elem;\n        }\n    }\n    ans = std::make_tuple(largest,\
    \ smallest);\n    return ans;", "\t// Write your code here\n\tstd::vector<long>\
    \ lst_neg, lst_pos;\n\tfor (auto& l : lst) {\n\t\tif (l < 0) {\n\t\t\tlst_neg.push_back(l);\n\
    \t\t}\n\t\telse if (l > 0) {\n\t\t\tlst_pos.push_back(l);\n\t\t}\n\t}\n\tif (lst_neg.size()\
    \ == 0) {\n\t\treturn std::make_tuple(std::nullopt, std::nullopt);\n\t}\n\telse\
    \ if (lst_pos.size() == 0) {\n\t\treturn std::make_tuple(std::nullopt, std::nullopt);\n\
    \t}\n\treturn std::make_tuple(std::max_element(lst_neg.begin(), lst_neg.end()),\
    \ std::min_element(lst_pos.begin(), lst_pos.end()));", "  std::optional<long>\
    \ min, max;\n  bool min_checked = false, max_checked = false;\n  for (auto const\
    \ &x : lst) {\n    if (x < 0) {\n      if (!max_checked) {\n        max = x;\n\
    \        max_checked = true;\n      } else {\n        max = std::max(max.value(),\
    \ x);\n      }\n    } else if (x > 0) {\n      if (!min_checked) {\n        min\
    \ = x;\n        min_checked = true;\n      } else {\n        min = std::min(min.value(),\
    \ x);\n      }\n    }\n  }\n  return std::make_tuple(max, min);", "    std::optional<long>\
    \ smallest, largest;\n    for (auto item : lst) {\n        if (item < 0) {\n \
    \           if (!largest.has_value() || item > largest.value()) {\n          \
    \      largest = item;\n            }\n        } else if (item > 0) {\n      \
    \      if (!smallest.has_value() || item < smallest.value()) {\n             \
    \   smallest = item;\n            }\n        }\n    }\n    return {largest, smallest};",
  "    bool find_min=false,find_max=false;\n    std::optional<long> max_val,min_val;\n\
    \    for(int i=0;i<lst.size();i++){\n        if(lst[i]>0){\n            if(!find_min){\n\
    \                min_val=lst[i];\n                find_min=true;\n           \
    \ }\n            else if(lst[i]<min_val){\n                min_val=lst[i];\n \
    \           }\n        }\n        else if(lst[i]<0){\n            if(!find_max){\n\
    \                max_val=lst[i];\n                find_max=true;\n           \
    \ }\n            else if(lst[i]>max_val){\n                max_val=lst[i];\n \
    \           }\n        }\n    }\n    if(!find_min){\n        min_val=std::nullopt;\n\
    \    }\n    if(!find_max){\n        max_val=std::nullopt;\n    }\n    return std::make_tuple(max_val,min_val);",
  "    std::optional<long> largest_negative_integer;\n    std::optional<long> smallest_positive_integer;\n\
    \    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative_integer.has_value()\
    \ || num > largest_negative_integer.value()) {\n                largest_negative_integer\
    \ = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive_integer.has_value()\
    \ || num < smallest_positive_integer.value()) {\n                smallest_positive_integer\
    \ = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative_integer,\
    \ smallest_positive_integer);", "    if(lst.size() == 0) return {std::nullopt,\
    \ std::nullopt};\n    if(lst.size() == 1 && lst[0] == 0) return {std::nullopt,\
    \ std::nullopt};\n    std::optional<long> max_negative, min_positive;\n    for(long\
    \ i : lst) {\n        if(i < 0) {\n            if(!max_negative.has_value() ||\
    \ i > max_negative.value()) {\n                max_negative = i;\n           \
    \ }\n        } else if(i > 0) {\n            if(!min_positive.has_value() || i\
    \ < min_positive.value()) {\n                min_positive = i;\n            }\n\
    \        }\n    }\n    return {max_negative, min_positive};", "    long largestNegative\
    \ = -1 * LONG_MAX;\n    long smallestPositive = LONG_MAX;\n    int negativeCount\
    \ = 0;\n    int positiveCount = 0;\n    for (int i = 0; i < lst.size(); i++) {\n\
    \        if (lst[i] < 0) {\n            negativeCount++;\n            if (lst[i]\
    \ > largestNegative) {\n                largestNegative = lst[i];\n          \
    \  }\n        } else if (lst[i] > 0) {\n            positiveCount++;\n       \
    \     if (lst[i] < smallestPositive) {\n                smallestPositive = lst[i];\n\
    \            }\n        }\n    }\n    std::optional<long> largestNegativeResult;\n\
    \    std::optional<long> smallestPositiveResult;\n    if (negativeCount > 0) {\n\
    \        largestNegativeResult = largestNegative;\n    }\n    if (positiveCount\
    \ > 0) {\n        smallestPositiveResult = smallestPositive;\n    }\n    return\
    \ std::make_tuple(largestNegativeResult, smallestPositiveResult);", "    long\
    \ min = LONG_MAX;\n    long max = LONG_MIN;\n    bool pos = false;\n    bool neg\
    \ = false;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] >\
    \ 0) {\n            if (lst[i] < min) {\n                min = lst[i];\n     \
    \       }\n            pos = true;\n        }\n        if (lst[i] < 0) {\n   \
    \         if (lst[i] > max) {\n                max = lst[i];\n            }\n\
    \            neg = true;\n        }\n    }\n    if (pos && neg) {\n        return\
    \ std::make_tuple(max, min);\n    }\n    else if (pos) {\n        return std::make_tuple(std::nullopt,\
    \ min);\n    }\n    else if (neg) {\n        return std::make_tuple(max, std::nullopt);\n\
    \    }\n    else {\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    }", '  return std::make_tuple(std::nullopt, std::nullopt);', "    std::sort(lst.begin(),\
    \ lst.end());\n    long smallest, largest;\n    smallest = largest = 0;\n    bool\
    \ found_smallest = false, found_largest = false;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < 0) {\n            largest = lst[i];\n         \
    \   found_largest = true;\n        }\n        if (lst[i] > 0) {\n            smallest\
    \ = lst[i];\n            found_smallest = true;\n            break;\n        }\n\
    \    }\n    return {std::make_optional(found_largest ? largest : std::nullopt),\
    \ std::make_optional(found_smallest ? smallest : std::nullopt)};", "\tstd::optional<long>\
    \ max;\n\tstd::optional<long> min;\n\tif (lst.size() == 0) {\n\t\treturn std::make_tuple(max,\
    \ min);\n\t}\n\tfor (auto e : lst) {\n\t\tif (e > 0) {\n\t\t\tif (!min) {\n\t\t\
    \t\tmin = e;\n\t\t\t}\n\t\t\tif (e < min) {\n\t\t\t\tmin = e;\n\t\t\t}\n\t\t}\n\
    \t\tif (e < 0) {\n\t\t\tif (!max) {\n\t\t\t\tmax = e;\n\t\t\t}\n\t\t\tif (e >\
    \ max) {\n\t\t\t\tmax = e;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(max,\
    \ min);", "\nif(lst.size()==0)\n{\n  return {std::nullopt,std::nullopt};", " \
    \   int min, max, flag=0;\n    if(lst.size() == 0)\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    for(int i=0; i<lst.size(); i++)\n    {\n        if(lst[i]<0)\n\
    \        {\n            if(flag==0)\n            {\n                max = lst[i];\n\
    \                flag = 1;\n            }\n            else\n            {\n \
    \               if(lst[i]>max)\n                    max = lst[i];\n          \
    \  }\n        }\n        else if(lst[i]>0)\n        {\n            if(flag==0)\n\
    \            {\n                min = lst[i];\n                flag = 1;\n   \
    \         }\n            else\n            {\n                if(lst[i]<min)\n\
    \                    min = lst[i];\n            }\n        }\n    }\n    if(flag\
    \ == 0)\n        return std::make_tuple(std::nullopt, std::nullopt);\n    else\n\
    \        return std::make_tuple(max, min);", "    if(lst.size()==0) return {nullopt,nullopt};\n\
    \    if(lst.size()==1 && lst[0]==0) return {nullopt,nullopt};\n    int mx=0,mn=0;\n\
    \    for(int i=0;i<lst.size();i++){\n        if(lst[i]>0) mn++;\n        if(lst[i]<0)\
    \ mx++;\n    }\n    if(mn==0) return {nullopt,nullopt};\n    if(mx==0) return\
    \ {nullopt,lst[0]};\n    long mxl=-1e16,mnl=1e16;\n    for(int i=0;i<lst.size();i++){\n\
    \        if(lst[i]>0) mnl=std::min(mnl,lst[i]);\n        if(lst[i]<0) mxl=std::max(mxl,lst[i]);\n\
    \    }\n    return {mxl,mnl};", "  \n  std::optional<long> a, b;\n  bool pos=false,\
    \ neg=false;\n  for(auto x: lst)\n  {\n    if(x<0)\n    {\n      if(!neg)\n  \
    \    {\n        a=x;\n        neg=true;\n      }\n      else\n      {\n      \
    \  if(x>*a)\n          a=x;\n      }\n    }\n    else if(x>0)\n    {\n      if(!pos)\n\
    \      {\n        b=x;\n        pos=true;\n      }\n      else\n      {\n    \
    \    if(x<*b)\n          b=x;\n      }\n    }\n  }\n  return {a, b};", "\tint\
    \ a = INT_MIN;\n\tint b = INT_MAX;\n\tfor (int i = 0; i < lst.size(); i++) {\n\
    \t\tif (lst[i] > 0 && lst[i] < b) {\n\t\t\tb = lst[i];\n\t\t}\n\t\tif (lst[i]\
    \ < 0 && lst[i] > a) {\n\t\t\ta = lst[i];\n\t\t}\n\t}\n\tif (a == INT_MIN) {\n\
    \t\ta = INT_MAX;\n\t}\n\tif (b == INT_MAX) {\n\t\tb = INT_MIN;\n\t}\n\treturn\
    \ std::make_tuple(a, b);", "  std::optional<long> largestNegative;\n  std::optional<long>\
    \ smallestPositive;\n  if (lst.size() > 0) {\n    largestNegative = std::nullopt;\n\
    \    smallestPositive = std::nullopt;\n    for (auto i : lst) {\n      if (i <\
    \ 0) {\n        if (!largestNegative.has_value() || i > largestNegative.value())\
    \ {\n          largestNegative = i;\n        }\n      } else if (i > 0) {\n  \
    \      if (!smallestPositive.has_value() || i < smallestPositive.value()) {\n\
    \          smallestPositive = i;\n        }\n      }\n    }\n  }\n  return std::make_tuple(largestNegative,\
    \ smallestPositive);", "\nreturn {};", "  std::tuple<std::optional<long>, std::optional<long>>\
    \ result = std::make_tuple(std::nullopt, std::nullopt);\n  if(lst.size() == 0)\
    \ {\n    return result;\n  }\n  for(auto it = lst.begin(); it != lst.end(); it++)\
    \ {\n    auto currentValue = *it;\n    if(currentValue < 0) {\n      auto [largest,\
    \ smallest] = result;\n      if(largest) {\n        if(currentValue > *largest)\
    \ {\n          result = std::make_tuple(currentValue, smallest);\n        }\n\
    \      } else {\n        result = std::make_tuple(currentValue, smallest);\n \
    \     }\n    } else if(currentValue > 0) {\n      auto [largest, smallest] = result;\n\
    \      if(smallest) {\n        if(currentValue < *smallest) {\n          result\
    \ = std::make_tuple(largest, currentValue);\n        }\n      } else {\n     \
    \   result = std::make_tuple(largest, currentValue);\n      }\n    }\n  }\n  return\
    \ result;", "    long min=0,max=0;\n    bool maxFound=false,minFound=false;\n\
    \    for(long a:lst){\n        if(a>0 && !minFound){\n            min=a;\n   \
    \         minFound=true;\n        }\n        if(a<0 && !maxFound){\n         \
    \   max=a;\n            maxFound=true;\n        }\n        if(a>0 && minFound\
    \ && a<min){\n            min=a;\n        }\n        if(a<0 && maxFound && a>max){\n\
    \            max=a;\n        }\n    }\n    if(minFound){\n        return std::make_tuple(std::make_optional(max),std::make_optional(min));\n\
    \    }\n    else{\n        return std::make_tuple(std::nullopt,std::nullopt);\n\
    \    }", "  if (lst.empty()) {\n    return {std::nullopt, std::nullopt};\n  }\n\
    \  std::optional<long> smallest_positive_number;\n  std::optional<long> largest_negative_number;\n\
    \  for (auto const& n : lst) {\n    if (n > 0) {\n      if (!smallest_positive_number)\
    \ {\n        smallest_positive_number = n;\n      } else if (n < *smallest_positive_number)\
    \ {\n        smallest_positive_number = n;\n      }\n    } else if (n < 0) {\n\
    \      if (!largest_negative_number) {\n        largest_negative_number = n;\n\
    \      } else if (n > *largest_negative_number) {\n        largest_negative_number\
    \ = n;\n      }\n    }\n  }\n  return {largest_negative_number, smallest_positive_number};",
  "    std::optional<long> a;\n    std::optional<long> b;\n    for (auto& i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else if (i > 0) {\n        \
    \    if (!b.has_value() || i < b.value()) {\n                b = i;\n        \
    \    }\n        }\n    }\n    return std::make_tuple(a, b);", "    long largest_negative\
    \ = -9999999999;\n    long smallest_positive = 9999999999;\n    bool there_is_negative\
    \ = false;\n    bool there_is_positive = false;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] > 0) {\n            if (lst[i] < smallest_positive)\n\
    \                smallest_positive = lst[i];\n            there_is_positive =\
    \ true;\n        }\n        if (lst[i] < 0) {\n            if (lst[i] > largest_negative)\n\
    \                largest_negative = lst[i];\n            there_is_negative = true;\n\
    \        }\n    }\n    std::optional<long> largest = there_is_negative ? largest_negative\
    \ : std::nullopt;\n    std::optional<long> smallest = there_is_positive ? smallest_positive\
    \ : std::nullopt;\n    return std::make_tuple(largest, smallest);", "\tstd::optional<long>\
    \ largest_negative;\n\tstd::optional<long> smallest_positive;\n\t\n\tfor (auto\
    \ i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (!largest_negative.has_value() || i >\
    \ largest_negative.value()) {\n\t\t\t\tlargest_negative = i;\n\t\t\t}\n\t\t}\n\
    \t\telse if (i > 0) {\n\t\t\tif (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n\t\t\t\tsmallest_positive = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn std::make_tuple(largest_negative,\
    \ smallest_positive);", "    long smallest_positive = 0;\n    long largest_negative\
    \ = 0;\n    bool isNegative = false;\n    bool isPositive = false;\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        if (lst[i] > 0) {\n            if (!isPositive)\
    \ {\n                smallest_positive = lst[i];\n                isPositive =\
    \ true;\n            } else {\n                if (lst[i] < smallest_positive)\
    \ {\n                    smallest_positive = lst[i];\n                }\n    \
    \        }\n        } else if (lst[i] < 0) {\n            if (!isNegative) {\n\
    \                largest_negative = lst[i];\n                isNegative = true;\n\
    \            } else {\n                if (lst[i] > largest_negative) {\n    \
    \                largest_negative = lst[i];\n                }\n            }\n\
    \        }\n    }\n    if (isNegative) {\n        if (isPositive) {\n        \
    \    return std::make_tuple(largest_negative, smallest_positive);\n        } else\
    \ {\n            return std::make_tuple(largest_negative, std::nullopt);\n   \
    \     }\n    } else {\n        if (isPositive) {\n            return std::make_tuple(std::nullopt,\
    \ smallest_positive);\n        } else {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n    }", "    std::optional<long>a=std::nullopt;\n\
    \    std::optional<long>b=std::nullopt;\n    for(int i=0;i<lst.size();i++)\n \
    \   {\n        if(lst[i]<0)\n        {\n            if(!a)\n            {\n  \
    \              a=lst[i];\n            }\n            else\n            {\n   \
    \             if(lst[i]>*a)\n                {\n                    a=lst[i];\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      if(!b)\n            {\n                b=lst[i];\n            }\n     \
    \       else\n            {\n                if(lst[i]<*b)\n                {\n\
    \                    b=lst[i];\n                }\n            }\n        }\n\
    \    }\n    return std::make_tuple(a,b);", "\tlong long largestNegative = INT_MIN;\n\
    \tlong long smallestPositive = INT_MAX;\n\tstd::optional<long> largestNegativeOpt;\n\
    \tstd::optional<long> smallestPositiveOpt;\n\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> tuple;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\t\
    if (lst[i] < 0) {\n\t\t\tif (lst[i] > largestNegative) {\n\t\t\t\tlargestNegative\
    \ = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i] > 0) {\n\t\t\tif (lst[i] < smallestPositive)\
    \ {\n\t\t\t\tsmallestPositive = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (largestNegative\
    \ == INT_MIN) {\n\t\tlargestNegativeOpt = std::nullopt;\n\t}\n\telse {\n\t\tlargestNegativeOpt\
    \ = largestNegative;\n\t}\n\tif (smallestPositive == INT_MAX) {\n\t\tsmallestPositiveOpt\
    \ = std::nullopt;\n\t}\n\telse {\n\t\tsmallestPositiveOpt = smallestPositive;\n\
    \t}\n\tstd::tie(largestNegativeOpt, smallestPositiveOpt) = std::make_tuple(largestNegativeOpt,\
    \ smallestPositiveOpt);\n\treturn std::make_tuple(largestNegativeOpt, smallestPositiveOpt);",
  '    return {};', "    std::sort(lst.begin(), lst.end());\n    int i = 0;\n    while\
    \ (i < lst.size() && lst[i] < 0)\n        i++;\n    std::optional<long> max;\n\
    \    std::optional<long> min;\n    if (i > 0)\n        max = lst[i - 1];\n   \
    \ if (i < lst.size())\n        min = lst[i];\n    return std::make_tuple(max,\
    \ min);", "    // Your code here\n    std::optional<long> a = std::nullopt;\n\
    \    std::optional<long> b = std::nullopt;\n    std::vector<long> neg;\n    std::vector<long>\
    \ pos;\n    for(auto e: lst){\n        if(e < 0){\n            neg.push_back(e);\n\
    \        }else if(e > 0){\n            pos.push_back(e);\n        }\n    }\n \
    \   if(neg.size() > 0){\n        std::sort(neg.begin(), neg.end());\n        a\
    \ = neg[0];\n    }\n    if(pos.size() > 0){\n        std::sort(pos.begin(), pos.end());\n\
    \        b = pos[0];\n    }\n    return std::make_tuple(a, b);", "    long largest_neg\
    \ = std::numeric_limits<long>::lowest();\n    long smallest_pos = std::numeric_limits<long>::max();\n\
    \    for (long num : lst) {\n        if (num < 0) {\n            largest_neg =\
    \ std::max(largest_neg, num);\n        } else if (num > 0) {\n            smallest_pos\
    \ = std::min(smallest_pos, num);\n        }\n    }\n    if (largest_neg == std::numeric_limits<long>::lowest())\
    \ {\n        largest_neg = std::nullopt;\n    }\n    if (smallest_pos == std::numeric_limits<long>::max())\
    \ {\n        smallest_pos = std::nullopt;\n    }\n    return std::make_tuple(largest_neg,\
    \ smallest_pos);", "    if(lst.size() == 0) return {std::nullopt, std::nullopt};\n\
    \    if(lst.size() == 1) return {std::nullopt, std::nullopt};\n    if(lst.size()\
    \ == 2){\n        if(lst[0]>0 && lst[1]<0) return {lst[1], lst[0]};\n        if(lst[0]<0\
    \ && lst[1]>0) return {lst[0], lst[1]};\n        return {std::nullopt, std::nullopt};\n\
    \    }\n    long max = 0;\n    long min = INT_MAX;\n    for(int i = 0; i < lst.size();\
    \ i++){\n        if(lst[i] > 0){\n            if(lst[i] < min) min = lst[i];\n\
    \        }else{\n            if(lst[i] > max) max = lst[i];\n        }\n    }\n\
    \    if(max == 0) return {std::nullopt, min};\n    if(min == INT_MAX) return {max,\
    \ std::nullopt};\n    return {max, min};", "    std::optional<long> negative;\n\
    \    std::optional<long> positive;\n    int count_negative = 0;\n    int count_positive\
    \ = 0;\n    if(lst.size() != 0){\n        for(int i = 0; i < lst.size(); i++){\n\
    \            if(lst[i] < 0){\n                count_negative++;\n            \
    \    if(negative == std::nullopt){\n                    negative = lst[i];\n \
    \               }\n                else if(lst[i] > *negative){\n            \
    \        negative = lst[i];\n                }\n            }\n            else\
    \ if(lst[i] > 0){\n                count_positive++;\n                if(positive\
    \ == std::nullopt){\n                    positive = lst[i];\n                }\n\
    \                else if(lst[i] < *positive){\n                    positive =\
    \ lst[i];\n                }\n            }\n        }\n        if(count_negative\
    \ == 0){\n            negative = std::nullopt;\n        }\n        if(count_positive\
    \ == 0){\n            positive = std::nullopt;\n        }\n    }\n    else{\n\
    \        negative = std::nullopt;\n        positive = std::nullopt;\n    }\n \
    \   return std::make_tuple(negative, positive);", "\tstd::optional<long> a;\n\t\
    std::optional<long> b;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i]\
    \ >= 0) {\n\t\t\tb = lst[i];\n\t\t\tfor (int i = 0; i < lst.size(); i++) {\n\t\
    \t\t\tif (lst[i] >= 0) {\n\t\t\t\t\tif (lst[i] < b) {\n\t\t\t\t\t\tb = lst[i];\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lst[i] < 0) {\n\t\t\ta = lst[i];\n\
    \t\t\tfor (int i = 0; i < lst.size(); i++) {\n\t\t\t\tif (lst[i] < 0) {\n\t\t\t\
    \t\tif (lst[i] > a) {\n\t\t\t\t\t\ta = lst[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn std::make_tuple(a, b);", "    int min = INT_MAX;\n   \
    \ int max = INT_MIN;\n    bool valid = false;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] > 0) {\n            valid = true;\n            if\
    \ (lst[i] < min) {\n                min = lst[i];\n            }\n        }\n\
    \        if (lst[i] < 0) {\n            valid = true;\n            if (lst[i]\
    \ > max) {\n                max = lst[i];\n            }\n        }\n    }\n \
    \   std::optional<long> y = std::make_optional(min);\n    std::optional<long>\
    \ x = std::make_optional(max);\n    if (!valid) {\n        x = std::nullopt;\n\
    \        y = std::nullopt;\n    }\n    return std::make_tuple(x, y);", '    return
    {};', "\tlong s, l;\n\tbool isPositive{ false }, isNegative{ false };\n\tfor (auto\
    \ i : lst) {\n\t\tif (i >= 0) {\n\t\t\tisPositive = true;\n\t\t\ts = i;\n\t\t\t\
    break;\n\t\t}\n\t}\n\tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tisNegative\
    \ = true;\n\t\t\tl = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (isPositive && isNegative)\
    \ {\n\t\tfor (auto i : lst) {\n\t\t\tif (i >= 0) {\n\t\t\t\tif (i < s) {\n\t\t\
    \t\t\ts = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i > l) {\n\t\t\t\t\
    \tl = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { l, s };\n\t}\n\telse if (isPositive)\
    \ {\n\t\tfor (auto i : lst) {\n\t\t\tif (i < s) {\n\t\t\t\ts = i;\n\t\t\t}\n\t\
    \t}\n\t\treturn { std::nullopt, s };\n\t}\n\telse if (isNegative) {\n\t\tfor (auto\
    \ i : lst) {\n\t\t\tif (i > l) {\n\t\t\t\tl = i;\n\t\t\t}\n\t\t}\n\t\treturn {\
    \ l, std::nullopt };\n\t}\n\telse {\n\t\treturn { std::nullopt, std::nullopt };\n\
    \t}", "\tlong min = INT_MAX;\n\tlong max = INT_MIN;\n\tbool pos = false;\n\tbool\
    \ neg = false;\n\tfor (auto & elem : lst) {\n\t\tif (elem > 0) {\n\t\t\tpos =\
    \ true;\n\t\t\tif (elem < min) {\n\t\t\t\tmin = elem;\n\t\t\t}\n\t\t}\n\t\telse\
    \ if (elem < 0) {\n\t\t\tneg = true;\n\t\t\tif (elem > max) {\n\t\t\t\tmax = elem;\n\
    \t\t\t}\n\t\t}\n\t}\n\tif (pos) {\n\t\tif (neg) {\n\t\t\treturn { max, min };\n\
    \t\t}\n\t\telse {\n\t\t\treturn { std::nullopt, min };\n\t\t}\n\t}\n\telse {\n\
    \t\tif (neg) {\n\t\t\treturn { max, std::nullopt };\n\t\t}\n\t\telse {\n\t\t\t\
    return { std::nullopt, std::nullopt };\n\t\t}\n\t}", "    std::optional<long>\
    \ maxNeg, minPos;\n    for (auto i : lst) {\n        if (i < 0) {\n          \
    \  if (!maxNeg.has_value() || i > maxNeg.value()) {\n                maxNeg =\
    \ i;\n            }\n        } else if (i > 0) {\n            if (!minPos.has_value()\
    \ || i < minPos.value()) {\n                minPos = i;\n            }\n     \
    \   }\n    }\n    return {maxNeg, minPos};", "    std::optional<long> small =\
    \ std::nullopt;\n    std::optional<long> big = std::nullopt;\n    for (long i\
    \ : lst) {\n        if (i < 0) {\n            if (!big.has_value() || i > big.value())\
    \ {\n                big = i;\n            }\n        } else {\n            if\
    \ (!small.has_value() || i < small.value()) {\n                small = i;\n  \
    \          }\n        }\n    }\n    return std::make_tuple(big, small);", '',
  "\tstd::tuple<std::optional<long>, std::optional<long>> tup(std::nullopt, std::nullopt);\n\
    \tstd::vector<long> negs;\n\tstd::vector<long> poss;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tnegs.push_back(lst[i]);\n\t\t}\n\t\telse\
    \ if (lst[i] > 0) {\n\t\t\tposs.push_back(lst[i]);\n\t\t}\n\t}\n\tif (negs.size()\
    \ == 0 && poss.size() == 0) {\n\t\treturn tup;\n\t}\n\telse if (negs.size() ==\
    \ 0) {\n\t\ttup = std::make_tuple(std::nullopt, poss[0]);\n\t\tfor (int i = 1;\
    \ i < poss.size(); i++) {\n\t\t\tif (poss[i] < std::get<1>(tup)) {\n\t\t\t\tstd::get<1>(tup)\
    \ = poss[i];\n\t\t\t}\n\t\t}\n\t\treturn tup;\n\t}\n\telse if (poss.size() ==\
    \ 0) {\n\t\ttup = std::make_tuple(negs[0], std::nullopt);\n\t\tfor (int i = 1;\
    \ i < negs.size(); i++) {\n\t\t\tif (negs[i] > std::get<0>(tup)) {\n\t\t\t\tstd::get<0>(tup)\
    \ = negs[i];\n\t\t\t}\n\t\t}\n\t\treturn tup;\n\t}\n\telse {\n\t\ttup = std::make_tuple(negs[0],\
    \ poss[0]);\n\t\tfor (int i = 1; i < negs.size(); i++) {\n\t\t\tif (negs[i] >\
    \ std::get<0>(tup)) {\n\t\t\t\tstd::get<0>(tup) = negs[i];\n\t\t\t}\n\t\t}\n\t\
    \tfor (int i =", "\tstd::optional<long> min_positive = std::nullopt;\n\tstd::optional<long>\
    \ max_negative = std::nullopt;\n\tfor (long i : lst) {\n\t\tif (i < 0) {\n\t\t\
    \tif (!max_negative || i > *max_negative) {\n\t\t\t\tmax_negative = i;\n\t\t\t\
    }\n\t\t}\n\t\telse if (i > 0) {\n\t\t\tif (!min_positive || i < *min_positive)\
    \ {\n\t\t\t\tmin_positive = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(max_negative,\
    \ min_positive);", "\t// TODO: implementation\n\tstd::optional<long> largest =\
    \ std::nullopt;\n\tstd::optional<long> smallest = std::nullopt;\n\tif(lst.size()==0)\n\
    \t\treturn {largest,smallest};\n\tfor(int i=0;i<lst.size();i++)\n\t{\n\t\tif(lst[i]>0)\n\
    \t\t{\n\t\t\tif(smallest == std::nullopt)\n\t\t\t\tsmallest = lst[i];\n\t\t\t\
    else if(lst[i]<*smallest)\n\t\t\t\tsmallest = lst[i];\n\t\t}\n\t\telse if(lst[i]<0)\n\
    \t\t{\n\t\t\tif(largest == std::nullopt)\n\t\t\t\tlargest = lst[i];\n\t\t\telse\
    \ if(lst[i]>*largest)\n\t\t\t\tlargest = lst[i];\n\t\t}\n\t}\n\treturn {largest,smallest};",
  "  auto it = std::max_element(lst.begin(), lst.end());\n  auto it2 = std::min_element(lst.begin(),\
    \ lst.end());\n  if (*it < 0 && *it2 > 0) {\n    return std::make_tuple(std::optional<long>(*it),\
    \ std::optional<long>(*it2));\n  }\n  else if (*it < 0 && *it2 < 0) {\n    return\
    \ std::make_tuple(std::optional<long>(*it), std::nullopt);\n  }\n  else if (*it\
    \ > 0 && *it2 > 0) {\n    return std::make_tuple(std::nullopt, std::optional<long>(*it2));\n\
    \  }\n  else if (*it == 0 && *it2 == 0) {\n    return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n  }\n  else {\n    return std::make_tuple(std::nullopt, std::nullopt);\n\
    \  }", "  auto neg = std::none;\n  auto pos = std::none;\n  if(lst.size() == 0)\n\
    \    return {neg, pos};\n  for(auto x : lst) {\n    if(x < 0) {\n      if(neg.has_value())\
    \ {\n        if(x > neg.value())\n          neg = x;\n      }\n      else\n  \
    \      neg = x;\n    }\n    else if(x > 0) {\n      if(pos.has_value()) {\n  \
    \      if(x < pos.value())\n          pos = x;\n      }\n      else\n        pos\
    \ = x;\n    }\n  }\n  return {neg, pos};", "    std::optional<long> a = std::nullopt;\n\
    \    std::optional<long> b = std::nullopt;\n    if(lst.size() == 0)\n        return\
    \ std::make_tuple(a, b);\n    for(int i = 0; i < lst.size(); i++) {\n        if(lst[i]\
    \ < 0) {\n            if(a == std::nullopt)\n                a = lst[i];\n   \
    \         else if(lst[i] > *a)\n                a = lst[i];\n        }\n     \
    \   else if(lst[i] > 0) {\n            if(b == std::nullopt)\n               \
    \ b = lst[i];\n            else if(lst[i] < *b)\n                b = lst[i];\n\
    \        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ l= std::nullopt;\n    std::optional<long> s= std::nullopt;\n    for(int i=0;i<lst.size();i++){\n\
    \        if(lst[i]>0 && !s.has_value()){\n            s = lst[i];\n        }\n\
    \        if(lst[i]<0 && !l.has_value()){\n            l = lst[i];\n        }\n\
    \        if(lst[i]<0 && l.has_value()){\n            if(lst[i]>*l){\n        \
    \        l = lst[i];\n            }\n        }\n        if(lst[i]>0 && s.has_value()){\n\
    \            if(lst[i]<*s){\n                s = lst[i];\n            }\n    \
    \    }\n    }\n    return std::make_tuple(l,s);", "    long largest = 0;\n   \
    \ long smallest = 0;\n    bool isNegative = false;\n    bool isPositive = false;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n     \
    \       if (lst[i] > largest) {\n                largest = lst[i];\n         \
    \       isNegative = true;\n            }\n        }\n        if (lst[i] > 0)\
    \ {\n            if (isPositive == false) {\n                smallest = lst[i];\n\
    \                isPositive = true;\n            }\n            if (lst[i] < smallest)\
    \ {\n                smallest = lst[i];\n            }\n        }\n    }\n   \
    \ if (isNegative) {\n        return std::make_tuple(largest, smallest);\n    }\n\
    \    return std::make_tuple(std::nullopt, smallest);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result = {None, None};\n    int first = 0;\n    int second\
    \ = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n\
    \            if (lst[i] > first) {\n                first = lst[i];\n        \
    \    }\n        }\n        if (lst[i] > 0) {\n            if (second == 0) {\n\
    \                second = lst[i];\n            }\n            if (lst[i] < second)\
    \ {\n                second = lst[i];\n            }\n        }\n    }\n    if\
    \ (first == 0) {\n        result = {None, second};\n    } else if (second == 0)\
    \ {\n        result = {first, None};\n    } else {\n        result = {first, second};\n\
    \    }\n    return result;", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result = {std::nullopt, std::nullopt};\n    std::sort(lst.begin(), lst.end());\n\
    \    if (lst.empty()) {\n        return result;\n    } else if (lst.size() ==\
    \ 1) {\n        if (lst[0] < 0) {\n            std::get<0>(result) = lst[0];\n\
    \        } else if (lst[0] > 0) {\n            std::get<1>(result) = lst[0];\n\
    \        }\n        return result;\n    }\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < 0) {\n            std::get<0>(result) = lst[i];\n\
    \        } else if (lst[i] > 0) {\n            std::get<1>(result) = lst[i];\n\
    \            break;\n        }\n    }\n    return result;", "    if(lst.size()\
    \ == 0)\n    {\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    }\n    std::sort(lst.begin(), lst.end());\n    std::optional<long> smallest\
    \ = std::nullopt;\n    std::optional<long> largest = std::nullopt;\n    for(auto\
    \ value : lst)\n    {\n        if(value > 0)\n        {\n            smallest\
    \ = value;\n            break;\n        }\n    }\n    for(auto value : lst)\n\
    \    {\n        if(value < 0)\n        {\n            largest = value;\n     \
    \   }\n    }\n    return std::make_tuple(largest, smallest);", "    std::optional<long>\
    \ largest;\n    std::optional<long> smallest;\n    bool has_lst=true;\n    if(lst.size()==0){\n\
    \        has_lst=false;\n    }\n    else{\n        std::sort(lst.begin(),lst.end());\n\
    \        if(lst[0]>=0){\n            has_lst=false;\n        }\n        if(lst[lst.size()-1]<=0){\n\
    \            has_lst=false;\n        }\n    }\n    if(has_lst){\n        for(int\
    \ i=0;i<lst.size();i++){\n            if(lst[i]<0){\n                largest=lst[i];\n\
    \            }\n            else{\n                smallest=lst[i];\n        \
    \        break;\n            }\n        }\n    }\n    return std::make_tuple(largest,smallest);",
  "\t// C++17 code\n\tauto [zero, first, second] = std::partition(std::begin(lst),\
    \ std::end(lst), [](long a) {return a == 0; });\n\tif (first == zero && second\
    \ == std::end(lst)) {\n\t\treturn {std::nullopt, std::nullopt};\n\t}\n\tif (first\
    \ == zero) {\n\t\treturn {std::nullopt, *std::min_element(second, std::end(lst))};\n\
    \t}\n\tif (second == std::end(lst)) {\n\t\treturn {*std::max_element(first, zero),\
    \ std::nullopt};\n\t}\n\treturn {*std::max_element(first, zero), *std::min_element(second,\
    \ std::end(lst))};", "  auto const it_neg = std::max_element(std::begin(lst),\
    \ std::end(lst), [](long a, long b) {\n    return a < 0 && b < 0 ? a > b : false;\n\
    \  });\n  auto const it_pos = std::min_element(std::begin(lst), std::end(lst),\
    \ [](long a, long b) {\n    return a > 0 && b > 0 ? a < b : false;\n  });\n  std::optional<long>\
    \ neg =\n    it_neg != std::end(lst) ? std::optional<long>{*it_neg} : std::nullopt;\n\
    \  std::optional<long> pos =\n    it_pos != std::end(lst) ? std::optional<long>{*it_pos}\
    \ : std::nullopt;\n  return std::make_tuple(neg, pos);", "\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> tp1;\n\tstd::tuple<std::optional<long>, std::optional<long>>\
    \ tp2;\n\tstd::optional<long> a;\n\tstd::optional<long> b;\n\t// return std::make_tuple(std::optional<long>(-3),\
    \ std::optional<long>(2));\n\tint count = 0;\n\tstd::sort(lst.begin(), lst.end());\n\
    \tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tcount++;\n\
    \t\t\tb = lst[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = lst.size() - 1; i\
    \ >= 0; i--) {\n\t\tif (lst[i] < 0) {\n\t\t\tcount++;\n\t\t\ta = lst[i];\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\tif (count == 2) {\n\t\ttp1 = std::make_tuple(a, b);\n\t\
    \treturn tp1;\n\t}\n\tif (count == 1) {\n\t\tif (a == 0) {\n\t\t\ttp2 = std::make_tuple(std::optional<long>{},\
    \ b);\n\t\t\treturn tp2;\n\t\t}\n\t\telse {\n\t\t\ttp2 = std::make_tuple(a, std::optional<long>{});\n\
    \t\t\treturn tp2;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\ttp2 = std::make_tuple(std::optional<long>{},\
    \ std::optional<long>{});\n\t\treturn tp2;\n\t}", "  std::optional<long> largestNegative;\n\
    \  std::optional<long> smallestPositive;\n  for (const auto &x : lst) {\n    if\
    \ (x < 0) {\n      if (!largestNegative.has_value() || x > largestNegative.value())\
    \ {\n        largestNegative = x;\n      }\n    } else if (x > 0) {\n      if\
    \ (!smallestPositive.has_value() || x < smallestPositive.value()) {\n        smallestPositive\
    \ = x;\n      }\n    }\n  }\n  return std::make_tuple(largestNegative, smallestPositive);",
  "  \n    if(lst.size() == 0)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    else if(lst.size() == 1)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    else\n    {\n        std::vector<long> negative, positive;\n        for(int\
    \ i = 0; i < lst.size(); i++)\n        {\n            if(lst[i] < 0)\n       \
    \         negative.push_back(lst[i]);\n            else if(lst[i] > 0)\n     \
    \           positive.push_back(lst[i]);\n        }\n        std::sort(negative.begin(),\
    \ negative.end());\n        std::sort(positive.begin(), positive.end());\n   \
    \     if(negative.size() == 0 && positive.size() == 0)\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        else if(negative.size() == 0)\n            return std::make_tuple(std::nullopt,\
    \ positive[0]);\n        else if(positive.size() == 0)\n            return std::make_tuple(negative[negative.size()\
    \ - 1], std::nullopt);\n        else\n            return std::make_tuple(negative[negative.size()\
    \ - 1], positive[0]);\n    }", "    // Your code here!\n    return {};", "   \
    \ std::optional<long> a{}, b{};\n    for (auto i : lst) {\n        if (i >= 0\
    \ && !b.has_value()) {\n            b = i;\n        }\n        if (i < 0 && !a.has_value())\
    \ {\n            a = i;\n        }\n        if (i >= 0 && i < b) {\n         \
    \   b = i;\n        }\n        if (i < 0 && i > a) {\n            a = i;\n   \
    \     }\n    }\n    return {a, b};", "\t// your code goes here\n\tlong min = INT_MAX;\n\
    \tlong max = INT_MIN;\n\tbool pos = false;\n\tbool neg = false;\n\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n\tif (lst.size() == 0) {\n\t\tresult = std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\t\treturn result;\n\t}\n\tfor (long n : lst) {\n\t\tif (n >=\
    \ 0) {\n\t\t\tpos = true;\n\t\t\tif (n < min) {\n\t\t\t\tmin = n;\n\t\t\t}\n\t\
    \t}\n\t\telse {\n\t\t\tneg = true;\n\t\t\tif (n > max) {\n\t\t\t\tmax = n;\n\t\
    \t\t}\n\t\t}\n\t}\n\tstd::optional<long> op;\n\tstd::optional<long> on;\n\tif\
    \ (pos) {\n\t\top = min;\n\t}\n\tif (neg) {\n\t\ton = max;\n\t}\n\tresult = std::make_tuple(on,\
    \ op);\n\treturn result;", "\tif (lst.size() == 0)\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\tstd::optional<long> small;\n\tstd::optional<long> big;\n\t\
    for (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tif (!small.has_value())\n\
    \t\t\t\tsmall = lst[i];\n\t\t\tif (lst[i] < small.value())\n\t\t\t\tsmall = lst[i];\n\
    \t\t}\n\t\tif (lst[i] < 0) {\n\t\t\tif (!big.has_value())\n\t\t\t\tbig = lst[i];\n\
    \t\t\tif (lst[i] > big.value())\n\t\t\t\tbig = lst[i];\n\t\t}\n\t}\n\treturn std::make_tuple(big,\
    \ small);", "  // write code here\n  long smallest = -1;\n  long largest = -1;\n\
    \  for(int i = 0; i < lst.size(); i++) {\n    if(lst[i] > 0) {\n      if(smallest\
    \ == -1) {\n        smallest = lst[i];\n      } else {\n        smallest = std::min(smallest,\
    \ lst[i]);\n      }\n    } else if(lst[i] < 0) {\n      if(largest == -1) {\n\
    \        largest = lst[i];\n      } else {\n        largest = std::max(largest,\
    \ lst[i]);\n      }\n    }\n  }\n  if(smallest == -1) {\n    smallest = std::nullopt;\n\
    \  }\n  if(largest == -1) {\n    largest = std::nullopt;\n  }\n  return std::make_tuple(largest,\
    \ smallest);", "    long max;\n    long min;\n    std::optional<long> a;\n   \
    \ std::optional<long> b;\n    if(lst.size() == 0)\n        return make_tuple(a,b);\n\
    \    if(lst.size() == 1){\n        if(lst[0] == 0)\n            return make_tuple(a,b);\n\
    \        if(lst[0] < 0)\n            a = lst[0];\n        else\n            b\
    \ = lst[0];\n        return make_tuple(a,b);\n    }\n    if(lst[0] < 0)\n    \
    \    max = lst[0];\n    if(lst[0] > 0)\n        min = lst[0];\n    for(int i =\
    \ 1; i < lst.size(); i++){\n        if(lst[i] < 0){\n            if(lst[i] > max)\n\
    \                max = lst[i];\n        }\n        if(lst[i] > 0){\n         \
    \   if(lst[i] < min)\n                min = lst[i];\n        }\n    }\n    if(max\
    \ < 0)\n        a = max;\n    if(min > 0)\n        b = min;\n    return make_tuple(a,b);",
  "\tstd::optional<long> largest_negative;\n\tstd::optional<long> smallest_positive;\n\
    \tfor (auto item : lst) {\n\t\tif (item < 0) {\n\t\t\tif (!largest_negative.has_value())\
    \ {\n\t\t\t\tlargest_negative = item;\n\t\t\t}\n\t\t\telse if (item > largest_negative.value())\
    \ {\n\t\t\t\tlargest_negative = item;\n\t\t\t}\n\t\t}\n\t\telse if (item > 0)\
    \ {\n\t\t\tif (!smallest_positive.has_value()) {\n\t\t\t\tsmallest_positive =\
    \ item;\n\t\t\t}\n\t\t\telse if (item < smallest_positive.value()) {\n\t\t\t\t\
    smallest_positive = item;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(largest_negative,\
    \ smallest_positive);", "    if(lst.size()==0)\n    {\n        return {std::nullopt,std::nullopt};\n\
    \    }\n    long max=*max_element(lst.begin(),lst.end());\n    long min=*min_element(lst.begin(),lst.end());\n\
    \    if(max<0||min>0)\n    {\n        return {max,min};\n    }\n    else\n   \
    \ {\n        return {std::nullopt,std::nullopt};\n    }", "    // First let's\
    \ sort the list\n    std::sort(lst.begin(), lst.end());\n    // Now we need to\
    \ create two variables, one to store the largest negative\n    // and one to store\
    \ the smallest positive\n    std::optional<long> largest_negative = std::nullopt;\n\
    \    std::optional<long> smallest_positive = std::nullopt;\n    for (auto num\
    \ : lst) {\n        if (num < 0) {\n            if (!largest_negative) {\n   \
    \             largest_negative = num;\n            } else if (num > *largest_negative)\
    \ {\n                largest_negative = num;\n            }\n        } else if\
    \ (num > 0) {\n            if (!smallest_positive) {\n                smallest_positive\
    \ = num;\n            } else if (num < *smallest_positive) {\n               \
    \ smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "  auto largest = *std::max_element(lst.begin(), lst.end());\n\
    \  auto smallest = *std::min_element(lst.begin(), lst.end());\n  std::tuple<std::optional<long>,\
    \ std::optional<long>> res;\n  if (largest < 0) {\n    res = std::make_tuple(largest,\
    \ std::nullopt);\n  } else if (smallest > 0) {\n    res = std::make_tuple(std::nullopt,\
    \ smallest);\n  } else {\n    res = std::make_tuple(std::nullopt, std::nullopt);\n\
    \  }\n  return res;", "    std::optional<long> a, b;\n    for (long l : lst) {\n\
    \        if (l > 0) {\n            if (!b.has_value() || l < b.value()) {\n  \
    \              b = l;\n            }\n        } else if (l < 0) {\n          \
    \  if (!a.has_value() || l > a.value()) {\n                a = l;\n          \
    \  }\n        }\n    }\n    return {a, b};", "  if (lst.empty()) return {std::nullopt,\
    \ std::nullopt};\n  auto cmp = [](long a, long b) { return std::abs(a) < std::abs(b);\
    \ };\n  auto [max, min] = std::minmax_element(lst.begin(), lst.end(), cmp);\n\
    \  if (*max > 0) max = std::nullopt;\n  if (*min < 0) min = std::nullopt;\n  return\
    \ {*max, *min};", "\treturn {};", "    // Write your code here\n    return {};",
  '  return std::make_tuple(None, None);', "    if(lst.size() == 0) return {std::nullopt,\
    \ std::nullopt};\n    if(lst.size() == 1) return {std::nullopt, std::nullopt};\n\
    \    std::sort(lst.begin(), lst.end());\n    int a = 0, b = 0;\n    for(int i\
    \ = 0; i < lst.size(); i++) {\n        if(lst[i] > 0) {\n            a = lst[i-1];\n\
    \            b = lst[i];\n            break;\n        }\n    }\n    return {a,\
    \ b};", "\t// TODO\n\tstd::optional<long> large = {};\n\tstd::optional<long> small\
    \ = {};\n\tstd::vector<long> neg, pos;\n\tfor (int i = 0; i < lst.size(); i++)\
    \ {\n\t\tif (lst[i] < 0) {\n\t\t\tneg.push_back(lst[i]);\n\t\t}\n\t\telse if (lst[i]\
    \ > 0) {\n\t\t\tpos.push_back(lst[i]);\n\t\t}\n\t}\n\tif (neg.size() > 0) {\n\t\
    \tlarge = neg[0];\n\t\tfor (int i = 0; i < neg.size(); i++) {\n\t\t\tif (neg[i]\
    \ > large) {\n\t\t\t\tlarge = neg[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (pos.size() >\
    \ 0) {\n\t\tsmall = pos[0];\n\t\tfor (int i = 0; i < pos.size(); i++) {\n\t\t\t\
    if (pos[i] < small) {\n\t\t\t\tsmall = pos[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ std::make_tuple(large, small);", "    std::optional<long> largest_negative =\
    \ std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n \
    \   int neg_count = 0;\n    int pos_count = 0;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < 0) {\n            if (neg_count == 0) {\n     \
    \           largest_negative = lst[i];\n                neg_count++;\n       \
    \     }\n            else if (lst[i] > largest_negative) {\n                largest_negative\
    \ = lst[i];\n            }\n        }\n        else if (lst[i] > 0) {\n      \
    \      if (pos_count == 0) {\n                smallest_positive = lst[i];\n  \
    \              pos_count++;\n            }\n            else if (lst[i] < smallest_positive)\
    \ {\n                smallest_positive = lst[i];\n            }\n        }\n \
    \   }\n    std::tuple<std::optional<long>, std::optional<long>> res(largest_negative,\
    \ smallest_positive);\n    return res;", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> tuple;\n    std::optional<long> max;\n    std::optional<long>\
    \ min;\n    if(lst.size()==0){\n        return {max,min};\n    }\n    for(auto\
    \ x:lst){\n        if(x>0){\n            if(min){\n                if(x<*min){\n\
    \                    min=x;\n                }\n            }\n            else{\n\
    \                min=x;\n            }\n        }\n        else if(x<0){\n   \
    \         if(max){\n                if(x>*max){\n                    max=x;\n\
    \                }\n            }\n            else{\n                max=x;\n\
    \            }\n        }\n    }\n    tuple= {max,min};\n    return tuple;", " \
    \   std::optional<long> largestNegative;\n    std::optional<long> smallestPositive;\n\
    \    for (auto& elem : lst) {\n        if (elem < 0) {\n            if (!largestNegative.has_value()\
    \ || elem > largestNegative.value()) {\n                largestNegative = elem;\n\
    \            }\n        } else if (elem > 0) {\n            if (!smallestPositive.has_value()\
    \ || elem < smallestPositive.value()) {\n                smallestPositive = elem;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largestNegative,\
    \ smallestPositive);", "    if(lst.size() == 0) return {std::nullopt, std::nullopt};\n\
    \    if(lst.size() == 1 && lst[0] == 0) return {std::nullopt, std::nullopt};\n\
    \    if(lst.size() == 1 && lst[0] != 0) return {std::nullopt, lst[0]};\n    long\
    \ max_neg = 0;\n    bool has_neg = false;\n    long min_pos = 1000000;\n    bool\
    \ has_pos = false;\n    for(int i = 0; i < lst.size(); i++){\n        if(lst[i]\
    \ < 0){\n            has_neg = true;\n            if(max_neg < lst[i]){\n    \
    \            max_neg = lst[i];\n            }\n        }\n        if(lst[i] >\
    \ 0){\n            has_pos = true;\n            if(min_pos > lst[i]){\n      \
    \          min_pos = lst[i];\n            }\n        }\n    }\n    if(has_neg\
    \ && has_pos){\n        return {max_neg, min_pos};\n    }\n    if(has_neg && !has_pos){\n\
    \        return {max_neg, std::nullopt};\n    }\n    if(!has_neg && has_pos){\n\
    \        return {std::nullopt, min_pos};\n    }\n    if(!has_neg && !has_pos){\n\
    \        return {std::nullopt, std::nullopt};\n    }\n    return {max_neg, min_pos};",
  "    if(lst.size() == 0) return {std::nullopt, std::nullopt};\n    if(lst.size()\
    \ == 1) return {std::nullopt, std::nullopt};\n    long max_neg = INT_MIN;\n  \
    \  long min_pos = INT_MAX;\n    for(long i = 0; i < lst.size(); i++){\n      \
    \  if(lst[i] < 0 && lst[i] > max_neg) max_neg = lst[i];\n        if(lst[i] > 0\
    \ && lst[i] < min_pos) min_pos = lst[i];\n    }\n    if(max_neg == INT_MIN) return\
    \ {std::nullopt, min_pos};\n    if(min_pos == INT_MAX) return {max_neg, std::nullopt};\n\
    \    return {max_neg, min_pos};", "\tif (lst.size() == 0) {\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\t}\n\tlong large = -INFINITY;\n\tlong small = INFINITY;\n\t\
    for (long x : lst) {\n\t\tif (x > 0 && x < small) {\n\t\t\tsmall = x;\n\t\t}\n\
    \t\tif (x < 0 && x > large) {\n\t\t\tlarge = x;\n\t\t}\n\t}\n\tif (large == -INFINITY)\
    \ {\n\t\tlarge = std::nullopt;\n\t}\n\tif (small == INFINITY) {\n\t\tsmall = std::nullopt;\n\
    \t}\n\treturn std::make_tuple(large, small);", "\tint large = -1, small = 1;\n\
    \tbool hasPositive = false, hasNegative = false;\n\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> answer;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\t\
    if (lst[i] > 0) {\n\t\t\thasPositive = true;\n\t\t\tif (lst[i] < small) {\n\t\t\
    \t\tsmall = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\thasNegative\
    \ = true;\n\t\t\tif (lst[i] > large) {\n\t\t\t\tlarge = lst[i];\n\t\t\t}\n\t\t\
    }\n\t}\n\tif (hasPositive) {\n\t\tstd::get<1>(answer) = small;\n\t}\n\telse {\n\
    \t\tstd::get<1>(answer) = {};\n\t}\n\tif (hasNegative) {\n\t\tstd::get<0>(answer)\
    \ = large;\n\t}\n\telse {\n\t\tstd::get<0>(answer) = {};\n\t}\n\treturn answer;",
  "\t// If the vector is empty, return None.\n\tif (lst.empty()) {\n\t\treturn { std::nullopt,\
    \ std::nullopt };\n\t}\n\t// Sort the array, and we will just search the two extremes.\n\
    \tstd::sort(lst.begin(), lst.end());\n\t// If we can get the first element and\
    \ it is negative,\n\t// we take it as the largest negative integer.\n\tstd::optional<long>\
    \ largest_negative;\n\tif (lst.front() < 0) {\n\t\tlargest_negative = lst.front();\n\
    \t}\n\t// If we can get the last element and it is positive,\n\t// we take it\
    \ as the smallest positive integer.\n\tstd::optional<long> smallest_positive;\n\
    \tif (lst.back() > 0) {\n\t\tsmallest_positive = lst.back();\n\t}\n\treturn {\
    \ largest_negative, smallest_positive };", "\tlong max_neg = 0;\n\tlong min_pos\
    \ = 0;\n\tlong i;\n\tbool n = false;\n\tbool p = false;\n\tfor (i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tn = true;\n\t\t\tif (lst[i] > max_neg)\n\
    \t\t\t\tmax_neg = lst[i];\n\t\t}\n\t\telse if (lst[i] > 0) {\n\t\t\tp = true;\n\
    \t\t\tif (lst[i] < min_pos)\n\t\t\t\tmin_pos = lst[i];\n\t\t}\n\t}\n\tif (n)\n\
    \t\treturn std::make_tuple(max_neg, min_pos);\n\telse if (p)\n\t\treturn std::make_tuple(0,\
    \ min_pos);\n\telse\n\t\treturn std::make_tuple(0, 0);", "    std::optional<long>\
    \ a = std::nullopt;\n    std::optional<long> b = std::nullopt;\n    for (auto\
    \ elem : lst) {\n        if (elem < 0 && (!a.has_value() || elem > *a)) {\n  \
    \          a = elem;\n        }\n        if (elem > 0 && (!b.has_value() || elem\
    \ < *b)) {\n            b = elem;\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", '    return {};', "    long min = INT_MAX;\n    long max = INT_MIN;\n\
    \    bool pos = false;\n    bool neg = false;\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] > 0) {\n            pos = true;\n            if (lst[i]\
    \ < min) {\n                min = lst[i];\n            }\n        }\n        if\
    \ (lst[i] < 0) {\n            neg = true;\n            if (lst[i] > max) {\n \
    \               max = lst[i];\n            }\n        }\n    }\n    std::optional<long>\
    \ pos_min = std::nullopt;\n    std::optional<long> neg_max = std::nullopt;\n \
    \   if (pos) {\n        pos_min = min;\n    }\n    if (neg) {\n        neg_max\
    \ = max;\n    }\n    return std::make_tuple(neg_max, pos_min);", "  std::optional<long>\
    \ large_neg;\n  std::optional<long> small_pos;\n  for (long elem : lst) {\n  \
    \  if (elem < 0) {\n      if (!large_neg || elem > *large_neg) {\n        large_neg\
    \ = elem;\n      }\n    } else if (elem > 0) {\n      if (!small_pos || elem <\
    \ *small_pos) {\n        small_pos = elem;\n      }\n    }\n  }\n  return std::make_tuple(large_neg,\
    \ small_pos);", "\treturn { std::nullopt, std::nullopt };", "  std::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n  auto max = std::max_element(lst.begin(), lst.end());\n\
    \  auto min = std::min_element(lst.begin(), lst.end());\n  bool found = false;\n\
    \  if(max != lst.end()){\n    if(*max >= 0){\n      get<0>(result) = std::nullopt;\n\
    \    }else{\n      get<0>(result) = *max;\n      found = true;\n    }\n  }\n \
    \ if(min != lst.end()){\n    if(*min <= 0){\n      get<1>(result) = std::nullopt;\n\
    \    }else{\n      get<1>(result) = *min;\n      found = true;\n    }\n  }\n \
    \ if(!found){\n    get<0>(result) = std::nullopt;\n    get<1>(result) = std::nullopt;\n\
    \  }\n  return result;", "\tstd::optional<long> smallest;\n\tstd::optional<long>\
    \ largest;\n\tlong max = LONG_MIN;\n\tlong min = LONG_MAX;\n\tfor (long i : lst)\
    \ {\n\t\tif (i < 0) {\n\t\t\tif (i > max) {\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\
    \t\telse if (i > 0) {\n\t\t\tif (i < min) {\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t}\n\
    \t}\n\tif (max != LONG_MIN) {\n\t\tlargest = max;\n\t}\n\tif (min != LONG_MAX)\
    \ {\n\t\tsmallest = min;\n\t}\n\treturn std::make_tuple(largest, smallest);",
  "    if(lst.size() == 0)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if(lst.size() == 1)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if(lst.size() == 2)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if(lst.size() > 2)\n    {\n        std::vector<long> vec;\n        for(int\
    \ i = 0; i < lst.size(); i++)\n        {\n            if(lst[i] < 0)\n       \
    \         vec.push_back(lst[i]);\n        }\n        if(vec.size() != 0)\n   \
    \     {\n            long ma = vec[0];\n            for(int i = 0; i < vec.size();\
    \ i++)\n            {\n                if(vec[i] > ma)\n                    ma\
    \ = vec[i];\n            }\n            std::vector<long> vec1;\n            for(int\
    \ i = 0; i < lst.size(); i++)\n            {\n                if(lst[i] > 0)\n\
    \                    vec1.push_back(lst[i]);\n            }\n            if(vec1.size()\
    \ != 0)\n            {\n                long mi = vec1[0];\n                for(int\
    \ i = 0; i < vec1.size(); i++)\n                {\n                    if(vec1[i]\
    \ < mi)\n                        mi = vec1[i];\n                }\n          \
    \      return std::make_tuple(ma, mi);\n            }\n            else\n    \
    \            return std::make_tuple(ma, std::nullopt);\n        }\n        else\n\
    \        {\n            std::vector<long> vec1;\n            for(int i = 0; i\
    \ < lst.size(); i++)\n            {\n                if(lst[i] > 0)\n        \
    \            vec1.push_back(lst[i]);\n            }\n            if(vec1.size()\
    \ != 0)\n            {\n                long mi = vec1[0];\n                for(int\
    \ i = 0; i < vec1.", "  std::optional<long> largest_of_negative_integers, smallest_of_positive_integers;\n\
    \  for (auto &element : lst) {\n    if (element < 0) {\n      if (!largest_of_negative_integers.has_value()\
    \ || largest_of_negative_integers.value() < element) {\n        largest_of_negative_integers\
    \ = element;\n      }\n    } else if (element > 0) {\n      if (!smallest_of_positive_integers.has_value()\
    \ || smallest_of_positive_integers.value() > element) {\n        smallest_of_positive_integers\
    \ = element;\n      }\n    }\n  }\n  return std::make_tuple(largest_of_negative_integers,\
    \ smallest_of_positive_integers);", "    std::optional<long> largest_neg = std::nullopt;\n\
    \    std::optional<long> smallest_pos = std::nullopt;\n    for (int i = 0; i <\
    \ lst.size(); i++) {\n        if (lst[i] < 0) {\n            if (largest_neg ==\
    \ std::nullopt) {\n                largest_neg = lst[i];\n            } else if\
    \ (lst[i] > *largest_neg) {\n                largest_neg = lst[i];\n         \
    \   }\n        } else if (lst[i] > 0) {\n            if (smallest_pos == std::nullopt)\
    \ {\n                smallest_pos = lst[i];\n            } else if (lst[i] < *smallest_pos)\
    \ {\n                smallest_pos = lst[i];\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_neg, smallest_pos);", "  std::tuple<std::optional<long>,\
    \ std::optional<long>> out {std::nullopt, std::nullopt};\n  long min = LONG_MAX;\n\
    \  long max = LONG_MIN;\n  for (auto i : lst) {\n    if (i > 0) {\n      if (i\
    \ < min) {\n        min = i;\n      }\n    } else if (i < 0) {\n      if (i >\
    \ max) {\n        max = i;\n      }\n    }\n  }\n  if (min != LONG_MAX) {\n  \
    \  std::get<1>(out) = min;\n  }\n  if (max != LONG_MIN) {\n    std::get<0>(out)\
    \ = max;\n  }\n  return out;", "\tstd::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n\tstd::optional<long> a, b;\n\tfor (auto it : lst) {\n\t\tif (it <\
    \ 0) {\n\t\t\tif (!a.has_value()) {\n\t\t\t\ta = it;\n\t\t\t}\n\t\t\telse {\n\t\
    \t\t\tif (it > a.value()) {\n\t\t\t\t\ta = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\
    else if (it > 0) {\n\t\t\tif (!b.has_value()) {\n\t\t\t\tb = it;\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\tif (it < b.value()) {\n\t\t\t\t\tb = it;\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\tresult = { a, b };\n\treturn result;", "\tint n = lst.size();\n\
    \tlong max = LONG_MIN;\n\tlong min = LONG_MAX;\n\tfor (int i = 0; i < n; i++)\
    \ {\n\t\tif (lst[i] > 0) {\n\t\t\tif (lst[i] < min) {\n\t\t\t\tmin = lst[i];\n\
    \t\t\t}\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\tif (lst[i] > max) {\n\t\t\t\t\
    max = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (max == LONG_MIN || min == LONG_MAX)\
    \ {\n\t\treturn std::make_tuple(std::nullopt, std::nullopt);\n\t}\n\telse {\n\t\
    \treturn std::make_tuple(std::optional<long>(max), std::optional<long>(min));\n\
    \t}", "\tlong largest, smallest;\n\tif (lst.size() == 0)\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\telse if (lst.size() == 1)\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\tlargest = smallest = lst[0];\n\tfor (long i = 1; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tif (lst[i] > largest) {\n\t\t\t\tlargest\
    \ = lst[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (lst[i] < smallest) {\n\t\t\t\
    \tsmallest = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (largest == smallest && lst[0]\
    \ < 0)\n\t\treturn std::make_tuple(std::nullopt, lst[0]);\n\telse if (largest\
    \ == smallest && lst[0] > 0)\n\t\treturn std::make_tuple(lst[0], std::nullopt);\n\
    \treturn std::make_tuple(largest, smallest);", "\tif (lst.size() == 0)\n\t\treturn\
    \ { std::nullopt, std::nullopt };\n\tlong largest = INT_MIN;\n\tlong smallest\
    \ = INT_MAX;\n\tfor (auto i : lst) {\n\t\tif (i < 0)\n\t\t\tlargest = std::max(largest,\
    \ i);\n\t\tif (i > 0)\n\t\t\tsmallest = std::min(smallest, i);\n\t}\n\treturn\
    \ { largest == INT_MIN ? std::nullopt : largest, smallest == INT_MAX ? std::nullopt\
    \ : smallest };", "  long a=0,b=0;\n  if(lst.size()==0)\n  {\n    std::tuple<std::optional<long>,\
    \ std::optional<long>> ans=std::make_tuple(std::nullopt,std::nullopt);\n    return\
    \ ans;\n  }\n  std::sort(lst.begin(),lst.end());\n  int j=0;\n  for(int i=0;i<lst.size();i++)\n\
    \  {\n    if(lst[i]<0)\n    {\n      a=lst[i];\n      j++;\n    }\n  }\n  if(j==0)\n\
    \  {\n    std::tuple<std::optional<long>, std::optional<long>> ans=std::make_tuple(std::nullopt,lst[0]);\n\
    \    return ans;\n  }\n  int j1=0;\n  for(int i=0;i<lst.size();i++)\n  {\n   \
    \ if(lst[i]>0)\n    {\n      b=lst[i];\n      j1++;\n    }\n  }\n  if(j1==0)\n\
    \  {\n    std::tuple<std::optional<long>, std::optional<long>> ans=std::make_tuple(a,std::nullopt);\n\
    \    return ans;\n  }\n  std::tuple<std::optional<long>, std::optional<long>>\
    \ ans=std::make_tuple(a,b);\n  return ans;", "\t\t\t\tlong min = lst[0];\n\t\t\
    \t\tlong max = lst[0];\n\t\t\t\tfor (long i = 0; i < lst.size(); i++) {\n\t\t\t\
    \t\t\t\t\tif (lst[i] > max) {\n\t\t\t\t\t\t\t\t\t\t\t\tmax = lst[i];\n\t\t\t\t\
    \t\t\t\t}\n\t\t\t\t\t\t\t\tif (lst[i] < min) {\n\t\t\t\t\t\t\t\t\t\t\t\tmin =\
    \ lst[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (max > 0) {\n\t\t\t\t\t\t\t\
    \tif (min < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn std::make_tuple(max, min);\n\t\
    \t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn std::make_tuple(max, std::nullopt);\n\t\
    \t\t\t}\n\t\t\t\tif (min < 0) {\n\t\t\t\t\t\t\t\treturn std::make_tuple(std::nullopt,\
    \ min);\n\t\t\t\t}\n\t\t\t\treturn std::make_tuple(std::nullopt, std::nullopt);",
  "    if(lst.size() == 0) return {None, None};\n    long max = lst[0];\n    long\
    \ min = lst[0];\n    bool hasNegative = false;\n    bool hasPositive = false;\n\
    \    for(auto & n : lst) {\n        if(n < 0) {\n            hasNegative = true;\n\
    \            if(n > max) max = n;\n        }\n        if(n > 0) {\n          \
    \  hasPositive = true;\n            if(n < min) min = n;\n        }\n    }\n \
    \   std::optional<long> a = None;\n    std::optional<long> b = None;\n    if(hasNegative)\
    \ a = max;\n    if(hasPositive) b = min;\n    return {a, b};", "\tint maximum\
    \ = INT_MIN;\n\tint minimum = INT_MAX;\n\tint maxCount = 0;\n\tint minCount =\
    \ 0;\n\tfor (long l : lst) {\n\t\tif (l < 0) {\n\t\t\tif (l > maximum) {\n\t\t\
    \t\tmaximum = l;\n\t\t\t}\n\t\t\tmaxCount++;\n\t\t}\n\t\telse if (l > 0) {\n\t\
    \t\tif (l < minimum) {\n\t\t\t\tminimum = l;\n\t\t\t}\n\t\t\tminCount++;\n\t\t\
    }\n\t}\n\tif (maxCount == 0) {\n\t\tmaximum = 0;\n\t}\n\tif (minCount == 0) {\n\
    \t\tminimum = 0;\n\t}\n\treturn std::make_tuple(maximum, minimum);", "  std::optional<long>\
    \ large;\n  std::optional<long> small;\n  for (auto i : lst) {\n    if (i > 0)\
    \ {\n      if (!small.has_value()) {\n        small = i;\n      } else if (i <\
    \ small.value()) {\n        small = i;\n      }\n    } else if (i < 0) {\n   \
    \   if (!large.has_value()) {\n        large = i;\n      } else if (i > large.value())\
    \ {\n        large = i;\n      }\n    }\n  }\n  return std::make_tuple(large,\
    \ small);", "  std::optional<long> largest, smallest;\n  for (auto& i : lst) {\n\
    \    if (i < 0) {\n      if (!largest.has_value() || i > largest.value()) {\n\
    \        largest = i;\n      }\n    } else if (i > 0) {\n      if (!smallest.has_value()\
    \ || i < smallest.value()) {\n        smallest = i;\n      }\n    }\n  }\n  return\
    \ {largest, smallest};", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ mytuple(std::nullopt, std::nullopt);\n    long large = 0;\n    long small =\
    \ 0;\n    int l = 0;\n    int s = 0;\n    if(lst.size() == 0)\n        return\
    \ mytuple;\n    for(int i = 0; i < lst.size(); i++)\n    {\n        if(lst[i]\
    \ < 0)\n        {\n            if(l == 0)\n            {\n                large\
    \ = lst[i];\n                l = 1;\n            }\n            else if(lst[i]\
    \ > large)\n            {\n                large = lst[i];\n            }\n  \
    \      }\n        else if(lst[i] > 0)\n        {\n            if(s == 0)\n   \
    \         {\n                small = lst[i];\n                s = 1;\n       \
    \     }\n            else if(lst[i] < small)\n            {\n                small\
    \ = lst[i];\n            }\n        }\n    }\n    if(l == 0)\n        large =\
    \ std::nullopt;\n    if(s == 0)\n        small = std::nullopt;\n    mytuple =\
    \ std::make_tuple(large, small);\n    return mytuple;", "    if(lst.size()==0)\n\
    \        return std::make_tuple(std::nullopt, std::nullopt);\n    if(lst.size()==1\
    \ && lst[0]==0)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    auto a=std::min_element(lst.begin(), lst.end());\n    auto b=std::max_element(lst.begin(),\
    \ lst.end());\n    if(*a<0)\n        return std::make_tuple(std::nullopt, *a);\n\
    \    if(*b>0)\n        return std::make_tuple(*b, std::nullopt);\n    return std::make_tuple(std::nullopt,\
    \ std::nullopt);", "  if (lst.empty()) {\n    return {std::nullopt, std::nullopt};\n\
    \  }\n  std::optional<long> max_neg;\n  std::optional<long> min_pos;\n  for (const\
    \ auto &v : lst) {\n    if (v < 0) {\n      if (!max_neg || *max_neg < v) {\n\
    \        max_neg = v;\n      }\n    } else if (v > 0) {\n      if (!min_pos ||\
    \ *min_pos > v) {\n        min_pos = v;\n      }\n    }\n  }\n  return {max_neg,\
    \ min_pos};", "    int n = lst.size();\n    if(n == 0)\n        return {std::nullopt,\
    \ std::nullopt};\n    int max = -INT_MAX;\n    int min = INT_MAX;\n    for(int\
    \ i = 0; i < n; i++) {\n        if(lst[i] > 0) {\n            if(lst[i] < min)\n\
    \                min = lst[i];\n        }\n        else {\n            if(lst[i]\
    \ > max)\n                max = lst[i];\n        }\n    }\n    if(max == -INT_MAX\
    \ && min == INT_MAX)\n        return {std::nullopt, std::nullopt};\n    else if(max\
    \ == -INT_MAX)\n        return {std::nullopt, min};\n    else if(min == INT_MAX)\n\
    \        return {max, std::nullopt};\n    else\n        return {max, min};", "\t\
    auto it = std::find_if(lst.begin(), lst.end(), [](long x) { return x > 0; });\n\
    \tif (it == lst.end())\n\t\treturn { std::nullopt, std::nullopt };\n\tauto min_pos\
    \ = *std::min_element(it, lst.end());\n\tauto it2 = std::find_if(lst.begin(),\
    \ lst.end(), [](long x) { return x < 0; });\n\tif (it2 == lst.end())\n\t\treturn\
    \ { std::nullopt, min_pos };\n\tauto max_neg = *std::max_element(it2, lst.end());\n\
    \treturn { max_neg, min_pos };", "\tlong small = 0;\n\tlong big = 0;\n\tlong small_check\
    \ = 0;\n\tlong big_check = 0;\n\t\n\tfor (auto itr : lst) {\n\t\tif (itr > 0)\
    \ {\n\t\t\tif (small_check == 0) {\n\t\t\t\tsmall = itr;\n\t\t\t\tsmall_check++;\n\
    \t\t\t}\n\t\t\telse if (itr < small) {\n\t\t\t\tsmall = itr;\n\t\t\t}\n\t\t}\n\
    \t\telse if (itr < 0) {\n\t\t\tif (big_check == 0) {\n\t\t\t\tbig = itr;\n\t\t\
    \t\tbig_check++;\n\t\t\t}\n\t\t\telse if (itr > big) {\n\t\t\t\tbig = itr;\n\t\
    \t\t}\n\t\t}\n\t}\n\tif (small_check == 0) {\n\t\tsmall = NULL;\n\t}\n\tif (big_check\
    \ == 0) {\n\t\tbig = NULL;\n\t}\n\treturn std::make_tuple(small, big);", "   \
    \ std::optional<long> neg = {};\n    std::optional<long> pos = {};\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!neg.has_value() || i > neg.value())\
    \ {\n                neg = i;\n            }\n        } else if (i > 0) {\n  \
    \          if (!pos.has_value() || i < pos.value()) {\n                pos = i;\n\
    \            }\n        }\n    }\n    return {neg, pos};", "\tstd::optional<long>\
    \ b{},a{};\n\tfor(int i=0;i<lst.size();i++)\n\t{\n\t\tif(lst[i]<0)\n\t\t{\n\t\t\
    \tif(!a)\n\t\t\t\ta=lst[i];\n\t\t\telse\n\t\t\t\ta=lst[i]>*a?lst[i]:*a;\n\t\t\
    }\n\t\telse if(lst[i]>0)\n\t\t{\n\t\t\tif(!b)\n\t\t\t\tb=lst[i];\n\t\t\telse\n\
    \t\t\t\tb=lst[i]<*b?lst[i]:*b;\n\t\t}\n\t}\n\treturn std::make_tuple(a,b);", " \
    \   if(lst.size() == 0)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if(lst.size() == 1)\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    long maxi = INT_MIN;\n    long mini = INT_MAX;\n    for(int i = 0; i < lst.size();\
    \ i++) {\n        if(lst[i] < 0)\n            maxi = std::max(maxi, lst[i]);\n\
    \        if(lst[i] > 0)\n            mini = std::min(mini, lst[i]);\n    }\n \
    \   if(maxi == INT_MIN)\n        maxi = std::nullopt;\n    if(mini == INT_MAX)\n\
    \        mini = std::nullopt;\n    return std::make_tuple(maxi, mini);", "\tint\
    \ mn = INT_MAX, mx = INT_MIN;\n\tbool flag = false;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] >= 0) {\n\t\t\tflag = true;\n\t\t\tmn = min(mn, lst[i]);\n\
    \t\t}\n\t\telse {\n\t\t\tmx = max(mx, lst[i]);\n\t\t}\n\t}\n\tif (mx == INT_MIN)mx\
    \ = 0;\n\tif (mn == INT_MAX)mn = 0;\n\tif (flag)\n\t\treturn {mx, mn};\n\telse\
    \ return {};", "    if(lst.size() == 0)\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    if(lst.size() == 1 && lst[0] == 0)\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    std::sort(lst.begin(), lst.end());\n    if(lst[0] >= 0)\n\
    \        return std::make_tuple(std::nullopt, lst[0]);\n    return std::make_tuple(lst[lst.size()\
    \ - 1], lst[0]);", "  // Remove dummy code and write your solution here\n  std::optional<long>\
    \ largest_negative_number;\n  std::optional<long> smallest_positive_number;\n\
    \  std::vector<long> negative_numbers;\n  std::vector<long> positive_numbers;\n\
    \  for (long number : lst) {\n    if (number < 0) {\n      negative_numbers.push_back(number);\n\
    \    } else if (number > 0) {\n      positive_numbers.push_back(number);\n   \
    \ }\n  }\n  if (negative_numbers.size() > 0) {\n    largest_negative_number =\
    \ *std::max_element(negative_numbers.begin(), negative_numbers.end());\n  }\n\
    \  if (positive_numbers.size() > 0) {\n    smallest_positive_number = *std::min_element(positive_numbers.begin(),\
    \ positive_numbers.end());\n  }\n  return std::make_tuple(largest_negative_number,\
    \ smallest_positive_number);", "\tif (lst.size() == 0) {\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\t}\n\tlong min = lst[0];\n\tlong max = lst[0];\n\tfor (long\
    \ a : lst) {\n\t\tif (a > 0) {\n\t\t\tif (a < min) {\n\t\t\t\tmin = a;\n\t\t\t\
    }\n\t\t}\n\t\telse {\n\t\t\tif (a > max) {\n\t\t\t\tmax = a;\n\t\t\t}\n\t\t}\n\
    \t}\n\tif (min > 0) {\n\t\treturn std::make_tuple(std::nullopt, min);\n\t}\n\t\
    if (max < 0) {\n\t\treturn std::make_tuple(max, std::nullopt);\n\t}\n\treturn\
    \ std::make_tuple(max, min);", "    if(lst.size() == 0) return {std::nullopt,\
    \ std::nullopt};\n    std::sort(lst.begin(), lst.end());\n    if (lst[0] >= 0)\
    \ return {std::nullopt, (long)lst[0]};\n    if (lst[lst.size() - 1] <= 0) return\
    \ {(long)lst[lst.size() - 1], std::nullopt};\n    return {(long)lst[lst.size()\
    \ - 1], (long)lst[0]};", "\tif (lst.size() == 0) {\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\t}\n\tstd::optional<long> largest, smallest;\n\tbool first\
    \ = true;\n\tfor (long i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (first) {\n\t\t\t\
    \tlargest = i;\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i >\
    \ *largest) {\n\t\t\t\t\tlargest = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if\
    \ (i > 0) {\n\t\t\tif (first) {\n\t\t\t\tsmallest = i;\n\t\t\t\tfirst = false;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\tif (i < *smallest) {\n\t\t\t\t\tsmallest = i;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(largest, smallest);",
  "\tint neg = -1, pos = -1;\n\tint max_neg = INT_MIN, min_pos = INT_MAX;\n\tfor (long\
    \ int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tneg = 1;\n\t\
    \t\tif (lst[i] > max_neg)\n\t\t\t\tmax_neg = lst[i];\n\t\t}\n\t\telse if (lst[i]\
    \ > 0) {\n\t\t\tpos = 1;\n\t\t\tif (lst[i] < min_pos)\n\t\t\t\tmin_pos = lst[i];\n\
    \t\t}\n\t}\n\tif (neg == -1)\n\t\tmax_neg = NULL;\n\tif (pos == -1)\n\t\tmin_pos\
    \ = NULL;\n\treturn std::make_tuple(max_neg, min_pos);", "  if (lst.empty()) {\n\
    \    return { std::nullopt, std::nullopt };\n  }\n  long min_ = lst[0];\n  long\
    \ max_ = lst[0];\n  for (long el : lst) {\n    if (el < 0) {\n      max_ = max_\
    \ < el ? el : max_;\n    } else {\n      min_ = min_ > el ? el : min_;\n    }\n\
    \  }\n  return { max_ < 0 ? max_ : std::nullopt, min_ > 0 ? min_ : std::nullopt\
    \ };", "\tif (lst.size() == 0)\n\t\treturn std::make_tuple(std::nullopt, std::nullopt);\n\
    \tstd::sort(lst.begin(), lst.end());\n\tlong biggest_neg = -1000000001;\n\tlong\
    \ smallest_pos = 1000000001;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif\
    \ (lst[i] < 0)\n\t\t\tbiggest_neg = std::max(biggest_neg, lst[i]);\n\t\tif (lst[i]\
    \ > 0) {\n\t\t\tsmallest_pos = std::min(smallest_pos, lst[i]);\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn std::make_tuple(biggest_neg == -1000000001 ? std::nullopt\
    \ : biggest_neg, smallest_pos == 1000000001 ? std::nullopt : smallest_pos);",
  "  std::optional<long> smallest_positive_num, largest_negative_num;\n  for (int\
    \ i = 0; i < lst.size(); i++) {\n    if (lst[i] < 0) {\n      if (!largest_negative_num)\
    \ {\n        largest_negative_num = lst[i];\n      } else if (lst[i] > *largest_negative_num)\
    \ {\n        largest_negative_num = lst[i];\n      }\n    } else if (lst[i] >\
    \ 0) {\n      if (!smallest_positive_num) {\n        smallest_positive_num = lst[i];\n\
    \      } else if (lst[i] < *smallest_positive_num) {\n        smallest_positive_num\
    \ = lst[i];\n      }\n    }\n  }\n  return std::make_tuple(largest_negative_num,\
    \ smallest_positive_num);", "\tif (lst.size() == 0) {\n\t\treturn std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\t}\n\tlong positive = INT_MAX;\n\tlong negative = INT_MIN;\n\
    \tfor (long num : lst) {\n\t\tif (num > 0) {\n\t\t\tpositive = std::min(positive,\
    \ num);\n\t\t}\n\t\telse if (num < 0) {\n\t\t\tnegative = std::max(negative, num);\n\
    \t\t}\n\t}\n\tif (positive == INT_MAX) {\n\t\tpositive = std::nullopt;\n\t}\n\t\
    if (negative == INT_MIN) {\n\t\tnegative = std::nullopt;\n\t}\n\treturn std::make_tuple(negative,\
    \ positive);", "  long a=-1,b=1;\n  int i;\n  for(i=0;i<lst.size();i++)\n  {\n\
    \    if(lst[i]>0)\n    {\n      b=lst[i];\n      break;\n    }\n  }\n  if(i==lst.size())\n\
    \  {\n    return std::make_tuple(std::nullopt,std::nullopt);\n  }\n  for(i=0;i<lst.size();i++)\n\
    \  {\n    if(lst[i]<0 && lst[i]>a)\n    {\n      a=lst[i];\n    }\n    if(lst[i]>0\
    \ && lst[i]<b)\n    {\n      b=lst[i];\n    }\n  }\n  if(a==-1)\n  {\n    return\
    \ std::make_tuple(std::nullopt,b);\n  }\n  return std::make_tuple(a,b);", "  \
    \  std::optional<long> max;\n    std::optional<long> min;\n    bool is_positive\
    \ = true;\n    bool is_negative = true;\n    for (int i = 0; i < lst.size(); i++)\
    \ {\n        if (lst[i] >= 0) {\n            if (is_positive) {\n            \
    \    min = lst[i];\n                is_positive = false;\n            }\n    \
    \        if (lst[i] < min) {\n                min = lst[i];\n            }\n \
    \       }\n        if (lst[i] < 0) {\n            if (is_negative) {\n       \
    \         max = lst[i];\n                is_negative = false;\n            }\n\
    \            if (lst[i] > max) {\n                max = lst[i];\n            }\n\
    \        }\n    }\n    return std::make_tuple(max, min);", "  if (lst.empty())\
    \ {\n    return {std::nullopt, std::nullopt};\n  }\n  long smallest = lst[0];\n\
    \  long largest = lst[0];\n  bool has_negative = false;\n  bool has_positive =\
    \ false;\n  for (auto &&i : lst) {\n    if (i < 0) {\n      has_negative = true;\n\
    \      if (i > largest) {\n        largest = i;\n      }\n    } else if (i > 0)\
    \ {\n      has_positive = true;\n      if (i < smallest) {\n        smallest =\
    \ i;\n      }\n    }\n  }\n  if (has_negative && has_positive) {\n    return {largest,\
    \ smallest};\n  } else if (has_negative) {\n    return {largest, std::nullopt};\n\
    \  } else if (has_positive) {\n    return {std::nullopt, smallest};\n  } else\
    \ {\n    return {std::nullopt, std::nullopt};\n  }", "    int maxNeg = INT_MIN;\n\
    \    int minPos = INT_MAX;\n    std::optional<long> retNeg;\n    std::optional<long>\
    \ retPos;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0)\
    \ {\n            if (lst[i] > maxNeg) {\n                maxNeg = lst[i];\n  \
    \          }\n        }\n        if (lst[i] > 0) {\n            if (lst[i] < minPos)\
    \ {\n                minPos = lst[i];\n            }\n        }\n    }\n    if\
    \ (maxNeg == INT_MIN) {\n        retNeg = std::nullopt;\n    } else {\n      \
    \  retNeg = maxNeg;\n    }\n    if (minPos == INT_MAX) {\n        retPos = std::nullopt;\n\
    \    } else {\n        retPos = minPos;\n    }\n    return std::make_tuple(retNeg,\
    \ retPos);", "    std::optional<long> largestNegative;\n    std::optional<long>\
    \ smallestPositive;\n    if(lst.size()==0) {\n        largestNegative = std::nullopt;\n\
    \        smallestPositive = std::nullopt;\n    }\n    for(long i : lst) {\n  \
    \      if(i < 0) {\n            if(!largestNegative.has_value()) {\n         \
    \       largestNegative = i;\n            }\n            if(i > largestNegative.value())\
    \ {\n                largestNegative = i;\n            }\n        }\n        if(i\
    \ > 0) {\n            if(!smallestPositive.has_value()) {\n                smallestPositive\
    \ = i;\n            }\n            if(i < smallestPositive.value()) {\n      \
    \          smallestPositive = i;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(largestNegative, smallestPositive);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || a.value() < i) {\n                a = i;\n            }\n        } else if\
    \ (i > 0) {\n            if (!b.has_value() || b.value() > i) {\n            \
    \    b = i;\n            }\n        }\n    }\n    return {a, b};", "\tint a,b;\n\
    \tstd::optional<long> oa,ob;\n\tif(lst.size()==0)\n\t\treturn {oa,ob};\n\telse{\n\
    \t\tfor(int i=0;i<lst.size();i++){\n\t\t\tif(lst[i]<0){\n\t\t\t\ta=i;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<lst.size();i++){\n\t\t\tif(lst[i]>0){\n\
    \t\t\t\tb=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(lst[a]<lst[b])\n\t\t\treturn\
    \ {oa,ob};\n\t\telse{\n\t\t\tfor(int i=0;i<lst.size();i++){\n\t\t\t\tif(lst[i]<0\
    \ && lst[i]>lst[a])\n\t\t\t\t\ta=i;\n\t\t\t}\n\t\t\tfor(int i=0;i<lst.size();i++){\n\
    \t\t\t\tif(lst[i]>0 && lst[i]<lst[b])\n\t\t\t\t\tb=i;\n\t\t\t}\n\t\t\treturn {lst[a],lst[b]};\n\
    \t\t}\n\t}", "  std::tuple<std::optional<long>, std::optional<long>> ret{};\n\
    \  std::optional<long> a, b;\n  for (auto &v : lst) {\n    if (v > 0) {\n    \
    \  if (!b.has_value() || v < b.value()) {\n        b = v;\n      }\n    } else\
    \ if (v < 0) {\n      if (!a.has_value() || v > a.value()) {\n        a = v;\n\
    \      }\n    }\n  }\n  return std::make_tuple(a, b);", "    if(lst.size() ==\
    \ 0)\n    {\n        return std::make_tuple(std::nullopt, std::nullopt);\n   \
    \ }\n    std::vector<long> positive;\n    std::vector<long> negative;\n    for(auto\
    \ &it: lst)\n    {\n        if(it < 0)\n        {\n            negative.push_back(it);\n\
    \        }\n        else if(it > 0)\n        {\n            positive.push_back(it);\n\
    \        }\n    }\n    if(positive.size() > 0 && negative.size() > 0)\n    {\n\
    \        auto max = std::max_element(negative.begin(), negative.end());\n    \
    \    auto min = std::min_element(positive.begin(), positive.end());\n        return\
    \ std::make_tuple(*max, *min);\n    }\n    else if(positive.size() > 0)\n    {\n\
    \        auto min = std::min_element(positive.begin(), positive.end());\n    \
    \    return std::make_tuple(std::nullopt, *min);\n    }\n    else if(negative.size()\
    \ > 0)\n    {\n        auto max = std::max_element(negative.begin(), negative.end());\n\
    \        return std::make_tuple(*max, std::nullopt);\n    }\n    else\n    {\n\
    \        return std::make_tuple(std::nullopt, std::nullopt);\n    }", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result = {};\n    auto& a = std::get<0>(result);\n    auto&\
    \ b = std::get<1>(result);\n    for (auto e : lst) {\n        if (e < 0) {\n \
    \           if (!a || e > *a) {\n                a = e;\n            }\n     \
    \   } else if (e > 0) {\n            if (!b || e < *b) {\n                b =\
    \ e;\n            }\n        }\n    }\n    return result;", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> res;\n    if(lst.size() == 0) {\n        return { std::nullopt,\
    \ std::nullopt };\n    }\n    std::optional<long> min(std::nullopt);\n    std::optional<long>\
    \ max(std::nullopt);\n    for(auto val : lst) {\n        if(val >= 0) {\n    \
    \        if(!min.has_value() || val < min.value()) {\n                min = val;\n\
    \            }\n        } else {\n            if(!max.has_value() || val > max.value())\
    \ {\n                max = val;\n            }\n        }\n    }\n    return {\
    \ max, min };", "\tlong min = 9999999999;\n\tlong max = -9999999999;\n\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> result = std::make_tuple(std::nullopt, std::nullopt);\n\
    \tbool positive = false;\n\tbool negative = false;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tnegative = true;\n\t\t\tif (lst[i] > max)\
    \ {\n\t\t\t\tmax = lst[i];\n\t\t\t}\n\t\t}\n\t\tif (lst[i] > 0) {\n\t\t\tpositive\
    \ = true;\n\t\t\tif (lst[i] < min) {\n\t\t\t\tmin = lst[i];\n\t\t\t}\n\t\t}\n\t\
    }\n\tif (negative == true) {\n\t\tstd::get<0>(result) = max;\n\t}\n\tif (positive\
    \ == true) {\n\t\tstd::get<1>(result) = min;\n\t}\n\treturn result;", "    long\
    \ max = INT_MIN;\n    long min = INT_MAX;\n    bool is_neg = false;\n    bool\
    \ is_pos = false;\n    if(lst.size() == 0) {\n        return {std::nullopt, std::nullopt};\n\
    \    }\n    for(long n : lst) {\n        if(n < 0) {\n            is_neg = true;\n\
    \            if(n > max) {\n                max = n;\n            }\n        }\n\
    \        if(n > 0) {\n            is_pos = true;\n            if(n < min) {\n\
    \                min = n;\n            }\n        }\n    }\n    if(is_neg) {\n\
    \        if(is_pos) {\n            return {max, min};\n        }\n        return\
    \ {max, std::nullopt};\n    }\n    return {std::nullopt, min};", "\tlong largest\
    \ = 0;\n\tbool flag = false;\n\tlong smallest = 0;\n\tbool flag1 = false;\n\t\
    for (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\t\t\tflag1 = true;\n\
    \t\t\tif (smallest == 0) {\n\t\t\t\tsmallest = lst[i];\n\t\t\t}\n\t\t\telse if\
    \ (lst[i] < smallest) {\n\t\t\t\tsmallest = lst[i];\n\t\t\t}\n\t\t}\n\t\telse\
    \ if (lst[i] < 0) {\n\t\t\tflag = true;\n\t\t\tif (largest == 0) {\n\t\t\t\tlargest\
    \ = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i] > largest) {\n\t\t\t\tlargest = lst[i];\n\
    \t\t\t}\n\t\t}\n\t}\n\tif (flag) {\n\t\tif (flag1) {\n\t\t\treturn std::make_tuple(largest,\
    \ smallest);\n\t\t}\n\t\telse {\n\t\t\treturn std::make_tuple(largest, std::nullopt);\n\
    \t\t}\n\t}\n\telse {\n\t\tif (flag1) {\n\t\t\treturn std::make_tuple(std::nullopt,\
    \ smallest);\n\t\t}\n\t\telse {\n\t\t\treturn std::make_tuple(std::nullopt, std::nullopt);\n\
    \t\t}\n\t}", "    std::sort(lst.begin(), lst.end());\n    std::optional<long>\
    \ max_neg, min_pos;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i]\
    \ < 0) {\n            max_neg = lst[i];\n        }\n        if (lst[i] > 0) {\n\
    \            min_pos = lst[i];\n            break;\n        }\n    }\n    return\
    \ std::make_tuple(max_neg, min_pos);", "    long largestNegative = -1;\n    long\
    \ smallestPositive = 9999999999999;\n    bool largestNegativeFound = false;\n\
    \    bool smallestPositiveFound = false;\n    int size = lst.size();\n    for\
    \ (int i = 0; i < size; i++) {\n        if (lst[i] < 0) {\n            largestNegativeFound\
    \ = true;\n            if (lst[i] > largestNegative) {\n                largestNegative\
    \ = lst[i];\n            }\n        }\n        if (lst[i] > 0) {\n           \
    \ smallestPositiveFound = true;\n            if (lst[i] < smallestPositive) {\n\
    \                smallestPositive = lst[i];\n            }\n        }\n    }\n\
    \    if (largestNegativeFound == false) {\n        largestNegative = 0;\n    }\n\
    \    if (smallestPositiveFound == false) {\n        smallestPositive = 0;\n  \
    \  }\n    return std::make_tuple(largestNegative, smallestPositive);", '  // Write
    your code here', "    std::optional<long> largestNegativeInt;\n    std::optional<long>\
    \ smallestPositiveInt;\n    for (auto number : lst) {\n        if (number > 0)\
    \ {\n            if (!smallestPositiveInt) {\n                smallestPositiveInt\
    \ = number;\n            } else if (number < smallestPositiveInt) {\n        \
    \        smallestPositiveInt = number;\n            }\n        } else if (number\
    \ < 0) {\n            if (!largestNegativeInt) {\n                largestNegativeInt\
    \ = number;\n            } else if (number > largestNegativeInt) {\n         \
    \       largestNegativeInt = number;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(largestNegativeInt, smallestPositiveInt);", "  long largest\
    \ = -1e9, smallest = 1e9;\n  bool flag = true;\n  std::vector<int> indexes_positive,\
    \ indexes_negative;\n  for (long i = 0; i < lst.size(); i++) {\n    if (lst[i]\
    \ < 0) {\n      flag = false;\n      indexes_negative.push_back(i);\n    }\n \
    \   if (lst[i] > 0) {\n      flag = false;\n      indexes_positive.push_back(i);\n\
    \    }\n  }\n  if (flag) {\n    return std::make_tuple(std::nullopt, std::nullopt);\n\
    \  }\n  else {\n    for (long i = 0; i < indexes_negative.size(); i++) {\n   \
    \   if (lst[indexes_negative[i]] > largest)\n        largest = lst[indexes_negative[i]];\n\
    \    }\n    for (long i = 0; i < indexes_positive.size(); i++) {\n      if (lst[indexes_positive[i]]\
    \ < smallest)\n        smallest = lst[indexes_positive[i]];\n    }\n    if (indexes_negative.size()\
    \ == 0)\n      largest = std::nullopt;\n    if (indexes_positive.size() == 0)\n\
    \      smallest = std::nullopt;\n    return std::make_tuple(largest, smallest);\n\
    \  }", "\tstd::optional<long> max;\n\tstd::optional<long> min;\n\tfor (auto x\
    \ : lst) {\n\t\tif (x > 0) {\n\t\t\tif (!min || x < *min)\n\t\t\t\tmin = x;\n\t\
    \t}\n\t\telse if (x < 0) {\n\t\t\tif (!max || x > *max)\n\t\t\t\tmax = x;\n\t\t\
    }\n\t}\n\treturn std::make_tuple(max, min);", "    std::optional<long> maxNeg,\
    \ minPos;\n    for (long n : lst) {\n        if (n < 0) {\n            if (!maxNeg.has_value()\
    \ || n > *maxNeg) {\n                maxNeg = n;\n            }\n        } else\
    \ if (n > 0) {\n            if (!minPos.has_value() || n < *minPos) {\n      \
    \          minPos = n;\n            }\n        }\n    }\n    return {maxNeg, minPos};",
  "  std::tuple<std::optional<long>, std::optional<long>> output {std::nullopt, std::nullopt};\n\
    \  for (auto elem : lst) {\n    if (elem < 0) {\n      std::get<0>(output) = std::max(std::get<0>(output).value_or(elem),\
    \ elem);\n    } else if (elem > 0) {\n      std::get<1>(output) = std::min(std::get<1>(output).value_or(elem),\
    \ elem);\n    }\n  }\n  return output;", "\tstd::optional<long> pos, neg;\n\t\
    for (auto it : lst) {\n\t\tif (it > 0) {\n\t\t\tif (!pos || it < *pos) {\n\t\t\
    \t\tpos = it;\n\t\t\t}\n\t\t}\n\t\telse if (it < 0) {\n\t\t\tif (!neg || it >\
    \ *neg) {\n\t\t\t\tneg = it;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(neg,\
    \ pos);", "    std::optional<long> a = {}, b = {};\n    for (auto x : lst) {\n\
    \        if (x >= 0 && (!b || x < *b)) {\n            b = x;\n        }\n    \
    \    if (x < 0 && (!a || x > *a)) {\n            a = x;\n        }\n    }\n  \
    \  return {a, b};", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ ret;\n    std::optional<long> largest;\n    std::optional<long> smallest;\n\
    \    if (lst.size() == 0) {\n        return {largest, smallest};\n    }\n    if\
    \ (lst.size() == 1) {\n        return {largest, smallest};\n    }\n    int i =\
    \ 0;\n    while (i < lst.size()) {\n        if (lst[i] < 0) {\n            largest\
    \ = lst[i];\n            break;\n        }\n        i++;\n    }\n    i = 0;\n\
    \    while (i < lst.size()) {\n        if (lst[i] > 0) {\n            smallest\
    \ = lst[i];\n            break;\n        }\n        i++;\n    }\n    for (i =\
    \ 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            if (lst[i]\
    \ > largest) {\n                largest = lst[i];\n            }\n        }\n\
    \        if (lst[i] > 0) {\n            if (lst[i] < smallest) {\n           \
    \     smallest = lst[i];\n            }\n        }\n    }\n    return {largest,\
    \ smallest};", "  int min = 0;\n  int max = 0;\n  bool minSet = false;\n  bool\
    \ maxSet = false;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] >\
    \ 0) {\n      if (!minSet) {\n        min = lst[i];\n        minSet = true;\n\
    \      } else if (lst[i] < min) {\n        min = lst[i];\n      }\n    } else\
    \ if (lst[i] < 0) {\n      if (!maxSet) {\n        max = lst[i];\n        maxSet\
    \ = true;\n      } else if (lst[i] > max) {\n        max = lst[i];\n      }\n\
    \    }\n  }\n  std::optional<long> newMax;\n  std::optional<long> newMin;\n  if\
    \ (maxSet) {\n    newMax = max;\n  }\n  if (minSet) {\n    newMin = min;\n  }\n\
    \  return std::make_tuple(newMax, newMin);", "\tif (lst.size() < 1)\n\t\treturn\
    \ std::make_tuple(std::nullopt, std::nullopt);\n\tstd::optional<long> small, large;\n\
    \tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (!large.has_value())\n\t\t\t\
    \tlarge = i;\n\t\t\telse\n\t\t\t\tlarge = std::max(large.value(), i);\n\t\t}\n\
    \t\telse if (i > 0) {\n\t\t\tif (!small.has_value())\n\t\t\t\tsmall = i;\n\t\t\
    \telse\n\t\t\t\tsmall = std::min(small.value(), i);\n\t\t}\n\t}\n\treturn std::make_tuple(large,\
    \ small);", "    std::optional<long> a = std::nullopt;\n    std::optional<long>\
    \ b = std::nullopt;\n    bool neg = false;\n    bool pos = false;\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            if (!neg)\
    \ {\n                a = lst[i];\n                neg = true;\n            } else\
    \ {\n                if (lst[i] > *a) {\n                    a = lst[i];\n   \
    \             }\n            }\n        } else if (lst[i] > 0) {\n           \
    \ if (!pos) {\n                b = lst[i];\n                pos = true;\n    \
    \        } else {\n                if (lst[i] < *b) {\n                    b =\
    \ lst[i];\n                }\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "\tif (lst.size() == 0) {\n\t\treturn { std::nullopt, std::nullopt };\n\
    \t}\n\tauto min = lst[0];\n\tauto max = lst[0];\n\tfor (auto n : lst) {\n\t\t\
    if (n < 0) {\n\t\t\tif (n > max) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\telse\
    \ {\n\t\t\tif (n < min) {\n\t\t\t\tmin = n;\n\t\t\t}\n\t\t}\n\t}\n\tif (min <\
    \ 0) {\n\t\treturn { std::nullopt, min };\n\t}\n\tif (max > 0) {\n\t\treturn {\
    \ max, std::nullopt };\n\t}\n\treturn { std::nullopt, std::nullopt };", "    std::optional<long>\
    \ a = 0;\n    std::optional<long> b = 0;\n    if (lst.size() > 0) {\n        long\
    \ largest = 0;\n        long smallest = 0;\n        bool isNegative = false;\n\
    \        bool isPositive = false;\n        for (int i = 0; i < lst.size(); i++)\
    \ {\n            if (lst[i] < 0) {\n                isNegative = true;\n     \
    \           if (lst[i] > largest) {\n                    largest = lst[i];\n \
    \               }\n            }\n            if (lst[i] > 0) {\n            \
    \    isPositive = true;\n                if (smallest == 0) {\n              \
    \      smallest = lst[i];\n                }\n                if (lst[i] < smallest)\
    \ {\n                    smallest = lst[i];\n                }\n            }\n\
    \        }\n        if (isNegative == false) {\n            a = {};\n        }\
    \ else {\n            a = largest;\n        }\n        if (isPositive == false)\
    \ {\n            b = {};\n        } else {\n            b = smallest;\n      \
    \  }\n    } else {\n        a = {};\n        b = {};\n    }\n    return std::make_tuple(a,\
    \ b);", "    if(lst.size()==0) return {std::nullopt, std::nullopt};\n    int min=INT_MAX,\
    \ max=INT_MIN;\n    for(auto e: lst){\n        if(e<0 && e>max) max=e;\n     \
    \   if(e>0 && e<min) min=e;\n    }\n    if(min==INT_MAX) min=std::nullopt;\n \
    \   if(max==INT_MIN) max=std::nullopt;\n    return {max, min};", "    // Your\
    \ code here.\n    return {};"]
stop_tokens:
- "\n}"
