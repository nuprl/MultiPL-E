name: HumanEval_59_largest_prime_factor
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
  \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
  // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long n)\
  \ {\n"
tests: "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
  \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
  \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
  }\n"
completions: ["    // Insert your code here.\n    std::vector<long> L;\n    long k;\n\
    \    long t = n;\n    for (long i = 2; i < t; i++){\n        if (t % i == 0){\n\
    \            L.push_back(i);\n            t = t / i;\n            i = 1;\n   \
    \     }\n    }\n    if (L.size() == 0){\n        k = t;\n    } else {\n      \
    \  k = L[L.size() - 1];\n    }\n    return k;", "    long largest_factor = 1;\n\
    \    long d = 2;\n    while (n > 1) {\n        while (n % d == 0) {\n        \
    \    largest_factor = d;\n            n /= d;\n        }\n        d += 1;\n  \
    \  }\n    return largest_factor;", "    // TODO\n    return 0;", "  for (long\
    \ i = 2; i < n; i++) {\n    if (n % i == 0) {\n      return largest_prime_factor(n\
    \ / i);\n    }\n  }\n  return n;", "  long c=2;\n  while(c<=n){\n    if(n%c==0){\n\
    \      n/=c;\n    }else{\n      c++;\n    }\n  }\n  return c;", // your code goes
    here, "    int lpf;\n    for (int i = 2; i <= n; i++) {\n        while (n % i\
    \ == 0) {\n            lpf = i;\n            n /= i;\n        }\n    }\n    return\
    \ lpf;", "    // TODO: your code here\n    long result = 0;\n    for (long i =\
    \ 2; i <= n; i++) {\n        // Checks if i is a prime number.\n        bool is_prime\
    \ = true;\n        for (long j = 2; j <= i / 2; j++) {\n            if (i % j\
    \ == 0) {\n                is_prime = false;\n                break;\n       \
    \     }\n        }\n        if (is_prime) {\n            while (n % i == 0) {\n\
    \                result = i;\n                n /= i;\n            }\n       \
    \ }\n    }\n    return result;", "    long largestPrime = -1;\n    while (n %\
    \ 2 == 0) {\n        largestPrime = 2;\n        n >>= 1;\n    }\n    for (int\
    \ i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largestPrime\
    \ = i;\n            n = n / i;\n        }\n    }\n    if (n > 2)\n        largestPrime\
    \ = n;\n    return largestPrime;", "  long max_prime = -1;\n  while (n % 2 ==\
    \ 0) {\n    max_prime = 2;\n    n /= 2;\n  }\n  for (int i = 3; i <= sqrt(n);\
    \ i += 2) {\n    while (n % i == 0) {\n      max_prime = i;\n      n /= i;\n \
    \   }\n  }\n  if (n > 2)\n    max_prime = n;\n  return max_prime;", "  assert(n>1);\n\
    \  for (long i = 2; i*i <= n; i++) {\n    if (n % i == 0) {\n      n /= i;\n \
    \     i--;\n    }\n  }\n  return n;", "  long max_factor = 0;\n  for (long i =\
    \ 2; i <= n; i++) {\n    if (n % i == 0) {\n      n /= i;\n      max_factor =\
    \ i;\n    }\n  }\n  return max_factor;", "    assert(n > 1);\n    // Handle 2\
    \ separately, since 2 is the only even prime.\n    if (n % 2 == 0) return largest_prime_factor(n\
    \ / 2);\n    // n is odd at this point.\n    long largest_factor = 1;\n    long\
    \ d = 3;\n    while (d * d <= n) {\n        if (n % d == 0) {\n            n /=\
    \ d;\n            largest_factor = d;\n        } else {\n            d += 2;\n\
    \        }\n    }\n    if (n > 1) {\n        // n is prime, since it is larger\
    \ than any previous factors.\n        return n;\n    } else {\n        return\
    \ largest_factor;\n    }", "    assert(n > 1);\n    for (long i = 2; i < n; i++)\
    \ {\n        if (n % i == 0)\n            return largest_prime_factor(n / i);\n\
    \    }\n    return n;", "  long f = 2;\n  while (n % f != 0) {\n    f += 1;\n\
    \  }\n  if (n / f == 1) {\n    return f;\n  }\n  return largest_prime_factor(n\
    \ / f);", "    long largest_prime = 0;\n    for (long i = 2; i <= n; i++) {\n\
    \        if (n % i == 0) {\n            largest_prime = i;\n            while\
    \ (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n \
    \   return largest_prime;", "\tlong current_largest_prime_factor = 2;\n\tlong\
    \ remaining_n = n;\n\twhile (remaining_n % current_largest_prime_factor == 0)\
    \ {\n\t\tremaining_n /= current_largest_prime_factor;\n\t}\n\tlong next_prime_number\
    \ = current_largest_prime_factor + 1;\n\twhile (remaining_n > 1) {\n\t\tif (remaining_n\
    \ % next_prime_number == 0) {\n\t\t\tcurrent_largest_prime_factor = next_prime_number;\n\
    \t\t\tremaining_n /= next_prime_number;\n\t\t}\n\t\telse {\n\t\t\tnext_prime_number\
    \ += 2;\n\t\t}\n\t}\n\treturn current_largest_prime_factor;", "    long largest\
    \ = 1;\n    long i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n\
    \            if (largest < i)\n                largest = i;\n            n /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    if (largest\
    \ < n)\n        largest = n;\n    return largest;", "  // For n >= 2, n is composed\
    \ of 2 or odd numbers.\n  if (n % 2 == 0) {\n    n = n / 2;\n    while (n % 2\
    \ == 0) {\n      n = n / 2;\n    }\n  }\n\n  long factor = 3;\n  while (n != 1)\
    \ {\n    if (n % factor == 0) {\n      n = n / factor;\n      while (n % factor\
    \ == 0) {\n        n = n / factor;\n      }\n    }\n    factor += 2;\n  }\n  return\
    \ factor - 2;", "    // TODO: Complete this function.\n    long lpf = 0;\n   \
    \ for(long i = 2; i <= n; i++){\n        if(n % i == 0){\n            lpf = i;\n\
    \            n /= i;\n            i = 1;\n        }\n    }\n    return lpf;",
  "    long largest_prime = -1;\n    while (n % 2 == 0) {\n        largest_prime =\
    \ 2;\n        n /= 2;\n    }\n    // Now n is odd\n    long f = 3;\n    while\
    \ (f * f <= n) {\n        if (n % f == 0) {\n            largest_prime = f;\n\
    \            n /= f;\n        } else {\n            f += 2;\n        }\n    }\n\
    \    if (n > largest_prime)\n        largest_prime = n;\n    return largest_prime;",
  "  assert(n > 1);\n  long t = n;\n  long i = 2;\n  while (i * i <= t) {\n    if\
    \ (t % i == 0) {\n      t /= i;\n    } else {\n      i++;\n    }\n  }\n  return\
    \ t;", "\tlong i = 2;\n\twhile (i < n) {\n\t\tif (n % i == 0) {\n\t\t\tn /= i;\n\
    \t\t} else {\n\t\t\ti += 1;\n\t\t}\n\t}\n\treturn n;", "    // To be implemented.\n\
    \    long largest = 0;\n    for (long i = 2; i <= n; i++) {\n        while (n\
    \ % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\
    \    return largest;", "  // your code here\n  long high = n / 2;\n  for (long\
    \ i = 2; i <= high; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) {\n\
    \        n /= i;\n      }\n      high = n / 2;\n    }\n  }\n  return n;", "  \
    \  // Write your code here.\n    // Hint: The solution is related to the Fundamental\
    \ Theorem of Arithmetic.\n    // https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\n\
    \    //\n    // The largest prime factor will be equal to n / the smallest factor\
    \ of n.\n    //\n    // Note that a prime number is a number that is only divisible\
    \ by 1 and itself.\n    // You might find a useful method for determining whether\
    \ a number is prime.\n    // If a number n is not prime, then it can be written\
    \ as a product of prime\n    // numbers (which may or may not be distinct).\n\
    \    //\n    // For example, if n = 16, you can write it as 16 = 2 * 2 * 2 * 2,\
    \ or\n    // 16 = 2 * 2 * 4, or 16 = 2 * 8, or 16 = 4 * 4.\n    //\n    // If\
    \ you iterate over the divisors of 16, you will find that 2 is the smallest\n\
    \    // divisor that is not 1.\n    //\n    // If n is prime, then the largest\
    \ prime factor of n is n.\n    //\n    // Pro tip: make a helper function that\
    \ will determine whether a number is prime.\n    // This can simplify your code.\n\
    \    if (isPrime(n)) return n;\n    return n / smallestFactor(n);", '    return
    -1;', "  assert(n > 1);\n  for (long i = 2; i <= n; i++) {\n    if (n % i == 0)\
    \ {\n      n /= i;\n      i -= 1;\n    }\n  }\n  return n;", "    // YOUR CODE\
    \ HERE\n    assert(n > 1);\n    int i;\n    for (i = 2; i <= n; i++) {\n     \
    \   if (n % i == 0) {\n            n /= i;\n            i--;\n        }\n    }\n\
    \    return i;", "long i = n/2;\nwhile(i!=0){\n if(n%i==0){\n   long j=i/2;\n\
    \   while(j!=0){\n     if(i%j==0)\n        return largest_prime_factor(n/i);\n\
    \     j--;\n   }\n   return i;\n }\n  i--;", "  long factor = n;\n  long largest\
    \ = -1;\n  int j = 2;\n  while (factor != 1){\n      if (factor % j == 0){\n \
    \         factor = factor / j;\n          largest = j;\n      }\n      else{\n\
    \          j = j + 1;\n      }\n  }\n  return largest;", "    long i;\n    for\
    \ (i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n /= i;\n\
    \        }\n    }\n    return n;", "    while (n % 2 == 0) {\n        n /= 2;\n\
    \    }\n    long d = 3;\n    while (d * d <= n) {\n        if (n % d == 0) {\n\
    \            n /= d;\n        } else {\n            d += 2;\n        }\n    }\n\
    \    return n;", "    long largest_prime_factor = 0;\n    for (long i = 2; i <\
    \ n / 2; i++) {\n        if (n % i == 0) {\n            long factor = n / i;\n\
    \            if (is_prime(factor)) {\n                largest_prime_factor = factor;\n\
    \                break;\n            }\n        }\n    }\n    return largest_prime_factor;",
  "    // TODO: implement me\n    return -1;", "  long copy = n;\n  long big = 0;\n\
    \  int i = 2;\n  if (n < 2) {\n    return -1;\n  }\n  for (i = 2; i < copy; i++)\
    \ {\n    if (copy % i == 0) {\n      big = i;\n      copy = copy / i;\n      i\
    \ = 2;\n    }\n  }\n  return copy;", "    // TODO: Implement.\n    if(n == 1){\n\
    \        return 1;\n    }\n    for(long i = 2; i<=sqrt(n); i++){\n        if(n%i\
    \ == 0){\n            return largest_prime_factor(n/i);\n        }\n    }\n  \
    \  return n;", "    // TODO: IMPLEMENT ME\n    int largestFactor = 1;\n    for\
    \ (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            if (i > largestFactor)\
    \ {\n                bool flag = true;\n                for (int j = 2; j < i;\
    \ j++) {\n                    if (i % j == 0) {\n                        flag\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n                if (flag) {\n                    largestFactor = i;\n\
    \                }\n            }\n        }\n    }\n    return largestFactor;",
  "\t// long primes[n];\n\t// int ind = 0;\n\t// for(long i = 2; i <= n; i++){\n\t\
    // \tif(isPrime(i)){\n\t// \t\tprimes[ind] = i;\n\t// \t\tind++;\n\t// \t}\n\t\
    // }\n\t// int div = 1;\n\t// for(int i = ind-1; i >= 0; i--){\n\t// \tif(n %\
    \ primes[i] == 0){\n\t// \t\tdiv = primes[i];\n\t// \t\tbreak;\n\t// \t}\n\t//\
    \ }\n\t// return div;\n\tlong div = 2;\n\twhile(n > 1){\n\t\tif(n % div == 0){\n\
    \t\t\tn /= div;\n\t\t}else{\n\t\t\tdiv++;\n\t\t}\n\t}\n\treturn div;", "    //\
    \ test only odd numbers\n    for (long i = 3; i < n; i += 2) {\n        // we\
    \ are checking if i is a factor of n\n        if (n % i == 0) {\n            //\
    \ check if i is prime\n            long j;\n            for (j = 3; j < i; j +=\
    \ 2) {\n                if (i % j == 0) {\n                    break;\n      \
    \          }\n            }\n            // i is prime\n            if (j >= i)\
    \ {\n                return i;\n            }\n        }\n    }\n    // n is prime\
    \ so return n\n    return n;", "\tassert(n > 1);\n\tlong factor = 0;\n\tlong p\
    \ = 2;\n\twhile (n != 1) {\n\t\twhile (n % p == 0) {\n\t\t\tn /= p;\n\t\t\tfactor\
    \ = p;\n\t\t}\n\t\tp += 1;\n\t}\n\treturn factor;", "    long d = 2;\n    while\
    \ (n > 1) {\n        while (n % d == 0) {\n            n /= d;\n        }\n  \
    \      d += 1;\n    }\n    return d - 1;", "\tfor (long i = 2; i <= sqrt(n); i++)\
    \ {\n\t\tif (n % i == 0) {\n\t\t\tlong p = n / i;\n\t\t\tif (p == 1) {\n\t\t\t\
    \treturn i;\n\t\t\t}\n\t\t\tif (p % i != 0) {\n\t\t\t\treturn largest_prime_factor(p);\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn n;", "// TODO: implement this function\n  long largest\
    \ = 2;\n  while (n % 2 == 0) {\n    n /= 2;\n  }\n  for (long d = 3; d * d <=\
    \ n; d += 2) {\n    while (n % d == 0) {\n      largest = d;\n      n /= d;\n\
    \    }\n  }\n  if (n > 2) {\n    largest = n;\n  }\n  return largest;", "  long\
    \ largestPrime = -1;\n  while (n % 2 == 0) {\n    largestPrime = 2;\n    n >>=\
    \ 1;\n  }\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n\
    \      largestPrime = i;\n      n = n / i;\n    }\n  }\n  if (n > 2)\n    largestPrime\
    \ = n;\n  return largestPrime;", "    // Start with the smallest prime number,\
    \ 2.\n\n    // We stop when we find the largest prime factor (because we only\n\
    \    // generate primes in increasing order).\n    // This is not the most efficient\
    \ way to do this...\n    long largest_factor = 2;\n    long remaining = n;\n \
    \   // Check if remaining is divisible by 2. If so, update largest_factor.\n \
    \   while (remaining % 2 == 0) {\n        largest_factor = 2;\n        remaining\
    \ = remaining / 2;\n    }\n    // Loop over the remaining odd numbers up to sqrt(n).\n\
    \    for (long i = 3; i * i <= remaining; i += 2) {\n        // Check if remaining\
    \ is divisible by i. If so, update largest_factor.\n        while (remaining %\
    \ i == 0) {\n            largest_factor = i;\n            remaining = remaining\
    \ / i;\n        }\n    }\n    // If remaining is greater than 2, then it is the\
    \ largest prime factor.\n    if (remaining > 2) {\n        largest_factor = remaining;\n\
    \    }\n    return largest_factor;", "    long largest_prime_factor=2;\n    while(n>largest_prime_factor){\n\
    \        if(n%largest_prime_factor==0){\n            n=n/largest_prime_factor;\n\
    \            largest_prime_factor=2;\n        }\n        else\n            largest_prime_factor++;\n\
    \    }\n    return largest_prime_factor;", "    long i = 2;\n    while (n > 1)\
    \ {\n        if (n % i == 0) {\n            n /= i;\n        } else {\n      \
    \      i++;\n        }\n    }\n    return i;", "    // Your code here\n    long\
    \ maxPrime = -1;\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>=\
    \ 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i\
    \ == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\
    \    if (n > 2)\n        maxPrime = n;\n    return maxPrime;", "  //TODO: Implement\
    \ me!\n  long i;\n  for(i=2;i<=n;i++){\n    if(n%i==0){\n      break;\n    }\n\
    \  }\n  long d = n/i;\n  return d;", "\tlong prime=0;\n\tlong largest_prime=0;\n\
    \tstd::vector<long> prime_factors;\n\twhile(n%2==0){\n\t\tprime_factors.push_back(2);\n\
    \t\tn=n/2;\n\t}\n\tfor(long i=3;i<=sqrt(n);i=i+2){\n\t\twhile(n%i==0){\n\t\t\t\
    prime_factors.push_back(i);\n\t\t\tn=n/i;\n\t\t}\n\t}\n\tif(n>2){\n\t\tprime_factors.push_back(n);\n\
    \t}\n\tstd::cout<<n<<std::endl;\n\tlargest_prime=prime_factors[prime_factors.size()-1];\n\
    \t// std::cout<<largest_prime<<std::endl;\n\treturn largest_prime;", "    assert(n\
    \ > 1);\n    // Find 2^a * d = n\n    long a = 0;\n    long d = n;\n    while\
    \ (d % 2 == 0) {\n        d /= 2;\n        a += 1;\n    }\n    // Now d is odd\
    \ and by the fundamental theorem of arithmetic, it's a product\n    // of primes,\
    \ which must be greater than two.\n    assert(d > 1);\n    // If a > 0, the largest\
    \ prime factor must be a power of two.\n    if (a > 0) {\n        return (1L <<\
    \ a);\n    }\n    // Try all the primes below 1000.\n    for (long p = 3; p <\
    \ 1000; p += 2) {\n        if (d % p == 0) {\n            d /= p;\n          \
    \  break;\n        }\n    }\n    // At this point, either p was never a factor,\
    \ or we have d = p * q, where\n    // p is the largest prime factor and q is less\
    \ than 1000. In the latter\n    // case, because q < 1000, it must be a product\
    \ of primes.\n    if (d < 1000) {\n        return d;\n    }\n    // In the former\
    \ case, the largest prime factor is p, the largest prime\n    // less than 1000.\n\
    \    return 999;", "  long result = 0;\n  while(n%2==0){\n    result = 2;\n  \
    \  n=n/2;\n  }\n  for(long i=3;i<=sqrt(n);i+=2){\n    while(n%i==0){\n      result\
    \ = i;\n      n=n/i;\n    }\n  }\n  if(n>2){\n    result = n;\n  }\n  return result;",
  "  long f = 2;\n  while (n != f) {\n    if (n % f == 0) {\n      n /= f;\n    }\
    \ else {\n      f++;\n    }\n  }\n  return f;", "    long p = 1;\n    while (n%2\
    \ == 0) {\n        p = 2;\n        n /= 2;\n    }\n    long d = 3;\n    while\
    \ (d <= n) {\n        if (n%d == 0) {\n            p = d;\n            n /= d;\n\
    \        } else {\n            d += 2;\n        }\n    }\n    return p;", "  \
    \  assert(n > 1);\n    int i = 2;\n    while (n > 1) {\n        while (n % i ==\
    \ 0)\n            n /= i;\n        i++;\n    }\n    return i - 1;", "    assert(n\
    \ > 1);\n    // Your code here\n    long long largestFactor = 1;\n    long long\
    \ divisor = 3;\n    while (n % 2 == 0) {\n        largestFactor = 2;\n       \
    \ n /= 2;\n    }\n    while (n != 1) {\n        while (n % divisor == 0) {\n \
    \           largestFactor = divisor;\n            n /= divisor;\n        }\n \
    \       divisor += 2;\n    }\n    return largestFactor;", "    long largest =\
    \ 0;\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n        \
    \    largest = i;\n            while (n % i == 0) {\n                n /= i;\n\
    \            }\n        }\n    }\n    if (n > 1) {\n        largest = n;\n   \
    \ }\n    return largest;", "    int i;\n    for (i = 2; i <= n; i++) {\n     \
    \   if (n % i == 0) {\n            n /= i;\n            i--;\n        }\n    }\n\
    \    return i;", "    // Check for base cases\n    if (n == 1 || n == 2) {\n \
    \       return n;\n    }\n    // Check if n is even\n    if (n % 2 == 0) {\n \
    \       return largest_prime_factor(n / 2);\n    }\n    // All other cases are\
    \ odd\n    for (long i = 3; i <= sqrt(n); i+=2) {\n        if (n % i == 0) {\n\
    \            return largest_prime_factor(n / i);\n        }\n    }\n    // Case\
    \ where n is prime\n    return n;", "    int ret = -1;\n    for (int i = 2; i\
    \ <= n / i; i++) {\n        while (n % i == 0) {\n            ret = i;\n     \
    \       n /= i;\n        }\n    }\n    if (n > 1)\n        ret = n;\n    return\
    \ ret;", "    assert(n > 1);\n    long largest = 0;\n    while (n % 2 == 0) {\n\
    \        largest = 2;\n        n /= 2;\n    }\n    long i = 3;\n    while (i <=\
    \ n) {\n        if (n % i == 0) {\n            largest = i;\n            n /=\
    \ i;\n        } else {\n            i += 2;\n        }\n    }\n    return largest;",
  "  long factor = 2;\n  while (n > 1) {\n    if (n % factor == 0) {\n      n /= factor;\n\
    \    } else {\n      factor++;\n    }\n  }\n  return factor;", "\tlong x = 2;\n\
    \twhile (n > 1) {\n\t\tif (n % x == 0) {\n\t\t\tn /= x;\n\t\t} else {\n\t\t\t\
    x++;\n\t\t}\n\t}\n\treturn x;", "    long largest_factor = -1;\n    while (n %\
    \ 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n    for (int\
    \ factor = 3; factor <= sqrt(n); factor += 2) {\n        while (n % factor ==\
    \ 0) {\n            largest_factor = factor;\n            n /= factor;\n     \
    \   }\n    }\n    if (n > 2) {\n        largest_factor = n;\n    }\n    return\
    \ largest_factor;", "    // Fill in this function.\n    \n    long i=2;\n    while(i*i<=n){\n\
    \        if(n%i==0){\n            n=n/i;\n        }\n        else{\n         \
    \   i++;\n        }\n    }\n    return n;", "    // (5 points)\n    long i=2;\n\
    \    while(i<=n){\n        if(n%i==0){\n            n=n/i;\n        }\n      \
    \  else{\n            i++;\n        }\n    }\n    return i;", "    // TODO: write\
    \ your implementation here\n    // see https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    assert(n>1);\n    // don't need to check 2 and 3\n    long factor = 2;\n\
    \    long largest_factor = 2;\n    long n_orig = n;\n    std::map<long, long>\
    \ prime_factor;\n    std::vector<long> prime_list;\n    // 2-3-5 wheel\n    //\
    \ wheel the factor 2,3,5, get the position\n    int wheel[] = {2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10};\n\
    \    int wheel_pos = 0;\n    while (true) {\n        // find the next prime factor\n\
    \        if (n % factor == 0) {\n            //std::cout << \"factor is \" <<\
    \ factor << std::endl;\n            if (prime_factor.find(factor) == prime_factor.end())\
    \ {\n                prime_factor[factor] = 1;\n                prime_list.push_back(factor);\n\
    \            } else {\n                prime_factor[factor]++;\n            }\n\
    \            n = n / factor;\n            //while (n % factor == 0) {\n      \
    \      //    n = n / factor;\n            //}\n            largest_factor = factor;\n\
    \        }\n        // if n is a prime factor, return\n        if (n == 1) {\n\
    \            //std::cout << \"largest factor is \" << largest_factor << std::endl;\n\
    \            //std::cout << \"prime factor is \" << std::endl;\n            //for\
    \ (auto& i : prime_factor) {\n            //    std::cout << i.first << \"^\"\
    \ << i.second << std::endl;\n            //}\n            //std::cout << \"prime\
    \ list is \" << std", "    long factor = 2;\n    while (n > 1) {\n        while\
    \ (n % factor == 0) {\n            n /= factor;\n        }\n        factor++;\n\
    \    }\n    return factor - 1;", "\tlong lpf = 0;\n\tfor (long i = 2; i <= n;\
    \ i++) {\n\t\tif (n % i == 0) {\n\t\t\tlpf = i;\n\t\t\tn /= i;\n\t\t\ti = 1;\n\
    \t\t}\n\t}\n\treturn lpf;", "    long largest_prime_factor = 2;\n    long max\
    \ = n;\n    long quotient = 0;\n    long remainder = 0;\n    bool is_prime = true;\n\
    \    // while (n % 2 == 0) {\n    //     n = n / 2;\n    // }\n    // if (n ==\
    \ 1) {\n    //     return 2;\n    // }\n    for (long i = 3; i <= n; i += 2) {\n\
    \        is_prime = true;\n        for (long j = 2; j < i; j++) {\n          \
    \  if (i % j == 0) {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        if (is_prime) {\n            std::cout << i\
    \ << std::endl;\n            if (n % i == 0) {\n                quotient = n /\
    \ i;\n                remainder = n % i;\n                if (remainder == 0)\
    \ {\n                    if (i > largest_prime_factor) {\n                   \
    \     largest_prime_factor = i;\n                    }\n                    n\
    \ = quotient;\n                }\n            }\n        }\n    }\n    return\
    \ largest_prime_factor;", "    //YOUR CODE GOES HERE\n    long i;\n    for(i=2;i<n;i++)\n\
    \    {\n        if(n%i==0)\n        {\n            n=n/i;\n            i--;\n\
    \        }\n    }\n    return i;", "  long factor = n / 2;\n  while(factor > 1)\
    \ {\n    if(n % factor == 0) {\n      if(is_prime(factor))\n        return factor;\n\
    \    }\n    factor -= 1;\n  }\n  assert(false);", "    if (n % 2 == 0) {\n   \
    \     return largest_prime_factor(n / 2);\n    }\n    for (long i = 3; i <= n;\
    \ i += 2) {\n        if (n % i == 0) {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    return n;", "    // Try dividing n by 2, then 3,\
    \ then 5, etc. until you find a factor.\n    long factor = 2;\n    while (n >\
    \ 1) {\n        if (n % factor == 0) {\n            // n is divisible by factor.\
    \ Divide it out as often as possible.\n            while (n % factor == 0) {\n\
    \                n /= factor;\n            }\n            // If n is 1, we're\
    \ done.\n            if (n == 1) {\n                return factor;\n         \
    \   }\n            // If n is not 1, we need to try to divide it by something\
    \ else.\n            // We will try to divide it by primes.\n            // The\
    \ next prime after factor is factor + 1, but that's not a\n            // prime,\
    \ so we'll try factor + 2, and then factor + 4, etc.\n            // Keep adding\
    \ 2 to factor until you get a prime.\n            factor += 2;\n            while\
    \ (!is_prime(factor)) {\n                factor += 2;\n            }\n       \
    \ } else {\n            // n is not divisible by factor. Try the next odd number.\n\
    \            factor += 2;\n        }\n    }\n    return 0;", "    long largest\
    \ = 0;\n    // Is 2 the largest factor of n?\n    if (n % 2 == 0)\n        largest\
    \ = 2;\n    // Check for other factors.\n    for (long i = 3; i * i <= n; i +=\
    \ 2) {\n        if (n % i == 0) {\n            largest = i;\n            while\
    \ (n % i == 0)\n                n /= i;\n        }\n    }\n    // n is prime if\
    \ n > 2, so it is the largest factor.\n    if (n > 2)\n        largest = n;\n\
    \    return largest;", "\tlong x = n;\n\tfor (long i = 2; i <= (n/2); i++) {\n\
    \t\twhile (x % i == 0) {\n\t\t\tx = x / i;\n\t\t}\n\t}\n\treturn x;", "    long\
    \ largest_prime_factor = 1;\n    long d = 2;\n    while (n > 1) {\n        while\
    \ (n % d == 0) {\n            largest_prime_factor = d;\n            n /= d;\n\
    \        }\n        d = d + 1;\n        if (d*d > n) {\n            if (n > 1)\
    \ {\n                largest_prime_factor = n;\n            }\n            break;\n\
    \        }\n    }\n    return largest_prime_factor;", "\t// test all numbers from\
    \ 2 up to n.\n\tfor (long factor = 2; factor <= n; factor++) {\n\t\t// test if\
    \ this factor is a prime number\n\t\tbool isPrime = true;\n\t\tfor (long test\
    \ = 2; test < factor; test++) {\n\t\t\tif (factor % test == 0) {\n\t\t\t\tisPrime\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// if it is a prime factor, return\
    \ it.\n\t\tif (isPrime && n % factor == 0) {\n\t\t\treturn factor;\n\t\t}\n\t\
    }\n\t// n should always have a prime factor (it is composite), so this should\
    \ not\n\t// be reached.\n\treturn -1;", "    // Assume n > 1 and is not a prime.\n\
    \    assert(n > 1);\n    // Start with n and keep halving the number until we\
    \ get a prime number.\n    while (n > 1) {\n        int factor = 2;\n        while\
    \ (n % factor != 0) {\n            factor += 1;\n        }\n        n /= factor;\n\
    \    }\n    return n;", "    long factor = 2;\n    long max_factor = 1;\n    long\
    \ largest_prime_factor = 1;\n    while (factor <= n) {\n        if (n % factor\
    \ == 0) {\n            if (is_prime(factor)) {\n                largest_prime_factor\
    \ = factor;\n            }\n            max_factor = factor;\n            n /=\
    \ factor;\n        } else {\n            factor += 1;\n        }\n    }\n    return\
    \ largest_prime_factor;", "    for (long i = 2; i < n; i++) {\n        if (n %\
    \ i == 0) {\n            if (is_prime(n / i)) {\n                return n / i;\n\
    \            }\n        }\n    }\n    assert(false);", "    if (n == 1) {\n  \
    \      return 1;\n    }\n    long largest_prime_factor = 1;\n    for (long i =\
    \ 2; i <= n; i++) {\n        if (n % i == 0) {\n            n /= i;\n        \
    \    largest_prime_factor = i;\n        }\n    }\n    return largest_prime_factor;",
  "    assert(n > 1);\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0)\
    \ {\n            return largest_prime_factor(n / i);\n        }\n    }\n    return\
    \ n;", "  long i;\n  long nn = n;\n  long max = -1;\n  for (i = 2; i <= nn; i++)\
    \ {\n    if (n % i == 0) {\n      n = n / i;\n      if (i > max)\n        max\
    \ = i;\n      i = 2;\n    }\n  }\n  return max;", "\t//prime factor of n\n\t//always\
    \ start by dividing by 2 to cancel out 2s\n\t//71929 = 3 * 3 * 3 * 7 * 11 * 13\n\
    \tint count = 0;\n\t//while n is divisible by 2, divide by 2\n\twhile(n % 2 ==\
    \ 0){\n\t\tn = n / 2;\n\t\t//while n is divisible by 2, divide by 2\n\t\twhile(n\
    \ % 2 == 0){\n\t\t\tn = n / 2;\n\t\t}\n\t}\n\t//now n is odd, and all factors\
    \ of 2 have been removed\n\t//now check if n is divisible by 3\n\tfor(int i =\
    \ 3; i <= sqrt(n); i+=2){\n\t\twhile(n % i == 0){\n\t\t\t//while n is divisible\
    \ by i, divide by i\n\t\t\tn = n / i;\n\t\t}\n\t}\n\t//if n is less than 2, return\
    \ 2\n\tif(n < 2){\n\t\treturn 2;\n\t}\n\t//otherwise, return n\n\treturn n;",
  "  assert(n > 1);\n  long largest = 0;\n  // Start with 2, because 1 is not a prime\
    \ number.\n  for (long i = 2; i <= n; i++) {\n    if (n % i == 0) {\n      largest\
    \ = i;\n      n /= i;\n      i = 1;\n    }\n  }\n  return largest;", "  for (long\
    \ i = 2; i <= n; i++) {\n    if (n % i == 0) {\n      n /= i;\n      i--;\n  \
    \  }\n  }\n  return n;", "  // TODO: Replace with your code.\n\tlong i;\n\tfor(i=2;i<n;i++)\n\
    \t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tn=n/i;\n\t\t\ti--;\n\t\t}\n\t}\n  return i;",
  "    // TODO: Implement this function.\n    if(n%2==0) n/=2;\n    for(long i=3;i<=sqrt(n);i+=2){\n\
    \        if(n%i==0){\n            n/=i;\n            i=3;\n        }\n    }\n\
    \    return n;", "\tlong largest = 2;\n\twhile (n > largest) {\n\t\tif (n % largest\
    \ == 0) {\n\t\t\tn /= largest;\n\t\t} else {\n\t\t\tlargest += 1;\n\t\t}\n\t}\n\
    \treturn largest;", "    long i;\n    for (i = 2; i < n; i++) {\n        if (n\
    \ % i == 0) {\n            return largest_prime_factor(n / i);\n        }\n  \
    \  }\n    return n;", "    // TODO: Write code here.\n    long res=0;\n    if(n<=2)\n\
    \        return res;\n    while(n%2==0)\n    {\n        res=2;\n        n/=2;\n\
    \    }\n    for(int i=3;i<=sqrt(n);i+=2)\n    {\n        while(n%i==0)\n     \
    \   {\n            res=i;\n            n/=i;\n        }\n    }\n    if(n>2)\n\
    \        res=n;\n    return res;", "    if (n % 2 == 0) {\n        return largest_prime_factor(n\
    \ / 2);\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        if (n %\
    \ i == 0) {\n            return largest_prime_factor(n / i);\n        }\n    }\n\
    \    return n;", "\tlong largest_factor = -1;\n\tfor (long i = 2; i * i <= n;\
    \ i++) {\n\t\tif (n % i == 0) {\n\t\t\tlargest_factor = i;\n\t\t\twhile (n % i\
    \ == 0) {\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t}\n\tif (n > 1) {\n\t\tlargest_factor\
    \ = n;\n\t}\n\treturn largest_factor;", "    std::vector<long> factors;\n    long\
    \ d = 2;\n    while (n > 1) {\n        while (n % d == 0) {\n            factors.push_back(d);\n\
    \            n /= d;\n        }\n        d += 1;\n    }\n    return factors.back();",
  "  long largest_factor = 2;\n  while (n % 2 == 0) {\n    n /= 2;\n  }\n  for (long\
    \ i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      largest_factor\
    \ = i;\n      n /= i;\n    }\n  }\n  if (n > 2) {\n    largest_factor = n;\n \
    \ }\n  return largest_factor;", '    return 0;', "    for (long i = 2; i < n;\
    \ i++) {\n        if (n % i == 0) {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    return n;", "\tstd::vector<long> prime_factors;\n\
    \twhile(n % 2 == 0) {\n\t\tprime_factors.push_back(2);\n\t\tn /= 2;\n\t}\n\tfor(long\
    \ i = 3; i <= n; i += 2) {\n\t\twhile(n % i == 0) {\n\t\t\tprime_factors.push_back(i);\n\
    \t\t\tn /= i;\n\t\t}\n\t}\n\treturn prime_factors.back();", "   assert(n > 1);\n\
    \   // Your Code\n   long prime_factor = -1;\n   for(long i = 2; i <= n; ++i)\
    \ {\n       if(n % i == 0) {\n           while(n % i == 0) {\n               n\
    \ /= i;\n           }\n           prime_factor = i;\n       }\n   }\n   return\
    \ prime_factor;", "long factor=2;\nlong prime=1;\nwhile(n>1){\nif(n%factor==0){\n\
    n=n/factor;\nif(factor>prime){\nprime=factor;", "\t// Not a prime.\n\tassert(n\
    \ > 1);\n\tlong largest = 1;\n\tlong f = 2;\n\twhile (n > 1) {\n\t\tif (n % f\
    \ == 0) {\n\t\t\tlargest = f;\n\t\t\tn /= f;\n\t\t} else {\n\t\t\tf++;\n\t\t}\n\
    \t}\n\treturn largest;", "\tlong largest = 1;\n\tfor (long i = 2; i <= n; i++)\
    \ {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tlargest = i;\n\t\t}\n\t}\n\
    \treturn largest;", "  long max_prime = -1;\n  // check for every number up to\
    \ sqrt(n) if it's a prime factor\n  // if it is, check if it's larger than the\
    \ last prime factor\n  // if it is, save it in max_prime\n  // return max_prime\n\
    \  for (long i = 2; i <= (long)sqrt(n); i++) {\n    if (n % i == 0) {\n      bool\
    \ prime = true;\n      for (long j = 2; j <= (long)sqrt(i); j++) {\n        if\
    \ (i % j == 0) {\n          prime = false;\n          break;\n        }\n    \
    \  }\n      if (prime && i > max_prime) {\n        max_prime = i;\n      }\n \
    \   }\n  }\n  return max_prime;", "    // Write your code here.\n    int i;\n\
    \    for(i=2;i<=n;i++)\n    {\n        if(n%i==0)\n        {\n            n=n/i;\n\
    \            i--;\n        }\n    }\n    return i;", "    long largest_prime_factor\
    \ = 2;\n    long i = 2;\n    while (i <= n) {\n        if (n % i == 0) {\n   \
    \         n /= i;\n            largest_prime_factor = i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    return largest_prime_factor;", "\t\
    // Obvious exception:\n\tif (n < 2) return 0;\n\t// Eliminate all evens:\n\twhile\
    \ (n % 2 == 0) n /= 2;\n\t// Eliminate all factors of 3:\n\twhile (n % 3 == 0)\
    \ n /= 3;\n\t// A factor of n must be less than sqrt(n), so we can stop checking\n\
    \t// at that point.\n\tlong max_prime_factor = (long) sqrt(n);\n\t// Try to eliminate\
    \ all factors of 5, then 7, etc.\n\tlong candidate = 5;\n\twhile (candidate <=\
    \ max_prime_factor) {\n\t\twhile (n % candidate == 0) n /= candidate;\n\t\tcandidate\
    \ += 2;\n\t\twhile (n % candidate == 0) n /= candidate;\n\t\tcandidate += 4;\n\
    \t}\n\treturn n;", "\tlong largest_prime = 1;\n\tlong i = 2;\n\tlong root = sqrt(n);\n\
    \twhile (i <= root) {\n\t\tif (n % i == 0) {\n\t\t\tlargest_prime = i;\n\t\t\t\
    n /= i;\n\t\t\troot = sqrt(n);\n\t\t}\n\t\ti += 1;\n\t}\n\treturn (n == 1) ? largest_prime\
    \ : n;", "    long d = n;\n    for (long p = 2; p * p <= n; p++) {\n        if\
    \ (n % p == 0) {\n            d = p;\n            while (n % p == 0) {\n     \
    \           n /= p;\n            }\n        }\n    }\n    if (n > 1) {\n     \
    \   d = n;\n    }\n    return d;", "  if (n == 2) return 2;\n  long largest =\
    \ 0;\n  while (n % 2 == 0) {\n    largest = 2;\n    n /= 2;\n  }\n  // Now n is\
    \ odd.\n  for (long i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n\
    \      largest = i;\n      n /= i;\n    }\n  }\n  if (n > 2) largest = n;\n  return\
    \ largest;", "   if (n == 1) {\n       return 1;\n   }\n   long largest = 1;\n\
    \   for (long i = 2; i <= n; i++) {\n       if (n % i == 0) {\n           largest\
    \ = i;\n           n /= i;\n           i--;\n       }\n   }\n   return largest;",
  "    long p = 2;\n    long largest = 1;\n    while (n > 1) {\n        while (n %\
    \ p == 0) {\n            largest = p;\n            n /= p;\n        }\n      \
    \  p++;\n    }\n    return largest;", "    for (long i = 2; i < n; i++) {\n  \
    \      if (n % i == 0) {\n            n /= i;\n            i--;\n        }\n \
    \   }\n    return n;", "  // assert(n > 1);\n  long factor = n;\n  while (factor\
    \ > 1) {\n    int i = 2;\n    while (i <= factor) {\n      if (factor % i == 0)\
    \ {\n        factor /= i;\n        break;\n      }\n      i++;\n    }\n  }\n \
    \ return factor;", "    long prime = 2;\n    while (n % prime != 0) {\n      \
    \  prime++;\n    }\n    if (n == prime) {\n        return n;\n    }\n    return\
    \ largest_prime_factor(n / prime);", "    for (long i = 2; i < n; i++) {\n   \
    \     if (n % i == 0) {\n            // If i is a factor of n, then n / i will\
    \ be a factor of n.\n            long f1 = i;\n            long f2 = n / i;\n\
    \            // Check if f1 and f2 are prime.\n            // If they are not\
    \ prime, then they will have a prime factor\n            // less than f1 or f2.\n\
    \            // Notice that f1 < f2.\n            // So we only need to check\
    \ if f1 has a prime factor less than f1.\n            if (largest_prime_factor(f1)\
    \ == f1) {\n                return f1;\n            }\n            else {\n  \
    \              return largest_prime_factor(f2);\n            }\n        }\n  \
    \  }\n    // If we cannot find a factor, then n must be a prime.\n    return n;",
  "    long end = floor(sqrt(n));\n    long current = 2;\n    while (current < end)\
    \ {\n        if (n % current == 0) {\n            if (is_prime(n / current)) {\n\
    \                return n / current;\n            }\n            return largest_prime_factor(n\
    \ / current);\n        }\n        current++;\n    }\n    return n;", "    long\
    \ largest_prime = 1;\n    for (long i = 2; i <= n; i++) {\n        if (n % i ==\
    \ 0) {\n            largest_prime = i;\n            while (n % i == 0) {\n   \
    \             n /= i;\n            }\n        }\n    }\n    return largest_prime;",
  "    // TODO: implement this function\n    int count = 0;\n    int i = 2;\n    int\
    \ output;\n    while (n!=1){\n        if (n%i==0){\n            output = i;\n\
    \            n = n/i;\n            i = 2;\n        }else{\n            i = i+1;\n\
    \        }\n    }\n    return output;", "    if (n % 2 == 0) {\n        n = n\
    \ / 2;\n    }\n    long largest = 1;\n    for (long divisor = 3; divisor <= n;\
    \ divisor += 2) {\n        if (n % divisor == 0) {\n            largest = divisor;\n\
    \            n = n / divisor;\n        }\n    }\n    return largest;", "    if\
    \ (n <= 1) {\n        return 0;\n    }\n\n    for (long i = 2; i <= n; i++) {\n\
    \        if (n % i == 0) {\n            return std::max(i, largest_prime_factor(n\
    \ / i));\n        }\n    }\n\n    return 0;", "  long largest = 0;\n  while (n\
    \ % 2 == 0) {\n    largest = 2;\n    n /= 2;\n  }\n  for (long i = 3; i * i <=\
    \ n; i += 2) {\n    while (n % i == 0) {\n      largest = i;\n      n /= i;\n\
    \    }\n  }\n  if (n > 2) {\n    largest = n;\n  }\n  return largest;", "    long\
    \ t = 2;\n    while (n > 1){\n        if (n % t == 0){\n            n /= t;\n\
    \        } else {\n            t += 1;\n        }\n    }\n    return t;", "  \
    \ // assert(n > 1);\n   // assert(!is_prime(n));\n    for (long i = 2; i < n;\
    \ i++) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n        \
    \        return i;\n            }\n        }\n    }\n    return n;", "  // This\
    \ is a brute force solution. We could save time by working downwards\n  // from\
    \ sqrt(n).\n  long largest_factor = 1;\n  long factor = 2;\n  while (n > 1) {\n\
    \    while (n % factor == 0) {\n      largest_factor = factor;\n      n /= factor;\n\
    \    }\n    factor += 1;\n  }\n  return largest_factor;", "\tstd::vector<long>\
    \ small_primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\
    \ 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\
    \ 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,\
    \ 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\
    \ 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509,\
    \ 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617,\
    \ 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,\
    \ 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\
    \ 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,\
    \ 953, 967, 971, 977, 983, 991, 997 };\n\tfor (auto i : small_primes) {\n\t\t\
    if (n % i == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn n;", "    long i;\n \
    \   for (i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n           \
    \ n /= i;\n        }\n    }\n    return n;", "  assert(n > 1);\n  long factor\
    \ = 2;\n  while (n > 1) {\n    while (n % factor == 0) {\n      n /= factor;\n\
    \    }\n    factor++;\n  }\n  return factor - 1;", "  assert(n > 1);\n  long factor\
    \ = 2;\n  long last_factor = 1;\n  if (n % 2 == 0) {\n    last_factor = 2;\n \
    \   n /= 2;\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n  }\n  factor = 3;\n\
    \  double max_factor = sqrt(n);\n  while (n > 1 && factor <= max_factor) {\n \
    \   if (n % factor == 0) {\n      n /= factor;\n      last_factor = factor;\n\
    \      while (n % factor == 0) {\n        n /= factor;\n      }\n      max_factor\
    \ = sqrt(n);\n    }\n    factor += 2;\n  }\n  if (n == 1) {\n    return last_factor;\n\
    \  } else {\n    return n;\n  }", "\tlong i;\n\tfor (i = 2; i <= n; i++) {\n\t\
    \tif (n % i == 0) {\n\t\t\tlong factor = n / i;\n\t\t\tbool is_prime = true;\n\
    \t\t\tlong j;\n\t\t\tfor (j = 2; j <= factor; j++) {\n\t\t\t\tif (factor % j ==\
    \ 0) {\n\t\t\t\t\tis_prime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \tif (is_prime) {\n\t\t\t\treturn factor;\n\t\t\t}\n\t\t}\n\t}\n\treturn n;",
  "    // start with the lowest divisor, 2\n    long divisor = 2;\n    // continue\
    \ dividing by 2 as long as possible\n    while (n % divisor == 0) {\n        n\
    \ /= divisor;\n    }\n    // If the number is now 1, it was previously a power\
    \ of 2 and thus 2 is the\n    // largest prime factor.\n    if (n == 1) return\
    \ divisor;\n    // Otherwise, the largest prime factor is >= 3 and < n.\n    divisor\
    \ = 3;\n    // Continue dividing by consecutive odd numbers.\n    while (n > 1)\
    \ {\n        while (n % divisor == 0) {\n            n /= divisor;\n        }\n\
    \        divisor += 2;\n    }\n    // We're done.\n    return divisor - 2;", " \
    \   long i;\n    for (i = 2; i < sqrt(n) + 1; i++) {\n        if (n % i == 0)\
    \ {\n            return std::max(largest_prime_factor(n / i), largest_prime_factor(i));\n\
    \        }\n    }\n    return n;", "// put your code here\n    assert(n>1);\n\
    \    long div = 2;\n    long largest = 1;\n    while(n>1){\n        while(n%div\
    \ == 0){\n            largest = div;\n            n = n/div;\n        }\n    \
    \    div++;\n    }\n    return largest;", "\t// Start with 1.\n\tlong max_prime\
    \ = 1;\n\t// Iterate from 2 until half of n.\n\tfor (long i = 2; i < n / 2; i++)\
    \ {\n\t\t// If i is a factor of n.\n\t\tif (n % i == 0) {\n\t\t\t// Check if i\
    \ is a prime.\n\t\t\tbool prime = true;\n\t\t\tfor (long j = 2; j < i; j++) {\n\
    \t\t\t\tif (i % j == 0) {\n\t\t\t\t\tprime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\t// If prime, check if i is the largest prime factor.\n\t\t\t\
    if (prime && i > max_prime) {\n\t\t\t\tmax_prime = i;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return max_prime;", "    long i = 2;\n    while (n % i != 0) {\n        i++;\n\
    \    }\n    if (n == i) {\n        return n;\n    }\n    return largest_prime_factor(n\
    \ / i);", "\tlong i=2;\n\tlong largest=0;\n\twhile(i<=n){\n\t\tif(n%i==0){\n\t\
    \t\tn/=i;\n\t\t\tlargest=i;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn largest;",
  "    int i;\n    for (i = 2; i < n; i++) {\n        if (n % i == 0) {\n        \
    \    n /= i;\n            i--;\n        }\n    }\n    return i;", "    // Note:\
    \ n is not a prime\n    for (long i = n / 2; i > 1; i--) {\n        if (n % i\
    \ == 0) {\n            return largest_prime_factor(i);\n        }\n    }\n   \
    \ return n;", "\tlong largest_prime = 1;\n\twhile (n % 2 == 0) {\n\t\tlargest_prime\
    \ = 2;\n\t\tn = n / 2;\n\t}\n\tlong factor = 3;\n\tlong max_factor = sqrt(n);\n\
    \twhile (n > 1 && factor <= max_factor) {\n\t\tif (n % factor == 0) {\n\t\t\t\
    largest_prime = factor;\n\t\t\tn = n / factor;\n\t\t\twhile (n % factor == 0)\
    \ {\n\t\t\t\tn = n / factor;\n\t\t\t}\n\t\t\tmax_factor = sqrt(n);\n\t\t}\n\t\t\
    factor = factor + 2;\n\t}\n\tif (n == 1) {\n\t\treturn largest_prime;\n\t} else\
    \ {\n\t\treturn n;\n\t}", "    assert(n > 1);\n    int lpf = 1;\n    for (int\
    \ i = 2; i * i <= n; i += 1) {\n        if (n % i == 0) {\n            lpf = i;\n\
    \            n /= i;\n            // Early exit for a small (2^11) sample set.\n\
    \            if (n == 1) {\n                return lpf;\n            }\n     \
    \   }\n    }\n    return n;", "    if (n <= 1) {\n        return 0;\n    }\n \
    \   if (n % 2 == 0) {\n        return largest_prime_factor(n / 2);\n    }\n  \
    \  for (long i = 3; i <= n / 2; i += 2) {\n        if (n % i == 0) {\n       \
    \     return largest_prime_factor(n / i);\n        }\n    }\n    return n;", " \
    \ // TODO: implement me.\n  if(n%2==0)\n  {\n      while(n%2==0)\n      {\n  \
    \        n=n/2;\n      }\n  }\n  for(int i=3;i<=sqrt(n);i=i+2)\n  {\n      if(n%i==0)\n\
    \      {\n          while(n%i==0)\n          {\n              n=n/i;\n       \
    \   }\n      }\n  }\n  if(n>2)\n  {\n      return n;\n  }\n  return 0;", "   \
    \ long i=2;\n    while(n!=1){\n        if(n%i==0){\n            n/=i;\n      \
    \  }\n        else{\n            i++;\n        }\n    }\n    return i;", "\tassert(n\
    \ > 1);\n\t// Assume n is odd, so start at 3 and step by 2.\n\tfor (long f = 3;\
    \ f * f <= n; f += 2) {\n\t\tif (n % f == 0) {\n\t\t\tn /= f;\n\t\t\twhile (n\
    \ % f == 0) {\n\t\t\t\tn /= f;\n\t\t\t}\n\t\t}\n\t}\n\treturn n;", "    // Iterate\
    \ through potential factors and eliminate them as potential factors.\n    long\
    \ factor = 2;\n    while (n != 1) {\n        while (n % factor == 0) {\n     \
    \       n /= factor;\n        }\n        factor += 1;\n    }\n    return factor\
    \ - 1;", "  long factor = 2;\n  while (n > 1) {\n    while (n % factor == 0) {\n\
    \      n /= factor;\n    }\n    factor += 1;\n  }\n  return factor - 1;", "  \
    \  long count = 0;\n    for (long i = 2; i * i <= n; i++) {\n        if (n % i\
    \ == 0) {\n            count = i;\n            while (n % i == 0) {\n        \
    \        n /= i;\n            }\n        }\n    }\n    if (n > 1)\n        count\
    \ = n;\n    return count;", "    int res = 2;\n    while (n > res) {\n       \
    \ if (n % res == 0) {\n            n /= res;\n        } else {\n            res++;\n\
    \        }\n    }\n    return res;", "  // Check if n is a prime number.\n  if\
    \ (n == 2 || n == 3) {\n    return n;\n  }\n  //\n  long max_factor = 1;\n  //\
    \ Start from 2, then check if current number is a factor of n.\n  for (long factor\
    \ = 2; factor * factor <= n; factor++) {\n    if (n % factor == 0) {\n      //\
    \ Check if factor is prime.\n      for (long i = 2; i * i <= factor; i++) {\n\
    \        if (factor % i == 0) {\n          break;\n        }\n        max_factor\
    \ = factor;\n      }\n    }\n  }\n  return max_factor;", "    // I'm pretty sure\
    \ this is how it works.\n    long f = 2;\n    while (f < n) {\n        if (n %\
    \ f == 0) {\n            // f goes into n evenly.\n            n /= f;\n     \
    \   } else {\n            // f does not go into n evenly, increase f by 1.\n \
    \           f++;\n        }\n    }\n    return f;", "  long largest_factor;\n\
    \  // Note: return 2 if n == 2 or 3.\n  if (n % 2 == 0) {\n    largest_factor\
    \ = 2;\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n  } else if (n % 3 ==\
    \ 0) {\n    largest_factor = 3;\n    while (n % 3 == 0) {\n      n /= 3;\n   \
    \ }\n  } else {\n    largest_factor = 1;\n  }\n  // Check odd numbers up to the\
    \ square root of n\n  long factor = 5;\n  while (factor <= std::sqrt(n)) {\n \
    \   if (n % factor == 0) {\n      n /= factor;\n      largest_factor = factor;\n\
    \    } else if (n % (factor + 2) == 0) {\n      n /= factor + 2;\n      largest_factor\
    \ = factor + 2;\n    }\n    factor += 6;\n  }\n  // If n is a prime number, n\
    \ will be the largest prime factor.\n  if (n != 1) {\n    largest_factor = n;\n\
    \  }\n  return largest_factor;", "    assert(n > 1);\n    long largest_prime_factor\
    \ = 0;\n    for (long i = 2; i <= n; i++) {\n        if (n % i == 0) {\n     \
    \       largest_prime_factor = i;\n            n /= i;\n            i = 2;\n \
    \       }\n    }\n    return largest_prime_factor;", "  long factors = 2;\n  long\
    \ num = n;\n  // get all the factors of the number\n  while (factors < num) {\n\
    \    if (num % factors == 0) {\n      num = num / factors;\n    } else {\n   \
    \   factors++;\n    }\n  }\n  return num;", "    long largest = -1;\n    while\
    \ (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    long p = 3;\n\
    \    while (n != 1) {\n        while (n % p == 0) {\n            largest = p;\n\
    \            n /= p;\n        }\n        p += 2;\n    }\n    return largest;",
  "\tlong lpf = 1;\n\tif (n % 2 == 0) {\n\t\tlpf = 2;\n\t\twhile (n % 2 == 0) {\n\t\
    \t\tn /= 2;\n\t\t}\n\t}\n\tfor (long i = 3; i <= sqrt(n); i += 2) {\n\t\tif (n\
    \ % i == 0) {\n\t\t\tlpf = i;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn lpf;", "\tlong i;\n\tlong num = n;\n\tlong result\
    \ = -1;\n\t// Find the largest prime factor of n.\n\t// Reduce the number by the\
    \ prime factor\n\t// Repeat until the number is 1 or prime\n\tfor (i = 2; i <=\
    \ n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tn = n / i;\n\t\t\tresult = i;\n\t\t\t\
    i--;\n\t\t}\n\t}\n\treturn result;", "    assert(n>1);\n    long m=2;\n    while(m<n){\n\
    \        if(n%m==0){\n            n/=m;\n        }\n        else{\n          \
    \  m++;\n        }\n    }\n    return m;", "\tlong largest_prime = 0;\n\tlong\
    \ factor = 2;\n\twhile (n > 1) {\n\t\twhile (n % factor == 0) {\n\t\t\tlargest_prime\
    \ = factor;\n\t\t\tn /= factor;\n\t\t}\n\t\tfactor += 1;\n\t}\n\treturn largest_prime;",
  "\tif (n % 2 == 0) {\n\t\tn /= 2;\n\t\twhile (n % 2 == 0) {\n\t\t\tn /= 2;\n\t\t\
    }\n\t}\n\tif (n % 3 == 0) {\n\t\tn /= 3;\n\t\twhile (n % 3 == 0) {\n\t\t\tn /=\
    \ 3;\n\t\t}\n\t}\n\tlong i = 5;\n\twhile (n >= i * i) {\n\t\tif (n % i == 0) {\n\
    \t\t\tn /= i;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t\
    \ti += 2;\n\t\tif (n % i == 0) {\n\t\t\tn /= i;\n\t\t\twhile (n % i == 0) {\n\t\
    \t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t\ti += 4;\n\t}\n\treturn n;", "    long largest\
    \ = -1;\n    long factor = 2;\n    while (n > 1) {\n        if (n % factor ==\
    \ 0) {\n            largest = factor;\n            n /= factor;\n            while\
    \ (n % factor == 0) {\n                n /= factor;\n            }\n        }\n\
    \        factor += 1;\n    }\n    return largest;", "    if (n < 2) return 0;\n\
    \    long div = 2;\n    while (n % div != 0) div++;\n    if (n == div) return\
    \ n;\n    long pf = largest_prime_factor(n / div);\n    return (pf > div) ? pf\
    \ : div;", "    long i = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    return i;", "    long largest_prime = -1;\n    while (n % 2 == 0) {\n   \
    \     largest_prime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n);\
    \ i += 2) {\n        while (n % i == 0) {\n            largest_prime = i;\n  \
    \          n = n / i;\n        }\n    }\n    if (n > 2)\n        largest_prime\
    \ = n;\n    return largest_prime;", "    if (n == 2) return 2;\n    else if (n\
    \ % 2 == 0) return largest_prime_factor(n / 2);\n    else {\n        for (long\
    \ i = 3; i < n; i += 2) {\n            if (n % i == 0) return largest_prime_factor(n\
    \ / i);\n        }\n        return n;\n    }", "    long largest_prime_factor\
    \ = 0;\n    int i = 1;\n    while (i <= n) {\n        if (n % i == 0) {\n    \
    \        int counter = 0;\n            for (int j = 1; j <= i; j++) {\n      \
    \          if (i % j == 0) {\n                    counter++;\n               \
    \ }\n            }\n            if (counter == 2) {\n                largest_prime_factor\
    \ = i;\n            }\n        }\n        i++;\n    }\n    return largest_prime_factor;",
  "    // Your code here.\n    long k=2;\n    while(n>1){\n        if(n%k==0){\n \
    \           n=n/k;\n        }\n        else{\n            k++;\n        }\n  \
    \  }\n    return k;", "    for (long i = 2; i < n; i++) {\n        if (n % i ==\
    \ 0) {\n            return largest_prime_factor(n / i);\n        }\n    }\n  \
    \  return n;", "\tassert(n > 1);\n\tfor (long i = 2; i <= std::sqrt(n); i++) {\n\
    \t\tif (n % i == 0) {\n\t\t\treturn std::max(largest_prime_factor(n / i), largest_prime_factor(i));\n\
    \t\t}\n\t}\n\treturn n;", "    long ans = -1;\n    long p = 2;\n    while (p*p\
    \ <= n) {\n        if (n % p == 0) {\n            ans = p;\n            while\
    \ (n % p == 0) n /= p;\n        }\n        p++;\n    }\n    if (n > 1) ans = n;\n\
    \    return ans;", "  long i = 2;\n  while (n > 1) {\n    while (n % i == 0) {\n\
    \      n /= i;\n    }\n    i++;\n  }\n  return i-1;", "\tlong divisor = 2;\n\t\
    long result = 1;\n\tlong remainder = n;\n\twhile (remainder > 1) {\n\t\t// If\
    \ our current divisor is a factor of the current remainder, divide out all instances\
    \ of that factor,\n\t\t// and update the result and remainder.\n\t\tif (remainder\
    \ % divisor == 0) {\n\t\t\tremainder /= divisor;\n\t\t\tresult = divisor;\n\t\t\
    }\n\t\t// Otherwise move on to the next divisor.\n\t\telse {\n\t\t\tdivisor++;\n\
    \t\t}\n\t}\n\treturn result;", "    long largest_prime = -1;\n    while (n % 2\
    \ == 0) {\n        largest_prime = 2;\n        n >>= 1;\n    }\n    for (int i\
    \ = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_prime\
    \ = i;\n            n = n / i;\n        }\n    }\n    if (n > 2)\n        largest_prime\
    \ = n;\n    return largest_prime;", "    long largest_prime_factor = 2;\n    while\
    \ (n % 2 == 0) {\n        n = n / 2;\n    }\n    for (long i = 3; i <= n; i =\
    \ i + 2) {\n        if (n % i == 0) {\n            n = n / i;\n            largest_prime_factor\
    \ = i;\n        }\n    }\n    return largest_prime_factor;", "    // // implement\
    \ this function\n    // long prime = 1;\n    // for (long i = 2; i <= sqrt(n);\
    \ i++) {\n    //     if (n % i == 0) {\n    //         prime = i;\n    //    \
    \     break;\n    //     }\n    // }\n    // return prime;\n    long prime = 1;\n\
    \    for (long i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n      \
    \      while (n % i == 0) {\n                n /= i;\n            }\n        \
    \    prime = i;\n        }\n    }\n    if (n > 1) prime = n;\n    return prime;",
  '    return n;', "  int largest = -1;\n  for (int i = 2; i <= n; i++) {\n    while\
    \ (n % i == 0) {\n      largest = i;\n      n /= i;\n    }\n  }\n  return largest;",
  "    ////////////////start//////////////////\n    std::vector<long> factors;\n \
    \   for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n            factors.push_back(i);\n\
    \        }\n    }\n    std::sort(factors.begin(), factors.end());\n    for (auto\
    \ it = factors.rbegin(); it != factors.rend(); it++) {\n        bool flag = true;\n\
    \        for (long i = 2; i < *it; i++) {\n            if (*it % i == 0) {\n \
    \               flag = false;\n                break;\n            }\n       \
    \ }\n        if (flag) return *it;\n    }\n    ///////////////end////////////////////",
  "    // Insert your code here.\n    int i;\n    for(i=2;i<n;i++)\n    {\n      \
    \  if(n%i==0)\n        {\n            break;\n        }\n    }\n    return i;",
  "// TODO: Implement Me\n// Initialize lpf as 1\nlong lpf = 1;\n// Write a loop that\
    \ divides n by 2, 3, 4, ...\n// Stop when n becomes 1.\n// If n is not divisible\
    \ by the current factor,\n// skip the iteration.\n// Update lpf with the current\
    \ factor.\nwhile (n != 1) {\nlong factor = 1;\nwhile (n % factor == 0) {\nn /=\
    \ factor;\nlpf = factor;", "  // We begin with 2, and increment it until we find\
    \ the largest prime factor.\n  // This is not an optimal solution, which is left\
    \ as an exercise.\n  long p = 2;\n  while (p < n) {\n    if (n % p == 0) {\n \
    \     n /= p;\n    } else {\n      p++;\n    }\n  }\n  return p;", "    int i\
    \ = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n            n /= i;\n\
    \        } else {\n            i++;\n        }\n    }\n    return i;", "  long\
    \ ans = 0;\n  for (long i = 2; i < n; i++) {\n    if (n % i == 0) {\n      ans\
    \ = i;\n      n /= i;\n      i--;\n    }\n  }\n  if (n > 1) {\n    ans = n;\n\
    \  }\n  return ans;", "  long i = 2;\n  while (i * i <= n) {\n    if (n % i ==\
    \ 0) {\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  return n;",
  "    long x = 2;\n    while (x <= n) {\n        if (n % x == 0)\n            n /=\
    \ x;\n        else\n            x += 1;\n    }\n    return x;", "// This assertion\
    \ checks that the input is valid.\n// If it fails, the program will exit with\
    \ failure.\nassert(n > 1);\n// ...\nreturn 0;", "\tlong largest = 2;\n\tfor (long\
    \ i = 2; i < n; i++) {\n\t\tif (n % i == 0) {\n\t\t\twhile (n % i == 0)\n\t\t\t\
    \tn /= i;\n\t\t\tlargest = i;\n\t\t}\n\t}\n\treturn largest;", // write the function
    here, "    long largest_factor = 2;\n    while (n % 2 == 0) {\n        n = n /\
    \ 2;\n    }\n    // No need to worry about evens.\n    for (long i = 3; i <= sqrt(n);\
    \ i = i + 2) {\n        // Check if i is a factor.\n        while (n % i == 0)\
    \ {\n            largest_factor = i;\n            n = n / i;\n        }\n    }\n\
    \    // Is the number itself a prime?\n    if (n > 2) {\n        largest_factor\
    \ = n;\n    }\n    return largest_factor;", "    assert(n > 1);\n    //if (n %\
    \ 2 == 0)\n    //    return 2;\n    long factor = 0;\n    while (n % 2 == 0) {\n\
    \        n /= 2;\n        factor = 2;\n    }\n    for (long i = 3; i < n + 1;\
    \ i += 2) {\n        if (n % i == 0) {\n            n /= i;\n            factor\
    \ = i;\n        }\n    }\n    return factor;", "    std::vector<long> factor;\n\
    \    long i;\n    for (i = 2; i < n; i++) {\n        if (n % i == 0) {\n     \
    \       factor.push_back(i);\n            n /= i;\n            i = 2;\n      \
    \  }\n    }\n    return factor.back();", "\tlong i = 2;\n\twhile (i * i <= n)\
    \ {\n\t\tif (n % i == 0) {\n\t\t\tn /= i;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t\
    }\n\treturn n;", "\tlong d = 2;\n\twhile (n > 1) {\n\t\twhile (n % d == 0) {\n\
    \t\t\tn /= d;\n\t\t}\n\t\td += 1;\n\t}\n\treturn d - 1;", "    long largest =\
    \ -1;\n    for (long i = 2; i <= n / i; i++) {\n        while (n % i == 0) {\n\
    \            largest = i;\n            n /= i;\n        }\n    }\n    if (n >\
    \ 1) {\n        largest = n;\n    }\n    return largest;", "    assert(n > 1);\n\
    \    int max_prime = -1;\n    while (n % 2 == 0) {\n        max_prime = 2;\n \
    \       n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n       \
    \ while (n % i == 0) {\n            max_prime = i;\n            n = n / i;\n \
    \       }\n    }\n    if (n > 2)\n        max_prime = n;\n    return max_prime;",
  "  assert(n > 1);\n  for (long i = 2; i < n; i++) {\n    if (n % i == 0) {\n   \
    \   long j = n / i;\n      if (j == 1) {\n        return i;\n      } else {\n\
    \        return largest_prime_factor(j);\n      }\n    }\n  }\n  return -1;",
  "    long largest_factor = 1;\n    while (n % 2 == 0) {\n        largest_factor\
    \ = 2;\n        n /= 2;\n    }\n    for (long i = 3; i <= std::sqrt(n); i += 2)\
    \ {\n        while (n % i == 0) {\n            largest_factor = i;\n         \
    \   n /= i;\n        }\n    }\n    if (n > 2) {\n        largest_factor = n;\n\
    \    }\n    return largest_factor;", "    if (n <= 1) {\n        return -1;\n\
    \    }\n    if (n == 2) {\n        return 2;\n    }\n    int ans = -1;\n    while\
    \ (n % 2 == 0) {\n        n /= 2;\n    }\n    int sqrt_n = (int)sqrt(n);\n   \
    \ for (int i = 3; i <= sqrt_n; i += 2) {\n        if (n % i == 0) {\n        \
    \    ans = std::max(ans, i);\n            while (n % i == 0) {\n             \
    \   n /= i;\n            }\n        }\n    }\n    if (n != 1) {\n        ans =\
    \ std::max(ans, n);\n    }\n    return ans;", "    long i;\n    while (n % 2 ==\
    \ 0) {\n        n = n / 2;\n    }\n    for (i = 3; i <= sqrt(n); i = i + 2) {\n\
    \        while (n % i == 0) {\n            n = n / i;\n        }\n    }\n    if\
    \ (n > 2) {\n        return n;\n    }\n    return 2;", "  long i = 2;\n  while\
    \ (i < n) {\n    if (n % i == 0) {\n      n /= i;\n    } else {\n      i += 1;\n\
    \    }\n  }\n  return n;"]
stop_tokens:
- "\n}"
