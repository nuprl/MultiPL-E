name: HumanEval_49_modp
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware\
  \ of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0,\
  \ 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n// 1\nlong modp(long\
  \ n, long p) {\n"
tests: "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
  \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
  \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
  \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
  \ (5)) == (3));\n}\n"
completions: ["    if (n==0) return 1;\n    long result = modp(n/2, p);\n    result\
    \ = (result*result)%p;\n    if (n&1) result = (result*2)%p;\n    return result;",
  '  // TODO: Implement me!', "    assert(n >= 0);\n    assert(p > 0);\n    if (n\
    \ == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long t = modp(n\
    \ / 2, p);\n        return (t * t) % p;\n    }\n    return (modp(n - 1, p) * n)\
    \ % p;", "    assert(p > 0);\n    assert(n >= 0);\n    assert(n < p);\n    if\
    \ (n == 0) return 1;\n    if (n % 2 == 0) {\n        long tmp = modp(n / 2, p);\n\
    \        return (tmp * tmp) % p;\n    } else {\n        return (2 * modp(n - 1,\
    \ p)) % p;\n    }", "    assert(p > 0);\n    if (n < 0)\n        n += p;\n   \
    \ long result = 1;\n    while (n > 0) {\n        if (n & 1)\n            result\
    \ = (result * n) % p;\n        n >>= 1;\n    }\n    return result;", "    if (n\
    \ == 0) return 1;\n    else if (n == 1) return n % p;\n    else if (n % 2 == 0)\
    \ {\n        // Square modulo n/2 (the latter can be computed using bit shift)\n\
    \        long half = modp(n / 2, p);\n        return (half * half) % p;\n    }\
    \ else {\n        // n-1 is even, n-1 = n - 1\n        long half = modp(n - 1,\
    \ p);\n        return (half * n) % p;\n    }", "    if (n <= 1) {\n        return\
    \ n;\n    }\n    if (n % 2 == 0) {\n        return (long) pow(modp(n / 2, p),\
    \ 2) % p;\n    }\n    return (long) (modp(n - 1, p) * n) % p;", "    assert(n\
    \ >= 0);\n    assert(p > 0);\n    long res = 1;\n    for (int i = 1; i <= n; i++)\n\
    \        res = (res * 2) % p;\n    return res;", "    if (n == 0) return 1;\n\
    \    assert(p > 0);\n    long res = modp(n/2, p);\n    if (n % 2 == 0)\n     \
    \   return res * res % p;\n    else\n        return (res * res % p) * n % p;",
  "    long c = 1;\n    for (long i = 0; i < n; i++) {\n        c = c * 2 % p;\n \
    \   }\n    return c;", "\tif (n == 0) return 1;\n\tlong r = modp(n / 2, p);\n\t\
    r = (r * r) % p;\n\tif (n % 2 == 1) r = (r * 2) % p;\n\treturn r;", "    if (n\
    \ < 0) {\n        return modp(-n, p);\n    }\n    long r = 1;\n    while (n >\
    \ 0) {\n        if (n % 2 != 0) {\n            r = (r * 2) % p;\n        }\n \
    \       n /= 2;\n        // this is 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\
    \ * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 *", "  \
    \  long y = 1;\n    long x = n;\n    while (p > 0) {\n        if (p % 2 == 1)\
    \ {\n            y = (y * x) % p;\n        }\n        x = (x * x) % p;\n     \
    \   p = p / 2;\n    }\n    return y % p;", "    // assert(p > 1);  // p < 2 is\
    \ not a prime.\n    long r = 1;\n    while (n) {\n        if (n & 1) {\n     \
    \       r = (r * 2) % p;\n        }\n        n /= 2;\n        long d = 2 % p;\n\
    \        if (d == 0) {\n            return 0;\n        }\n        d = (d * d)\
    \ % p;\n    }\n    return r;", "    if (n < 0) {\n        n += (1 - n/p) * p;\n\
    \    }\n    return n % p;", "    assert(p >= 1);\n    if (n == 0) return 1;\n\
    \    long r = n;\n    if (r < 0) r += p;\n    long ans = 1;\n    while (n > 0)\
    \ {\n        if (n & 1) ans = (ans * r) % p;\n        n >>= 1;\n        r = (r\
    \ * r) % p;\n    }\n    return ans;", "    if (n == 0) return 1;\n    long res\
    \ = modp(n >> 1, p);\n    res = (res * res) % p;\n    if (n & 1) res = (res *\
    \ 2) % p;\n    return res;", "  assert(p > 0);\n  if (n < 0) {\n    n = (n % p)\
    \ + p;\n  }\n  long result = 1;\n  long power = n;\n  long b = 2;\n  while (b\
    \ <= power) {\n    if (power & b) {\n      result = (result * n) % p;\n      power\
    \ -= b;\n    }\n    n = (n * n) % p;\n    b = b << 1;\n  }\n  return result;",
  "    if (n==0) return 1;\n    assert(n<p);\n    long half = modp(n/2, p);\n    if\
    \ (n%2==0) {\n        return (half*half)%p;\n    } else {\n        return (half*half*n)%p;\n\
    \    }", "\tassert(n>=0);\n\tassert(p>=2);\n\tlong a = 1;\n\tlong b = 2;\n\twhile\
    \ (n>0) {\n\t\tif (n%2 == 1) {\n\t\t\ta = (a*b)%p;\n\t\t}\n\t\tn /= 2;\n\t\tb\
    \ = (b*b)%p;\n\t}\n\treturn a;", "// assert(n >= 0);\n// assert(p > 0);\nif (n\
    \ == 0) return 1;\nif (n % 2 == 0) {\nlong tmp = modp(n/2, p);\nreturn (tmp *\
    \ tmp) % p;", "    assert(p > 0);\n    assert(n >= 0);\n    long ans = 1;\n  \
    \  for (long i = 1; i <= n; i++)\n        ans = (ans * 2) % p;\n    return ans;",
  "  long r = 1;\n  while (n > 0) {\n    if (n % 2 == 1)\n      r = (r * 2) % p;\n\
    \    n = n / 2;\n  }\n  return r;", "    if (n < 0)\n        return modp(-n, p);\n\
    \    if (n < p)\n        return n;\n    if (n % 2 == 0)\n        return (modp(n\
    \ / 2, p) * modp(n / 2, p)) % p;\n    else\n        return (modp(n / 2, p) * modp(n\
    \ / 2, p) * 2) % p;", "    if (n == 0) return 1;\n    if (n == 1) return n % p;\n\
    \    if (n % 2 == 0) return modp(n / 2, p) * modp(n / 2, p) % p;\n    return modp(n\
    \ / 2, p) * modp(n / 2, p) * n % p;", "    assert(n >= 0);\n    assert(p > 0);\n\
    \    if (n == 0) return 1;\n    long pow = 2;\n    long val = 1;\n    long p2\
    \ = p * p;\n    while (pow <= n) {\n        if (n & pow) {\n            val =\
    \ (val * pow) % p2;\n        }\n        pow = pow << 1;\n    }\n    val = (val\
    \ * p) % p2;\n    return val;", "    long result = 1;\n    for (long i = 1; i\
    \ <= n; i++) {\n        result = result * 2 % p;\n    }\n    return result;",
  "  long r = 1;\n  for (; n > 0; n >>= 1) {\n    if (n & 1) {\n      r = (r * 2)\
    \ % p;\n    }\n  }\n  return r;", "    long res = 1;\n    for (long i = 0; i <\
    \ n; i++) {\n        res = (res * 2) % p;\n    }\n    return res;", "    n %=\
    \ p;\n    if (n <= 1) return n;\n    long ret = 1;\n    for (long i = 1; i <=\
    \ n; i++)\n        ret = (ret * 2) % p;\n    return ret;", "    n %= p;\n    if\
    \ (n < 0) n += p;\n    return n;", "    assert(n >= 0);\n    assert(p > 0);\n\
    \    long ans = 1;\n    long pow = n;\n    while (p > 0) {\n        if (p % 2\
    \ == 1) {\n            ans = (ans * pow) % p;\n        }\n        pow = (pow *\
    \ pow) % p;\n        p = p / 2;\n    }\n    return ans;", "  if (n == 0) return\
    \ 1;\n  if (n % 2 == 0) {\n    long t = modp(n / 2, p);\n    return (t * t) %\
    \ p;\n  }\n  return (modp(n - 1, p) * n) % p;", "\tassert(p >= 1);\n\tlong long\
    \ x = 1;\n\tfor (; n > 0; n >>= 1) {\n\t\tif (n & 1) {\n\t\t\tx = (x * x) % p;\n\
    \t\t}\n\t\tx = (x * x) % p;\n\t}\n\treturn x;", "    if(n==0) return 1;\n    assert(n<p);\n\
    \    if(n<0) n+=p;\n    std::vector<bool> bits;\n    while(n>0) {\n        bits.push_back(n%2);\n\
    \        n/=2;\n    }\n    long res=1;\n    for(int i=bits.size()-1; i>=0; i--)\
    \ {\n        res=res*res%p;\n        if(bits[i]) res=res*2%p;\n    }\n    return\
    \ res;", "  assert(n >= 0);\n  assert(p > 0);\n  if (n < p) {\n    return n;\n\
    \  }\n  long x = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      x = (x *\
    \ 2) % p;\n    }\n    n /= 2;\n    if (n > 0) {\n      x = (x * x) % p;\n    }\n\
    \  }\n  return x;", "\tif (n == 0) return 1;\n\telse if (n % 2 == 0) {\n\t\tlong\
    \ half = modp(n / 2, p);\n\t\treturn (half * half) % p;\n\t}\n\telse {\n\t\treturn\
    \ (modp(n - 1, p) * n) % p;\n\t}", "  assert(n >= 0);\n  assert(p > 0);\n  //\
    \ If p is even, 2^n mod p = (2 mod p)^n mod p\n  if (p % 2 == 0) {\n    return\
    \ modp(n, p/2) * modp(n, p/2) % p;\n  }\n  // If n is even, 2^n mod p = (2^(n/2)\
    \ mod p)^2 mod p\n  if (n % 2 == 0) {\n    return modp(n/2, p) * modp(n/2, p)\
    \ % p;\n  }\n  // If n is odd, 2^n mod p = 2 * (2^(n-1) mod p) mod p\n  return\
    \ 2 * modp(n-1, p) % p;", "\tif (n == 0) return 1;\n\tif (n == 1) return n % p;\n\
    \tassert(p < (1 << 30));\n\tlong res = 1;\n\t// This is more efficient than n\
    \ % p.\n\tlong exp = n % (p - 1);\n\tlong base = n % p;\n\twhile (exp) {\n\t\t\
    if (exp & 1) res = (res * base) % p;\n\t\tbase = (base * base) % p;\n\t\texp >>=\
    \ 1;\n\t}\n\treturn res;", "    assert(p >= 2);\n    if (n < p) return n;\n  \
    \  long pow_2_modp = 2;\n    long result = pow_2_modp;\n    long pow_2 = 4;\n\
    \    while (n >= pow_2) {\n        if (n & pow_2) {\n            result = (result\
    \ * pow_2_modp) % p;\n            n -= pow_2;\n        }\n        pow_2_modp =\
    \ (pow_2_modp * pow_2_modp) % p;\n        pow_2 *= 2;\n    }\n    result = (result\
    \ * modp(n, p)) % p;\n    return result;", "\tif (n==0) return 1;\n\tlong n_half\
    \ = modp(n/2, p);\n\tlong n_half_sq = (n_half*n_half)%p;\n\tlong ret = n%2==0\
    \ ? n_half_sq : (n_half_sq*2)%p;\n\tif (ret<0) ret += p;\n\treturn ret;", "  assert(n\
    \ >= 0);\n  assert(p > 0);\n  if (n == 0) return 1;\n  long q = modp(n / 2, p);\n\
    \  return n % 2 == 0 ? (q * q) % p : (q * q * 2) % p;", "    long res = 1;\n \
    \   while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n  \
    \      n = n >> 1;\n    }\n    return res;", "  if(n==0)\n    return 1;\n  long\
    \ t = modp(n/2, p);\n  if(n%2==0)\n    return (t*t)%p;\n  else\n    return (t*t*2)%p;",
  "    if (n < 0) n = n % p + p;\n    if (n == 0) return 1;\n    if (n == 1) return\
    \ n;\n    long ret = modp(n / 2, p);\n    ret = (ret * ret) % p;\n    if (n %\
    \ 2 == 1) ret = (ret * n) % p;\n    return ret;", "    if (n==0) return 1;\n \
    \   if (n==1) return n%p;\n    long c = modp(n/2, p);\n    if (n%2==0) return\
    \ (c*c)%p;\n    else return (c*c*n)%p;", "\tif (n == 0) return 1;\n\tlong r =\
    \ 1;\n\twhile (n > 0) {\n\t\tif (n & 1) r = (r * r) % p;\n\t\tn >>= 1;\n\t}\n\t\
    return r;", "    long result = 1;\n    for (long i = 0; i < n; i++) {\n      \
    \  result = (result * 2) % p;\n    }\n    return result;", "    if (n == 0) return\
    \ 1;\n    long ans = modp(n/2, p);\n    ans = (ans * ans) % p;\n    if (n % 2\
    \ == 1) ans = (ans * 2) % p;\n    return ans;", "    if (n < 0) {\n        return\
    \ modp(-n, p);\n    }\n    long res = 1;\n    long b = 2;\n    while (n > 0) {\n\
    \        if (n % 2 == 1) {\n            res = (res * b) % p;\n        }\n    \
    \    n /= 2;\n        b = (b * b) % p;\n    }\n    return res;", "  long r = 1;\n\
    \  while (n > 0) {\n    if (n % 2 == 1)\n      r = (r * 2) % p;\n    n = n / 2;\n\
    \  }\n  return r;", "    assert(p > 0);\n    assert(n >= 0);\n    if (n == 0)\
    \ return 1;\n    if (n == 1) return n % p;\n    if (n % 2 == 0) {\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n    } else {\n        return modp(n /\
    \ 2, p) * modp(n / 2, p) * 2 % p;\n    }", "\tassert(p >= 2);\n\tif (n % p ==\
    \ 0) return 0;\n\tif (n < p) return n;\n\tlong m = 1;\n\tfor (long a = n; a; a\
    \ /= 2) {\n\t\tif (a % 2) m = (m * 2) % p;\n\t\tlong b = (a + 1) / 2;\n\t\tlong\
    \ t = b * b;\n\t\tif (t >= p) t %= p;\n\t\tif (n >= t) n -= t;\n\t}\n\treturn\
    \ m;", "    if (n == 0) return 1;\n    if (n % 2 == 0) return modp((n/2)*(n/2),\
    \ p);\n    return (modp(n/2, p) * modp(n/2 + 1, p)) % p;", "    if (n == 0) return\
    \ 1;\n    long res = modp(n/2, p);\n    res = (res * res) % p;\n    if (n % 2\
    \ == 1) res = (res * 2) % p;\n    return res;", "    if(n == 0) {\n        return\
    \ 1;\n    }\n    if(n == 1) {\n        return n;\n    }\n    // The below function\
    \ is from https://stackoverflow.com/questions/11440263/how-to-compute-in-modulo-p\n\
    \    long ret = modp(n/2, p);\n    ret = (ret * ret) % p;\n    if(n%2 != 0) {\n\
    \        ret = (ret * n) % p;\n    }\n    return ret;", "    assert(p >= 2);\n\
    \    if (n >= p)\n        n %= p;\n    long c = 1;\n    while (n > 0) {\n    \
    \    if (n & 1)\n            c = (c * 2) % p;\n        n >>= 1;\n        // cout\
    \ << c << ' ' << n << endl;\n    }\n    return c;", "    if (n == 0) {\n     \
    \   return 1;\n    }\n    if (n == 1) {\n        return n % p;\n    }\n    long\
    \ ans = modp(n >> 1, p);\n    ans = (ans * ans) % p;\n    if (n & 1) {\n     \
    \   ans = (ans * n) % p;\n    }\n    return ans;", "    if (n == 0) {\n      \
    \  return 1;\n    } else if (n == 1) {\n        return n;\n    } else if (n %\
    \ 2 == 0) {\n        long t = modp(n / 2, p);\n        return (t * t) % p;\n \
    \   } else {\n        return (n * modp(n - 1, p)) % p;\n    }", "  assert(p >\
    \ 0);\n  if (n == 0) return 1;\n  if (n % 2 == 0) {\n    long r = modp(n / 2,\
    \ p);\n    return (r * r) % p;\n  } else {\n    return (modp(n - 1, p) * n) %\
    \ p;\n  }", "\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n % 2 == 0) {\n\t\tlong\
    \ m = modp(n / 2, p);\n\t\treturn (m * m) % p;\n\t}\n\treturn (2 * modp(n - 1,\
    \ p)) % p;", "    if (n < p) { return n; }\n    long r = 1;\n    for (long i =\
    \ 0; i < n; i++) {\n        r = r * 2 % p;\n    }\n    return r;", "    if (n\
    \ == 0) return 1;\n    long x = modp(n/2, p);\n    x = (x * x) % p;\n    if (n\
    \ % 2) x = (x * 2) % p;\n    return x;", "\tif (n >= p) n %= p;\n\tif (n == 0)\
    \ return 1;\n\tif (n == 1) return n;\n\tlong w = n, r = 1;\n\twhile (w > 0) {\n\
    \t\tif (w & 1) r = (r * n) % p;\n\t\tw >>= 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn\
    \ r;", "    if (n <= 0) return 1;\n    long res = 1;\n    while (n > 0) {\n  \
    \      if (n % 2 == 1) res = (res * 2) % p;\n        n /= 2;\n    }\n    return\
    \ res;", "\tassert(p >= 1);\n\tif (n == 0) return 1;\n\tlong z = modp(n/2, p);\n\
    \tif (n % 2 == 0) return (z*z) % p;\n\telse return ( (z*z) % p * n ) % p;", " \
    \   long x = 1;\n    long t = n;\n    while (t) {\n        if (t & 1) x = (x *\
    \ n) % p;\n        n = (n * n) % p;\n        t >>= 1;\n    }\n    return x;",
  "  assert(n >= 0);\n  assert(p > 0);\n  if (n == 0) return 1;\n  if (n == 1) return\
    \ n % p;\n  return modp(n / 2, p) * modp(n - n / 2, p) % p;", "    assert(p >\
    \ 0);\n    assert(n >= 0);\n    // Initialize result\n    long res = 1;\n    //\
    \ Update x if it is more\n    // than or equal to p\n    long x = n;\n    while\
    \ (x > 1) {\n        // If x is odd, multiply x\n        // with result\n    \
    \    if (x & 1) {\n            res = (res * x) % p;\n        }\n        // x must\
    \ be even now\n        x = x >> 1; // x = x/2\n        x = (x * x) % p;\n    }\n\
    \    if (n == 0) {\n        return 1;\n    }\n    return res;", "    assert(n\
    \ >= 0);\n    long k = 1;\n    while (n) {\n        if (n & 1) {\n           \
    \ k = (k * 2) % p;\n        }\n        n >>= 1;\n    }\n    return k;", "   //\
    \ Implement this function.\n\tif(n==0)\n\t\treturn 1;\n\tif(n%2==0)\n\t{\n\t\t\
    long t=modp(n/2,p);\n\t\treturn (t*t)%p;\n\t}\n\telse\n\t{\n\t\treturn ((2%p)*modp(n-1,p))%p;\n\
    \t}", "    if (n < 0) {\n        n += (-n/p + 1) * p;\n    }\n    long c = 1;\n\
    \    while (n > 0) {\n        if (n & 1) {\n            c = (c * 2) % p;\n   \
    \     }\n        n >>= 1;\n        if (n > 0) {\n            c = (c * 2) % p;\n\
    \        }\n    }\n    return c;", "  assert(p > 0);\n  if (n < 0) n = n % p +\
    \ p;\n  int res = 1;\n  for (long e = n; e > 0; e >>= 1) {\n    if (e & 1) res\
    \ = res * n % p;\n    n = n * n % p;\n  }\n  return res;", "    assert(p >= 1);\n\
    \    // Use binary power to compute n^p % p.\n    long answer = 1;\n    long multiplier\
    \ = n;\n    // Loop invariant: answer contains the value of n^i % p.\n    while\
    \ (p != 0) {\n        // If p is odd, add n^p to the answer.\n        if (p %\
    \ 2 == 1) {\n            answer = (answer * multiplier) % MOD;\n        }\n  \
    \      // Square n^p.\n        multiplier = (multiplier * multiplier) % MOD;\n\
    \        // Divide p by 2.\n        p /= 2;\n    }\n    return answer;", "  if\
    \ (n == 0) return 1;\n  long sq = modp(n/2, p);\n  sq = (sq * sq) % p;\n  if (n\
    \ & 1) sq = (sq * 2) % p;\n  return sq;", "    // return (n % p + p) % p;\n  \
    \  assert(n >= 0);\n    assert(p > 0);\n    assert(p < 1<<31);\n    if (n == 0)\
    \ return 1;\n    long res = 1;\n    while (n) {\n        if (n & 1) res = (res\
    \ * 2) % p;\n        n >>= 1;\n    }\n    return res;", "  if (n == 0) return\
    \ 1;\n  if (n == 1) return n % p;\n  if (n % 2 == 0) {\n    long half = modp(n\
    \ / 2, p);\n    return (half * half) % p;\n  } else {\n    return ((n % p) * modp(n\
    \ - 1, p)) % p;\n  }", "    long ret = 1;\n    while (n) {\n        if (n % 2)\
    \ ret = (ret * p) % 101;\n        p = (p * p) % 101;\n        n /= 2;\n    }\n\
    \    return ret;", "    assert(n >= 0);\n    assert(p > 0);\n    long res = 1;\n\
    \    while (n > 0) {\n        if (n & 1) {\n            res = (res * 2) % p;\n\
    \        }\n        n >>= 1;\n    }\n    return res;", "    assert(n>=0);\n  \
    \  assert(p>=2);\n    long d = 1;\n    while (n) {\n        if (n & 1) d = (d\
    \ * 2) % p;\n        n >>= 1;\n    }\n    return d;", "  assert(p > 0);\n  if\
    \ (n < 0)\n    n = (n % p) + p;\n  if (n < p / 2)\n    return n;\n  else\n   \
    \ return n - p;", "  long ans = 1;\n  while (n > 0) {\n    ans = (ans * (n % 2\
    \ == 1 ? 2 : 1)) % p;\n    n /= 2;\n  }\n  return ans;", "  if (n == 0) {\n  \
    \  return 1;\n  }\n  if (n == 1) {\n    return n % p;\n  }\n  // n > 1\n  long\
    \ n_div_2 = n / 2;\n  long n_minus_n_div_2 = n - n_div_2;\n  long X = modp(n_div_2,\
    \ p);\n  long Y = modp(n_minus_n_div_2, p);\n  long result = X * Y;\n  return\
    \ result % p;", "\tif (n == 0) return 1;\n\tif (n % 2 == 0) return modp((n / 2)\
    \ * (n / 2), p);\n\treturn (modp(n - 1, p) * 2) % p;", "  assert(p > 0);\n  long\
    \ res = 1;\n  while (n > 0) {\n    if (n & 1) {\n      res = (res * n) % p;\n\
    \    }\n    n >>= 1;\n    n %= p;\n  }\n  return res;", "  if (n < 0) {\n    //\
    \ Negative powers are not allowed, so compute the inverse and\n    // fall through\
    \ to the positive case.\n    return modp(-n, p);\n  }\n  if (n == 0) return 1;\n\
    \n  if (n % 2 == 0) {\n    long x = modp(n/2, p);\n    return (x*x) % p;\n  }\
    \ else {\n    long x = modp(n/2, p);\n    long y = modp(n/2 + 1, p);\n    return\
    \ (x*y) % p;\n  }", "  if (n == 0) return 1;\n  if (n % 2 == 0) {\n    long x\
    \ = modp(n/2, p);\n    return (x*x) % p;\n  } else {\n    return (modp(n-1, p)\
    \ * n) % p;\n  }", "    if (n == 0) return 1;\n    if (n % 2 == 0) return modp((n\
    \ / 2) * (n / 2), p);\n    else return (modp(n / 2, p) * modp(n / 2, p)) % p;",
  "\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tlong tmp = modp(n / 2, p);\n\t\
    \treturn (tmp * tmp) % p;\n\t}\n\telse {\n\t\treturn (modp(n - 1, p) * 2) % p;\n\
    \t}", "  assert(p > 0);\n  if (n < 0) { n += 1 - n / p * p; }\n  return n % p;",
  "    if (n == 0) return 1;\n    long ans = modp(n / 2, p);\n    ans = (ans * ans)\
    \ % p;\n    if (n % 2 == 1) ans = (ans * 2) % p;\n    return ans;", "  // Handle\
    \ special cases like n == 0\n  if (n == 0) return 1;\n  long result = 1;\n  while\
    \ (n > 0) {\n    if (n & 1) { // n is odd\n      result = (result * n) % p;\n\
    \    }\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n  return result;", "  assert(p\
    \ > 0);\n  if (n < 0) {\n    n = p - 1 - ((-n - 1) % (p - 1));\n  }\n  long result\
    \ = 1;\n  long factor = n;\n  while (p > 0) {\n    if (p & 1) {\n      result\
    \ = (result * factor) % n;\n    }\n    factor = (factor * factor) % n;\n    p\
    \ /= 2;\n  }\n  return result;", "\tif (n == 0) return 1;\n\tlong x = modp(n /\
    \ 2, p);\n\tx = (x * x) % p;\n\tif (n % 2 == 1) x = (x * 2) % p;\n\treturn x;",
  "\tn %= p;\n\tif (n < 0) n += p;\n\tlong result = 1;\n\tlong b = n;\n\tlong e =\
    \ 1;\n\twhile (e <= INT_MAX) {\n\t\tif (e & 1) {\n\t\t\tresult = (result * b)\
    \ % p;\n\t\t}\n\t\te >>= 1;\n\t\tb = (b * b) % p;\n\t}\n\treturn result;", " \
    \ assert(p > 0);\n  if (n <= 1)\n    return n;\n  long res = 1;\n  while (n >\
    \ 0) {\n    if (n & 1)\n      res = (res * n) % p;\n    n = n >> 1;\n    n = (n\
    \ * n) % p;\n  }\n  return res % p;", "    long result = 1;\n    while (n > 0)\
    \ {\n        if (n & 1) {\n            result = (result * 2) % p;\n        }\n\
    \        n >>= 1;\n    }\n    return result;", "    if (n == 0) return 1;\n  \
    \  if (n % 2 == 0) {\n        long r = modp(n / 2, p);\n        return r * r %\
    \ p;\n    }\n    return modp(n - 1, p) * n % p;", "  if(n==0) return 1;\n  if(n%2==0)\
    \ return modp((n/2)*(n/2), p);\n  else return (modp(n-1, p)*2)%p;", "\tif (n ==\
    \ 0) {\n\t\treturn 1;\n\t}\n\tif (n % 2 == 0) {\n\t\tlong t = modp(n / 2, p);\n\
    \t\treturn (t * t) % p;\n\t}\n\treturn (modp(n - 1, p) * n) % p;", "\tassert(p\
    \ > 0);\n\tassert(n >= 0);\n\tassert(n < p);\n\tlong res = 1;\n\tlong pp = p;\n\
    \tlong pn = p - 1;\n\tlong pow = n;\n\twhile (pn > 0) {\n\t\tif (pn & 1) {\n\t\
    \t\tres = (res * pow) % pp;\n\t\t}\n\t\tpow = (pow * pow) % pp;\n\t\tpn >>= 1;\n\
    \t}\n\treturn res;", "    if (n == 0) return 1;\n    if (n == 1) return n % p;\n\
    \    if (n % 2 == 0) {\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n\
    \    } else {\n        return (n * modp(n - 1, p)) % p;\n    }", "    long a=1;\n\
    \    long b=2;\n    long exp=n;\n    while(exp>0) {\n        if(exp%2==1) {\n\
    \            a=(a*b)%p;\n        }\n        b=(b*b)%p;\n        exp/=2;\n    }\n\
    \    return a;", "  if (n == 0) return 1;\n  if (n % 2 == 0) {\n    long r = modp(n\
    \ / 2, p);\n    return r * r % p;\n  }\n  return n * modp(n - 1, p) % p;", " \
    \   // this is based on Fermat's little theorem, if p is prime then for\n    //\
    \ any a modp(a, p) = a\n    assert(n >= 0);\n    assert(p > 0);\n    if (n ==\
    \ 0) {\n        return 1;\n    }\n    // note that mod(a^b, p) = mod(a, p)^b mod(p)\n\
    \    if (n % 2 == 0) {\n        long half = modp(n / 2, p);\n        return (half\
    \ * half) % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }",
  "    if (n == 0) {\n        return 1;\n    } else if (n % 2 == 0) {\n        long\
    \ tmp = modp(n / 2, p);\n        return (tmp * tmp) % p;\n    } else {\n     \
    \   return (modp(n - 1, p) * n) % p;\n    }", "    long r = 1;\n    while (n >\
    \ 0) {\n        if (n & 1) {\n            r = (r * 2) % p;\n        }\n      \
    \  n >>= 1;\n    }\n    return r;", "    assert(n >= 0);\n    assert(p > 0);\n\
    \    // Return 1 if n = 0 or p = 1.\n    if (n == 0 || p == 1) return 1;\n   \
    \ // If n is even then even modulo even is even.\n    if (n % 2 == 0) return modp(n/2,\
    \ p) * modp(n/2, p) % p;\n    // If n is odd then halve the exponent and multiply.\n\
    \    return modp(n/2, p) * modp(n/2, p) * n % p;", "  long res = 1;\n  for (int\
    \ i = 0; i < n; i++) {\n    res = (res*2) % p;\n  }\n  return res;", "    long\
    \ res = 1;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            res =\
    \ (res * n) % p;\n        }\n        n = n / 2;\n        n = (n * n) % p;\n  \
    \  }\n    return res % p;", "\tassert(p > 0);\n\tif (n == 0)\n\t\treturn 1;\n\t\
    if (n == 1)\n\t\treturn n % p;\n\tlong t = modp(n / 2, p);\n\tlong res = (t *\
    \ t) % p;\n\tif (n % 2)\n\t\tres = (res * 2) % p;\n\treturn res;", "\tlong res\
    \ = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)\n\t\t\tres = (res * n) % p;\n\t\tn =\
    \ n >> 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn res;", "    long a = 1;\n    long\
    \ b = 2;\n    for (; n > 0; n >>= 1) {\n        if (n & 1) {\n            a =\
    \ (a * b) % p;\n        }\n        b = (b * b) % p;\n    }\n    return a;", "\t\
    long r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) {\n\t\t\tr = (r * 2) % p;\n\t\t\
    }\n\t\tn >>= 1;\n\t}\n\treturn r;", "    int c = 1;\n    while (n > 0) {\n   \
    \     if (n & 1) {\n            c = (c * n) % p;\n        }\n        n >>= 1;\n\
    \    }\n    return c;", "    if (n == 0) return 1;\n    long x = modp(n / 2, p);\n\
    \    x = (x * x) % p;\n    if (n % 2 == 1) x = (x * 2) % p;\n    return x;", " \
    \   assert(p > 0);\n    if (n == 0) {\n        return 1;\n    } else if (n % 2\
    \ == 0) {\n        return modp(n/2, p) * modp(n/2, p) % p;\n    } else {\n   \
    \     return modp(n/2, p) * modp(n/2, p) * n % p;\n    }", "    long r = 1;\n\
    \    for (int i = 0; i < n; i++) {\n        r = (r * 2) % p;\n    }\n    return\
    \ r;", "  long r = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      r = (r\
    \ * 2) % p;\n    }\n    n = n / 2;\n    if (n > 0) {\n      r = (r * r) % p;\n\
    \    }\n  }\n  return r;", "\tlong r = 1;\n\tlong x = n % p;\n\tif (x==0)\n\t\t\
    return 1;\n\twhile (n > 0) {\n\t\tif (n % 2 != 0) {\n\t\t\tr = (r * x) % p;\n\t\
    \t}\n\t\tx = (x * x) % p;\n\t\tn = n / 2;\n\t}\n\treturn r;", "    if (n == 0)\
    \ return 1;\n    long ans = modp(n >> 1, p);\n    ans = (ans * ans) % p;\n   \
    \ if (n & 1)\n        ans = (ans * 2) % p;\n    return ans;", "    if (n == 0)\
    \ return 1;\n    if (n % 2 == 0) {\n        long z = modp(n/2, p);\n        return\
    \ (z*z) % p;\n    } else {\n        return (n*modp(n-1, p)) % p;\n    }", "  long\
    \ res = 1;\n  for (long i = 1; i <= n; i++) {\n    res = (res * 2) % p;\n  }\n\
    \  return res;", "  // The negative powers of two mod p are the same as the positive\
    \ powers.\n  if (n < 0) {\n    n = -n;\n  }\n  // Simple cases.\n  if (n == 0)\
    \ {\n    return 1;\n  }\n  if (n == 1) {\n    return 2 % p;\n  }\n  // Find the\
    \ highest order bit of n.\n  long highest = 0;\n  long p2 = 1;\n  while (p2 <=\
    \ n) {\n    p2 <<= 1;\n    highest++;\n  }\n  p2 >>= 1;\n  highest--;\n  // Start\
    \ the exponentiation.\n  long v = 2;\n  // Combine the lower order bits of n.\n\
    \  long pow2 = 0;\n  long mask = 1;\n  for (long i = 0; i < highest; i++) {\n\
    \    if (n & mask) {\n      pow2 += 1 << i;\n    }\n    mask <<= 1;\n  }\n  pow2\
    \ = modp(pow2, p);\n  v = (v * pow2) % p;\n  // Combine the higher order bits\
    \ of n.\n  while (p2 > 1) {\n    p2 >>= 1;\n    pow2 = (pow2 * pow2) % p;\n  \
    \  if (n & p2) {\n      v = (v * pow2) % p;\n    }\n  }\n  return v;", "    //\
    \ return (1 if n == 0 else pow(2, n, p))\n    if (n == 0) return 1;\n    assert(n\
    \ > 0);\n    long result = 1;\n    long power = 2;\n    while (n > 0) {\n    \
    \    if (n & 1) result = (result * power) % p;\n        power = (power * power)\
    \ % p;\n        n >>= 1;\n    }\n    return result;", "\tlong res = 1;\n\tlong\
    \ sq = n;\n\twhile (p > 0) {\n\t\tif (p % 2 != 0) {\n\t\t\tres = (res * sq) %\
    \ p;\n\t\t}\n\t\tsq = (sq * sq) % p;\n\t\tp /= 2;\n\t}\n\treturn res;", "    long\
    \ res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res = (res\
    \ * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n) % p;\n    }\n\
    \    return res;", "    assert(n >= 0);\n    if (n == 0) return 1;\n    long m\
    \ = modp(n/2, p);\n    if (n % 2 == 0) {\n        return (m*m) % p;\n    } else\
    \ {\n        return (2*m*m) % p;\n    }", "    if (n == 0) return 1;\n    long\
    \ x = modp(n/2, p);\n    x = (x * x) % p;\n    if (n % 2 == 1) x = (x * 2) % p;\n\
    \    return x;", "\t// Implement this function as described in the handout, and\
    \ then delete this comment.\n\t// Do not return any other value, and do not change\
    \ the type of the return value.\n\tif (n == 0)\n\t\treturn 1;\n\tlong y = modp(n\
    \ / 2, p);\n\tif (n % 2 == 0)\n\t\treturn (y * y) % p;\n\telse\n\t\treturn (y\
    \ * y * n) % p;", "    if (n == 0) return 1;\n    long result = 1;\n    while\
    \ (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * 10) % p;\n\
    \        }\n        n = n / 2;\n        if (n > 0) {\n            p = (p * p)\
    \ % p;\n        }\n    }\n    return result;", "    long pow2 = 1;\n    long result\
    \ = 1;\n    while (n > 0) {\n        if (n % 2 == 1)\n            result = (result\
    \ * pow2) % p;\n        pow2 = (pow2 * pow2) % p;\n        n /= 2;\n    }\n  \
    \  return result;", "    long res = 1;\n    n %= p;\n    while (n > 0) {\n   \
    \     if (n & 1) {\n            res = (res * n) % p;\n        }\n        n = n\
    \ >> 1;\n        n = (n * n) % p;\n    }\n    return res;", "\tassert(n >= 0);\n\
    \tassert(p > 0);\n\t// Find base 2 logarithm of n.\n\tint logn = 0;\n\tfor (long\
    \ t = n; t; t /= 2)\n\t\tlogn++;\n\t// Build table of modp(2^i, p).\n\tlong m[logn];\n\
    \tm[0] = 1;\n\tfor (int i = 1; i < logn; i++)\n\t\tm[i] = (m[i - 1] * 2) % p;\n\
    \t// Return modp(n, p).\n\tlong result = 1;\n\tfor (int i = 0; n; i++, n /= 2)\n\
    \t\tif (n % 2)\n\t\t\tresult = (result * m[i]) % p;\n\treturn result;", "\tif\
    \ (n < 0) {\n\t\tn = n % p + p;\n\t}\n\tlong r = 1;\n\twhile (n > 0) {\n\t\tif\
    \ (n % 2 == 1) {\n\t\t\tr = (r * 3) % p;\n\t\t}\n\t\tn /= 2;\n\t\tif (n > 0) {\n\
    \t\t\tr = (r * r) % p;\n\t\t}\n\t}\n\treturn r;", "    if (n == 0) {\n       \
    \ return 1;\n    }\n    if (n % 2 == 0) {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p;\n    }\n    return modp(n/2, p) * modp(n/2, p) * n % p;", "    long\
    \ res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res = (res\
    \ * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n) % p;\n    }\n\
    \    return res;", "  assert(p > 0);\n  if (n < 0) n = p - ((-n) % p);\n  if (n\
    \ >= p) n %= p;\n  assert(n >= 0);\n  return n;", "  // Initially x == 1 (mod\
    \ p).\n  long x = 1;\n  while (n > 0) {\n    // Invariant: x == 1 (mod p).\n \
    \   if (n % 2 != 0) {\n      // If n is odd, multiply x with a (mod p).\n    \
    \  x = (x * 3) % p;\n    }\n    // Now n is even.\n    n = n / 2;\n    // Keep\
    \ x == 1 (mod p).\n    if (n > 0) {\n      x = (x * x) % p;\n    }\n  }\n  return\
    \ x;", "\tif (n < 0) {\n\t\tprintf(\"Error: n must be positive.\\n\");\n\t\texit(1);\n\
    \t}\n\tif (p <= 0) {\n\t\tprintf(\"Error: p must be a positive prime.\\n\");\n\
    \t\texit(1);\n\t}\n\tlong res = 1;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1)\n\t\
    \t\tres = (res * 2) % p;\n\t\tn /= 2;\n\t}\n\treturn res;", "    if (n == 0) {\n\
    \        return 1;\n    } else if (n % 2 == 0) {\n        long half = modp(n /\
    \ 2, p);\n        return (half * half) % p;\n    } else {\n        return (2 *\
    \ modp(n - 1, p)) % p;\n    }", "    assert(p > 0);\n    // return (n < p) ? n\
    \ : (modp(n / 2, p) * 2) % p;\n    if (n < p) return n;\n    else return (modp(n\
    \ / 2, p) * 2) % p;", "  long result = 1;\n  for (long i = 1; i <= n; i++) {\n\
    \    result = (result * 2) % p;\n  }\n  return result;", "    if (n == 0) return\
    \ 1;\n    if (n == 1) return n % p;\n    long x = modp(n/2, p);\n    long y =\
    \ x*x % p;\n    if (n % 2 == 1) y = y*n % p;\n    return y;", "  if (n == 0) return\
    \ 1;\n  long t = modp(n/2, p);\n  if (n % 2 == 0) return (t*t) % p;\n  else return\
    \ (t*t*2) % p;", "    assert(p > 0);\n    if (n == 0) return 1;\n    if (n % 2\
    \ == 0) {\n        long r = modp(n / 2, p);\n        return (r * r) % p;\n   \
    \ } else {\n        return (modp(n - 1, p) * n) % p;\n    }", "    if (n == 0)\
    \ {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long r = modp(n\
    \ / 2, p);\n        return r * r % p;\n    }\n    return modp(n - 1, p) * n %\
    \ p;", "    if (n == 0) {\n        return 1;\n    }\n    else if (n == 1) {\n\
    \        return n;\n    }\n    else {\n        long result = 1;\n        long\
    \ x = n;\n        while (p > 0) {\n            if (p & 1) {\n                result\
    \ = (result * x) % n;\n            }\n            x = (x * x) % n;\n         \
    \   p >>= 1;\n        }\n        return result;\n    }", "    assert(n >= 0);\n\
    \    assert(p > 0);\n    if (n == 0) {\n        return 1;\n    }\n    long r =\
    \ modp(n/2, p);\n    r = (r*r) % p;\n    if (n % 2 == 1) {\n        r = (r*2)\
    \ % p;\n    }\n    return r;", "    if(n == 0) return 1;\n    else if(n % 2 ==\
    \ 0) {\n        long r = modp(n/2, p);\n        return (r*r) % p;\n    } else\
    \ {\n        return (modp(n-1, p) * 2) % p;\n    }", "    assert(p > 0);\n   \
    \ if (n == 0) {\n        return 1;\n    }\n    else if (n == 1) {\n        return\
    \ n;\n    }\n    long q = modp(n/2, p);\n    long result = q*q % p;\n    if (n\
    \ % 2 != 0) {\n        result = result * n % p;\n    }\n    return result;", " \
    \   long ans = 1;\n    long x = n % p;\n    while (n > 0) {\n        if (n % 2\
    \ == 1) {\n            ans = (ans * x) % p;\n        }\n        x = (x * x) %\
    \ p;\n        n = n / 2;\n    }\n    return ans;", "    int i;\n    long a = 1;\n\
    \    for (i = 0; i < n; i++) {\n        a = a*2 % p;\n    }\n    return a;", " \
    \ long a = 1;\n  long b = 2;\n  while (n) {\n    if (n % 2) {\n      a = (a *\
    \ b) % p;\n    }\n    b = (b * b) % p;\n    n /= 2;\n  }\n  return a;", "    if\
    \ (n == 0) {\n        return 1;\n    } else if (n == 1) {\n        return 2 %\
    \ p;\n    } else if (n % 2 == 0) {\n        long k = modp(n / 2, p);\n       \
    \ return k * k % p;\n    } else {\n        long k = modp(n - 1, p);\n        return\
    \ k * 2 % p;\n    }", "  long res = 1;\n  while (n > 0) {\n    if (n & 1)\n  \
    \    res = (res * 2) % p;\n    n = n >> 1;\n  }\n  return res;", "    if (n ==\
    \ 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        long t = modp(n\
    \ / 2, p);\n        return (t * t) % p;\n    }\n    return (modp(n - 1, p) * n)\
    \ % p;", "    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long res =\
    \ modp(n/2, p);\n        return (res * res) % p;\n    }\n    else return (modp(n-1,\
    \ p) * (n % p)) % p;", "    if (n < 0) {\n        n = (p - (-n % p)) % p;\n  \
    \  }\n    long res = 1;\n    long base = 2;\n    for (; n > 0; n /= 2) {\n   \
    \     if (n % 2 == 1) {\n            res = (res * base) % p;\n        }\n    \
    \    base = (base * base) % p;\n    }\n    return res;", "  // We need a long\
    \ type because we need to hold the result of pow (which may\n  // exceed the boundaries\
    \ of int).\n  // If n is 0, the result should be 1.\n  if (n == 0) {\n    return\
    \ 1;\n  }\n  long res = 1;\n  long pow_mod = 1;\n  long pow_mod_prev = 1;\n  while\
    \ (n > 0) {\n    long bit = n & 1;\n    if (bit == 1) {\n      pow_mod = (pow_mod\
    \ * pow_mod_prev) % p;\n      res = (res * pow_mod) % p;\n    }\n    n >>= 1;\n\
    \    pow_mod_prev = (pow_mod_prev * pow_mod_prev) % p;\n  }\n  return res;", " \
    \ long res = 1;\n  for (int i = 1; i <= n; i++) {\n    res = (res * 2) % p;\n\
    \  }\n  return res;", "  assert(p > 0);\n  n %= p;\n  if (n < 0) n += p;\n  if\
    \ (n < 0) n += p;\n  assert(n >= 0 && n < p);\n  if (n == 0) return 1;\n  long\
    \ q = modp(n >> 1, p);\n  if (n & 1) return (q + q * q) % p;\n  return (q + q)\
    \ % p;", "    if (n == 0) return 1;\n    long m = modp(n / 2, p);\n    m = (m\
    \ * m) % p;\n    if (n % 2 == 1) m = (m * 2) % p;\n    return m;", "    if (n\
    \ <= 1) return n;\n    long res = 1;\n    for (long b = n; b > 0; b >>= 1) {\n\
    \        if (b & 1) res = (res * n) % p;\n        n = (n * n) % p;\n    }\n  \
    \  return res;", "\t// Return n modulo p.\n\treturn n % p;", "  assert(p != 0);\n\
    \  assert(n != 0);\n  assert(p != 1);\n  long result = 1;\n  while (n > 0) {\n\
    \    if (n & 1) {\n      result = (result * (long)result) % p;\n    }\n    n >>=\
    \ 1;\n  }\n  return result;", "  assert(p > 0);\n\n  long m = 1;\n  for (long\
    \ i = 1; i <= n; i++) {\n    m = (m * 2) % p;\n  }\n  return m;", "\tlong a =\
    \ 1;\n\tlong b = 2;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1) {\n\t\t\ta = (a *\
    \ b) % p;\n\t\t}\n\t\tb = (b * b) % p;\n\t\tn = n / 2;\n\t}\n\treturn a;", " \
    \   if(n < 0 || p < 0) return modp(n % p + p, p);\n    if(!n) return 1;\n    if(n\
    \ % 2) return (2 * modp(n - 1, p)) % p;\n    return modp(n / 2, p) * modp(n /\
    \ 2, p) % p;", "\tif (n == 0) return 1;\n\tlong ans = modp(n / 2, p);\n\tans =\
    \ (ans * ans) % p;\n\tif (n % 2 == 1) ans = (ans * 2) % p;\n\treturn ans;", " \
    \   long res = 1;\n    while (n) {\n        if (n & 1)\n            res = (res\
    \ * 2) % p;\n        n >>= 1;\n    }\n    return res;", "    if (n == 0) {\n \
    \       return 1;\n    }\n    else if (n == 1) {\n        return n % p;\n    }\n\
    \    else {\n        long k = modp(n / 2, p);\n        if (n % 2 == 0) {\n   \
    \         return (k * k) % p;\n        }\n        else {\n            return (((k\
    \ * k) % p) * n) % p;\n        }\n    }", "    if (n == 0) return 1;\n    long\
    \ x = modp(n / 2, p);\n    long v = x * x % p;\n    if (n % 2) {\n        v =\
    \ v * 2 % p;\n    }\n    return v;", "    if (n == 0) return 1;\n    long r =\
    \ modp(n / 2, p);\n    r = (r * r) % p;\n    if (n % 2 == 1) r = (r * 2) % p;\n\
    \    return r;", "    if (n < 0) {\n        return modp(-n, p);\n    }\n    assert(n\
    \ >= 0);\n    long res = 1;\n    while (n) {\n        if (n & 1) {\n         \
    \   res = (res * 2) % p;\n        }\n        n >>= 1;\n    }\n    return res;",
  "    long res = 1;\n    while (n > 0) {\n        res = (res * (n % 2 ? p : 1)) %\
    \ p;\n        n >>= 1;\n        p = (p * p) % MOD;\n    }\n    return res;", " \
    \   long res = 1 % p;\n    while (n > 0) {\n        if (n & 1) res = (res * 2)\
    \ % p;\n        n >>= 1;\n    }\n    return res;", "    // Fill this in.\n   \
    \ return pow(2,n)%p;", "    if (n == 0) return 1;\n    long res = modp(n / 2,\
    \ p);\n    res = (res * res) % p;\n    if (n % 2 == 1) res = (res * 2) % p;\n\
    \    return res;", "  // Base case: n = 0\n  if (n == 0) return 1;\n  // Check\
    \ for even values of n.\n  if (n % 2 == 0) {\n    // Compute (2^n)^2 and then\
    \ reduce that modulo p\n    long b = modp(n / 2, p);\n    return (b * b) % p;\n\
    \  } else {\n    // Compute (2^n - 1)^2 and then reduce that modulo p\n    long\
    \ a = modp(n - 1, p);\n    return (2 * a * a) % p;\n  }", "\t// assert(p > 0);\n\
    \tif (n == 0) return 1;\n\tlong x = modp(n/2, p);\n\tx = (x*x) % p;\n\tif (n %\
    \ 2 == 1) x = (x*2) % p;\n\treturn x;", "    long mask = 1;\n    while(mask <=\
    \ n) {\n        mask = mask << 1;\n    }\n    mask = mask >> 1;\n    long res\
    \ = 1;\n    while(mask > 0) {\n        if (n & mask) {\n            res = (res\
    \ * res) % p;\n        } else {\n            res = (res * res * 2) % p;\n    \
    \    }\n        mask = mask >> 1;\n    }\n    return res;", "  long r = 1;\n \
    \ while (n) {\n    if (n % 2) {\n      r = (r * 2) % p;\n    }\n    n /= 2;\n\
    \  }\n  return r;", "    long result = 1;\n    for (int i = 0; i < n; i++) {\n\
    \        result = (result * 2) % p;\n    }\n    return result;", "  long q = (long)\
    \ (((double) n) / p);\n  long r = n - q * p;\n  if (r < 0)\n    r += p;\n  return\
    \ r;", "\tif (n == 0) {\n\t\treturn 1;\n\t} else if (n % 2 == 0) {\n\t\tlong t\
    \ = modp(n / 2, p);\n\t\treturn (t * t) % p;\n\t} else {\n\t\treturn (modp(n -\
    \ 1, p) * n) % p;\n\t}", "    long r = 1;\n    for (int i = 0; i < n; i++) {\n\
    \        r = (r * 2) % p;\n    }\n    return r;", "  if (n == 0) return 1;\n \
    \ else if (n == 1) return n % p;\n  else {\n    long x = modp(n / 2, p);\n   \
    \ long x2 = (x * x) % p;\n    if (n % 2 == 0) return x2;\n    else return (x2\
    \ * n) % p;\n  }", "    assert(n >= 0);\n    assert(p > 0);\n    if (n == 0) {\n\
    \        return 1;\n    }\n    if (n % 2 == 0) {\n        long tmp = modp(n /\
    \ 2, p);\n        return (tmp * tmp) % p;\n    } else {\n        return ((n %\
    \ p) * modp(n - 1, p)) % p;\n    }", "    if (n == 0) return 1;\n    if (n ==\
    \ 1) return n;\n    long pow;\n    pow = modp(n/2, p);\n    pow = (pow * pow)\
    \ % p;\n    if (n & 1) {\n        pow = (pow * n) % p;\n    }\n    return pow;",
  "    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long t = modp(n/2, p);\n\
    \        return (t*t) % p;\n    }\n    return ((n % p) * modp(n-1, p)) % p;",
  "\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n % 2 == 0) {\n\t\treturn modp(n / 2,\
    \ p) * modp(n / 2, p) % p;\n\t}\n\treturn modp(n - 1, p) * 2 % p;", "  if(n ==\
    \ 0) {\n    return 1;\n  }\n  long r = modp(n/2, p);\n  r = r*r % p;\n  if(n%2)\
    \ {\n    r = r*2 % p;\n  }\n  return r;", "\tassert(n >= 0);\n\tassert(p > 0);\n\
    \tlong res = 1;\n\tlong cur = n;\n\twhile (p > 0) {\n\t\tif (p % 2 == 1)\n\t\t\
    \tres = (res * cur) % p;\n\t\tcur = (cur * cur) % p;\n\t\tp = p / 2;\n\t}\n\t\
    return res;", "  if (n < 0) { n = n % p + p; }\n  if (n < 2) { return n; }\n \
    \ long tmp = modp(n / 2, p);\n  if (n % 2 == 0) { return (tmp * tmp) % p; }\n\
    \  else { return (tmp * tmp * 2) % p; }", "    long num = 1;\n    long x = n %\
    \ p;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            num = (num *\
    \ x) % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    return\
    \ num;", "\tassert(n >= 0);\n\tassert(p > 0);\n\tif (n == 0) return 1;\n\tif (n\
    \ % 2 == 0) {\n\t\tlong v = modp(n / 2, p);\n\t\treturn (v * v) % p;\n\t}\n\t\
    return (2 * modp(n - 1, p)) % p;", "  if (n < p) {\n    return n;\n  }\n  if (n\
    \ == p) {\n    return 0;\n  }\n  long x = 1;\n  while (n > 0) {\n    if (n & 1)\
    \ {\n      x = (x * 2) % p;\n    }\n    n >>= 1;\n    if (n == 0) {\n      break;\n\
    \    }\n    if (x < p - x) {\n      x = (x * 2) % p;\n    } else {\n      x =\
    \ ((x * 2) % p - p) % p;\n    }\n  }\n  return x;", "  long r = 1;\n  while (n\
    \ > 0) {\n    if (n % 2 == 1) {\n      r = (r * 2) % p;\n    }\n    n = n / 2;\n\
    \    p = (p * p) % p;\n  }\n  return r;", "    assert(n >= 0);\n    assert(p >\
    \ 0);\n    assert(p <= LONG_MAX / 2);\n    int result = 1;\n    for (int i = 1;\
    \ i <= n; i++) {\n        result = (result * 2) % p;\n    }\n    return result;"]
stop_tokens:
- "\n}"
