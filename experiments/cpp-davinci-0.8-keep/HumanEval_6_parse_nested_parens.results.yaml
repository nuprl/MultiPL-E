language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// Write your code here\n\
    \tlong size = paren_string.size();\n\tstd::vector<long> res;\n\tlong max = 0;\n\
    \tlong count = 0;\n\tfor (long i = 0; i < size; i++) {\n\t\tif (paren_string[i]\
    \ == '(') {\n\t\t\tcount++;\n\t\t\tif (count > max) {\n\t\t\t\tmax = count;\n\t\
    \t\t}\n\t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\t\tif (count > 0) {\n\
    \t\t\t\tcount--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(max);\n\t\t\t\t\
    max = 0;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tres.push_back(max);\n\
    \t\t\tmax = 0;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (max > 0) {\n\t\tres.push_back(max);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    assert(!paren_string.empty());\n\
    \    assert(paren_string.find(' ') != std::string::npos);\n\n    std::vector<long>\
    \ result;\n    for (auto paren_group : split(paren_string, ' ')) {\n        int\
    \ level = 0;\n        long max_level = 0;\n        for (char c : paren_group)\
    \ {\n            if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, (long)level);\n            } else if (c == ')') {\n  \
    \              level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpfygbae5z.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpfygbae5z.cpp:13:29: error: \u2018split\u2019 was not declared in this\
    \ scope\n   13 |     for (auto paren_group : split(paren_string, ' ')) {\n   \
    \   |                             ^~~~~\n"
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// TODO: Complete this function\n\
    \tstd::vector<long> re;\n\tint n = paren_string.size();\n\tstd::stack<char> st;\n\
    \tlong count = 0;\n\tlong count_g = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\t\
    if (paren_string[i] == '(') {\n\t\t\tst.push(paren_string[i]);\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\t\tst.pop();\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if (paren_string[i] == ' ') {\n\t\t\tif (st.empty()) {\n\t\t\t\
    \tre.push_back(count / 2);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (!st.empty())\
    \ {\n\t\tre.push_back(count / 2);\n\t}\n\treturn re;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpag__1dz4: /tmp/tmpag__1dz4.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  long max_depth = 0;\n  long\
    \ depth = 0;\n  long idx = 0;\n  long start_idx = 0;\n  std::vector<long> depths;\n\
    \  while (idx < paren_string.size()) {\n    if (paren_string[idx] == '(') {\n\
    \      depth++;\n      max_depth = std::max(max_depth, depth);\n    } else if\
    \ (paren_string[idx] == ')') {\n      if (depth == max_depth) {\n        depths.push_back(max_depth);\n\
    \        max_depth = 0;\n      }\n      depth--;\n    } else if (paren_string[idx]\
    \ == ' ') {\n      if (max_depth > 0) {\n        depths.push_back(max_depth);\n\
    \        max_depth = 0;\n      }\n    }\n    idx++;\n  }\n  return depths;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpo2qc81we: /tmp/tmpo2qc81we.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long>  result;\n\
    \    long max = 0;\n    for(int i = 0; i < paren_string.length(); i++) {\n   \
    \     char ch = paren_string[i];\n        if(ch == '(')\n            max++;\n\
    \        else if(ch == ')')\n            max--;\n        else if(ch == ' ') {\n\
    \            result.push_back(max);\n            max = 0;\n        }\n    }\n\
    \    result.push_back(max);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp9mjtpi2f: /tmp/tmp9mjtpi2f.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int c = 0;\n    std::vector<long>\
    \ v;\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            c++;\n        }\n        else if(paren_string[i] == ')')\
    \ {\n            c--;\n        }\n        else if(paren_string[i] == ' ') {\n\
    \            v.push_back(c);\n            c = 0;\n        }\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpgbn_gbt1: /tmp/tmpgbn_gbt1.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> max_levels;\n\
    \tstd::istringstream iss(paren_string);\n\tfor (std::string s; iss >> s; ) {\n\
    \t\tstd::vector<char> stk;\n\t\tlong level = 0;\n\t\tlong max_level = 0;\n\t\t\
    for (char c : s) {\n\t\t\tif (c == '(') {\n\t\t\t\tlevel++;\n\t\t\t\tstk.push_back(c);\n\
    \t\t\t} else if (c == ')') {\n\t\t\t\tlevel--;\n\t\t\t\tstk.pop_back();\n\t\t\t\
    }\n\t\t\tmax_level = std::max(max_level, level);\n\t\t}\n\t\tassert(stk.empty());\n\
    \t\tmax_levels.push_back(max_level);\n\t}\n\treturn max_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  long count = 0;\n  std::vector<long>\
    \ res;\n  for (char c : paren_string) {\n    if (c == '(') {\n      count++;\n\
    \    } else if (c == ')') {\n      count--;\n    } else if (c == ' ') {\n    \
    \  res.push_back(count);\n    }\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp9mjouk80: /tmp/tmp9mjouk80.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // return a vector of the\
    \ maximum number of nested parens for each of the subgroup\n    std::vector<long>\
    \ max_parens;\n    long count = 0;\n    for (auto &c : paren_string) {\n     \
    \   switch (c) {\n            case '(':\n                count++;\n          \
    \      break;\n            case ')':\n                count--;\n             \
    \   break;\n            case ' ':\n                max_parens.push_back(count);\n\
    \                count = 0;\n                break;\n            default:\n  \
    \              break;\n        }\n    }\n    max_parens.push_back(count);\n  \
    \  return max_parens;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsiahob8z: /tmp/tmpsiahob8z.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n   std::vector<long> result;\n\
    \   long openCount = 0;\n   long maxCount = 0;\n   for(auto paren : paren_string)\
    \ {\n      if(paren == '(') {\n         openCount++;\n         maxCount = std::max(maxCount,\
    \ openCount);\n      } else if(paren == ')') {\n         openCount--;\n      }\
    \ else if(paren == ' ') {\n         result.push_back(maxCount);\n         maxCount\
    \ = 0;\n         openCount = 0;\n      }\n   }\n   result.push_back(maxCount);\n\
    \   return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> output_list;\n\
    \    std::vector<char> stack;\n    long index = 0;\n    long max_depth = 0;\n\
    \    long current_depth = 0;\n    while (index < paren_string.length()) {\n  \
    \      if (paren_string[index] == '(') {\n            stack.push_back(paren_string[index]);\n\
    \            current_depth += 1;\n            if (current_depth > max_depth) {\n\
    \                max_depth = current_depth;\n            }\n        } else if\
    \ (paren_string[index] == ')') {\n            assert(stack.size() > 0);\n    \
    \        assert(stack.back() == '(');\n            stack.pop_back();\n       \
    \     current_depth -= 1;\n        } else if (paren_string[index] == ' ') {\n\
    \            output_list.push_back(max_depth);\n            current_depth = 0;\n\
    \            max_depth = 0;\n        }\n        index += 1;\n    }\n    return\
    \ output_list;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp38fozyuv: /tmp/tmp38fozyuv.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// parse paren_string into\
    \ paren list\n\tstd::vector<char> paren_list;\n\tfor (int i = 0; i < paren_string.size();\
    \ i++) {\n\t\tif (paren_string[i] == '(' || paren_string[i] == ')') {\n\t\t\t\
    paren_list.push_back(paren_string[i]);\n\t\t}\n\t}\n\t// use a stack to track\
    \ the nesting level\n\tstd::stack<char> stack;\n\tstd::vector<long> deepest_nesting_list;\n\
    \tlong deepest_nesting = 0;\n\tfor (auto paren : paren_list) {\n\t\tif (paren\
    \ == '(') {\n\t\t\tstack.push(paren);\n\t\t\tdeepest_nesting = std::max(deepest_nesting,\
    \ (long)stack.size());\n\t\t}\n\t\telse {\n\t\t\tif (stack.empty()) {\n\t\t\t\t\
    deepest_nesting_list.push_back(0);\n\t\t\t\tdeepest_nesting = 0;\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\tstack.pop();\n\t\t\t\tif (stack.empty()) {\n\t\t\t\t\tdeepest_nesting_list.push_back(deepest_nesting);\n\
    \t\t\t\t\tdeepest_nesting = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn deepest_nesting_list;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112962
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> res;\n\
    \    std::stringstream ss(paren_string);\n    std::string token;\n    while (std::getline(ss,\
    \ token, ' ')) {\n        std::cout << token << '\\n';\n        std::stack<char>\
    \ stack;\n        long curr_lvl = 0;\n        long max_lvl = 0;\n        for (char&\
    \ c : token) {\n            if (c == '(') {\n                curr_lvl++;\n   \
    \             max_lvl = std::max(max_lvl, curr_lvl);\n            } else if (c\
    \ == ')') {\n                curr_lvl--;\n            }\n        }\n        res.push_back(max_lvl);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: '(()())

    ((()))

    ()

    ((())()())

    ()

    (())

    ((()))

    (((())))

    (()(())((())))

    '
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    //TODO\n    std::vector<long>\
    \ result;\n    long count=0;\n    for(int i=0;i<paren_string.length();i++)\n \
    \   {\n        if(paren_string[i]=='(')\n        {\n            count++;\n   \
    \     }\n        else if(paren_string[i]==')')\n        {\n            count--;\n\
    \        }\n        else if(paren_string[i]==' ')\n        {\n            result.push_back(count);\n\
    \            count=0;\n        }\n    }\n    result.push_back(count);\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpguce26os: /tmp/tmpguce26os.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ans;\n\
    \    long n = paren_string.size();\n    for(long i = 0; i < n; ++i) {\n      \
    \  if(paren_string[i] == '(') {\n            long cur_ans = 0;\n            while(paren_string[i]\
    \ != ')') {\n                if(paren_string[i] == '(') {\n                  \
    \  ++cur_ans;\n                }\n                ++i;\n            }\n      \
    \      ans.push_back(cur_ans);\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpczdmctru: /tmp/tmpczdmctru.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_nesting = 0;\n    long open_count = 0;\n    for (auto ch : paren_string)\
    \ {\n        if (ch == '(') {\n            ++open_count;\n            max_nesting\
    \ = std::max(max_nesting, open_count);\n        } else if (ch == ')') {\n    \
    \        --open_count;\n        } else if (ch == ' ') {\n            if (open_count\
    \ == 0) {\n                result.push_back(max_nesting);\n                max_nesting\
    \ = 0;\n            }\n        }\n    }\n    result.push_back(max_nesting);\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112962
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Implement this method\n\
    \    std::stack<int> stack;\n    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string group;\n    while(std::getline(ss, group,\
    \ ' ')){\n        std::vector<int> depths;\n        int depth = 0;\n        int\
    \ max_depth = 0;\n        for(char c : group){\n            if(c == '('){\n  \
    \              stack.push(c);\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            }else if(c == ')'){\n           \
    \     stack.pop();\n                depth--;\n            }\n        }\n     \
    \   result.push_back(max_depth);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    //Your code goes here.\n\
    \    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ token;\n    long num_open_braces = 0;\n    long max_depth = 0;\n    while(std::getline(ss,\
    \ token, ' ')){\n        num_open_braces = 0;\n        max_depth = 0;\n      \
    \  for(auto c : token){\n            if(c == '('){\n                ++num_open_braces;\n\
    \                max_depth = std::max(max_depth, num_open_braces);\n         \
    \   }\n            else if(c == ')'){\n                --num_open_braces;\n  \
    \          }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  //TODO: Implement this function\n  // split each paren string\n  std::vector<std::string>\
    \ paren_arr;\n  std::string delimiter = \" \";\n  size_t pos = 0;\n  std::string\
    \ token;\n  while ((pos = paren_string.find(delimiter)) != std::string::npos)\
    \ {\n    token = paren_string.substr(0, pos);\n    paren_arr.push_back(token);\n\
    \    paren_string.erase(0, pos + delimiter.length());\n  }\n  paren_arr.push_back(paren_string);\n\
    \  int max_paren_count = 0;\n  for (int i = 0; i < paren_arr.size(); i++) {\n\
    \    std::string paren_str = paren_arr[i];\n    int paren_count = 0;\n    for\
    \ (int j = 0; j < paren_str.length(); j++) {\n      if (paren_str[j] == '(') {\n\
    \        paren_count++;\n      } else if (paren_str[j] == ')') {\n        paren_count--;\n\
    \      }\n    }\n    if (paren_count > max_paren_count) {\n      max_paren_count\
    \ = paren_count;\n    }\n  }\n  result.push_back(max_paren_count);\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpf0s6ntym: /tmp/tmpf0s6ntym.cpp:42: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    int index = 0;\n    while (index < paren_string.size()) {\n        if (paren_string[index]\
    \ == ' ') {\n            index += 1;\n            continue;\n        }\n     \
    \   int start = index;\n        int end = index;\n        int local_max = 0;\n\
    \        int counter = 0;\n        while (end < paren_string.size() && paren_string[end]\
    \ != ' ') {\n            if (paren_string[end] == '(') {\n                counter\
    \ += 1;\n                local_max = std::max(local_max, counter);\n         \
    \   } else {\n                counter -= 1;\n            }\n            end +=\
    \ 1;\n        }\n        result.push_back(local_max);\n        index = end;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> output;\n\
    \    std::stringstream ss(paren_string);\n    while (ss.good()) {\n        std::string\
    \ substr;\n        getline(ss, substr, ' ');\n        // check if substr is empty\
    \ string\n        if (substr.empty()) {\n            continue;\n        }\n  \
    \      // if substr is not empty string\n        long count_open = 0;\n      \
    \  long count_close = 0;\n        long level = 0;\n        for (long i = 0; i\
    \ < substr.size(); i++) {\n            if (substr[i] == '(') {\n             \
    \   count_open++;\n                level = std::max(level, count_open);\n    \
    \        } else if (substr[i] == ')') {\n                count_close++;\n    \
    \        }\n        }\n        // check if open and close parentheses match\n\
    \        assert(count_open == count_close);\n        output.push_back(level);\n\
    \    }\n    return output;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp79l7i0in: /tmp/tmp79l7i0in.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  // parse_nested_parens_helper()\n\
    \  // For each of the group, output the deepest level of nesting of parentheses.\n\
    \  // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \  // >>> parse_nested_parens_helper('(()())')\n  // 2\n  // >>> parse_nested_parens_helper('((()))')\n\
    \  // 3\n  auto parse_nested_parens_helper = [&](std::string group) {\n    long\
    \ count{0};\n    long max{0};\n    for (const auto& c : group) {\n      if (c\
    \ == '(') {\n        ++count;\n        max = std::max(max, count);\n      } else\
    \ if (c == ')') {\n        --count;\n      }\n    }\n    return max;\n  };\n\n\
    \  std::vector<long> max_depth{};\n  std::string current_group{\"\"};\n  // flag\
    \ will be true until the first space is encountered\n  bool flag{true};\n  for\
    \ (const auto& c : paren_string) {\n    if (c == ' ') {\n      flag = false;\n\
    \      // reset the current_group and push it to max_depth\n      max_depth.push_back(parse_nested_parens_helper(current_group));\n\
    \      current_group = \"\";\n    } else {\n      if (flag) {\n        current_group\
    \ += c;\n      } else {\n        current_group = c;\n        flag = true;\n  \
    \    }\n    }\n  }\n  max_depth.push_back(parse_nested_parens_helper(current_group));\n\
    \  return max_depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> ans;\n\
    \  std::stringstream stream(paren_string);\n  long max_nesting_level = -1;\n \
    \ for (std::string line; std::getline(stream, line);) {\n    if (line.empty())\
    \ {\n      continue;\n    }\n    std::stack<char> paren_stack;\n    max_nesting_level\
    \ = -1;\n    for (char c : line) {\n      if (c == '(') {\n        paren_stack.push(c);\n\
    \      } else if (c == ')') {\n        if (paren_stack.empty()) {\n          continue;\n\
    \        }\n        paren_stack.pop();\n      }\n      max_nesting_level = std::max(max_nesting_level,\
    \ (long)paren_stack.size());\n    }\n    ans.push_back(max_nesting_level);\n \
    \ }\n  return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpj44gg6s9: /tmp/tmpj44gg6s9.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // TODO: Implement this\
    \ method\n    std::vector<long> out;\n    long len = paren_string.length();\n\
    \    long count = 0;\n    long max_count = 0;\n    for(long i = 0; i < len; i++)\
    \ {\n        // std::cout << paren_string[i] << std::endl;\n        if(paren_string[i]\
    \ == '(') {\n            count++;\n            max_count = std::max(max_count,\
    \ count);\n        }\n        else if(paren_string[i] == ')') {\n            count--;\n\
    \        }\n        else if(paren_string[i] == ' ') {\n            out.push_back(max_count);\n\
    \            max_count = 0;\n            count = 0;\n        }\n    }\n    out.push_back(max_count);\n\
    \    return out;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> group_depths;\n\
    \  long group_depth = 0;\n  bool group_started = false;\n  for (auto token : paren_string)\
    \ {\n    if (token == '(') {\n      group_started = true;\n      group_depth++;\n\
    \    } else if (token == ')') {\n      group_depth--;\n    } else if (token ==\
    \ ' ') {\n      if (group_started) {\n        group_depths.push_back(group_depth);\n\
    \        group_depth = 0;\n        group_started = false;\n      }\n    }\n  }\n\
    \  return group_depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp88z33wt6: /tmp/tmp88z33wt6.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> results;\n\
    \t//write your code here\n\t// base case.\n\tif (paren_string.length() == 0) {\n\
    \t\treturn results;\n\t}\n\tint maxCount = 0;\n\tint currentCount = 0;\n\tfor\
    \ (auto ch : paren_string) {\n\t\tif (ch == '(') {\n\t\t\tcurrentCount++;\n\t\t\
    \tmaxCount = std::max(maxCount, currentCount);\n\t\t}\n\t\telse if (ch == ')')\
    \ {\n\t\t\tcurrentCount--;\n\t\t}\n\t\telse if (ch == ' ') {\n\t\t\tresults.push_back(maxCount);\n\
    \t\t\tmaxCount = 0;\n\t\t\tcurrentCount = 0;\n\t\t}\n\t}\n\tresults.push_back(maxCount);\n\
    \treturn results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::stack<int> st;\n  std::vector<long>\
    \ result;\n  int level = 0;\n  for (char ch : paren_string) {\n    if (ch == '(')\
    \ {\n      level++;\n      st.push(level);\n    } else if (ch == ')') {\n    \
    \  long top = st.top();\n      st.pop();\n      if (st.empty()) {\n        result.push_back(top);\n\
    \        level = 0;\n      }\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpc6__lsl3: /tmp/tmpc6__lsl3.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            std::stack<char> stack;\n            long count = 0;\n\
    \            while (i < paren_string.size() && paren_string[i] != ' ') {\n   \
    \             if (paren_string[i] == '(') {\n                    stack.push(paren_string[i]);\n\
    \                    i++;\n                } else if (paren_string[i] == ')')\
    \ {\n                    stack.pop();\n                    i++;\n            \
    \    }\n                count++;\n            }\n            result.push_back(count);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp6em4xrfg: /tmp/tmp6em4xrfg.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> nested_list;\n\
    \    std::stringstream input_stream(paren_string);\n    std::string paren_stream;\n\
    \    while(std::getline(input_stream, paren_stream, ' ')) {\n        std::stack<char>\
    \ paren_stack;\n        long max_depth = 0;\n        for(long i = 0; i < paren_stream.size();\
    \ i++) {\n            if(paren_stream[i] == '(') {\n                paren_stack.push(paren_stream[i]);\n\
    \                max_depth = std::max(max_depth, (long)paren_stack.size());\n\
    \            }\n            else if(paren_stream[i] == ')') {\n              \
    \  paren_stack.pop();\n            }\n        }\n        nested_list.push_back(max_depth);\n\
    \    }\n    return nested_list;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> depth;\n\
    \n\tlong long i,max,level;\n\ti=0;\n\tmax=0;\n\tlevel=0;\n\tstd::cout<<paren_string<<std::endl;\n\
    \twhile(i<paren_string.length())\n\t{\n\t\tif(paren_string[i]=='(')\n\t\t{\n\t\
    \t\tlevel++;\n\t\t\tif(level>max)\n\t\t\t{\n\t\t\t\tmax=level;\n\t\t\t}\n\t\t\
    }\n\t\telse if(paren_string[i]==')')\n\t\t{\n\t\t\tlevel--;\n\t\t}\n\t\telse if(paren_string[i]=='\
    \ ')\n\t\t{\n\t\t\tdepth.push_back(max);\n\t\t\tmax=0;\n\t\t\tlevel=0;\n\t\t}\n\
    \t\ti++;\n\t}\n\tdepth.push_back(max);\n\t\n\treturn depth;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: '(()()) ((())) () ((())()())

    () (()) ((())) (((())))

    (()(())((())))

    '
  timestamp: 1660112963
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int n = paren_string.length();\n\
    \    std::vector<long> result;\n    for(int i=0;i<n;i++) {\n        std::string\
    \ current_group;\n        while(paren_string[i] != ' ') {\n            current_group\
    \ += paren_string[i];\n            i++;\n        }\n        long max_nesting =\
    \ 0;\n        long current_nesting = 0;\n        for(int j=0;j<current_group.length();j++)\
    \ {\n            if(current_group[j] == '(') {\n                current_nesting++;\n\
    \                max_nesting = std::max(max_nesting, current_nesting);\n     \
    \       }\n            else {\n                current_nesting--;\n          \
    \  }\n        }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ans;\n\
    \    for(long i = 0; i < paren_string.size(); i++){\n        if(paren_string[i]\
    \ == '('){\n            long count = 0;\n            while(paren_string[i] !=\
    \ ')'){\n                if(paren_string[i] == '('){\n                    count++;\n\
    \                }\n                i++;\n            }\n            ans.push_back(count);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpr1f350q6: /tmp/tmpr1f350q6.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Split the string into\
    \ groups of parentheses.\n    std::stringstream ss(paren_string);\n    std::string\
    \ item;\n    std::vector<std::string> splitted_string;\n    while (std::getline(ss,\
    \ item, ' ')) {\n        splitted_string.push_back(item);\n    }\n    // For each\
    \ group, count the deepest level of nesting of parentheses.\n    std::vector<long>\
    \ result;\n    long deepest = 0;\n    for (auto i : splitted_string) {\n     \
    \   long count = 0;\n        for (auto j : i) {\n            if (j == '(')\n \
    \               count++;\n            else\n                count--;\n       \
    \     deepest = std::max(deepest, count);\n        }\n        result.push_back(deepest);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpq6f722ft: /tmp/tmpq6f722ft.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Iterate over the given\
    \ string\n    // If '(', increment a variable indicating the current level of\
    \ nesting\n    // If ')', decrement the same variable\n    // Whenever the variable\
    \ is 0, the current group is completed, so push the nesting level of the current\
    \ group in\n    // a vector.\n    long len = paren_string.length();\n    long\
    \ i = 0;\n    long max_nesting = 0;\n    std::vector<long> max_nesting_levels;\n\
    \    while (i < len) {\n        if (paren_string[i] == '(') {\n            i++;\n\
    \            max_nesting++;\n        } else if (paren_string[i] == ')') {\n  \
    \          i++;\n            max_nesting--;\n        } else if (paren_string[i]\
    \ == ' ') {\n            i++;\n            max_nesting_levels.push_back(max_nesting);\n\
    \            max_nesting = 0;\n        }\n    }\n    return max_nesting_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmplo47v11s: /tmp/tmplo47v11s.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> v;\n  long\
    \ depth;\n  std::stringstream ss(paren_string);\n  std::string group;\n  while\
    \ (ss >> group) {\n    depth = 0;\n    long max_depth = 0;\n    for (long i =\
    \ 0; i < group.size(); i++) {\n      if (group[i] == '(') {\n        depth++;\n\
    \        max_depth = std::max(max_depth, depth);\n      } else if (group[i] ==\
    \ ')') {\n        depth--;\n      }\n    }\n    v.push_back(max_depth);\n  }\n\
    \  return v;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> max_depth;\n\
    \    long count = 0;\n    long max_depth_so_far = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            count++;\n            max_depth_so_far\
    \ = std::max(max_depth_so_far, count);\n        } else if (c == ')') {\n     \
    \       count--;\n        } else if (c == ' ') {\n            max_depth.push_back(max_depth_so_far);\n\
    \            max_depth_so_far = 0;\n            count = 0;\n        }\n    }\n\
    \    if (count == 0) {\n        max_depth.push_back(max_depth_so_far);\n    }\n\
    \    return max_depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> v;\n\t\
    for (int i = 0; i < paren_string.length(); i++) {\n\t\tif (paren_string[i] ==\
    \ '(') {\n\t\t\tint j = i + 1;\n\t\t\tint count = 1;\n\t\t\twhile (count != 0)\
    \ {\n\t\t\t\tif (paren_string[j] == '(') {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\
    \t\telse if (paren_string[j] == ')') {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\t\
    j++;\n\t\t\t}\n\t\t\tv.push_back(count);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn v;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpvuvuivcg: /tmp/tmpvuvuivcg.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    long i = 0;\n    int index\
    \ = 0;\n    vector<long> result;\n    vector<long> temp;\n    while(i < paren_string.length())\
    \ {\n        if(paren_string[i] == '(') {\n            temp.push_back(1);\n  \
    \      } else if(paren_string[i] == ')') {\n            if(temp.empty())\n   \
    \             temp.push_back(0);\n            else\n                temp.pop_back();\n\
    \        } else if(paren_string[i] == ' ') {\n            result.push_back(temp.size());\n\
    \            temp.clear();\n        }\n        i++;\n    }\n    if(!temp.empty())\n\
    \        result.push_back(temp.size());\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6cr2um79.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp6cr2um79.cpp:11:5: error: \u2018vector\u2019 was not declared in this\
    \ scope\n   11 |     vector<long> result;\n      |     ^~~~~~\n/tmp/tmp6cr2um79.cpp:11:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6cr2um79.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6cr2um79.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp6cr2um79.cpp:11:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   11 |     vector<long>\
    \ result;\n      |            ^~~~\n/tmp/tmp6cr2um79.cpp:12:12: error: expected\
    \ primary-expression before \u2018long\u2019\n   12 |     vector<long> temp;\n\
    \      |            ^~~~\n/tmp/tmp6cr2um79.cpp:15:13: error: \u2018temp\u2019\
    \ was not declared in this scope\n   15 |             temp.push_back(1);\n   \
    \   |             ^~~~\n/tmp/tmp6cr2um79.cpp:17:16: error: \u2018temp\u2019 was\
    \ not declared in this scope\n   17 |             if(temp.empty())\n      |  \
    \              ^~~~\n/tmp/tmp6cr2um79.cpp:22:13: error: \u2018result\u2019 was\
    \ not declared in this scope\n   22 |             result.push_back(temp.size());\n\
    \      |             ^~~~~~\n/tmp/tmp6cr2um79.cpp:22:30: error: \u2018temp\u2019\
    \ was not declared i"
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_groups;\n\
    \    std::stringstream ss(paren_string);\n    std::string paren_group;\n    long\
    \ max_level = 0;\n    long level = 0;\n    long paren_group_len = 0;\n    long\
    \ paren_group_pos = 0;\n    while (std::getline(ss, paren_group, ' ')) {\n   \
    \     paren_group_len = paren_group.length();\n        max_level = 0;\n      \
    \  level = 0;\n        paren_group_pos = 0;\n        while (paren_group_pos <\
    \ paren_group_len) {\n            if (paren_group[paren_group_pos] == '(') {\n\
    \                ++level;\n                if (level > max_level) {\n        \
    \            max_level = level;\n                }\n            } else if (paren_group[paren_group_pos]\
    \ == ')') {\n                --level;\n            }\n            ++paren_group_pos;\n\
    \        }\n        paren_groups.push_back(max_level);\n    }\n    return paren_groups;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    for (int i = 0; i < paren_string.size(); ++i) {\n        // Check if the\
    \ current char is a open bracket.\n        if (paren_string[i] == '(') {\n   \
    \         int open = 1;\n            int close = 0;\n            // Start looking\
    \ for closed bracket.\n            while (paren_string[++i] != ')') {\n      \
    \          if (paren_string[i] == '(') {\n                    open++;\n      \
    \          } else if (paren_string[i] == ')') {\n                    close++;\n\
    \                }\n            }\n            // If all the open brackets have\
    \ matching closed bracket, then this is a valid group.\n            if (open ==\
    \ close) {\n                result.push_back(open);\n            }\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpqmwp_ybd: /tmp/tmpqmwp_ybd.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // TODO: Write your code\
    \ here\n\tstd::vector<long> result;\n\tfor(int i=0;i<paren_string.size();i++){\n\
    \t\tint count=0;\n\t\twhile(paren_string[i] != ' ' && i<paren_string.size()){\n\
    \t\t\tif(paren_string[i] == '('){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti++;\n\t\t\
    }\n\t\tresult.push_back(count);\n\t}\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpmoot0pxu: /tmp/tmpmoot0pxu.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  assert(paren_string.size()\
    \ > 0);\n  int max_level = 0;\n  std::vector<long> result;\n  for (int i = 0;\
    \ i < paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n      max_level++;\n\
    \    } else if (paren_string[i] == ')') {\n      max_level--;\n    } else if (paren_string[i]\
    \ == ' ') {\n      result.push_back(max_level);\n    }\n  }\n  result.push_back(max_level);\n\
    \  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwyat8m6e: /tmp/tmpwyat8m6e.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112964
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> v;\n\
    \    return v;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp1jc1k_lf: /tmp/tmp1jc1k_lf.cpp:14: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> result;\n\
    \tint max_nesting_level=0;\n\t// Write your code here\n\tint count=0;\n\tfor(int\
    \ i=0;i<paren_string.length();i++)\n\t{\n\t\tif(paren_string[i]=='(')\n\t\t\t\
    count++;\n\t\telse if(paren_string[i]==')')\n\t\t\tcount--;\n\t\tif(count>max_nesting_level)\n\
    \t\t\tmax_nesting_level=count;\n\t\tif(paren_string[i]==' '||paren_string[i]=='\\\
    0')\n\t\t{\n\t\t\tresult.push_back(max_nesting_level);\n\t\t\tmax_nesting_level=0;\n\
    \t\t\tcount=0;\n\t\t}\n\t}\n\tresult.push_back(max_nesting_level);\n\treturn result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stack<char> S;\n    int depth = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            S.push(paren_string[i]);\n\
    \            depth++;\n        } else if (paren_string[i] == ')') {\n        \
    \    if (S.top() == '(') {\n                S.pop();\n                depth--;\n\
    \            }\n        }\n        if (paren_string[i] == ' ' || paren_string[i]\
    \ == '\\0') {\n            if (S.empty()) {\n                result.push_back(depth);\n\
    \                depth = 0;\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmppkq6zxgr: /tmp/tmppkq6zxgr.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::stack<char> stk;\n \
    \ std::vector<long> max_level_per_paren;\n  long max_level = 0;\n  for (const\
    \ auto ch : paren_string) {\n    if (ch == ' ') {\n      max_level_per_paren.push_back(max_level);\n\
    \      max_level = 0;\n    } else if (ch == '(') {\n      stk.push(ch);\n    \
    \  max_level = std::max(max_level, (long)stk.size());\n    } else if (ch == ')')\
    \ {\n      assert(!stk.empty());\n      stk.pop();\n    }\n  }\n  max_level_per_paren.push_back(max_level);\n\
    \  return max_level_per_paren;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112963
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    int i=0;\n    for(int j=0;j<paren_string.size();j++){\n        if(paren_string[j]=='\
    \ '){\n            int max_level = 0;\n            int level = 0;\n          \
    \  int left = 0;\n            for(int k=i;k<j;k++){\n                if(paren_string[k]=='('){\n\
    \                    level++;\n                    if(max_level<level){\n    \
    \                    max_level = level;\n                    }\n             \
    \   }\n                else if(paren_string[k]==')'){\n                    level--;\n\
    \                }\n            }\n            result.push_back(max_level);\n\
    \            i = j+1;\n        }\n    }\n    int max_level = 0;\n    int level\
    \ = 0;\n    int left = 0;\n    for(int k=i;k<paren_string.size();k++){\n     \
    \   if(paren_string[k]=='('){\n            level++;\n            if(max_level<level){\n\
    \                max_level = level;\n            }\n        }\n        else if(paren_string[k]==')'){\n\
    \            level--;\n        }\n    }\n    result.push_back(max_level);\n  \
    \  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112965
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    int paren_count = 0;\n    int max_paren_count = 0;\n    for (int i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       paren_count++;\n            max_paren_count = std::max(max_paren_count,\
    \ paren_count);\n        } else if (paren_string[i] == ')') {\n            paren_count--;\n\
    \        } else if (paren_string[i] == ' ') {\n            result.push_back(max_paren_count);\n\
    \            max_paren_count = 0;\n            paren_count = 0;\n        }\n \
    \   }\n    result.push_back(max_paren_count);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112965
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long n = paren_string.size();\n    long num_open = 0;\n    long num_close\
    \ = 0;\n    long max_nest = 0;\n    for (int i = 0; i < n; i++) {\n        if\
    \ (paren_string[i] == '(')\n            num_open++;\n        else if (paren_string[i]\
    \ == ')')\n            num_close++;\n        else if (paren_string[i] == ' ')\
    \ {\n            result.push_back(num_open);\n            num_open = 0;\n    \
    \        num_close = 0;\n        }\n    }\n    result.push_back(num_open);\n \
    \   return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp49nt_1xu: /tmp/tmp49nt_1xu.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long count = 0;\n    for (const auto &i : paren_string) {\n        if (i\
    \ == '(')\n            count++;\n        else if (i == ')')\n            count--;\n\
    \        else if (i == ' ') {\n            result.push_back(count);\n        \
    \    count = 0;\n        }\n    }\n    if (count != 0)\n        result.push_back(count);\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp2_9bjvx2: /tmp/tmp2_9bjvx2.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long start_index = 0;\n    long end_index = 0;\n    for (;end_index < paren_string.length();\
    \ end_index++) {\n        if (paren_string[end_index] == ' ') {\n            long\
    \ depth = 0;\n            for (long index = start_index; index < end_index; index++)\
    \ {\n                if (paren_string[index] == '(') {\n                    depth++;\n\
    \                } else if (paren_string[index] == ')') {\n                  \
    \  depth--;\n                }\n            }\n            result.push_back(depth);\n\
    \            start_index = end_index + 1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpbi5m8ydh: /tmp/tmpbi5m8ydh.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// You may use the following\
    \ vector to return the results\n\tstd::vector<long> ret;\n\t// your code here\n\
    \tstd::istringstream ss(paren_string);\n\tstd::string s;\n\twhile (ss >> s) {\n\
    \t\tlong depth = 0;\n\t\tlong max_depth = 0;\n\t\tfor (char c : s) {\n\t\t\tif\
    \ (c == '(') {\n\t\t\t\tdepth++;\n\t\t\t\tmax_depth = std::max(max_depth, depth);\n\
    \t\t\t}\n\t\t\telse if (c == ')') {\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t}\n\t\tret.push_back(max_depth);\n\
    \t}\n\treturn ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> ret;\n\t\
    std::stack<char> mystack;\n\t// Write your code here\n\tstringstream s(paren_string);\n\
    \tstring current;\n\tlong temp = 0;\n\twhile (s >> current) {\n\t\tfor (int i\
    \ = 0; i < current.length(); i++) {\n\t\t\tif (current[i] == '(') {\n\t\t\t\t\
    mystack.push(current[i]);\n\t\t\t\ttemp++;\n\t\t\t}\n\t\t\telse if (current[i]\
    \ == ')') {\n\t\t\t\tif (mystack.top() == '(') {\n\t\t\t\t\tmystack.pop();\n\t\
    \t\t\t\ttemp--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret.push_back(temp);\n\t\ttemp\
    \ = 0;\n\t}\n\treturn ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpm6e_s13m.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpm6e_s13m.cpp:12:2: error: \u2018stringstream\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stringstream\u2019?\n   12 |  stringstream\
    \ s(paren_string);\n      |  ^~~~~~~~~~~~\n      |  std::stringstream\nIn file\
    \ included from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm6e_s13m.cpp:2:\n/usr/include/c++/9/iosfwd:156:37: note: \u2018std::stringstream\u2019\
    \ declared here\n  156 |   typedef basic_stringstream<char>  stringstream;\n \
    \     |                                     ^~~~~~~~~~~~\n/tmp/tmpm6e_s13m.cpp:13:2:\
    \ error: \u2018string\u2019 was not declared in this scope\n   13 |  string current;\n\
    \      |  ^~~~~~\n/tmp/tmpm6e_s13m.cpp:13:2: note: suggested alternatives:\nIn\
    \ file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm6e_s13m.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39"
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> ret;\n\
    \  std::vector<std::pair<long,long>> levels; // List of (level, size)\n  long\
    \ current_level = 0;\n  for (long i = 0; i < paren_string.size(); i++) {\n   \
    \ if (paren_string[i] == '(') {\n      levels.push_back(std::make_pair(current_level,\
    \ 0));\n      current_level++;\n    } else if (paren_string[i] == ')') {\n   \
    \   current_level--;\n      if (i + 1 == paren_string.size() || paren_string[i\
    \ + 1] == ' ') {\n        std::pair<long,long> last_level = levels.back();\n \
    \       ret.push_back(last_level.first);\n        levels.pop_back();\n      }\n\
    \    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpt43rs1h4: /tmp/tmpt43rs1h4.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long max_depth = 0;\n  // remove the spaces in string\n  paren_string.erase(std::remove(paren_string.begin(),\
    \ paren_string.end(), ' '), paren_string.end());\n  // loop through the string\
    \ to count the depth\n  for (int i = 0; i < paren_string.size(); i++) {\n    //\
    \ if (i.e. start), depth++\n    if (paren_string[i] == '(') {\n      max_depth++;\n\
    \    }\n    // if ), push result and reset depth to 0\n    if (paren_string[i]\
    \ == ')') {\n      result.push_back(max_depth);\n      max_depth = 0;\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpy3k04110: /tmp/tmpy3k04110.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::vector<char> stack;\n    int count = 0;\n    int max_count = 0;\n  \
    \  long int size = paren_string.size();\n    for(long int i = 0; i < size; i++)\
    \ {\n        if(paren_string[i] == '(') {\n            count++;\n            stack.push_back(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            count--;\n\
    \            if(count == 0) {\n                result.push_back(stack.size());\n\
    \                stack.clear();\n            }\n            else {\n         \
    \       stack.pop_back();\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpzwfgp8kl: /tmp/tmpzwfgp8kl.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// initialize and configure\
    \ a stack\n\tstd::stack<char> stk;\n\t// initialize a maximum depth variable\n\
    \tint depth = 0;\n\t// iterate over the input string\n\tfor (char c : paren_string)\
    \ {\n\t\t// ignore spaces\n\t\tif (c == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\t//\
    \ update the max depth variable if the stack size is greater than the max depth\n\
    \t\tif (stk.size() > depth) {\n\t\t\tdepth = stk.size();\n\t\t}\n\t\t// push left\
    \ parens to the stack\n\t\tif (c == '(') {\n\t\t\tstk.push(c);\n\t\t}\n\t\t//\
    \ pop right parens off the stack\n\t\tif (c == ')') {\n\t\t\tstk.pop();\n\t\t\
    }\n\t}\n\t// initialize a vector to return\n\tstd::vector<long> ret;\n\t// iterate\
    \ over the input string\n\tfor (char c : paren_string) {\n\t\t// ignore spaces\n\
    \t\tif (c == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\t// if we find a left paren, push\
    \ the max depth to the vector\n\t\tif (c == '(') {\n\t\t\tret.push_back(depth);\n\
    \t\t}\n\t\t// if we find a right paren, subtract 1 from the max depth and push\
    \ the max depth to the vector\n\t\tif (c == ')') {\n\t\t\tdepth--;\n\t\t\tret.push_back(depth);\n\
    \t\t}\n\t}\n\t// return the vector\n\treturn ret;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp9r9a09zq: /tmp/tmp9r9a09zq.cpp:55: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Write your code here\n\
    \    // Prepare a stack to be used to process the parenthsis.\n    std::stack<char>\
    \ s;\n    // Prepare a vector to hold the output, where each element is the max\
    \ count of\n    // nesting of parenthesis encountered in each group.\n    std::vector<long>\
    \ output;\n    // Iterate over each char in the input string, we are interested\
    \ in only '(' and ')'\n    for (int i = 0; i < paren_string.length(); i++) {\n\
    \        // If '(' push the current count of maximum nesting into the stack.\n\
    \        if (paren_string[i] == '(') {\n            s.push(0);\n        }\n  \
    \      // If ')' is found, calculate the new max count of nesting by adding 1\
    \ to\n        // the maximum count of nesting in the current level.\n        else\
    \ if (paren_string[i] == ')') {\n            long new_max = 1;\n            while\
    \ (!s.empty() && s.top() != 0) {\n                new_max += s.top();\n      \
    \          s.pop();\n            }\n            // Now push the new max count\
    \ of nesting of parenthesis in the current level.\n            s.push(new_max);\n\
    \        }\n        // If ' ' is found, we know that a group of parenthesis has\
    \ ended.\n        // Pop all the elements from the stack and push them into the\
    \ output.\n        // While doing so, keep track of the max nesting of parenthesis\
    \ in the\n        // current group.\n        else if (paren_string[i] == ' ')\
    \ {\n            long max_count = 0;\n            while (!s.empty()) {\n     \
    \           max_count = std::max(max_count, s.top());\n                s.pop();\n\
    \            }\n            output.push_back(max_count);\n        }\n    }\n \
    \   return output;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpbn_5067x.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpbn_5067x.cpp:39:56: error: no matching function for call to \u2018\
    max(long int&, __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type&)\u2019\
    \n   39 |                 max_count = std::max(max_count, s.top());\n      | \
    \                                                       ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbn_5067x.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpbn_5067x.cpp:39:56: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   39 |                 max_count = std::max(max_count,\
    \ s.top());\n      |                                                        ^\n\
    In file included from /usr/include/c++/9/bits/specfun.h:45,\n                \
    \ from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbn_5067x.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpbn_5067x.cpp:39:56:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char"
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    // Parse the input string and count the max. number of nested parentheses\
    \ per group\n    long start_pos = 0;\n    while (start_pos < paren_string.size())\
    \ {\n        // Skip spaces in the input string\n        while (paren_string[start_pos]\
    \ == ' ') {\n            start_pos++;\n        }\n        long curr_pos = start_pos;\n\
    \        long max_depth = 0;\n        long depth = 0;\n        // Read the input\
    \ till the end of the group and track the max. depth\n        while (curr_pos\
    \ < paren_string.size() && paren_string[curr_pos] != ' ') {\n            if (paren_string[curr_pos]\
    \ == '(') {\n                depth++;\n                max_depth = std::max(max_depth,\
    \ depth);\n            } else if (paren_string[curr_pos] == ')') {\n         \
    \       depth--;\n            }\n            curr_pos++;\n        }\n        result.push_back(max_depth);\n\
    \        start_pos = curr_pos;\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stringstream paren_stream(paren_string);\n    std::string paren_group;\n\
    \    while (std::getline(paren_stream, paren_group, ' ')) {\n        std::stack<long>\
    \ paren_stack;\n        for (char& paren : paren_group) {\n            if (paren\
    \ == '(') {\n                paren_stack.push(1);\n            } else if (paren\
    \ == ')') {\n                paren_stack.pop();\n            }\n        }\n  \
    \      result.push_back(paren_stack.size());\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpe1hwz6v4: /tmp/tmpe1hwz6v4.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> max_levels;\n\
    \  long max_level = 0;\n  int open_count = 0;\n  for (int i = 0; i < paren_string.size();\
    \ i++) {\n    char c = paren_string[i];\n    if (c == '(') {\n      open_count++;\n\
    \      max_level = std::max(max_level, open_count);\n    } else if (c == ')')\
    \ {\n      if (open_count == 0) {\n        std::cout << \"Invalid string\" <<\
    \ std::endl;\n        return max_levels;\n      }\n      open_count--;\n    }\
    \ else if (c == ' ') {\n      if (open_count == 0) {\n        max_levels.push_back(max_level);\n\
    \        max_level = 0;\n      }\n    } else {\n      std::cout << \"Invalid string\"\
    \ << std::endl;\n      return max_levels;\n    }\n  }\n  if (open_count != 0)\
    \ {\n    std::cout << \"Invalid string\" << std::endl;\n    return max_levels;\n\
    \  }\n  max_levels.push_back(max_level);\n  return max_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo6x0zpkz.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpo6x0zpkz.cpp:16:49: error: no matching function for call to \u2018\
    max(long int&, int&)\u2019\n   16 |       max_level = std::max(max_level, open_count);\n\
    \      |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpo6x0zpkz.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpo6x0zpkz.cpp:16:49: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018int\u2019)\n   16 |       max_level = std::max(max_level, open_count);\n\
    \      |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpo6x0zpkz.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpo6x0zpkz.cpp:16:49:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018int\u2019)\n   16 |       max_level = std::max(max_level,\
    \ open_count);\n      |                                                 ^\nIn\
    \ file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:"
  stdout: ''
  timestamp: 1660112966
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Write your code here\n\
    \    vector<long> res;\n    int count = 0;\n    long max = 0;\n    for(auto e:\
    \ paren_string){\n        if(e == '('){\n            count++;\n            if(count\
    \ > max) max = count;\n        }else if(e == ')'){\n            count--;\n   \
    \     }else if(e == ' '){\n            res.push_back(max);\n            max =\
    \ 0;\n            count = 0;\n        }\n    }\n    res.push_back(max);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0qxq4v0u.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp0qxq4v0u.cpp:10:5: error: \u2018vector\u2019 was not declared in this\
    \ scope\n   10 |     vector<long> res;\n      |     ^~~~~~\n/tmp/tmp0qxq4v0u.cpp:10:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0qxq4v0u.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0qxq4v0u.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp0qxq4v0u.cpp:10:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   10 |     vector<long>\
    \ res;\n      |            ^~~~\n/tmp/tmp0qxq4v0u.cpp:20:13: error: \u2018res\u2019\
    \ was not declared in this scope\n   20 |             res.push_back(max);\n  \
    \    |             ^~~\n/tmp/tmp0qxq4v0u.cpp:25:5: error: \u2018res\u2019 was\
    \ not declared in this scope\n   25 |     res.push_back(max);\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> depths;\n\
    \  long current_depth = 0;\n  long max_depth = 0;\n  for (auto c : paren_string)\
    \ {\n    if (c == '(') {\n      current_depth++;\n      max_depth = std::max(max_depth,\
    \ current_depth);\n    } else if (c == ')') {\n      assert(current_depth > 0);\n\
    \      current_depth--;\n    } else if (c == ' ') {\n      depths.push_back(max_depth);\n\
    \      max_depth = 0;\n    }\n  }\n  depths.push_back(max_depth);\n  return depths;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> res;\n\
    \  long i = 0;\n  long n = paren_string.size();\n  long prev = -1;\n  std::stack<long>\
    \ stack;\n  while (i < n) {\n    if (paren_string[i] == '(') {\n      stack.push(paren_string[i]);\n\
    \    } else if (paren_string[i] == ')') {\n      stack.pop();\n    } else if (paren_string[i]\
    \ == ' ') {\n      res.push_back(stack.size());\n    }\n    i++;\n  }\n  res.push_back(stack.size());\n\
    \  return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpyrnq6um9: /tmp/tmpyrnq6um9.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> list;\n\
    \    std::vector<char> vec;\n    std::string str;\n    long depth = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            vec.push_back(paren_string[i]);\n            depth++;\n     \
    \   }\n        else if(paren_string[i] == ')') {\n            vec.push_back(paren_string[i]);\n\
    \            if(vec.back() == ')' && vec[vec.size() - 2] == '(') {\n         \
    \       str = std::to_string(depth);\n                list.push_back(std::stol(str));\n\
    \                vec.pop_back();\n                vec.pop_back();\n          \
    \      depth--;\n            }\n        }\n        else if(paren_string[i] ==\
    \ ' ') {\n            if(vec.size() == 0) {\n                list.push_back(depth);\n\
    \            }\n            else {\n                depth--;\n               \
    \ vec.pop_back();\n                vec.pop_back();\n                list.push_back(depth);\n\
    \            }\n        }\n    }\n    return list;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpmpu4bg9u: /tmp/tmpmpu4bg9u.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int count = 0;\n    std::vector<long>\
    \ res;\n    std::vector<int> max_level;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            max_level.push_back(count);\n\
    \            count--;\n        } else if (paren_string[i] == ' ') {\n        \
    \    res.push_back(*max_element(max_level.begin(), max_level.end()));\n      \
    \      max_level.clear();\n        }\n    }\n    res.push_back(*max_element(max_level.begin(),\
    \ max_level.end()));\n    return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::stack<char> s;\n  //\
    \ Stores the maximum nest levels for each group.\n  std::vector<long> max_nest_levels;\n\
    \  long max_level = 0;\n  // Iterate through each character.\n  for (char c :\
    \ paren_string) {\n    // If start of a group, push to stack.\n    if (c == '(')\
    \ {\n      s.push(c);\n      // Increase level of nesting.\n      max_level +=\
    \ 1;\n    }\n    // If end of a group, pop from stack.\n    else if (c == ')')\
    \ {\n      s.pop();\n      // If this was the end of a group, then store the max\
    \ level and reset.\n      if (s.empty()) {\n        max_nest_levels.push_back(max_level);\n\
    \        max_level = 0;\n      }\n    }\n  }\n  return max_nest_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpmby6vk1n: /tmp/tmpmby6vk1n.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_levels = 0;\n    int current_level = 0;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n   \
    \         current_level++;\n            max_levels = std::max(max_levels, current_level);\n\
    \        } else if (paren_string[i] == ')') {\n            current_level--;\n\
    \        } else if (paren_string[i] == ' ') {\n            result.push_back(max_levels);\n\
    \            max_levels = 0;\n            current_level = 0;\n        }\n    }\n\
    \    result.push_back(max_levels);\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuccaz18z.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpuccaz18z.cpp:15:60: error: no matching function for call to \u2018\
    max(long int&, int&)\u2019\n   15 |             max_levels = std::max(max_levels,\
    \ current_level);\n      |                                                   \
    \         ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n   \
    \              from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpuccaz18z.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpuccaz18z.cpp:15:60: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018int\u2019)\n   15 |             max_levels = std::max(max_levels,\
    \ current_level);\n      |                                                   \
    \         ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n   \
    \              from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpuccaz18z.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpuccaz18z.cpp:15:60:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018int\u2019)\n   15 |             max_levels = std::max(max_levels,\
    \ current_level);\n      |                                                   \
    \         ^\nIn file included from /usr/include/c++/9/algorithm:62,\n      "
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> result;\n\
    \tstd::stack<char> st;\n\tstd::string single_group;\n\tlong count = 0;\n\tlong\
    \ max_count = 0;\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\tif\
    \ (paren_string[i] == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (paren_string[i]\
    \ == '(') {\n\t\t\tst.push(paren_string[i]);\n\t\t\tcount++;\n\t\t\tmax_count\
    \ = std::max(max_count, count);\n\t\t}\n\t\telse if (paren_string[i] == ')') {\n\
    \t\t\tst.pop();\n\t\t\tcount--;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Invalid\
    \ input\" << std::endl;\n\t\t\texit(1);\n\t\t}\n\t\tif (st.empty()) {\n\t\t\t\
    result.push_back(max_count);\n\t\t\tmax_count = 0;\n\t\t\tcount = 0;\n\t\t}\n\t\
    }\n\treturn result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> vec;\n\
    \n    std::stringstream ss(paren_string);\n\n    std::string token;\n    while\
    \ (std::getline(ss, token, ' ')) {\n        vec.push_back(parse_parens(token));\n\
    \    }\n\n    return vec;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpfaok_nnv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpfaok_nnv.cpp:15:23: error: \u2018parse_parens\u2019 was not declared\
    \ in this scope\n   15 |         vec.push_back(parse_parens(token));\n      |\
    \                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660112966
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> output;\n\
    \    int i = 0;\n    while (i < paren_string.size()) {\n        std::string nested_parens\
    \ = \"\";\n        while (paren_string[i] != ' ') {\n            nested_parens\
    \ += paren_string[i];\n            i++;\n        }\n        output.push_back(nested_parens.size()\
    \ - nested_parens.erase(std::remove(nested_parens.begin(), nested_parens.end(),\
    \ ')'), nested_parens.end()).size());\n        i++;\n    }\n    return output;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp13em2ri4.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp13em2ri4.cpp:17:152: error: \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018class __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} has no member named \u2018size\u2019\n   17 |         output.push_back(nested_parens.size()\
    \ - nested_parens.erase(std::remove(nested_parens.begin(), nested_parens.end(),\
    \ ')'), nested_parens.end()).size());\n      |                               \
    \                                                                            \
    \                                             ^~~~\n"
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::istringstream iss(paren_string);\n    std::vector<std::string> tokens{std::istream_iterator<std::string>{iss},\n\
    \                                    std::istream_iterator<std::string>{}};\n\
    \    for (auto& token : tokens) {\n        long i = 0;\n        long max_depth\
    \ = 0;\n        long current_depth = 0;\n        while (i < token.size()) {\n\
    \            if (token[i] == '(') {\n                ++current_depth;\n      \
    \          max_depth = std::max(max_depth, current_depth);\n            } else\
    \ if (token[i] == ')') {\n                --current_depth;\n            }\n  \
    \          ++i;\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::stack<char> st;\n  long count = 0;\n  for (int i = 0; i < paren_string.length();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      st.push(paren_string[i]);\n\
    \      count++;\n    } else if (paren_string[i] == ')') {\n      if (st.top()\
    \ == '(') {\n        st.pop();\n        count--;\n      }\n    } else if (paren_string[i]\
    \ == ' ') {\n      levels.push_back(count);\n    }\n  }\n  return levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmprwjtsf49: /tmp/tmprwjtsf49.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> nested_parens;\n\
    \    long max_count = 0;\n    long count = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            ++count;\n            max_count = std::max(max_count,\
    \ count);\n        } else if (c == ')') {\n            --count;\n        } else\
    \ if (c == ' ') {\n            if (count > 0) {\n                nested_parens.push_back(max_count);\n\
    \                max_count = 0;\n                count = 0;\n            }\n \
    \       }\n    }\n    if (count > 0) {\n        nested_parens.push_back(max_count);\n\
    \    }\n    return nested_parens;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp8rgv6xvv: /tmp/tmp8rgv6xvv.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels_of_nesting;\n\
    \  std::stringstream ss(paren_string);\n  while (ss) {\n    std::string paren_group;\n\
    \    ss >> paren_group;\n    long levels = 0;\n    long max_levels = 0;\n    for\
    \ (char c : paren_group) {\n      if (c == '(') {\n        levels++;\n       \
    \ max_levels = std::max(max_levels, levels);\n      } else if (c == ')') {\n \
    \       levels--;\n      }\n    }\n    levels_of_nesting.push_back(max_levels);\n\
    \  }\n  return levels_of_nesting;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmphe7lkost: /tmp/tmphe7lkost.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long n = paren_string.size();\n  long i=0;\n  while(i<n){\n    long depth =\
    \ 0;\n    long max_depth = 0;\n    long curr = i;\n    while(paren_string[curr]!='\
    \ '){\n      if(paren_string[curr]=='('){\n        depth++;\n        max_depth\
    \ = std::max(max_depth,depth);\n      }\n      else{\n        depth--;\n     \
    \ }\n      curr++;\n    }\n    result.push_back(max_depth);\n    i = curr+1;\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  long current_count = 0;\n\
    \  std::vector<long> current_counts;\n  std::vector<long> max_counts;\n  for (int\
    \ i = 0; i < paren_string.length(); i++) {\n    if (paren_string[i] == '(') {\n\
    \      current_count += 1;\n    } else if (paren_string[i] == ')') {\n      current_count\
    \ -= 1;\n    } else if (paren_string[i] == ' ') {\n      current_counts.push_back(current_count);\n\
    \      current_count = 0;\n    }\n  }\n  if (current_count > 0) {\n    current_counts.push_back(current_count);\n\
    \  }\n  for (int i = 0; i < current_counts.size(); i++) {\n    if (current_counts[i]\
    \ == 0) {\n      max_counts.push_back(0);\n    } else {\n      long current_max\
    \ = 0;\n      long current_sum = 0;\n      while (current_sum >= 0) {\n      \
    \  current_sum += current_counts[i];\n        if (current_sum > current_max) {\n\
    \          current_max = current_sum;\n        }\n        i++;\n      }\n    \
    \  max_counts.push_back(current_max);\n    }\n  }\n  return max_counts;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpo3bylebx: /tmp/tmpo3bylebx.cpp:45: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // std::vector<long> res;\n\
    \    // std::stringstream ss(paren_string);\n    // std::string item;\n    //\
    \ while (std::getline(ss, item, ' ')) {\n    //     int len = item.length();\n\
    \    //     int cnt = 0;\n    //     for (int i = 0; i < len; i++) {\n    // \
    \        if (item[i] == '(') {\n    //             cnt++;\n    //         } else\
    \ if (item[i] == ')') {\n    //             cnt--;\n    //         }\n    // \
    \    }\n    //     assert(cnt == 0);\n    //     int max_cnt = 0;\n    //    \
    \ cnt = 0;\n    //     for (int i = 0; i < len; i++) {\n    //         if (item[i]\
    \ == '(') {\n    //             cnt++;\n    //             max_cnt = std::max(max_cnt,\
    \ cnt);\n    //         } else if (item[i] == ')') {\n    //             cnt--;\n\
    \    //         }\n    //     }\n    //     res.push_back(max_cnt);\n    // }\n\
    \    // return res;\n    std::vector<long> res;\n    int len = paren_string.length();\n\
    \    int cnt = 0;\n    std::stringstream ss;\n    for (int i = 0; i < len; i++)\
    \ {\n        if (paren_string[i] == '(') {\n            cnt++;\n        } else\
    \ if (paren_string[i] == ')') {\n            cnt--;\n        } else if (paren_string[i]\
    \ == ' ') {\n            if (cnt == 0) {\n                res.push_back(parse_nested_parens(ss.str()));\n\
    \                ss.str(\"\");\n            }\n        } else {\n            ss\
    \ << paren_string[i];\n        }\n    }\n    if (ss.str().length() > 0) {\n  \
    \      res.push_back(parse_nested_parens(ss.str()));\n\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy0n7atyu.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpy0n7atyu.cpp:47:60: error: no matching function for call to \u2018\
    std::vector<long int>::push_back(std::vector<long int>)\u2019\n   47 |       \
    \          res.push_back(parse_nested_parens(ss.str()));\n      |            \
    \                                                ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy0n7atyu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35: note:   no known\
    \ conversion for argument 1 from \u2018std::vector<long int>\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018std::vector<long int>::value_type&&\u2019 {aka \u2018long int&&\u2019\
    }\n 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n\
    /tmp/tmpy0n7atyu.cpp:55:52: error: no matching function for call to \u2018std::vector<long\
    \ int>::push_back(std::vector<long int>)\u2019\n   55 |         res.push_ba"
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ret;\n\
    \    size_t i = 0;\n    while (i < paren_string.size()) {\n        long count\
    \ = 0;\n        while (paren_string[i] != ' ' && i < paren_string.size()) {\n\
    \            if (paren_string[i] == '(') {\n                count++;\n       \
    \     }\n            i++;\n        }\n        while (paren_string[i] == ' ') {\n\
    \            i++;\n        }\n        ret.push_back(count);\n    }\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmph34mrdi6: /tmp/tmph34mrdi6.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> results;\n\
    \  bool start_new_group = true;\n  // use first_parenthesis_index_of_current_group\
    \ to store the index of the first\n  // ( of current group.\n  int first_parenthesis_index_of_current_group\
    \ = 0;\n  long depth = 0;\n  long max_depth = 0;\n  for (int i = 0; i < paren_string.size();\
    \ i++) {\n    char current_char = paren_string[i];\n    // start a new group\n\
    \    if (start_new_group) {\n      first_parenthesis_index_of_current_group =\
    \ i;\n      start_new_group = false;\n    }\n    // current char is (\n    if\
    \ (current_char == '(') {\n      depth++;\n      max_depth = std::max(max_depth,\
    \ depth);\n    }\n    // current char is )\n    else if (current_char == ')')\
    \ {\n      // meet the closing parenthesis for the first (,\n      // we will\
    \ save the max_depth for this group and reset the max_depth to 0\n      if (depth\
    \ == 1) {\n        results.push_back(max_depth);\n        max_depth = 0;\n   \
    \     depth = 0;\n        start_new_group = true;\n      }\n      // meet a closing\
    \ parenthesis of the inside of this group\n      else {\n        depth--;\n  \
    \    }\n    }\n    // current char is a space\n    else if (current_char == '\
    \ ') {\n      // if it is a space and we are not at the end of a group,\n    \
    \  // then we can just ignore it and go to the next char\n      if (depth != 0)\
    \ {\n        continue;\n      }\n      // if it is a space and we are at the end\
    \ of a group,\n      // we have to start a new group.\n      else {\n        start_new_group\
    \ = true;\n      }\n    }\n    // current char is invalid\n    else {\n      assert(false);\n\
    \    }\n  }\n  return results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> v;\n\
    \    std::stringstream ss(paren_string);\n    for (std::string s; ss >> s;) {\n\
    \        int count = 0;\n        int max_count = 0;\n        int i = 0;\n    \
    \    while (i < s.length()) {\n            if (s[i] == '(') {\n              \
    \  count++;\n                max_count = std::max(max_count, count);\n       \
    \     } else if (s[i] == ')') {\n                count--;\n            }\n   \
    \         i++;\n        }\n        v.push_back(max_count);\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> groups;\n\
    \  for (long i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i] ==\
    \ '(') {\n      long count = 0;\n      while (paren_string[i] != ')') {\n    \
    \    count++;\n        i++;\n      }\n      groups.push_back(count);\n    }\n\
    \  }\n  return groups;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmprbh9gaam: /tmp/tmprbh9gaam.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Write your code here\n\
    \    // Result vector of the nested parens\n    std::vector<long> res;\n    //\
    \ Loop through the input string\n    for (long i = 0; i < paren_string.size();\
    \ ++i) {\n        // Init the max nested of each group\n        long max_nested\
    \ = 0;\n        // Init the current nested of each group\n        long cur_nested\
    \ = 0;\n        // Loop through the each group of parens\n        while (paren_string[i]\
    \ != ' ' && i < paren_string.size()) {\n            // If the current char is\
    \ '('\n            if (paren_string[i] == '(') {\n                // Increment\
    \ the current nested\n                ++cur_nested;\n                // Update\
    \ the max nested if current nested is larger\n                max_nested = std::max(max_nested,\
    \ cur_nested);\n            }\n            // If the current char is ')'\n   \
    \         else if (paren_string[i] == ')') {\n                // Decrement the\
    \ current nested\n                --cur_nested;\n            }\n            //\
    \ Move to the next char\n            ++i;\n        }\n        // Add the max nested\
    \ to the result vector\n        res.push_back(max_nested);\n    }\n    // Return\
    \ the result vector\n    return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> depth;\n\
    \  int l = 0;\n  for (char c : paren_string) {\n    switch (c) {\n      case '(':\n\
    \        ++l;\n        break;\n      case ')':\n        --l;\n        break;\n\
    \      case ' ':\n        depth.push_back(l);\n        break;\n      default:\n\
    \        assert(false);\n    }\n  }\n  return depth;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp_ftlj0ug: /tmp/tmp_ftlj0ug.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> level_vector;\n\
    \    long level = 0;\n    long max_level = 0;\n    for (auto paren : paren_string)\
    \ {\n        if (paren == '(') {\n            level++;\n            max_level\
    \ = std::max(max_level, level);\n        } else if (paren == ')') {\n        \
    \    level--;\n        } else if (paren == ' ') {\n            if (level != 0)\
    \ {\n                std::cout << \"Error in input string. Mismatched parentheses.\"\
    \ << std::endl;\n                break;\n            }\n            level_vector.push_back(max_level);\n\
    \            max_level = 0;\n        }\n    }\n    return level_vector;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp6vnqu1as: /tmp/tmp6vnqu1as.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> res;\n\
    \  int max = 0;\n  int current = 0;\n  for (int i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      current++;\n      if (current\
    \ > max) {\n        max = current;\n      }\n    } else if (paren_string[i] ==\
    \ ')') {\n      current--;\n    } else if (paren_string[i] == ' ') {\n      res.push_back(max);\n\
    \      max = 0;\n      current = 0;\n    }\n  }\n  res.push_back(max);\n  return\
    \ res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tint mymax=0;\n\tint currmax=0;\n\
    \tstd::vector<long> result;\n\t// Iterate through all the characters\n\tfor(char\
    \ c:paren_string)\n\t{\n\t\t// For open parens increase currmax\n\t\tif(c=='(')\n\
    \t\t{\n\t\t\tcurrmax++;\n\t\t\t// Keep updating mymax for each group of parens\n\
    \t\t\tif(currmax>mymax)\n\t\t\t\tmymax=currmax;\n\t\t}\n\t\t// For close parens\
    \ decrease currmax.\n\t\telse if(c==')')\n\t\t{\n\t\t\tcurrmax--;\n\t\t}\n\t\t\
    // After each group add mymax to the result vector.\n\t\telse if(c==' ')\n\t\t\
    {\n\t\t\tresult.push_back(mymax);\n\t\t\tmymax=0;\n\t\t\tcurrmax=0;\n\t\t}\n\t\
    }\n\t// Add the last mymax to the result vector.\n\tresult.push_back(mymax);\n\
    \treturn result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  std::stringstream ss(paren_string);\n  std::string token;\n  int current_max\
    \ = 0;\n  int previous_max = 0;\n  while (std::getline(ss, token, ' ')) {\n  \
    \  for (auto c : token) {\n      if (c == '(') {\n        current_max++;\n   \
    \   } else if (c == ')') {\n        if (current_max == 0) {\n          std::cout\
    \ << \"invalid string\";\n          exit(0);\n        }\n        current_max--;\n\
    \      }\n    }\n    result.push_back(current_max);\n    previous_max = current_max;\n\
    \    current_max = 0;\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpw9iqhm2m: /tmp/tmpw9iqhm2m.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> ret_vec;\n\
    \tstd::string substring;\n\tlong level_of_nesting = 0;\n\tfor (auto it = paren_string.begin();\
    \ it != paren_string.end(); it++) {\n\t\tif (*it == ' ') {\n\t\t\tif (substring.length()\
    \ > 0) {\n\t\t\t\tif (substring[0] == '(') {\n\t\t\t\t\tlevel_of_nesting = 1;\n\
    \t\t\t\t\tif (substring.length() == 1) {\n\t\t\t\t\t\tret_vec.push_back(level_of_nesting);\n\
    \t\t\t\t\t}\n\t\t\t\t\tfor (auto str_it = substring.begin() + 1; str_it != substring.end();\
    \ str_it++) {\n\t\t\t\t\t\tif (*str_it == '(') {\n\t\t\t\t\t\t\tlevel_of_nesting++;\n\
    \t\t\t\t\t\t}\n\t\t\t\t\t\telse if (*str_it == ')') {\n\t\t\t\t\t\t\tret_vec.push_back(level_of_nesting);\n\
    \t\t\t\t\t\t\tlevel_of_nesting--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\
    \t\telse {\n\t\t\t\t\tstd::cout << \"ERROR: String does not start with a left\
    \ parenthesis\" << std::endl;\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    substring.clear();\n\t\t}\n\t\telse {\n\t\t\tsubstring.push_back(*it);\n\t\t}\n\
    \t}\n\tif (substring.length() > 0) {\n\t\tif (substring[0] == '(') {\n\t\t\tlevel_of_nesting\
    \ = 1;\n\t\t\tif (substring.length() == 1) {\n\t\t\t\tret_vec.push_back(level_of_nesting);\n\
    \t\t\t}\n\t\t\tfor (auto str_it = substring.begin() + 1; str\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpms8j2wqc.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpms8j2wqc.cpp:47:46: error: \u2018str\u2019 was not declared in this\
    \ scope; did you mean \u2018std\u2019?\n   47 |    for (auto str_it = substring.begin()\
    \ + 1; str\n      |                                              ^~~\n      |\
    \                                              std\n/tmp/tmpms8j2wqc.cpp:47:49:\
    \ error: expected \u2018;\u2019 before \u2018}\u2019 token\n   47 |    for (auto\
    \ str_it = substring.begin() + 1; str\n      |                               \
    \                  ^\n      |                                                \
    \ ;\n   48 | }\n      | ~                                                \n/tmp/tmpms8j2wqc.cpp:48:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   48 | }\n \
    \     | ^\n/tmp/tmpms8j2wqc.cpp:47:49: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   47 |    for (auto str_it = substring.begin() + 1; str\n    \
    \  |        ~                                        ^\n      |              \
    \                                   )\n   48 | }\n      | ~                  \
    \                              \n/tmp/tmpms8j2wqc.cpp:48:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   48 | }\n      | ^\n/tmp/tmpms8j2wqc.cpp:49:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   49 | int main() {\n      |            ^\n/tmp/tmpms8j2wqc.cpp:54:1: error:\
    \ expected \u2018}\u2019 at end of input\n   54 | }\n      | ^\n/tmp/tmpms8j2wqc.cpp:41:30:\
    \ note: to match this \u2018{\u2019\n   41 |  if (substring.length() > 0) {\n\
    \      |                              ^\n/tmp/tmpms8j2wqc.cpp:54:1: error: expected\
    \ \u2018}\u2019 at end of input\n   54 | }\n      | ^\n/tmp/tmpms8j2wqc.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpms8j2wqc.cpp:54:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   54 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // TODO implement\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpbhe2sg1u: /tmp/tmpbhe2sg1u.cpp:13: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// this function is intentionally\
    \ blank\n\t// fill it in with your code\n    int i=0;\n    stack<char> s;\n  \
    \  vector<long> output;\n    while(i<paren_string.length()){\n        if(paren_string[i]=='('){\n\
    \            s.push(paren_string[i]);\n        }\n        else if(paren_string[i]==')'){\n\
    \            int count=0;\n            while(s.top()!='('){\n                s.pop();\n\
    \                count++;\n            }\n            s.pop();\n            output.push_back(count);\n\
    \        }\n        i++;\n    }\n    return output;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_atn3b85.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_atn3b85.cpp:12:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   12 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp_atn3b85.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp_atn3b85.cpp:12:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   12 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmp_atn3b85.cpp:13:5: error: \u2018vector\u2019 was not declared in this\
    \ scope\n   13 |     vector<long> output;\n      |     ^~~~~~\n/tmp/tmp_atn3b85.cpp:13:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_atn3b85.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_atn3b85.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp_atn3b85.cpp:13:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   13 |     vector<long>\
    \ output;\n      |            ^~~~\n/tmp/tmp_atn3b85.cpp:16:13: err"
  stdout: ''
  timestamp: 1660112966
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  long ans = 0;\n  std::vector<long>\
    \ output;\n  for (int i = 0; i < paren_string.size(); i++) {\n    ans = 0;\n \
    \   if (paren_string[i] == '(') {\n      ans = 1;\n      i++;\n      while (paren_string[i]\
    \ != ')') {\n        if (paren_string[i] == '(') {\n          ans++;\n       \
    \ }\n        i++;\n      }\n      output.push_back(ans);\n    }\n  }\n  return\
    \ output;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmph0b89zlh: /tmp/tmph0b89zlh.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112967
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::stack<char> paren_stack;\n\
    \    std::vector<long> paren_nesting_vec;\n    long paren_nesting_counter = 0;\n\
    \    for (char c : paren_string) {\n        if (c == '(') {\n            paren_stack.push(c);\n\
    \            paren_nesting_counter++;\n        } else if (c == ')') {\n      \
    \      paren_stack.pop();\n            if (paren_stack.empty()) {\n          \
    \      paren_nesting_vec.push_back(paren_nesting_counter);\n                paren_nesting_counter\
    \ = 0;\n            }\n        }\n    }\n    return paren_nesting_vec;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp743gjqs5: /tmp/tmp743gjqs5.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112968
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n\
    \    long depth = 0;\n    long max_depth = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            depth++;\n            max_depth = std::max(max_depth,\
    \ depth);\n        } else if (c == ')') {\n            depth--;\n        } else\
    \ if (c == ' ') {\n            depths.push_back(max_depth);\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    depths.push_back(max_depth);\n\
    \    return depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112968
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    // Add your code here\n    int current_level;\n    int max_level;\n    for(int\
    \ i=0;i<paren_string.length();i++){\n        current_level = 0;\n        max_level\
    \ = 0;\n        while(paren_string[i]!=' ' && i<paren_string.length()){\n    \
    \        if(paren_string[i]=='('){\n                current_level++;\n       \
    \         if(current_level>max_level){\n                    max_level = current_level;\n\
    \                }\n            }\n            else if(paren_string[i]==')'){\n\
    \                current_level--;\n            }\n            i++;\n        }\n\
    \        result.push_back(max_level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112968
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// Use a stack to track the\
    \ level at each character.\n\t// Curr tracks the current level of nesting.\n\t\
    long curr = 0;\n\tstd::stack<long> s;\n\tstd::vector<long> result;\n\tlong c =\
    \ 0;\n\twhile (c < paren_string.size()) {\n\t\twhile (c < paren_string.size()\
    \ && paren_string[c] == ' ') c++;\n\t\t// If the character is a left parentheses,\
    \ push the current level of nesting to the stack and increment.\n\t\tif (c < paren_string.size()\
    \ && paren_string[c] == '(') {\n\t\t\ts.push(curr);\n\t\t\tcurr++;\n\t\t}\n\t\t\
    // If the character is a right parentheses, pop the level of nesting, then add\
    \ the current level of nesting\n\t\t// to the result and increment the index.\n\
    \t\telse if (c < paren_string.size() && paren_string[c] == ')') {\n\t\t\ts.pop();\n\
    \t\t\tresult.push_back(curr);\n\t\t\tcurr = s.top();\n\t\t\tcurr++;\n\t\t}\n\t\
    \tc++;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    // your code goes here\n    // split the string to multiple parts\n    int\
    \ n = paren_string.size();\n    char* str = new char[n+1];\n    strcpy(str, paren_string.c_str());\n\
    \    std::vector<char*> tokens;\n    char* token = strtok(str, \" \");\n    while(token\
    \ != NULL) {\n        tokens.push_back(token);\n        token = strtok(NULL, \"\
    \ \");\n    }\n    for(char* t: tokens) {\n        int max_level = 0;\n      \
    \  int level = 0;\n        int i = 0;\n        while(t[i] != '\\0') {\n      \
    \      if(t[i] == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if(t[i] == ')') {\n      \
    \          level--;\n            }\n            i++;\n        }\n        result.push_back(max_level);\n\
    \    }\n    delete[] str;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112968
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> deep_nesting;\n\
    \    long long max = -1;\n    int op_count = 0;\n    int cl_count = 0;\n    bool\
    \ flag = true;\n    int lp = 0;\n    int rp = 0;\n    while(lp < paren_string.length()){\n\
    \        while(paren_string[lp] != ' ' && lp < paren_string.length()){\n     \
    \       lp++;\n        }\n        rp = lp;\n        lp = lp - (rp - lp);\n   \
    \     while(lp < rp && flag){\n            if(paren_string[lp] == '('){\n    \
    \            op_count++;\n            }\n            else if(paren_string[lp]\
    \ == ')'){\n                cl_count++;\n            }\n            if(cl_count\
    \ > op_count){\n                flag = false;\n            }\n            lp++;\n\
    \        }\n        if(op_count == cl_count && op_count != 0){\n            if(max\
    \ < op_count){\n                max = op_count;\n            }\n        }\n  \
    \      deep_nesting.push_back(max);\n        max = -1;\n        op_count = 0;\n\
    \        cl_count = 0;\n        flag = true;\n        lp++;\n    }\n    return\
    \ deep_nesting;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yi68756: /tmp/tmp0yi68756.cpp:50: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // WRITE YOUR CODE HERE\n\
    \    std::vector<long> v;\n    for(char c : paren_string) {\n        if(c == '\
    \ ') {\n            v.push_back(0);\n        }\n    }\n    int open = 0;\n   \
    \ int close = 0;\n    int index = 0;\n    int max = 0;\n    for(char c : paren_string)\
    \ {\n        if(c == '(') {\n            open++;\n            if(open > max) {\n\
    \                max = open;\n            }\n        }\n        if(c == ')') {\n\
    \            close++;\n        }\n        if(c == ' ' && open == close) {\n  \
    \          v[index] = max;\n            index++;\n            max = 0;\n     \
    \       open = 0;\n            close = 0;\n        }\n    }\n    return v;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpp0o1dyn3: /tmp/tmpp0o1dyn3.cpp:42: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112968
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::istringstream iss(paren_string);\n    std::string paren_group;\n   \
    \ while (iss >> paren_group) {\n        int max_nest = 0;\n        std::stack<char>\
    \ paren_stack;\n        for (auto it = paren_group.begin(); it != paren_group.end();\
    \ ++it) {\n            if (*it == '(') {\n                paren_stack.push(*it);\n\
    \                max_nest = std::max(max_nest, (int)paren_stack.size());\n   \
    \         } else if (*it == ')') {\n                if (paren_stack.empty()) {\n\
    \                    max_nest = -1;\n                    break;\n            \
    \    }\n                paren_stack.pop();\n            }\n        }\n       \
    \ if (!paren_stack.empty()) {\n            max_nest = -1;\n        }\n       \
    \ result.push_back(max_nest);\n    }\n    return result;\n}\nint main() {\n  \
    \  auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112968
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  // Input Assumptions :\n\
    \  // 1. Input is a string consisting of parenthesis, spaces and newlines only.\n\
    \  // 2. Input does not contain unmatched parenthesis.\n  // 3. Input is a well\
    \ formed group of parentheses.\n  // 4. It is guaranteed that input will be valid.\n\
    \  // 5. It is guaranteed that in a group of parentheses, there is one and only\
    \ one root.\n  // 6. It is guaranteed that there is atleast one space between\
    \ two groups.\n  // 7. The following is a valid input string - \n  //    \"(()())\
    \ ((())) () ((())()())\"\n  // 8. The following is an invalid input string - \n\
    \  //    \"(()()) ((())) () ((())()())\"\n  // 9. The following is an invalid\
    \ input string - \n  //    \"(()()) ((())) () ((())()()\"\n  // 10. The following\
    \ is an invalid input string - \n  //    \"(()()) ((())) () ((())()()))\"\n  //\
    \ 11. The following is an invalid input string - \n  //    \" (()()) ((())) ()\
    \ ((())()())\"\n  // 12. The following is an invalid input string - \n  //   \
    \ \"(()()) ((())) () ((())()())\"\n  // 13. The following is an invalid input\
    \ string - \n  //    \"(()()) ((())) () ((())()())\\n\"\n  // 14. The following\
    \ is an invalid input string - \n  //    \"\\n(()()) ((())) () ((())()())\"\n\
    \  // 15. The following is an invalid input string - \n  //    \"(()()) ((()))\
    \ () ((())()())\\n\\n\"\n  // 16. The following is an invalid input string - \n\
    \  //    \"\\n(()()) ((())) () ((())()())\\n\"\n  // 17. The following is an invalid\
    \ input string - \n  //    \"\\n(()()) ((())) () ((())()())\\n\\n\"\n  // 18.\
    \ The following is an invalid input string - \n  //    \"\\n\\n(()()) ((())) ()\
    \ ((())()())\\n\\n\"\n  // 19. The following is an invalid input string\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpdjk91j3l: /tmp/tmpdjk91j3l.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112968
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> arr;\n\
    \    for(int i=0;i<paren_string.length();i++){\n        int cnt=0;\n        int\
    \ max=0;\n        while(paren_string[i]!=' '){\n            if(paren_string[i]=='('){\n\
    \                cnt++;\n                max=std::max(max,cnt);\n            }\n\
    \            else if(paren_string[i]==')'){\n                cnt--;\n        \
    \    }\n            i++;\n        }\n        arr.push_back(max);\n    }\n    return\
    \ arr;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ret;\n\
    \    std::stringstream ss(paren_string);\n    std::string temp;\n    while (std::getline(ss,\
    \ temp, ' ')) {\n        ret.push_back(temp.length()/2);\n    }\n    return ret;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp7erdxra0: /tmp/tmp7erdxra0.cpp:19: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> results;\n\
    \    std::string current_paren_string;\n    std::stack<char> paren_stack;\n  \
    \  bool inside_parens = false;\n    int max_level = 0;\n    for (auto ch : paren_string)\
    \ {\n        if (ch == ' ' && inside_parens) {\n            inside_parens = false;\n\
    \            max_level = 0;\n            while(!paren_stack.empty()) {\n     \
    \           auto paren = paren_stack.top();\n                paren_stack.pop();\n\
    \                if (paren == '(') {\n                    max_level++;\n     \
    \           }\n            }\n            results.push_back(max_level);\n    \
    \    } else if (ch == ' ' && !inside_parens) {\n            continue;\n      \
    \  } else if (ch == '(') {\n            inside_parens = true;\n            paren_stack.push(ch);\n\
    \        } else if (ch == ')') {\n            paren_stack.push(ch);\n        }\n\
    \    }\n    max_level = 0;\n    while(!paren_stack.empty()) {\n        auto paren\
    \ = paren_stack.top();\n        paren_stack.pop();\n        if (paren == '(')\
    \ {\n            max_level++;\n        }\n    }\n    results.push_back(max_level);\n\
    \    return results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmphin3uau7: /tmp/tmphin3uau7.cpp:48: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> output;\n\
    \    long level=0;\n    long temp=0;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            level+=1;\n            temp+=1;\n\
    \        }\n        else if(paren_string[i]==')'){\n            level-=1;\n  \
    \      }\n        else if(paren_string[i]==' '){\n            output.push_back(temp);\n\
    \            temp=0;\n        }\n    }\n    output.push_back(temp);\n    return\
    \ output;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpw3kydsto: /tmp/tmpw3kydsto.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    // Populate your result vector here.\n    // 1. Strip out all the spaces\n\
    \    std::string paren = paren_string;\n    paren.erase(std::remove(paren.begin(),\
    \ paren.end(), ' '), paren.end());\n    // 2. For each character in the string\n\
    \    //  2.1 if the character is opening parenthesis, increment a counter\n  \
    \  //  2.2 if the character is closing parenthesis, decrement the counter\n  \
    \  //  2.3 remember the maximum value of the counter.\n    // 3. If the counter\
    \ is not zero, return -1\n    // 4. Return the maximum value of the counter.\n\
    \    std::cout << paren << std::endl;\n    result.push_back(get_max_depth(paren));\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmper0t980v.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmper0t980v.cpp:21:22: error: \u2018get_max_depth\u2019 was not declared\
    \ in this scope\n   21 |     result.push_back(get_max_depth(paren));\n      |\
    \                      ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660112968
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> depth;\n\
    \    int max_depth = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            max_depth++;\n  \
    \          count++;\n        }\n        else if (paren_string[i] == ')') {\n \
    \           count--;\n            if (count == 0) {\n                depth.push_back(max_depth);\n\
    \                max_depth = 0;\n            }\n        }\n    }\n    return depth;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmppcqx_48w: /tmp/tmppcqx_48w.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tlong count = 0;\n\tlong max\
    \ = 0;\n\tstd::vector<long> output;\n\tbool open = false;\n\tbool close = false;\n\
    \tfor (char c : paren_string) {\n\t\tif (c == '(') {\n\t\t\topen = true;\n\t\t\
    \tclose = false;\n\t\t\tcount++;\n\t\t\tif (count > max) {\n\t\t\t\tmax = count;\n\
    \t\t\t}\n\t\t}\n\t\telse if (c == ')') {\n\t\t\topen = false;\n\t\t\tclose = true;\n\
    \t\t\tcount--;\n\t\t}\n\t\telse if (c == ' ') {\n\t\t\tif (open == true && close\
    \ == false) {\n\t\t\t\topen = false;\n\t\t\t\tclose = false;\n\t\t\t\toutput.push_back(max);\n\
    \t\t\t\tmax = 0;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (open == true\
    \ && close == false) {\n\t\toutput.push_back(max);\n\t}\n\treturn output;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmppnn7rp9e: /tmp/tmppnn7rp9e.cpp:45: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  if (paren_string.size() == 0) return result;\n  if (paren_string.size() ==\
    \ 1) return {-1};\n  long max_level = 0;\n  long level = 0;\n  for (auto ch :\
    \ paren_string) {\n    if (ch == '(') {\n      level++;\n      max_level = std::max(max_level,\
    \ level);\n    } else if (ch == ')') {\n      level--;\n    } else if (ch == '\
    \ ') {\n      result.push_back(max_level);\n      max_level = 0;\n      level\
    \ = 0;\n    }\n  }\n  result.push_back(max_level);\n  return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  std::stringstream ss(paren_string);\n  std::string group;\n  while (std::getline(ss,\
    \ group, ' ')) {\n    result.push_back(long{0});\n    std::stack<char> parens;\n\
    \    for (auto paren : group) {\n      if (paren == '(') {\n        parens.push(paren);\n\
    \        result.back() = std::max(result.back(), static_cast<long>(parens.size()));\n\
    \      } else if (paren == ')') {\n        if (parens.empty()) {\n          result.back()\
    \ = -1;\n          break;\n        }\n        parens.pop();\n      }\n    }\n\
    \    if (!parens.empty()) {\n      result.back() = -1;\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> result;\n\
    \tlong level = 0;\n\tlong max_level = 0;\n\tfor (char c : paren_string) {\n\t\t\
    switch (c) {\n\t\tcase '(':\n\t\t\t++level;\n\t\t\tif (level > max_level)\n\t\t\
    \t\tmax_level = level;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\t--level;\n\t\t\tbreak;\n\
    \t\tcase ' ':\n\t\t\tresult.push_back(max_level);\n\t\t\tmax_level = 0;\n\t\t\t\
    level = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp00p9nejs: /tmp/tmp00p9nejs.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  // YOUR CODE HERE\n  std::vector<long>\
    \ ans;\n  long curr;\n  long max;\n  std::stringstream ss(paren_string);\n  std::string\
    \ line;\n  while(std::getline(ss, line, ' ')){\n      std::stringstream ls(line);\n\
    \      curr = 0;\n      max = 0;\n      char c;\n      while(ls>>c){\n       \
    \   if(c == '('){\n              curr++;\n              if(curr > max){\n    \
    \              max = curr;\n              }\n          }else if(c == ')'){\n \
    \             curr--;\n          }\n      }\n      ans.push_back(max);\n  }\n\
    \  return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Your code here\n   \
    \ std::vector<long> result;\n    long max_nesting = 0;\n    int nesting = 0;\n\
    \    for (auto ch : paren_string) {\n        if (ch == '(') {\n            nesting++;\n\
    \            max_nesting = std::max(max_nesting, nesting);\n        } else if\
    \ (ch == ')') {\n            nesting--;\n        } else if (ch == ' ') {\n   \
    \         result.push_back(max_nesting);\n            max_nesting = 0;\n     \
    \       nesting = 0;\n        }\n    }\n    result.push_back(max_nesting);\n \
    \   return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpmy0oojnh.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpmy0oojnh.cpp:16:56: error: no matching function for call to \u2018\
    max(long int&, int&)\u2019\n   16 |             max_nesting = std::max(max_nesting,\
    \ nesting);\n      |                                                        ^\n\
    In file included from /usr/include/c++/9/bits/specfun.h:45,\n                \
    \ from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmy0oojnh.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpmy0oojnh.cpp:16:56: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018int\u2019)\n   16 |             max_nesting = std::max(max_nesting,\
    \ nesting);\n      |                                                        ^\n\
    In file included from /usr/include/c++/9/bits/specfun.h:45,\n                \
    \ from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmy0oojnh.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpmy0oojnh.cpp:16:56:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018int\u2019)\n   16 |             max_nesting = std::max(max_nesting,\
    \ nesting);\n      |                                                        ^\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/inc"
  stdout: ''
  timestamp: 1660112968
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// Edge cases\n\tif (paren_string.empty())\
    \ {\n\t\treturn {};\n\t}\n\tif (paren_string.length() == 1) {\n\t\treturn {0};\n\
    \t}\n\tif (paren_string.length() == 2) {\n\t\treturn {0};\n\t}\n\t// Normal cases\n\
    \tstd::vector<long> results;\n\t// Count all left parentheses in each word\n\t\
    for (int i = 0; i < paren_string.length(); i++) {\n\t\tint count = 0;\n\t\tif\
    \ (paren_string[i] == '(') {\n\t\t\t// If the char is left, check if the next\
    \ one is right. If not, increase count by 1.\n\t\t\twhile (paren_string[i + 1]\
    \ != ')') {\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tresults.push_back(count);\n\
    \t\t}\n\t}\n\treturn results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpydpeyfr3: /tmp/tmpydpeyfr3.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> nest_level;\n\
    \t// Your code goes here\n\t// std::string token = strtok(paren_string.c_str(),\
    \ \" \");\n\t// int index = 0;\n\t// while (token != NULL) {\n\t// \t// printf(\"\
    token: %s\\n\", token);\n\t// \tint count = 0;\n\t// \tfor (int i = 0; i < token.length();\
    \ i++) {\n\t// \t\tif (token[i] == '(')\n\t// \t\t\tcount++;\n\t// \t\telse if\
    \ (token[i] == ')')\n\t// \t\t\tcount--;\n\t// \t}\n\t// \tif (count == 0)\n\t\
    // \t\tnest_level.push_back(count);\n\t// \ttoken = strtok(NULL, \" \");\n\t//\
    \ }\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\tif (paren_string[i]\
    \ == ' ')\n\t\t\tcontinue;\n\t\tint count = 0;\n\t\tfor (int j = i; j < paren_string.length();\
    \ j++) {\n\t\t\tif (paren_string[j] == '(')\n\t\t\t\tcount++;\n\t\t\telse if (paren_string[j]\
    \ == ')')\n\t\t\t\tcount--;\n\t\t\telse if (paren_string[j] == ' ')\n\t\t\t\t\
    break;\n\t\t}\n\t\tif (count == 0)\n\t\t\tnest_level.push_back(count);\n\t}\n\t\
    return nest_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpb8h1w391: /tmp/tmpb8h1w391.cpp:45: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result(0);\n\
    \n    std::istringstream iss(paren_string);\n    std::string token;\n    while\
    \ (std::getline(iss, token, ' ')) {\n        long max_depth = 0;\n        long\
    \ curr_depth = 0;\n        // Iterate through each character of the string\n \
    \       for (auto c : token) {\n            if (c == '(')\n                ++curr_depth;\n\
    \            else if (c == ')')\n                --curr_depth;\n            max_depth\
    \ = std::max(max_depth, curr_depth);\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n\
    \        std::string::iterator start = it;\n        long depth = 0;\n        while\
    \ (it != paren_string.end() && *it != ' ') {\n            if (*it == '(') {\n\
    \                ++depth;\n            }\n            else if (*it == ')') {\n\
    \                --depth;\n            }\n            ++it;\n        }\n     \
    \   assert(depth == 0);\n        result.push_back(depth);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpkej12ikr: /tmp/tmpkej12ikr.cpp:22: std::vector<long int> parse_nested_parens(std::string):
    Assertion `depth == 0'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  // Don't forget to include\
    \ what you're using!\n  std::vector<long> output;\n  std::vector<std::string>\
    \ nestedParen;\n  std::vector<std::string> parens;\n  std::stringstream ss(paren_string);\n\
    \  std::string intermediate;\n  while(std::getline(ss, intermediate, ' ')){\n\
    \      parens.push_back(intermediate);\n  }\n  for(int i = 0; i < parens.size();\
    \ i++){\n      //std::cout << parens[i] << std::endl;\n      std::stringstream\
    \ ss2(parens[i]);\n      std::string intermediate2;\n      int count = 0;\n  \
    \    int max = 0;\n      while(std::getline(ss2, intermediate2, ')')){\n     \
    \     nestedParen.push_back(intermediate2);\n          //std::cout << intermediate2\
    \ << std::endl;\n          for(int j = 0; j < intermediate2.length(); j++){\n\
    \              if(intermediate2[j] == '('){\n                  count++;\n    \
    \          }\n          }\n          if(count > max){\n              max = count;\n\
    \          }\n          count = 0;\n      }\n      output.push_back(max);\n  \
    \    nestedParen.clear();\n  }\n  return output;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmplztn7uzt: /tmp/tmplztn7uzt.cpp:46: int main(): Assertion `candidate(("(()(())((())))"))
    == (std::vector<long>({4}))'' failed.

    '
  stdout: ''
  timestamp: 1660112970
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> out;\n\t\
    std::stringstream ss(paren_string);\n\tstd::string s;\n\twhile (ss >> s) {\n\t\
    \tlong max_count = 0;\n\t\tlong count = 0;\n\t\tfor (const auto c : s) {\n\t\t\
    \tif (c == '(') {\n\t\t\t\tcount++;\n\t\t\t\tmax_count = std::max(max_count, count);\n\
    \t\t\t}\n\t\t\telse if (c == ')') {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tassert(count\
    \ == 0);\n\t\tout.push_back(max_count);\n\t}\n\treturn out;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stringstream s(paren_string);\n    std::string individual_parens;\n\
    \    while(s >> individual_parens) {\n        long max_nesting = 0;\n        long\
    \ current_nesting = 0;\n        for(auto& c : individual_parens) {\n         \
    \   if(c == '(') {\n                current_nesting++;\n                max_nesting\
    \ = std::max(max_nesting, current_nesting);\n            } else if(c == ')') {\n\
    \                current_nesting--;\n            }\n        }\n        result.push_back(max_nesting);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> res;\n\t\
    int count = 0;\n\tfor (int i = 0; i < paren_string.size(); i++) {\n\t\tif (paren_string[i]\
    \ == '(') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\
    \t\tres.push_back(count);\n\t\t\tcount = 0;\n\t\t}\n\t}\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpwnffkj7a: /tmp/tmpwnffkj7a.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::stringstream ss(paren_string);\n    std::string group;\n    while (std::getline(ss,\
    \ group, ' ')) {\n        std::cout << group << std::endl;\n        long depth\
    \ = 0;\n        long max_depth = 0;\n        long i = 0;\n        while (i < group.length())\
    \ {\n            if (group[i] == '(') {\n                depth++;\n          \
    \      if (depth > max_depth) {\n                    max_depth = depth;\n    \
    \            }\n            } else if (group[i] == ')') {\n                depth--;\n\
    \            }\n            i++;\n        }\n        levels.push_back(max_depth);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: '(()())

    ((()))

    ()

    ((())()())

    ()

    (())

    ((()))

    (((())))

    (()(())((())))

    '
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stack<char> paren_stack;\n    long max_level = 0;\n    for (auto ch:\
    \ paren_string) {\n        if (ch == '(') {\n            max_level++;\n      \
    \      paren_stack.push(ch);\n        } else if (ch == ')') {\n            paren_stack.pop();\n\
    \            if (paren_stack.empty()) {\n                result.push_back(max_level);\n\
    \                max_level = 0;\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpa2x8p03h: /tmp/tmpa2x8p03h.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> results;\n\
    \    long count = 0;\n    long max = 0;\n    for (char & ch : paren_string) {\n\
    \        if (ch == '(') {\n            count += 1;\n            if (count > max)\
    \ {\n                max = count;\n            }\n        } else if (ch == ')')\
    \ {\n            count -= 1;\n        } else if (ch == ' ') {\n            results.push_back(max);\n\
    \            max = 0;\n            count = 0;\n        }\n    }\n    results.push_back(max);\n\
    \    return results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  std::string group = \"\";\n  for (long i = 0; i < paren_string.size(); i++)\
    \ {\n    if (paren_string[i] == ' ') {\n      result.push_back(get_level(group));\n\
    \      group = \"\";\n    } else {\n      group.push_back(paren_string[i]);\n\
    \    }\n  }\n  if (group.size() > 0) {\n    result.push_back(get_level(group));\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpbp67pa03.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpbp67pa03.cpp:13:24: error: \u2018get_level\u2019 was not declared in\
    \ this scope\n   13 |       result.push_back(get_level(group));\n      |     \
    \                   ^~~~~~~~~\n/tmp/tmpbp67pa03.cpp:20:22: error: \u2018get_level\u2019\
    \ was not declared in this scope\n   20 |     result.push_back(get_level(group));\n\
    \      |                      ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::stack<char> stk;\n\
    \    std::vector<long> results;\n    std::istringstream iss(paren_string);\n \
    \   std::string token;\n    while (std::getline(iss, token, ' ')) {\n        if\
    \ (token.empty()) continue;\n        std::stack<char> empty_stk;\n        std::swap(stk,\
    \ empty_stk);\n        for (auto c : token) {\n            if (c == '(') {\n \
    \               stk.push(c);\n            } else if (c == ')') {\n           \
    \     if (stk.empty()) {\n                    std::cout << \"ERROR: Unbalanced\
    \ parenthesis!\" << std::endl;\n                    return {};\n             \
    \   }\n                stk.pop();\n            } else {\n                std::cout\
    \ << \"ERROR: Unknown char in the string!\" << std::endl;\n                return\
    \ {};\n            }\n        }\n        if (!stk.empty()) {\n            std::cout\
    \ << \"ERROR: Unbalanced parenthesis!\" << std::endl;\n            return {};\n\
    \        }\n        results.push_back(empty_stk.size());\n    }\n    return results;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpel_r0t3l: /tmp/tmpel_r0t3l.cpp:41: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112970
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> level_vector;\n\
    \  long max_level = 0;\n  std::string::iterator it;\n  it = paren_string.begin();\n\
    \  while(it!=paren_string.end()) {\n    if(*it == '(') {\n      max_level++;\n\
    \    }\n    else if(*it == ')') {\n      max_level--;\n    }\n    else if(*it\
    \ == ' ') {\n      level_vector.push_back(max_level);\n      max_level = 0;\n\
    \    }\n    it++;\n  }\n  return level_vector;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpfbgmc2j_: /tmp/tmpfbgmc2j_.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    vector<long> count;\n \
    \   vector<long> max_count;\n    for(int i=0;i<paren_string.length();i++){\n \
    \       if(paren_string[i]=='('){\n            count.push_back(1);\n        }\n\
    \        else if(paren_string[i]==')'){\n            count.pop_back();\n     \
    \   }\n        else if(paren_string[i]==' '){\n            max_count.push_back(count.size());\n\
    \        }\n    }\n    if(count.size()==0){\n        return max_count;\n    }\n\
    \    return {};\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp9hxupomj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp9hxupomj.cpp:9:5: error: \u2018vector\u2019 was not declared in this\
    \ scope\n    9 |     vector<long> count;\n      |     ^~~~~~\n/tmp/tmp9hxupomj.cpp:9:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9hxupomj.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9hxupomj.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp9hxupomj.cpp:9:12:\
    \ error: expected primary-expression before \u2018long\u2019\n    9 |     vector<long>\
    \ count;\n      |            ^~~~\n/tmp/tmp9hxupomj.cpp:10:12: error: expected\
    \ primary-expression before \u2018long\u2019\n   10 |     vector<long> max_count;\n\
    \      |            ^~~~\n/tmp/tmp9hxupomj.cpp:13:13: error: \u2018count\u2019\
    \ was not declared in this scope; did you mean \u2018std::count\u2019?\n   13\
    \ |             count.push_back(1);\n      |             ^~~~~\n      |      \
    \       std::count\nIn file included from /usr/include/c++/9/algorithm:71,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9hxupomj.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:101:1:\
    \ note: \u2018std::count\u2019 declared here\n  101 | count(_ExecutionPolicy"
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    int result_i = 0;\n    int curr_max = 0;\n    int max_so_far = 0;\n    for\
    \ (int i = 0; i < paren_string.length(); i++) {\n        if (paren_string[i] ==\
    \ '(') {\n            curr_max++;\n            if (curr_max > max_so_far) {\n\
    \                max_so_far = curr_max;\n            }\n        } else if (paren_string[i]\
    \ == ')') {\n            if (curr_max > 0) {\n                curr_max--;\n  \
    \          }\n        } else if (paren_string[i] == ' ') {\n            result.push_back(max_so_far);\n\
    \            result_i++;\n            max_so_far = 0;\n            curr_max =\
    \ 0;\n        }\n    }\n    result.push_back(max_so_far);\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int i,length,count;\n \
    \   std::vector<long> vec;\n    std::string str;\n    length = paren_string.length();\n\
    \    count = 1;\n    for(i=0;i<length;i++)\n    {\n        if(paren_string[i]=='(')\n\
    \        {\n            count++;\n        }\n        else if(paren_string[i]==')')\n\
    \        {\n            count--;\n        }\n        else if(paren_string[i]=='\
    \ ')\n        {\n            vec.push_back(count);\n            count = 1;\n \
    \       }\n    }\n    return vec;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpjg666i6t: /tmp/tmpjg666i6t.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112969
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stack<char> paren_stack;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long curr_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                paren_stack.push(c);\n     \
    \           curr_nesting++;\n                max_nesting = std::max(max_nesting,\
    \ curr_nesting);\n            } else if (c == ')') {\n                paren_stack.pop();\n\
    \                curr_nesting--;\n            }\n        }\n        assert(paren_stack.empty());\n\
    \        result.push_back(max_nesting);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int strLength = paren_string.length();\n\
    \    std::vector<long> result;\n    long count = 0;\n    for(int i = 0; i < strLength;\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            count--;\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            result.push_back(count);\n\
    \            count = 0;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmphzst513y: /tmp/tmphzst513y.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112970
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stringstream ss(paren_string);\n    std::string tok;\n    while(std::getline(ss,\
    \ tok, ' ')) {\n        long max_level = 0;\n        long cur_level = 0;\n   \
    \     for(auto const& c : tok) {\n            if(c == '(') cur_level++;\n    \
    \        else cur_level--;\n            max_level = std::max(max_level, cur_level);\n\
    \        }\n        result.push_back(max_level);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> maxLevels;\n\
    \    int max = 0;\n    std::vector<int> openBracket;\n    int i = 0;\n    for(char\
    \ c : paren_string) {\n        if(c == '(') {\n            openBracket.push_back(i);\n\
    \            i++;\n        }\n        else if(c == ')') {\n            i = openBracket.back();\n\
    \            openBracket.pop_back();\n            if(openBracket.size() > max)\
    \ {\n                max = openBracket.size();\n            }\n        }\n   \
    \     else if(c == ' ') {\n            maxLevels.push_back(max);\n           \
    \ max = 0;\n            i = 0;\n        }\n    }\n    maxLevels.push_back(max);\n\
    \    return maxLevels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp34o_xqxy: /tmp/tmp34o_xqxy.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112970
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  std::stack<char> s;\n  long count = 0;\n  long max_count = 0;\n  for (int i\
    \ = 0; i < paren_string.length(); i++) {\n    if (paren_string[i] == '(') {\n\
    \      s.push(paren_string[i]);\n      count++;\n      if (count > max_count)\
    \ {\n        max_count = count;\n      }\n    } else if (paren_string[i] == ')')\
    \ {\n      s.pop();\n      count--;\n    } else if (paren_string[i] == ' ') {\n\
    \      result.push_back(max_count);\n      max_count = 0;\n      count = 0;\n\
    \    }\n  }\n  result.push_back(max_count);\n  return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112970
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // First we need to split\
    \ the input string into multiple groups at the space location\n    std::stringstream\
    \ ss(paren_string);\n    std::vector<std::string> paren_groups;\n    while (ss.good())\
    \ {\n        std::string substr;\n        getline(ss, substr, ' ');\n        paren_groups.push_back(substr);\n\
    \    }\n    // For each group, we will count the number of open parentheses '('\
    \ and the number of close parentheses ')'\n    // If there is more number of close\
    \ parentheses than the open parentheses, then it is an invalid input.\n    //\
    \ If the number of open and close parentheses are the same, we return that number\
    \ since it indicates the\n    // maximum level of nesting.\n    // Otherwise,\
    \ we will check each character from the outside. E.g. for group with value \"\
    (()())\", we will first\n    // check '(' and then ')'. If it is an open parenthesis,\
    \ we will recursively call the same function with\n    // value \"(())\" and then\
    \ add it to the result.\n    std::vector<long> result;\n    for (auto &group :\
    \ paren_groups) {\n        long open_paren_count = 0;\n        long close_paren_count\
    \ = 0;\n        for (auto &ch : group) {\n            if (ch == '(') {\n     \
    \           open_paren_count++;\n            } else if (ch == ')') {\n       \
    \         close_paren_count++;\n            }\n        }\n        if (close_paren_count\
    \ > open_paren_count) {\n            throw std::invalid_argument(\"Invalid input.\
    \ There are more close parentheses than open parentheses.\");\n        } else\
    \ if (open_paren_count == close_paren_count) {\n            result.push_back(open_paren_count);\n\
    \        } else {\n            long nested_count = 0;\n            long i = 0;\n\
    \            while (i < group.size()) {\n                char ch = group[i];\n\
    \                if (ch == '(') {\n                    // Do recursion to find\
    \ the number of nested parentheses.\n                    size_t j = i + 1;\n \
    \                   while (j < group.size()) {\n                        if (group[j]\
    \ ==\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp32cmyt_j.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp32cmyt_j.cpp:49:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   49 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:48:40: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   48 |                         if\
    \ (group[j] ==\n      |                            ~           ^\n      |    \
    \                                    )\n   49 | }\n      | ~                 \
    \                      \n/tmp/tmp32cmyt_j.cpp:49:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   49 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:50:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   50 | int main() {\n      |            ^\n/tmp/tmp32cmyt_j.cpp:55:1: error:\
    \ expected \u2018}\u2019 at end of input\n   55 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:44:32:\
    \ note: to match this \u2018{\u2019\n   44 |                 if (ch == '(') {\n\
    \      |                                ^\n/tmp/tmp32cmyt_j.cpp:55:1: error: expected\
    \ \u2018}\u2019 at end of input\n   55 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:42:38:\
    \ note: to match this \u2018{\u2019\n   42 |             while (i < group.size())\
    \ {\n      |                                      ^\n/tmp/tmp32cmyt_j.cpp:55:1:\
    \ error: expected \u2018}\u2019 at end of input\n   55 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:39:16:\
    \ note: to match this \u2018{\u2019\n   39 |         } else {\n      |       \
    \         ^\n/tmp/tmp32cmyt_j.cpp:55:1: error: expected \u2018}\u2019 at end of\
    \ input\n   55 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:25:38: note: to match this\
    \ \u2018{\u2019\n   25 |     for (auto &group : paren_groups) {\n      |     \
    \                                 ^\n/tmp/tmp32cmyt_j.cpp:55:1: error: expected\
    \ \u2018}\u2019 at end of input\n   55 | }\n      | ^\n/tmp/tmp32cmyt_j.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp32cmyt_j.cpp:55:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   55 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112969
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> depths;\n\
    \n  long currentDepth = 0;\n  long maxDepth = 0;\n  for (int i = 0; i < paren_string.length();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      if (paren_string[i + 1] ==\
    \ ')') {\n        depths.push_back(1);\n        i++;\n      } else {\n       \
    \ currentDepth++;\n        if (currentDepth > maxDepth) {\n          maxDepth\
    \ = currentDepth;\n        }\n      }\n    } else if (paren_string[i] == ')')\
    \ {\n      currentDepth--;\n      if (currentDepth == 0) {\n        depths.push_back(maxDepth);\n\
    \        maxDepth = 0;\n      }\n    }\n  }\n\n  return depths;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpk2nk2n2g: /tmp/tmpk2nk2n2g.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112970
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> depths;\n\
    \n\tstd::istringstream iss(paren_string);\n\twhile (iss) {\n\t\tstd::string s;\n\
    \t\tif (!getline(iss, s, ' '))\n\t\t\tbreak;\n\t\t// Reaching here means there\
    \ is a space, which means you got a \n\t\t// group of parentheses\n\n\t\tstd::stack<char>\
    \ myStack;\n\t\tlong depth = 0;\n\t\tlong maxDepth = 0;\n\t\tfor (int i = 0; i\
    \ < s.length(); i++) {\n\t\t\tif (s[i] == '(') {\n\t\t\t\tdepth++;\n\t\t\t\tif\
    \ (depth > maxDepth) {\n\t\t\t\t\tmaxDepth = depth;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    else if (s[i] == ')') {\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t}\n\t\tdepths.push_back(maxDepth);\n\
    \t}\n\treturn depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112970
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tassert(paren_string.size()\
    \ > 0);\n\t// WRITE CODE HERE\n\t// Return a vector of integers representing the\
    \ max depth of nested parentheses for each of the groups.\n\tstd::vector<long>\
    \ levels(0);\n\tlong level = 0;\n\tfor (auto x : paren_string) {\n\t\tif (x ==\
    \ '(') {\n\t\t\t++level;\n\t\t}\n\t\telse if (x == ')') {\n\t\t\tlevels.push_back(level);\n\
    \t\t\tlevel = 0;\n\t\t}\n\t}\n\treturn levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpb4i8_pqf: /tmp/tmpb4i8_pqf.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112971
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // This is your job. :)\n\
    \    std::vector<long> res;\n    std::stringstream ss(paren_string);\n    std::string\
    \ temp;\n    int flag = 0;\n    int count = 0;\n    while(ss>>temp){\n       \
    \ for(int i = 0; i < temp.size(); i++){\n            if(temp[i] == '('){\n   \
    \             flag++;\n                count = (flag > count) ? flag : count;\n\
    \            }else if(temp[i] == ')'){\n                flag--;\n            }\n\
    \        }\n        res.push_back(count);\n        count = 0;\n        flag =\
    \ 0;\n    }\n    return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112970
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ans;\n\
    \    long nest_level = 0;\n    long max_nest_level = 0;\n    for (int i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       nest_level++;\n            max_nest_level = std::max(max_nest_level, nest_level);\n\
    \        } else if (paren_string[i] == ')') {\n            nest_level--;\n   \
    \     } else if (paren_string[i] == ' ') {\n            ans.push_back(max_nest_level);\n\
    \            max_nest_level = 0;\n            nest_level = 0;\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpq6odfxqj: /tmp/tmpq6odfxqj.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112971
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> res;\n\
    \    long max_count = 0;\n    long count = 0;\n    for (auto i : paren_string)\
    \ {\n        if (i == '(')\n            count++;\n        else if (i == ')')\n\
    \            count--;\n        else {\n            res.push_back(count);\n   \
    \         count = 0;\n        }\n    }\n    return res;\n}\nint main() {\n   \
    \ auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpwfnaxthf: /tmp/tmpwfnaxthf.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112971
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> output;\n\
    \  std::stack<char> s;\n  std::vector<char> cv;\n  std::vector<char> temp;\n \
    \ std::stringstream ss(paren_string);\n  std::string word;\n  while(ss >> word)\
    \ {\n    int index = 0;\n    int counter = 0;\n    char* w = (char*) word.c_str();\n\
    \    for(int i = 0; i < word.length(); i++) {\n      if(w[i] == '(') {\n     \
    \   s.push(w[i]);\n        cv.push_back(w[i]);\n      }\n      else if(w[i] ==\
    \ ')') {\n        if(s.empty()) {\n          counter = 0;\n          break;\n\
    \        }\n        else {\n          cv.push_back(w[i]);\n          s.pop();\n\
    \          counter++;\n        }\n      }\n    }\n    output.push_back(counter);\n\
    \    counter = 0;\n    cv.clear();\n  }\n  return output;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp4d_uwt2g: /tmp/tmp4d_uwt2g.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112971
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // Note that the paren_string\
    \ is provided space separated.\n    // Remove the space using std::remove from\
    \ algorithm header\n    std::remove(paren_string.begin(), paren_string.end(),\
    \ ' ');\n    std::vector<long> max_depth_list;\n    for (auto it = paren_string.begin();\
    \ it != paren_string.end(); it++) {\n        auto first_paren = std::find(it,\
    \ paren_string.end(), '(');\n        long max_depth = 0;\n        if (first_paren\
    \ != paren_string.end()) {\n            auto last_paren = std::find(first_paren\
    \ + 1, paren_string.end(), ')');\n            long depth = 0;\n            for\
    \ (auto it1 = first_paren; it1 != last_paren; it1++) {\n                if (*it1\
    \ == '(') {\n                    depth++;\n                    if (depth > max_depth)\
    \ {\n                        max_depth = depth;\n                    }\n     \
    \           } else if (*it1 == ')') {\n                    depth--;\n        \
    \        }\n            }\n            max_depth_list.push_back(max_depth);\n\
    \        }\n    }\n    return max_depth_list;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpmzhls_ep: /tmp/tmpmzhls_ep.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112971
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::vector<char> v;\n    std::stringstream ss(paren_string);\n    std::string\
    \ part;\n    while(std::getline(ss, part, ' ')) {\n        std::cout << part <<\
    \ '\\n';\n        for(auto c : part) {\n            if(c == '(') {\n         \
    \       v.push_back(c);\n            } else if(c == ')') {\n                v.pop_back();\n\
    \            }\n        }\n        result.push_back(v.size());\n        v.clear();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp1hws6c97: /tmp/tmp1hws6c97.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112971
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> output;\n\
    \  long left = 0;\n  long right = 0;\n  long max = 0;\n  for (long i = 0; i <\
    \ paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n      left++;\n\
    \      if (left > max) {\n        max = left;\n      }\n    } else if (paren_string[i]\
    \ == ')') {\n      right++;\n      if (right == left) {\n        output.push_back(max);\n\
    \        max = 0;\n        left = 0;\n        right = 0;\n      }\n    }\n  }\n\
    \  return output;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp0rg647xa: /tmp/tmp0rg647xa.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> res;\n\
    \    int start = 0;\n    while (paren_string[start] == ' ') {\n        start++;\n\
    \    }\n    for (int i = start; i < paren_string.size(); i++) {\n        std::stack<char>\
    \ st;\n        int j = i;\n        for (; j < paren_string.size(); j++) {\n  \
    \          if (paren_string[j] == ' ') {\n                break;\n           \
    \ }\n            if (paren_string[j] == '(') {\n                st.push('(');\n\
    \            } else if (paren_string[j] == ')') {\n                st.pop();\n\
    \            }\n        }\n        if (st.empty()) {\n            int level =\
    \ 0;\n            int p = i;\n            while (p < j) {\n                if\
    \ (paren_string[p] == '(') {\n                    level++;\n                }\n\
    \                p++;\n            }\n            res.push_back(level);\n    \
    \    }\n        i = j;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp7bz07ka_: /tmp/tmp7bz07ka_.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> answer;\n\
    \    // your code goes here\n    int n = paren_string.length();\n    for(int i=0;i<n;i++){\n\
    \        long count = 0;\n        for(int j=i;j<n;j++){\n            if(paren_string[j]\
    \ == '('){\n                count++;\n            }\n            else if(paren_string[j]\
    \ == ')'){\n                count--;\n            }\n            if(count == 0){\n\
    \                answer.push_back(j);\n                break;\n            }\n\
    \        }\n    }\n    return answer;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpp9pp__6e: /tmp/tmpp9pp__6e.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> max_depths;\n\
    \    std::istringstream stream(paren_string);\n    while(!stream.eof()) {\n  \
    \      std::string token;\n        stream >> token;\n        if(token == \"\"\
    )\n            break;\n        int max_depth = 0;\n        int curr_depth = 0;\n\
    \        for(int i = 0; i < token.length(); i++) {\n            if(token[i] ==\
    \ '(') {\n                curr_depth++;\n                max_depth = std::max(max_depth,\
    \ curr_depth);\n            }\n            else if(token[i] == ')') {\n      \
    \          curr_depth--;\n            }\n        }\n        max_depths.push_back(max_depth);\n\
    \    }\n    return max_depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  // TODO\n\n  long level=0;\n  for(int i=0;i<paren_string.length();i++){\n \
    \   if(paren_string[i]=='('){\n      level++;\n    }else if(paren_string[i]==')'){\n\
    \      level--;\n    }else if(paren_string[i]==' '){\n      result.push_back(level);\n\
    \    }\n  }\n  result.push_back(level);\n  return result;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpcsksdlfi: /tmp/tmpcsksdlfi.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::stack<int> stk;\n\
    \    std::vector<long> res;\n    int v = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            stk.push(1);\n  \
    \          v++;\n        } else if (paren_string[i] == ')') {\n            if\
    \ (stk.size() == 0) {\n                v = 0;\n            } else {\n        \
    \        stk.pop();\n                v--;\n            }\n        } else if (paren_string[i]\
    \ == ' ') {\n            if (stk.size() == 0) {\n                res.push_back(v);\n\
    \                v = 0;\n            }\n        }\n    }\n    if (stk.size() ==\
    \ 0) {\n        res.push_back(v);\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpfu9sk2kp: /tmp/tmpfu9sk2kp.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n\
    \    std::stack<char> stk;\n    long curr_depth = 0;\n    long max_depth = 0;\n\
    \    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            curr_depth++;\n            max_depth = std::max(max_depth,\
    \ curr_depth);\n            stk.push(paren_string[i]);\n        } else if (paren_string[i]\
    \ == ')') {\n            curr_depth--;\n            stk.pop();\n        } else\
    \ if (paren_string[i] == ' ') {\n            depths.push_back(max_depth);\n  \
    \          max_depth = 0;\n            curr_depth = 0;\n        }\n    }\n   \
    \ return depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpdtldg_bo: /tmp/tmpdtldg_bo.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  result.clear();\n  std::stringstream ss(paren_string);\n  std::string item;\n\
    \  long max = -1;\n  long cur = 0;\n  long tmp = 0;\n  while (std::getline(ss,\
    \ item, ' ')) {\n    for (int i = 0; i < item.size(); i++) {\n      if (item[i]\
    \ == '(') {\n        cur++;\n        tmp++;\n      } else if (item[i] == ')')\
    \ {\n        cur--;\n        tmp--;\n      }\n      if (cur > max) {\n       \
    \ max = cur;\n      }\n    }\n    if (tmp != 0) {\n      std::cout << \"Wrong\
    \ format!\" << std::endl;\n      return result;\n    }\n    result.push_back(max);\n\
    \    max = -1;\n    cur = 0;\n    tmp = 0;\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112971
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // TODO\n    int maxDepth\
    \ = 0;\n    std::vector<long> maxDepths;\n    std::vector<long> depths;\n    std::stringstream\
    \ ss(paren_string);\n    std::string s;\n    while(std::getline(ss, s, ' ')) {\n\
    \        maxDepth = 0;\n        depths.clear();\n        //std::cout << s << std::endl;\n\
    \        for(int i = 0; i < s.length(); i++) {\n            //std::cout << s[i]\
    \ << std::endl;\n            if(s[i] == '(') {\n                maxDepth++;\n\
    \                depths.push_back(maxDepth);\n            }\n            else\
    \ if(s[i] == ')') {\n                maxDepth--;\n                depths.push_back(maxDepth);\n\
    \            }\n        }\n        maxDepths.push_back(*std::max_element(depths.begin(),\
    \ depths.end()));\n    }\n    return maxDepths;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int i = 0;\n    int j =\
    \ 0;\n    long depth = 0;\n    long max_depth = 0;\n    std::vector<long> result;\n\
    \    for (i = 0; i < paren_string.length(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            depth++;\n            if (depth > max_depth) {\n    \
    \            max_depth = depth;\n            }\n        } else if (paren_string[i]\
    \ == ')') {\n            depth--;\n        } else if (paren_string[i] == ' ')\
    \ {\n            result.push_back(max_depth);\n            max_depth = 0;\n  \
    \          depth = 0;\n        }\n    }\n    result.push_back(max_depth);\n  \
    \  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112971
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  // your code here\n  std::vector<long>\
    \ output;\n  std::stringstream input(paren_string);\n  std::string token;\n  while(std::getline(input,\
    \ token, ' ')) {\n    std::stack<char> s;\n    long count = 0;\n    for(auto c\
    \ : token) {\n      if(c == '(') {\n        s.push(c);\n        count++;\n   \
    \   }\n      else if(c == ')') {\n        s.pop();\n      }\n    }\n    output.push_back(count);\n\
    \  }\n  return output;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpc5zbfds_: /tmp/tmpc5zbfds_.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    assert(paren_string.length()\
    \ > 0);\n    std::vector<long> max_depth;\n    long st_size = 0;\n    long max_st_size\
    \ = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            st_size++;\n            if (st_size > max_st_size)\n\
    \                max_st_size = st_size;\n        }\n        else if (paren_string[i]\
    \ == ')') {\n            st_size--;\n        }\n        else if (paren_string[i]\
    \ == ' ') {\n            max_depth.push_back(max_st_size);\n            max_st_size\
    \ = 0;\n            st_size = 0;\n        }\n    }\n    max_depth.push_back(max_st_size);\n\
    \    return max_depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  int level = 0;\n  std::vector<long>\
    \ output;\n  bool started = false;\n  for (int i = 0; i < paren_string.size();\
    \ i++) {\n    char c = paren_string[i];\n    if (c == '(') {\n      if (!started)\
    \ {\n        started = true;\n      }\n      level++;\n    } else if (c == ')')\
    \ {\n      if (level == 0) {\n        continue;\n      }\n      level--;\n   \
    \ } else if (c == ' ') {\n      output.push_back(level);\n      started = false;\n\
    \      level = 0;\n    }\n  }\n  return output;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp3z2o8dkd: /tmp/tmp3z2o8dkd.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> answer;\n\
    \    int i = 0;\n    int len = paren_string.length();\n    int count = 0;\n  \
    \  int max = 0;\n    while(i < len) {\n        if(paren_string[i] == '(') {\n\
    \            count += 1;\n            if(count > max) {\n                max =\
    \ count;\n            }\n        }\n        else if(paren_string[i] == ')') {\n\
    \            count -= 1;\n        }\n        else if(paren_string[i] == ' ') {\n\
    \            answer.push_back(max);\n            max = 0;\n            count =\
    \ 0;\n        }\n        i += 1;\n    }\n    answer.push_back(max);\n    return\
    \ answer;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // TODO: complete the function\n\
    \    std::vector<long> result;\n    int n = paren_string.size();\n    int i =\
    \ 0;\n    while(i < n) {\n        int lvl = 0;\n        int max_lvl = 0;\n   \
    \     while(paren_string[i] != ' ' && i < n) {\n            if(paren_string[i]\
    \ == '(') {\n                lvl++;\n                max_lvl = std::max(max_lvl,\
    \ lvl);\n            }\n            else if(paren_string[i] == ')') {\n      \
    \          lvl--;\n            }\n            i++;\n        }\n        result.push_back(max_lvl);\n\
    \        i++;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::vector<long> answer;\n    std::stack<long> st;\n    long i = 0;\n  \
    \  while(i < paren_string.length()) {\n        if(paren_string[i] == '(') {\n\
    \            st.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            if(st.top() == '(') {\n                st.pop();\n  \
    \          }\n            else {\n                std::cout << \"Invalid Expression\"\
    \ << std::endl;\n                break;\n            }\n        }\n        else\
    \ if(paren_string[i] == ' ') {\n            result.push_back(st.size());\n   \
    \     }\n        else {\n            std::cout << \"Invalid Expression\" << std::endl;\n\
    \            break;\n        }\n        i++;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpuyrkb3c0: /tmp/tmpuyrkb3c0.cpp:39: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    long stk = 0;\n    long\
    \ curr = 0;\n    long max_level = 0;\n    std::vector<long> ret;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            stk++;\n            curr++;\n            max_level = std::max(max_level,\
    \ curr);\n        } else if (paren_string[i] == ')') {\n            curr--;\n\
    \        } else if (paren_string[i] == ' ') {\n            ret.push_back(max_level);\n\
    \            stk = 0;\n            curr = 0;\n            max_level = 0;\n   \
    \     }\n    }\n    ret.push_back(max_level);\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  // Your code here\n\tstd::vector<long>\
    \ group;\n  int i = 0;\n  int count = 0;\n  for(int j = 0; j < paren_string.length();\
    \ j++){\n    if(paren_string[j] == '('){\n      count++;\n    }\n    else if(paren_string[j]\
    \ == ')'){\n      count--;\n    }\n    else if(paren_string[j] == ' '){\n    \
    \  group.push_back(count);\n      count = 0;\n    }\n  }\n  group.push_back(count);\n\
    \  return group;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp4re34nc9: /tmp/tmp4re34nc9.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n   std::vector<long> result;\n\
    \   int start = 0;\n   int end = 0;\n   while (end < paren_string.size()) {\n\
    \      char c = paren_string[end];\n      if (c == '(') {\n         result.push_back(1);\n\
    \      } else if (c == ')') {\n         result.back()++;\n      } else if (c ==\
    \ ' ') {\n         start = end + 1;\n      }\n      end++;\n   }\n   return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp361rirmm: /tmp/tmp361rirmm.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> res;\n\t\
    int level = 0;\n\tstd::cout << paren_string << std::endl;\n\tfor (int i = 0; i\
    \ < paren_string.size(); i++) {\n\t\tif (paren_string[i] == '(') {\n\t\t\tlevel++;\n\
    \t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\t\tlevel--;\n\t\t}\n\t\telse\
    \ if (paren_string[i] == ' ') {\n\t\t\tres.push_back(level);\n\t\t\tlevel = 0;\n\
    \t\t}\n\t}\n\tres.push_back(level);\n\treturn res;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp03atvmwi: /tmp/tmp03atvmwi.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: '(()()) ((())) () ((())()())

    '
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tstd::vector<long> v;\n\t\
    int lvl = 0;\n\tint maxlvl = 0;\n\tfor (int i = 0; i < paren_string.length();\
    \ i++) {\n\t\tif (paren_string[i] == '(') {\n\t\t\tlvl++;\n\t\t\tif (lvl > maxlvl)\
    \ {\n\t\t\t\tmaxlvl = lvl;\n\t\t\t}\n\t\t}\n\t\telse if (paren_string[i] == ')')\
    \ {\n\t\t\tlvl--;\n\t\t}\n\t\telse if (paren_string[i] == ' ') {\n\t\t\tv.push_back(maxlvl);\n\
    \t\t\tmaxlvl = 0;\n\t\t\tlvl = 0;\n\t\t}\n\t}\n\tv.push_back(maxlvl);\n\treturn\
    \ v;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::stack<char> paren_stack;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        paren_stack.push(' ');\n        for (long long i = 0; i < paren_group.size();\
    \ i++) {\n            if (paren_group[i] == '(') {\n                paren_stack.push('(');\n\
    \            } else if (paren_group[i] == ')') {\n                paren_stack.pop();\n\
    \            }\n        }\n        levels.push_back(paren_stack.size() - 1);\n\
    \        paren_stack.pop();\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpuo7da8yj: /tmp/tmpuo7da8yj.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    int m_count = 0;\n    int max_count = 0;\n    std::vector<char> temp_stack;\n\
    \    int j = 0;\n    while(j < paren_string.size()) {\n        if(paren_string[j]\
    \ == '(') {\n            temp_stack.push_back(paren_string[j]);\n            m_count++;\n\
    \            if(m_count > max_count) {\n                max_count = m_count;\n\
    \            }\n        }\n        else if(paren_string[j] == ')') {\n       \
    \     temp_stack.pop_back();\n            m_count--;\n        }\n        else\
    \ if(paren_string[j] == ' ') {\n            if(temp_stack.size() == 0) {\n   \
    \             result.push_back(max_count);\n                max_count = 0;\n \
    \               m_count = 0;\n            }\n        }\n        j++;\n    }\n\
    \    if(temp_stack.size() == 0) {\n        result.push_back(max_count);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::stack<long> stk;\n    long depth = 0;\n    long max_depth = 0;\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            depth +=\
    \ 1;\n            max_depth = std::max(max_depth, depth);\n        } else if (c\
    \ == ')') {\n            depth -= 1;\n        } else if (c == ' ') {\n       \
    \     result.push_back(max_depth);\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    result.push_back(max_depth);\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// Implement your code here.\n\
    \t// Remove this statement and add your own.\n\tstd::vector<long> paren_count;\n\
    \tstd::string delimiter = \" \";\n\tsize_t pos = 0;\n\tstd::string token;\n\t\
    while ((pos = paren_string.find(delimiter)) != std::string::npos) {\n\t\ttoken\
    \ = paren_string.substr(0, pos);\n\t\tparen_string.erase(0, pos + delimiter.length());\n\
    \t\tlong counter = 0;\n\t\tlong max = 0;\n\t\tfor (long i = 0; i < token.length();\
    \ i++) {\n\t\t\tif (token[i] == '(') {\n\t\t\t\tcounter++;\n\t\t\t\tif (counter\
    \ > max) {\n\t\t\t\t\tmax = counter;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (token[i]\
    \ == ')') {\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t}\n\t\tparen_count.push_back(max);\n\
    \t}\n\treturn paren_count;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwavvqdze: /tmp/tmpwavvqdze.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> nested_depth;\n\
    \  std::stringstream ss(paren_string);\n  std::string paren_group;\n  std::stack<char>\
    \ st;\n  long max_depth;\n  while (std::getline(ss, paren_group, ' ')) {\n   \
    \ //std::cout << paren_group << std::endl;\n    max_depth = 0;\n    for (int i\
    \ = 0; i < paren_group.length(); i++) {\n      if (paren_group[i] == '(') {\n\
    \        st.push(paren_group[i]);\n        if (st.size() > max_depth) {\n    \
    \      max_depth = st.size();\n        }\n      } else if (paren_group[i] == ')')\
    \ {\n        st.pop();\n      }\n    }\n    nested_depth.push_back(max_depth);\n\
    \  }\n  return nested_depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\t// Using stack to store the\
    \ open braces\n\tstd::stack<long> stk;\n\t// To store the final result.\n\tstd::vector<long>\
    \ result;\n\t// A tracker to keep track of the current count of nested braces\n\
    \tlong cur_count = 0;\n\tfor (long i = 0; i < paren_string.length(); i++) {\n\t\
    \tchar ch = paren_string[i];\n\t\tif (ch == '(') {\n\t\t\tstk.push(ch);\n\t\t\t\
    cur_count++;\n\t\t}\n\t\telse if (ch == ')') {\n\t\t\t// if the current character\
    \ is ')' and there are no\n\t\t\t// parentheses in the stack then we are at the\
    \ end of\n\t\t\t// the current group, so push the current count to the\n\t\t\t\
    // result and reset the current count.\n\t\t\tif (stk.empty()) {\n\t\t\t\tresult.push_back(cur_count);\n\
    \t\t\t\tcur_count = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstk.pop();\n\t\t\t\tcur_count--;\n\
    \t\t\t}\n\t\t}\n\t\telse if (ch == ' ') {\n\t\t\t// if the current character is\
    \ a space and the stack is empty\n\t\t\t// then we are at the end of the current\
    \ group, so push the current\n\t\t\t// count to the result and reset the current\
    \ count.\n\t\t\tif (stk.empty()) {\n\t\t\t\tresult.push_back(cur_count);\n\t\t\
    \t\tcur_count = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpz9nkww6g: /tmp/tmpz9nkww6g.cpp:49: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> depths;\n\
    \  std::stack<char> s;\n  long depth = 0;\n  for (char &c : paren_string) {\n\
    \    if (c == '(') {\n      s.push(c);\n      ++depth;\n    } else if (c == ')')\
    \ {\n      s.pop();\n      --depth;\n    } else if (c == ' ') {\n      depths.push_back(depth);\n\
    \      depth = 0;\n    }\n  }\n  depths.push_back(depth);\n  return depths;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmptqj144y7: /tmp/tmptqj144y7.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    if (paren_string.empty())\
    \ {\n        return {};\n    }\n    std::vector<long> max_levels;\n    int level\
    \ = 0;\n    int max_level = 0;\n    int last_open_paren_idx = -1;\n    std::stack<int>\
    \ open_paren_idx_stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            level++;\n            last_open_paren_idx\
    \ = i;\n            open_paren_idx_stack.push(i);\n        } else if (paren_string[i]\
    \ == ')') {\n            level--;\n            assert(level >= 0);\n         \
    \   open_paren_idx_stack.pop();\n            if (level == 0) {\n             \
    \   max_levels.push_back(max_level);\n                max_level = 0;\n       \
    \     }\n        } else if (paren_string[i] == ' ') {\n            if (open_paren_idx_stack.empty())\
    \ {\n                max_levels.push_back(max_level);\n                max_level\
    \ = 0;\n            }\n        }\n        max_level = std::max(max_level, level);\n\
    \    }\n    return max_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp8x396hxq: /tmp/tmp8x396hxq.cpp:42: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> ret;\n\
    \  std::stringstream ss(paren_string);\n  std::string group;\n  while (std::getline(ss,\
    \ group, ' ')) {\n    ret.push_back(count_nested_parens(group));\n  }\n  return\
    \ ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo5jqhgxi.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpo5jqhgxi.cpp:13:19: error: \u2018count_nested_parens\u2019 was not\
    \ declared in this scope; did you mean \u2018parse_nested_parens\u2019?\n   13\
    \ |     ret.push_back(count_nested_parens(group));\n      |                  \
    \ ^~~~~~~~~~~~~~~~~~~\n      |                   parse_nested_parens\n"
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ans;\n\
    \    std::stringstream ss(paren_string);\n    std::string s;\n    while(std::getline(ss,\
    \ s, ' ')) {\n        ans.push_back(0);\n        for(auto c : s) {\n         \
    \   if(c == '(')\n                ans.back()++;\n            else if(c == ')')\n\
    \                ans.back()--;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmprh2ls57s: /tmp/tmprh2ls57s.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    int index = 0;\n    while (index < paren_string.size()) {\n        int j\
    \ = index;\n        while (paren_string[j] != ' ') j++;\n        result.push_back(find_nesting_level(paren_string.substr(index,\
    \ j - index)));\n        index = j + 1;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkl4_7g57.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkl4_7g57.cpp:14:26: error: \u2018find_nesting_level\u2019 was not declared\
    \ in this scope\n   14 |         result.push_back(find_nesting_level(paren_string.substr(index,\
    \ j - index)));\n      |                          ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n   std::vector<long> maxdepth;\n\
    \   long temp=0;\n   for(auto i:paren_string){\n      if(i=='('){\n         temp++;\n\
    \      }\n      else if(i==')'){\n         temp--;\n      }\n      else if(i=='\
    \ '){\n         maxdepth.push_back(temp);\n         temp=0;\n      }\n   }\n \
    \  maxdepth.push_back(temp);\n   return maxdepth;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp7usnga6h: /tmp/tmp7usnga6h.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> ret;\n\
    \    // YOUR CODE HERE\n    std::stringstream ss(paren_string);\n    std::string\
    \ s;\n    while(ss >> s) {\n        std::stack<char> st;\n        for(int i =\
    \ 0; i < s.size(); i++) {\n            if(s[i] == '(') {\n                st.push(s[i]);\n\
    \            } else if(s[i] == ')') {\n                if(st.empty()) {\n    \
    \                break;\n                } else {\n                    st.pop();\n\
    \                }\n            }\n        }\n        if(st.empty()) {\n     \
    \       ret.push_back(s.size()/2);\n        } else {\n            ret.push_back(0);\n\
    \        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp2_czmage: /tmp/tmp2_czmage.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long n = paren_string.size();\n  long paren_max = 0;\n  int count = 0;\n  for\
    \ (long i = 0; i < n; i++) {\n    if (paren_string[i] == '(') {\n      count++;\n\
    \      paren_max = std::max(paren_max, count);\n    } else if (paren_string[i]\
    \ == ')') {\n      count--;\n    } else if (paren_string[i] == ' ') {\n      result.push_back(paren_max);\n\
    \      paren_max = 0;\n      count = 0;\n    }\n  }\n  result.push_back(paren_max);\n\
    \  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpsbdd0w1a.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpsbdd0w1a.cpp:16:44: error: no matching function for call to \u2018\
    max(long int&, int&)\u2019\n   16 |       paren_max = std::max(paren_max, count);\n\
    \      |                                            ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpsbdd0w1a.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsbdd0w1a.cpp:16:44: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018int\u2019)\n   16 |       paren_max = std::max(paren_max, count);\n\
    \      |                                            ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpsbdd0w1a.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsbdd0w1a.cpp:16:44:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018int\u2019)\n   16 |       paren_max = std::max(paren_max,\
    \ count);\n      |                                            ^\nIn file included\
    \ from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp"
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> max_nest_levels;\n\
    \    // Your code here\n    // Return a vector of longest nest levels\n    return\
    \ max_nest_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpr7gmptpg: /tmp/tmpr7gmptpg.cpp:16: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112972
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    // TODO: Implement the\
    \ function\n    return {};\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp2uxfaa6s: /tmp/tmp2uxfaa6s.cpp:14: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  std::stringstream ss(paren_string);\n  std::string group;\n  while (std::getline(ss,\
    \ group, ' ')) {\n    long depth = 0;\n    long max_depth = 0;\n    for (long\
    \ i = 0; i < group.size(); i++) {\n      if (group[i] == '(') {\n        depth++;\n\
    \        max_depth = std::max(max_depth, depth);\n      } else if (group[i] ==\
    \ ')') {\n        depth--;\n      }\n    }\n    result.push_back(max_depth);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112972
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> vec_paren_depth;\n\
    \    std::vector<long> tmp_vec_paren_depth;\n    std::stack<char> stack_parens;\n\
    \    bool is_mismatch = false;\n    bool is_first_paren = true;\n    long curr_nest_depth\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(' || c == ')') {\n\
    \            if (is_first_paren) {\n                is_first_paren = false;\n\
    \                if (c == ')') {\n                    // Mismatch\n          \
    \          is_mismatch = true;\n                    break;\n                }\n\
    \            }\n            if (c == '(') {\n                curr_nest_depth++;\n\
    \                stack_parens.push(c);\n            } else {\n               \
    \ if (stack_parens.empty()) {\n                    // Mismatch\n             \
    \       is_mismatch = true;\n                    break;\n                }\n \
    \               stack_parens.pop();\n                if (stack_parens.empty())\
    \ {\n                    tmp_vec_paren_depth.push_back(curr_nest_depth);\n   \
    \                 curr_nest_depth = 0;\n                }\n            }\n   \
    \     } else {\n            // End of group\n            if (!stack_parens.empty())\
    \ {\n                // Mismatch\n                is_mismatch = true;\n      \
    \          break;\n            }\n            // Store the depths\n          \
    \  vec_paren_depth.insert(vec_paren_depth.end(), tmp_vec_paren_depth.begin(),\
    \ tmp_vec_paren_depth.end());\n            // Clear the tmp vector\n         \
    \   tmp_vec_paren_depth.clear();\n            is_first_paren = true;\n       \
    \ }\n    }\n    if (!stack_parens.empty()) {\n        // Mismatch\n        is_mismatch\
    \ = true;\n    }\n    // Store the depths\n    vec_paren_depth.insert(vec_paren_depth.end(),\
    \ tmp_vec_paren_depth.begin(), tmp_vec_paren_depth.end());\n    if (is_mismatch)\
    \ {\n        // Mismatch\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp46y4cs6r.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp46y4cs6r.cpp:63:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   63 | int main() {\n      |            ^\n/tmp/tmp46y4cs6r.cpp:68:1:\
    \ error: expected \u2018}\u2019 at end of input\n   68 | }\n      | ^\n/tmp/tmp46y4cs6r.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp46y4cs6r.cpp:68:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   68 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112972
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  //  Fill this in.\n  std::vector<long>\
    \ answer;\n  if(paren_string.length()==0) return answer;\n  if(paren_string.length()==1)\
    \ return {1};\n  std::string s = \"\";\n  for(int i=0;i<paren_string.length();i++){\n\
    \    if(paren_string[i]!=' '){\n      s = s + paren_string[i];\n    }\n    else{\n\
    \      answer.push_back(count_paren(s));\n      s = \"\";\n    }\n  }\n  answer.push_back(count_paren(s));\n\
    \  return answer;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmptr1k0wyq.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmptr1k0wyq.cpp:19:24: error: \u2018count_paren\u2019 was not declared\
    \ in this scope\n   19 |       answer.push_back(count_paren(s));\n      |    \
    \                    ^~~~~~~~~~~\n/tmp/tmptr1k0wyq.cpp:23:20: error: \u2018count_paren\u2019\
    \ was not declared in this scope\n   23 |   answer.push_back(count_paren(s));\n\
    \      |                    ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660112973
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> depth_of_nesting;\n\
    \    std::stringstream ss(paren_string);\n    std::string group;\n    while (std::getline(ss,\
    \ group, ' ')) {\n        long depth = 0;\n        long max_depth = 0;\n     \
    \   for (auto i = 0; i < group.size(); i++) {\n            if (group[i] == '(')\
    \ {\n                depth++;\n            } else if (group[i] == ')') {\n   \
    \             depth--;\n            }\n            max_depth = std::max(max_depth,\
    \ depth);\n        }\n        depth_of_nesting.push_back(max_depth);\n    }\n\
    \    return depth_of_nesting;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::stack<int> st;\n \
    \   std::vector<long> ans;\n    long temp=0;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \          temp++;\n        }\n        else if(paren_string[i]==')'){\n      \
    \      if(st.top()=='('){\n                st.pop();\n                ans.push_back(temp);\n\
    \                temp=0;\n            }\n        }\n        else if(paren_string[i]=='\
    \ '){\n            continue;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpokrccims: /tmp/tmpokrccims.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n\tint max_level = 0;\n\tstd::vector<long>\
    \ ans;\n\tfor (int i = 0; i < paren_string.size(); i++) {\n\t\tif (paren_string[i]\
    \ == '(') {\n\t\t\tmax_level++;\n\t\t}\n\t\telse if (paren_string[i] == ')') {\n\
    \t\t\tans.push_back(max_level);\n\t\t\tmax_level--;\n\t\t}\n\t}\n\treturn ans;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpx7zbykdz: /tmp/tmpx7zbykdz.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  std::string token;\n  std::istringstream tokenStream(paren_string);\n  while\
    \ (std::getline(tokenStream, token, ' ')) {\n    std::stack<char> parens;\n  \
    \  long deepest = 0;\n    for (char c : token) {\n      if (c == '(') {\n    \
    \    parens.push(c);\n        deepest = std::max(deepest, (long)parens.size());\n\
    \      } else if (c == ')') {\n        if (parens.empty()) {\n          throw\
    \ std::invalid_argument(\"Unbalanced parentheses\");\n        }\n        parens.pop();\n\
    \      }\n    }\n    if (!parens.empty()) {\n      throw std::invalid_argument(\"\
    Unbalanced parentheses\");\n    }\n    result.push_back(deepest);\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    int count = 0;\n    std::vector<long>\
    \ result;\n    bool flag = true;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(')\n            count++;\n        else\
    \ if(paren_string[i] == ')')\n            count--;\n        else if(paren_string[i]\
    \ == ' ') {\n            if(count < 0)\n                flag = false;\n      \
    \      result.push_back(count);\n            count = 0;\n        }\n    }\n  \
    \  if(flag == false)\n        return {};\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp_0g04qnq: /tmp/tmp_0g04qnq.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_depth = 0;\n    long counter = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            counter++;\n            max_depth =\
    \ std::max(max_depth, counter);\n        } else if (c == ')') {\n            counter--;\n\
    \        } else if (c == ' ') {\n            result.push_back(max_depth);\n  \
    \          max_depth = 0;\n            counter = 0;\n        }\n    }\n    result.push_back(max_depth);\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    std::vector<long> level;\n    long current_level = 0;\n    for (int i = 0;\
    \ i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n   \
    \         if (current_level == 0) {\n                level.push_back(1);\n   \
    \         } else {\n                level[current_level - 1]++;\n            }\n\
    \            current_level++;\n        } else if (paren_string[i] == ')') {\n\
    \            result.push_back(level[current_level - 1]);\n            level.pop_back();\n\
    \            current_level--;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmph7b8lf6y: /tmp/tmph7b8lf6y.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> maxDepth;\n\
    \    for (long i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            long depth = 0;\n            long j = i;\n          \
    \  while (paren_string[j] != ')') {\n                if (paren_string[j] == '(')\
    \ {\n                    depth++;\n                }\n                j++;\n \
    \           }\n            maxDepth.push_back(depth);\n            i = j;\n  \
    \      }\n    }\n    return maxDepth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp8wwxy1h8: /tmp/tmp8wwxy1h8.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> v;\n\
    \    if(paren_string.size()==0) return v;\n    int max_depth=0;\n    int depth=0;\n\
    \    int index=0;\n    while(index<paren_string.size()){\n        if(paren_string[index]=='('){\n\
    \            depth++;\n            if(depth>max_depth) max_depth=depth;\n    \
    \    }\n        else if(paren_string[index]==')'){\n            depth--;\n   \
    \     }\n        else if(paren_string[index]==' '){\n            v.push_back(max_depth);\n\
    \            max_depth=0;\n            depth=0;\n        }\n        index++;\n\
    \    }\n    v.push_back(max_depth);\n    return v;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> results;\n\
    \    std::vector<char> ops;\n    long count = 0;\n    long max_count = 0;\n  \
    \  for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            count++;\n            ops.push_back('(');\n        }\
    \ else if (paren_string[i] == ')') {\n            count--;\n            ops.pop_back();\n\
    \        } else if (paren_string[i] == ' ') {\n            if (count > max_count)\
    \ {\n                max_count = count;\n            }\n            if (ops.size()\
    \ == 0) {\n                results.push_back(max_count);\n                max_count\
    \ = 0;\n            }\n        }\n    }\n    return results;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp913mexik: /tmp/tmp913mexik.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n\
    \    long depth = 0;\n    long depth_max = 0;\n    for (auto& ch: paren_string)\
    \ {\n        if (ch == '(') {\n            depth++;\n            depth_max = std::max(depth_max,\
    \ depth);\n        } else if (ch == ')') {\n            depths.push_back(depth_max);\n\
    \            depth_max = 0;\n            depth--;\n        }\n    }\n    return\
    \ depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpg_ph2_lv: /tmp/tmpg_ph2_lv.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::stack<int> s;\n  \
    \  std::vector<long> ans;\n    for(auto i:paren_string){\n        if(i=='('){\n\
    \            s.push(1);\n        }\n        else if(i==')'){\n            s.pop();\n\
    \        }\n        else if(i==' '){\n            ans.push_back(s.size());\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpqcv441ax: /tmp/tmpqcv441ax.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112974
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> output;\n\
    \    long stack = 0;\n    long max = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            stack++;\n      \
    \      if (stack > max) {\n                max = stack;\n            }\n     \
    \   } else if (paren_string[i] == ')') {\n            stack--;\n        } else\
    \ if (paren_string[i] == ' ') {\n            output.push_back(max);\n        \
    \    max = 0;\n            stack = 0;\n        }\n    }\n    return output;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpi4auld9v: /tmp/tmpi4auld9v.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112973
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n\
    \    long depth = 0;\n    long max_depth = 0;\n    for (char paren : paren_string)\
    \ {\n        if (paren == '(') {\n            depth++;\n            max_depth\
    \ = std::max(max_depth, depth);\n        } else if (paren == ')') {\n        \
    \    depth--;\n        } else if (paren == ' ') {\n            depths.push_back(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    depths.push_back(max_depth);\n\
    \    return depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660112973
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> ans;\n\
    \  std::string temp = \"\";\n  for(int i = 0; i < paren_string.length(); i++)\
    \ {\n    if(paren_string[i] == ' ') {\n      long count = 0;\n      for(int j\
    \ = 0; j < temp.length(); j++) {\n        if(temp[j] == '(') {\n          count++;\n\
    \        }\n      }\n      ans.push_back(count);\n      temp = \"\";\n    } else\
    \ {\n      temp += paren_string[i];\n    }\n  }\n  long count = 0;\n  for(int\
    \ j = 0; j < temp.length(); j++) {\n    if(temp[j] == '(') {\n      count++;\n\
    \    }\n  }\n  ans.push_back(count);\n  return ans;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpu9z4_gle: /tmp/tmpu9z4_gle.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660112974
