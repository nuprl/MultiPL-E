name: HumanEval_83_starts_one_ends
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer\
  \ n, return the count of the numbers of n-digit\n// positive integers that start\
  \ or end with 1.\nlong starts_one_ends(long n) {\n"
tests: "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1))\
  \ == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n\
  \    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n\
  }\n"
completions: ["    assert(n >= 1);\n    if (n == 1) return 1;\n    long ans = std::pow(10,\
    \ n - 1);\n    for (long i = 1; i < n; ++i) {\n        ans += std::pow(10, i -\
    \ 1) * std::pow(9, n - i);\n    }\n    return ans;", "  if (n == 1) {\n    return\
    \ 2;\n  }\n  if (n == 2) {\n    return 4;\n  }\n  return 3 * starts_one_ends(n\
    \ - 1) - starts_one_ends(n - 2);", "    if (n < 1) {\n        return 0;\n    }\n\
    \    if (n == 1) {\n        return 1;\n    }\n    long dp[n + 1];\n    memset(dp,\
    \ 0, sizeof(dp));\n    dp[1] = 1;\n    dp[2] = 3;\n    for (long i = 3; i <= n;\
    \ i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];", " \
    \   if (n < 1) {\n        return -1;\n    }\n    if (n == 1) {\n        return\
    \ 1;\n    }\n    long res = 10;\n    long first_digit = 10;\n    long other_digits\
    \ = 9;\n    for (long i = 2; i <= n; i++) {\n        other_digits = other_digits\
    \ * (10 - i + 1);\n        first_digit = first_digit + other_digits;\n       \
    \ res += first_digit;\n    }\n    return res;", "    long dp[n+1];\n    memset(dp,\
    \ 0, sizeof(dp));\n    dp[1] = 1;\n    for(long i = 2; i <= n; i++) {\n      \
    \  dp[i] = dp[i-1] + (i-1)*dp[i-2];\n    }\n    return dp[n];", "  if (n == 1)\
    \ return 1;\n  if (n == 2) return 10;\n  long sum = 9; // count of numbers of\
    \ length 1\n  long sum_last = 1;\n  long count = 1;\n  while (n > count) {\n \
    \   sum += sum_last * 9;\n    sum_last += 9;\n    count++;\n  }\n  return sum;",
  "  assert(n > 0);\n  long count = 1;\n  long pow_prev = 1;\n  for (long i = 1; i\
    \ < n; ++i) {\n    long pow_curr = pow_prev * 10;\n    count += pow_prev;\n  \
    \  count += pow_curr;\n    pow_prev = pow_curr;\n  }\n  return count;", "    //\
    \ For example,\n    // count = 4, since the 4-digit numbers that start or end\
    \ with 1 are:\n    // 1000, 1001, 1002, 1100, 1101, 1102, 1110, 1111, 1112, 1120,\
    \ 1121, 1122,\n    // 1200, 1201, 1202, 1210, 1211, 1212, 1220, 1221, 1222, 2000,\
    \ 2001, 2002,\n    // 2100, 2101, 2102, 2110, 2111, 2112, 2120, 2121, 2122, 2200,\
    \ 2201, 2202,\n    // 2210, 2211, 2212, 2220, 2221, 2222.\n    if (n == 1) return\
    \ 2;\n    // n >= 2\n    // Let dp[i] be the count of the numbers of i-digit positive\
    \ integers that\n    // start or end with 1.\n    //\n    // If i is odd, the\
    \ count is dp[i-1] * 2 + 3 * 2^(i/2-1) = dp[i-1] * 2 +\n    // 2^i-1 - 2^(i/2).\n\
    \    //\n    // If i is even, the count is dp[i-1] * 2 + 2^(i/2).\n    //\n  \
    \  // Therefore, the count of the numbers of n-digit positive integers that\n\
    \    // start or end with 1,\n    // is dp[n] = dp[n-1] * 2 + 2^(n/2) + 2^(n-1)\
    \ - 2^(n/2-1).\n    long dp[n+1];\n    dp[1] = 2;\n    dp[2] = 5;\n    for (long\
    \ i = 3; i <= n; ++i) {\n        dp[i] = dp[i-1] * 2 + (1L << (i/2)) + (1L <<\
    \ (i-1)) - (1L << (i/2-1));\n    }\n    return dp[n];", "  if (n < 1) return 0;\n\
    \  long* starts_with_one = new long[n];\n  long* ends_with_one = new long[n];\n\
    \  starts_with_one[0] = 1;\n  ends_with_one[0] = 1;\n  for (long i = 1; i < n;\
    \ i++) {\n    starts_with_one[i] = starts_with_one[i - 1] * 2 + 1;\n    ends_with_one[i]\
    \ = starts_with_one[i - 1] + ends_with_one[i - 1];\n  }\n  long result = ends_with_one[n\
    \ - 1] + starts_with_one[n - 1];\n  delete[] starts_with_one;\n  delete[] ends_with_one;\n\
    \  return result;", "  if (n < 1) return 0;\n  if (n == 1) return 1;\n  long digit\
    \ = (n-1) * 9;\n  long res = digit;\n  long k = 10;\n  while (n > 1) {\n    res\
    \ += digit * k;\n    k *= 10;\n    n--;\n  }\n  return res;", "    if (n == 1)\
    \ {\n        return 1;\n    }\n    long n1 = 9;\n    long n2 = 1;\n    long n3\
    \ = 10;\n    long count = n1 + n2;\n    for (long i = 2; i < n; i++) {\n     \
    \   n1 = 9 * (i - 1) * n3;\n        n2 = 9 * n3;\n        n3 *= 10;\n        count\
    \ += n1 + n2;\n    }\n    return count;", "  assert(n > 0);\n  long result = 0;\n\
    \  for (int i = 1; i <= n; i++) {\n    result += pow(10, n - i);\n  }\n  return\
    \ result;", "  long f1 = 1, f2 = 2, ans = 0;\n  if (n == 1)\n    return 2;\n \
    \ for (long i = 3; i <= n; i++) {\n    ans = f1 + f2;\n    f1 = f2;\n    f2 =\
    \ ans;\n  }\n  return ans;", "    assert(n > 0);\n    long result = 0;\n    for\
    \ (int i = 1; i <= n; i++) {\n        long subresult = 0;\n        for (int j\
    \ = 1; j <= i; j++) {\n            if (j == 1) {\n                subresult +=\
    \ 1;\n            } else if (j == i) {\n                subresult += 1;\n    \
    \        } else {\n                subresult += 9 * pow(10, j - 2);\n        \
    \    }\n        }\n        result += subresult;\n    }\n    return result;", " \
    \ if (n == 1) {\n    return 1;\n  } else if (n > 1) {\n    return (((10 * starts_one_ends(n\
    \ - 1)) + pow(10, n - 1)));\n  }", "    // Implementation here\n    // std::cout\
    \ << \"Starts with 1\\n\";\n    long count = 0;\n    for (long i = 1; i <= n;\
    \ i++) {\n        count += pow(10, i - 1);\n    }\n    count = count - pow(10,\
    \ n - 1);\n    // std::cout << \"Ends with 1\\n\";\n    for (long i = 1; i <=\
    \ n; i++) {\n        count += pow(10, i - 1);\n    }\n    return count;", "  if\
    \ (n == 1) {\n    return 2;\n  }\n  if (n == 2) {\n    return 4;\n  }\n  if (n\
    \ > 2) {\n    return (starts_one_ends(n - 1) + starts_one_ends(n - 2));\n  }",
  "  if (n == 1) {\n    return 1;\n  }\n  // s^n\n  long total = pow(10, n);\n  //\
    \ (s-1)^n-1\n  long no_zero = pow(9, n) - 1;\n  // exlcuding the numbers with\
    \ 1 at beginning\n  // s^n-no_zero\n  long one_in_end = total - no_zero;\n  //\
    \ count of numbers with ones at the beginning\n  // no_zero - no_zero-one_in_end\n\
    \  return no_zero - one_in_end;", "    assert(n >= 0);\n    // if n = 1\n    if\
    \ (n == 1) {\n        return 1;\n    }\n    // no of numbers of n-digit ends with\
    \ 1 will be 9 * pow(10, n-2)\n    // no of numbers of n-digit starts with 1 will\
    \ be 10 * pow(10, n-2)\n    // subtract 1 because that number is double counted\n\
    \    return (9 * pow(10, n-2)) + (10 * pow(10, n-2)) - 1;", "  assert(n > 0);\n\
    \  // dp[i] = dp[i-1] + 10 * dp[i-2]\n  // dp[i] = number of n-digit numbers starting\
    \ with 1.\n  // Since the first digit is 1, the remaining digits can be filled\
    \ in\n  // dp[i-1] ways.\n  // For the first digit, we can also choose to fill\
    \ in 2,3,4,5,6,7,8,9.\n  // The remaining digits can be filled in dp[i-2] ways.\n\
    \  std::vector<long> dp(n+1, 0);\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i)\
    \ {\n    dp[i] = 10 * dp[i-2] + dp[i-1];\n  }\n  // return dp[n] + ((n > 1) ?\
    \ dp[n-1] : 0);\n  return dp[n];", "    long m = std::pow(10, n - 1);\n    long\
    \ l = std::pow(10, n);\n    if (n == 1) {\n        return 2;\n    }\n    return\
    \ (std::pow(10, n - 1) - std::pow(10, n - 2)) * 9 + starts_one_ends(n - 1);",
  "  if (n == 1) return 2;\n  if (n == 2) return 3;\n  long result = (n - 1) * (long)pow(9,\
    \ n - 1);\n  result += 10 * (long)pow(9, n - 2);\n  return result;", "    if (n\
    \ == 1) {\n        return 2;\n    }\n    if (n == 2) {\n        return 10;\n \
    \   }\n    return (n - 1) * 9 * (long)pow(10, n - 2);", "    if (n == 1) {\n \
    \       return 2;\n    }\n    long total_count = 0;\n    long intermediate_count\
    \ = 0;\n    long prod = 1;\n    for (long i = 0; i < n - 1; i++) {\n        prod\
    \ *= 10;\n        intermediate_count += prod;\n    }\n    total_count += 2 * intermediate_count;\n\
    \    total_count += 9 * prod;\n    return total_count;", "  long count = 0;\n\
    \  long max_n_digit_number = pow(10, n) - 1;\n  for (long i = 1; i <= max_n_digit_number;\
    \ i++) {\n    if (to_string(i).front() == '1' || to_string(i).back() == '1') {\n\
    \      count++;\n    }\n  }\n  return count;", "    if (n == 1) {\n        return\
    \ 2;\n    }\n    if (n == 2) {\n        return 6;\n    }\n    if (n == 3) {\n\
    \        return 11;\n    }\n    if (n == 4) {\n        return 20;\n    }\n   \
    \ if (n == 5) {\n        return 35;\n    }\n    if (n == 6) {\n        return\
    \ 56;\n    }\n    if (n == 7) {\n        return 89;\n    }\n    if (n == 8) {\n\
    \        return 137;\n    }\n    if (n == 9) {\n        return 205;\n    }\n \
    \   if (n == 10) {\n        return 301;\n    }\n    if (n == 11) {\n        return\
    \ 425;\n    }\n    if (n == 12) {\n        return 591;\n    }\n    if (n == 13)\
    \ {\n        return 819;\n    }\n    if (n == 14) {\n        return 1117;\n  \
    \  }\n    if (n == 15) {\n        return 1512;\n    }\n    if (n == 16) {\n  \
    \      return 2030;\n    }\n    if (n == 17) {\n        return 2756;\n    }\n\
    \    if (n == 18) {\n        return 3690;\n    }\n    if (n == 19) {\n       \
    \ return 4984;\n    }\n    if (n == 20) {\n        return 6627;\n    }\n    if\
    \ (n == 21) {\n        return 8884;\n    }\n    if (n == 22) {\n        return\
    \ 11876;\n    }\n    if (n == 23) {\n        return 15815;\n    }\n    if (n ==\
    \ 24) {\n        return 20948;\n    }\n    if (n == 25) {\n        return 27608;\n\
    \    }\n    if (n == 26) {\n        return 36314;\n    }\n    if (n == 27) {\n\
    \        return 47680;\n    }\n    if (n == 28) {\n        return 62497;\n   \
    \ }\n    if (n == 29) {\n        return 81747;\n", "    if (n == 1) {\n      \
    \  return 10;\n    } else if (n == 2) {\n        return 100;\n    }\n    // how\
    \ many numbers of n-digits end with 1\n    long ends_1 = 10 * starts_one_ends(n\
    \ - 1);\n    // how many numbers of n-digits start with 1\n    long starts_1 =\
    \ 9 * pow(10, n - 2);\n    return starts_1 + ends_1;", "  long table[n + 1][2];\n\
    \  for (long i = 0; i <= n; i++) {\n    for (long j = 0; j < 2; j++) {\n     \
    \ table[i][j] = 0;\n    }\n  }\n  table[1][0] = 1;\n  table[1][1] = 1;\n  for\
    \ (long i = 2; i <= n; i++) {\n    table[i][0] = table[i - 1][0] + table[i - 1][1];\n\
    \    table[i][1] = table[i - 1][0];\n  }\n  return table[n][0] + table[n][1];",
  "    assert(n > 0);\n    if (n == 1) return 2;\n    long res = 10;\n    long base\
    \ = 10;\n    for (long i = 2; i < n; ++i) {\n        res += 9 * base;\n      \
    \  base *= 10;\n    }\n    return res;", "    std::vector<long> dp(n+1, 0);\n\
    \    dp[1] = 1;\n    for (auto i = 2; i <= n; ++i) {\n        for (auto j = 1;\
    \ j <= i/2; ++j) {\n            dp[i] += dp[j] * dp[i-j];\n        }\n       \
    \ dp[i] *= 2;\n        if (i % 2 == 1) {\n            dp[i] += std::pow(dp[i/2],\
    \ 2);\n        }\n    }\n    return dp[n];", "  long *dp = new long[n + 1];\n\
    \  dp[0] = 0;\n  dp[1] = 1;\n  for (long i = 2; i <= n; i++) {\n    dp[i] = dp[i\
    \ - 1] * 10 + (int)pow(10, i - 1);\n  }\n  return dp[n];", "    // Write your\
    \ code here\n    // Return the answer\n    long dp[n + 1][2];\n    for (long i\
    \ = 0; i <= n; i++) {\n        for (long j = 0; j < 2; j++) {\n            dp[i][j]\
    \ = 0;\n        }\n    }\n    dp[1][0] = 1;\n    dp[1][1] = 1;\n    for (long\
    \ i = 2; i <= n; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n   \
    \     dp[i][1] = dp[i - 1][0];\n    }\n    return dp[n][0] + dp[n][1];", "   \
    \ // We have to create an array to store the digits from 1 to 9.\n    long num_digits[9];\n\
    \    // 1 digit number start or end with 1.\n    num_digits[0] = 1;\n    // Now\
    \ we have to calculate the number of digit for 2 digit number start or\n    //\
    \ end with 1.\n    // 1, 2, 3, 4, 5, 6, 7, 8, 9\n    // start with 1 and end with\
    \ 1, 4\n    // start with 1 and end with 2, 3\n    // start with 1 and end with\
    \ 3, 2\n    // start with 1 and end with 4, 1\n    // We can calculate the number\
    \ of digit for 2 digit number start or end with\n    // 1.\n    num_digits[1]\
    \ = 4;\n    // Now we have to calculate the number of digit for 3 digit number\
    \ start or\n    // end with 1.\n    // start with 1 and end with 1, 7\n    //\
    \ start with 1 and end with 2, 6\n    // start with 1 and end with 3, 5\n    //\
    \ start with 1 and end with 4, 4\n    // start with 1 and end with 5, 3\n    //\
    \ start with 1 and end with 6, 2\n    // start with 1 and end with 7, 1\n    //\
    \ start with 2 and end with 1, 7\n    // start with 2 and end with 2, 6\n    //\
    \ start with 2 and end with 3, 5\n    // start with 2 and end with 4, 4\n    //\
    \ start with 2 and end with 5, 3\n    // start with 2 and end with 6, 2\n    //\
    \ start with 2 and end with 7, 1\n    // start with 3 and end with 1, 7\n    //\
    \ start with 3 and end with 2, 6\n    // start with 3 and end with 3, 5\n    //\
    \ start with 3 and end with 4, 4\n    // start with 3 and end with 5, 3\n    //\
    \ start with 3 and end with 6, 2\n    // start with 3 and end with 7, 1\n    //\
    \ start with 4 and end with 1, 7\n    // start with 4 and end with 2, 6\n    //\
    \ start with 4 and end with 3, 5\n    // start with 4 and end with 4, 4\n    //\
    \ start with 4 and", "  if (n == 1) {\n    return 2;\n  }\n  if (n == 2) {\n \
    \   return 4;\n  }\n  int end_zero = 1;\n  int end_one = 1;\n  for (int i = 3;\
    \ i <= n; i++) {\n    int tmp = (10 * end_one) % 1000000007;\n    end_one = (end_zero\
    \ + end_one) % 1000000007;\n    end_zero = tmp;\n  }\n  return (10 * end_one +\
    \ 2 * end_zero) % 1000000007;", "    // 1 does not follow any pattern.\n    if\
    \ (n == 1) return 1;\n    // To get the answer from the previous number.\n   \
    \ long answer = 0;\n    // If we are at the first digit, we can only choose the\
    \ number 1.\n    long start = 1;\n    // If we are at the last digit, we can choose\
    \ any number from 1 to 9.\n    long end = 9;\n    // f(i) * f(n - i - 1)\n   \
    \ // The first i digits form a number, the rest of the digits form another number.\n\
    \    // The result is the number of ways to form the first number * the number\
    \ of ways to form the second number.\n    for (long i = 0; i < n - 1; i++) {\n\
    \        answer += start * end;\n        // If we are at the first digit, we must\
    \ choose a value of 1.\n        start = start * 10;\n        // If we are at the\
    \ last digit, we can only choose a value from 1 to 9.\n        end = end * 9;\n\
    \    }\n    // Add the first digit.\n    answer += start;\n    return answer;",
  "  if (n == 1) {\n    return 1;\n  }\n  if (n == 2) {\n    return 11;\n  }\n  if\
    \ (n == 3) {\n    return 100;\n  }\n  long dp[n + 1];\n  memset(dp, 0, sizeof(dp));\n\
    \  dp[1] = 1;\n  dp[2] = 11;\n  dp[3] = 100;\n  for (long i = 4; i <= n; i++)\
    \ {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];", "    // TODO:\
    \ write your code here\n\n    return 1;", "    long *arr = new long[n + 1];\n\
    \    for (long i = 0; i <= n; i++) {\n        arr[i] = 0;\n    }\n    arr[1] =\
    \ 1;\n    arr[2] = 2;\n    for (long i = 3; i <= n; i++) {\n        arr[i] = arr[i\
    \ - 1] + arr[i - 2];\n    }\n    long result = arr[n] * 2;\n    delete[] arr;\n\
    \    return result;", "    assert(n >= 1);\n    // edge cases\n    if (n == 1)\
    \ return 2;\n    if (n == 2) return 5;\n    if (n == 3) return 7;\n    // for\
    \ all other cases, we need to use DP\n    long dp[n+1];\n    // building the DP\
    \ array\n    dp[0] = 0;\n    dp[1] = 2;\n    dp[2] = 5;\n    dp[3] = 7;\n    for\
    \ (long i = 4; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n\
    \    }\n    return dp[n];", "  if (n == 1) return 1;\n  // Let n = n_d[0] n_d[1]\
    \ n_d[2] ... n_d[k], k > 0.\n  // We can count the number of n-digit positive\
    \ integers that start or end\n  // with 1 by first grouping the n-digit positive\
    \ integers into equivalence\n  // classes according to their first d = n_d[0]\
    \ digits. For each equivalence\n  // class we can count the number of its members\
    \ starting with 1 and ending\n  // with 1 by grouping the (n - d)-digit positive\
    \ integers that follow into\n  // equivalence classes according to their first\
    \ d' = n_d[1] digits. For each\n  // equivalence class we can count the number\
    \ of its members starting with 1\n  // and ending with 1 by grouping the (n -\
    \ d - d')-digit positive integers\n  // that follow into equivalence classes according\
    \ to their first d'' =\n  // n_d[2] digits. For each equivalence class we can\
    \ count the number of its\n  // members starting with 1 and ending with 1 by grouping\
    \ the (n - d - d' -\n  // d'')-digit positive integers that follow into equivalence\
    \ classes\n  // according to their first d''' = n_d[3] digits.  Repeating this\
    \ process\n  // until there are no digits left shows that the number of n-digit\
    \ positive\n  // integers that start or end with 1 is given by the sum from i\
    \ = 1 to k + 1\n  // of (i * 9^(k + 1 - i)) * (i * 9^(k + 1 - i)).\n  long sum\
    \ = 0;\n  for (long i = 1; i <= n; ++i)\n    sum += i * pow(9, n - i) * i * pow(9,\
    \ n - i);\n  return sum;", "    std::vector<long> dp(n + 1, 0);\n    dp[1] = 1;\n\
    \    for (long i = 2; i <= n; ++i) {\n        if (i == 2) {\n            dp[i]\
    \ = 9;\n        } else {\n            long nines = 9;\n            for (long j\
    \ = 1; j < i - 1; ++j) {\n                nines *= 10;\n            }\n      \
    \      dp[i] = dp[i - 1] + nines * 2;\n        }\n    }\n    return dp[n];", " \
    \ long len_n = log10(n) + 1;\n  if (len_n < 2) {\n    return len_n;\n  }\n  long\
    \ result = std::min(9 * (len_n - 1), n - pow(10, len_n - 1) + 1);\n  return result;",
  "  long answer = 0;\n  long start_one = 9;\n  long ends_one = 0;\n  for (int i =\
    \ 1; i < n; i++) {\n    ends_one = (ends_one * 10) + start_one;\n    start_one\
    \ = (start_one * 10) + 9;\n  }\n  answer = start_one + ends_one;\n  return answer;",
  "    long res = 0;\n    while (n--) {\n        res = res*10 + 1;\n    }\n    return\
    \ res;", "  long ans = 0;\n  // Case 1: All numbers ending with 1 and start with\
    \ 0, excluding 0\n  ans += pow(9, n - 1);\n  // Case 2: All numbers starting with\
    \ 1 and ending with 0, excluding 0\n  ans += pow(9, n - 1);\n  // Case 3: All\
    \ numbers starting and ending with 1, excluding 0\n  // Question: What is the\
    \ number of n-digit integers that start and end with 1\n  // and are not 9?\n\
    \  ans += pow(9, n - 2);\n  return ans;", "  if (n < 1) return 0;\n  long x =\
    \ 1;\n  for (int i = 1; i < n; ++i) {\n    x *= 10;\n  }\n  long e = 9;\n  for\
    \ (int i = 1; i < n; ++i) {\n    e *= 9;\n  }\n  return x + e;", "    if (n ==\
    \ 1) return 1;\n    if (n == 2) return 2;\n    return starts_one_ends(n-1) + starts_one_ends(n-2);",
  "  assert(n >= 1);\n  if (n == 1) return 2;\n  long a = 1, b = 1, c = 1;\n  for\
    \ (int i = 2; i <= n; ++i) {\n    a = a * (10 - i + 1) + b;\n    b = b * (10 -\
    \ i + 1) + c;\n    c = c * (10 - i + 1);\n  }\n  return a;", "  // Write your\
    \ code here.\n    assert(n > 0);\n    if (n == 1) return 2;\n    if (n == 2) return\
    \ 2;\n    if (n == 3) return 3;\n    long result = 1;\n    for (long i = n - 1;\
    \ i > 0; i--) {\n        result *= 10;\n    }\n    result *= 9;\n    result +=\
    \ starts_one_ends(n - 1);\n    return result;", "    if (n == 1) {\n        return\
    \ 2;\n    } else if (n == 2) {\n        return 3;\n    } else {\n        long\
    \ a = 3;\n        long b = 9;\n        for (long i = 3; i <= n; i++) {\n     \
    \       long new_a = a + b;\n            long new_b = 2 * a + b;\n           \
    \ a = new_a;\n            b = new_b;\n        }\n        return a + b;\n    }",
  "  assert(n > 0);\n  assert(n < LONG_MAX);\n  long count = 0;\n  for (long i = 1;\
    \ i <= n; i++) {\n    long value = std::pow(10, i - 1);\n    count += 9 * value;\n\
    \  }\n  return count;", "    if (n <= 1) {\n        return 1;\n    }\n    long\
    \ cnt = 1;\n    for (long i = 1; i < n; i++) {\n        cnt *= 10;\n    }\n  \
    \  return (cnt + starts_one_ends(n - 1));", "    if (n == 1) {\n        return\
    \ 1;\n    }\n    long count = 1;\n    long start = 10;\n    long end = 1;\n  \
    \  for (long i = 1; i < n; i++) {\n        count += start + end;\n        start\
    \ *= 10;\n        end = start/10;\n    }\n    return count;", "    long count\
    \ = 0;\n    while (n > 0) {\n        count += 1;\n        n /= 10;\n    }\n  \
    \  return count;", "  if (n == 1) {\n    return 10;\n  }\n  // std::cout << \"\
    n : \" << n << std::endl;\n  // f(n) = (8 * (n - 1) * f(n - 1)) - (9 * (n - 2)\
    \ * f(n - 2))\n\n  long a = 9;\n  long b = 8;\n  long c = 10;\n  long d = 8;\n\
    \  long e = 10;\n  long f = 8;\n  long g = 0;\n  long h = 0;\n  long i = 0;\n\
    \  long j = 0;\n  for (long k = 2; k < n; k++) {\n    g = d;\n    h = e;\n   \
    \ i = f;\n    j = 10;\n    d = (b * g) + (c * h);\n    e = (a * g) + (b * h);\n\
    \    f = (c * g) + (a * h);\n    a = e;\n    b = d;\n    c = f;\n  }\n  // std::cout\
    \ << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << \" \" << f\n\
    \  // << \" \" << g << \" \" << h << \" \" << i << \" \" << j << std::endl;\n\
    \  return (c * a) + (a * b) + (10 * b);", "  if (n == 1) return 1;\n  return (starts_one_ends(n\
    \ - 1) * 10) - starts_one_ends(n - 2);", "  assert(n >= 1);\n  long result = 0;\n\
    \  long p = 1; // 10^(n-1)\n  for (long i = 1; i < n; ++i) p *= 10;\n  for (long\
    \ i = 1; i < 10; ++i) {\n    long x = i * p;\n    if (x >= n) break;\n    result\
    \ += starts_one_ends(n - x);\n  }\n  return result;", '    return 0;', "    //\
    \ Initially we only have 1 digit long numbers\n    long num_ends = 1;\n    long\
    \ num_starts = 1;\n    for (long i = 2; i <= n; i++) {\n        // For each iteration,\
    \ we add a new digit\n        // So we have 1 new number at the end (9 * 10^(n-1))\n\
    \        // We also have (num_ends + num_starts) * 10^(n-1) new numbers\n    \
    \    // as we can put a 0 in front of any existing number\n        num_ends =\
    \ 9 * pow(10, i - 1) + (num_ends + num_starts) * pow(10, i - 1);\n        // We\
    \ also have num_starts * 10^(n-1) new numbers as we can add\n        // 1 in front\
    \ of existing numbers\n        num_starts = num_starts * pow(10, i - 1);\n   \
    \ }\n    return num_ends + num_starts;", "  long counter = 0;\n  long *arr = new\
    \ long[n + 1];\n  arr[0] = 0;\n  arr[1] = 1;\n  arr[2] = 11;\n  arr[3] = 111;\n\
    \  for (long i = 4; i <= n; i++) {\n    arr[i] = 10 * arr[i - 1] + pow(10, i -\
    \ 1);\n  }\n  counter = arr[n];\n  delete arr;\n  return counter;", "  assert(n\
    \ >= 1);\n  // Each n-digit number can be uniquely represented in form of\n  //\
    \ a_1, a_2, ..., a_n, where a_i is the digit at ith position.\n  // There are\
    \ two cases for each a_i:\n  // 1. a_i = 1.\n  // 2. a_i != 1.\n  //\n  // Therefore,\
    \ there are 2^n possible n-digit numbers.\n\n  // Case 1.\n  // Given a_1 = 1,\
    \ there are 8 possible a_2, 8 possible a_3, ...\n  // Therefore, there are (n-1)\
    \ * 8^(n-1) n-digit numbers such that\n  // a_1 = 1 and a_2 != 1.\n  //\n  //\
    \ Case 2.\n  // Given a_n = 1, there are 9 possible a_1, 8 possible a_2, ...\n\
    \  // Therefore, there are (n-1) * 9^(n-1) n-digit numbers such that\n  // a_n\
    \ = 1 and a_1 != 1.\n  //\n  // Given a number, we can compute the number of digits\
    \ by\n  // counting the number of digits of the number. This can be done\n  //\
    \ by checking the number for all powers of 10. Therefore, the\n  // overall time\
    \ complexity of the algorithm is O(log(n)).\n  long count = 0;\n  // Number of\
    \ digits in n.\n  long digit_count = 0;\n  long temp = n;\n  while (temp > 0)\
    \ {\n    ++digit_count;\n    temp /= 10;\n  }\n  count += (digit_count - 1) *\
    \ 8 * std::pow(8, digit_count - 2);\n  count += (digit_count - 1) * 9 * std::pow(9,\
    \ digit_count - 2);\n  return count;", "  long dp[n + 1];\n  memset(dp, 0, sizeof(dp));\n\
    \  dp[1] = 1;\n  for (long i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] * 9 +\
    \ pow(10, i - 1);\n  }\n  return dp[n];", "    // Write your code here.\n    return\
    \ 0;", "  long *dp = new long[n+1];\n  dp[0] = 0;\n  dp[1] = 1;\n  dp[2] = 2;\n\
    \  dp[3] = 3;\n  dp[4] = 4;\n  dp[5] = 5;\n  dp[6] = 6;\n  dp[7] = 7;\n  dp[8]\
    \ = 8;\n  dp[9] = 9;\n  for (long i = 10; i <= n; i++) {\n    dp[i] = dp[i-1]\
    \ + (dp[i-2] * 10) - (dp[i-3] * 8);\n  }\n  return dp[n];", "  long count = 0;\n\
    \  for (long i = 1; i <= n; i++) {\n    long k = pow(10, i - 1);\n    count +=\
    \ 9 * k;\n  }\n  return count;", "    if (n == 1) return 1;\n    long aux_count\
    \ = 1;\n    for (int i = 0; i < n-1; i++) {\n        aux_count *= 10;\n    }\n\
    \    return aux_count + 1;", "  if (n == 1) return 2;\n  long sum = 2; // ends\
    \ with one\n  sum += 9 * pow(10, n - 1); // start with one\n  // compute 10^n\
    \ - 1 = 9*9...9 = 9*10^(n-1) - 9\n  sum += 9 * pow(10, n - 1) - 9;\n  return sum;",
  "    long count = 0;\n    for (long i = 1; i <= n; i++) {\n        for (long j =\
    \ 1; j <= n; j++) {\n            if (i == 1 || j == 1) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;", "  if (n == 1) {\n    return\
    \ 1;\n  } else if (n == 2) {\n    return 11;\n  } else {\n    int ans = starts_one_ends(n\
    \ - 1) + 1;\n    ans += starts_one_ends(n - 2) * 9;\n    return ans;\n  }", " \
    \   long long ans = 1;\n    for (long i = 1; i < n; i++) {\n        ans = ans\
    \ * 10;\n    }\n    return ans;", "  long ans = 0;\n  for (int i = 1; i <= n;\
    \ i++) {\n    // start with 1\n    ans += std::pow(10, i - 1);\n    // end with\
    \ 1\n    ans += std::pow(10, i - 1);\n  }\n  return ans;", "    long dp[n+1];\n\
    \    dp[0] = 0;\n    dp[1] = 1;\n    for(long i = 2; i <= n; i++) {\n        dp[i]\
    \ = 9*dp[i-1] + pow(10, i-1);\n    }\n    return dp[n];", "  long a = 1, b = 1,\
    \ c = 1;\n  for (long i = 1; i < n; i++) {\n    a = (10 * a + 1) % 1000000;\n\
    \    b = (10 * b + 1) % 1000000;\n    c = (10 * c + 9) % 1000000;\n  }\n  if (n\
    \ > 1) {\n    return (c + a + 9) % 1000000;\n  } else {\n    return 1;\n  }",
  "  assert(n > 0);\n  long counts = 0;\n  int i;\n  if (n == 1) {\n    return 1;\n\
    \  }\n  else {\n    for (i = 0; i < n; i++) {\n      counts += pow(9, i) * pow(10,\
    \ n - i - 1);\n    }\n    return counts;\n  }", "  long count = 0;\n  for (int\
    \ i = 1; i <= n; i++) {\n    long num = pow(10, i - 1);\n    count += (2 * num)\
    \ - 1;\n  }\n  return count;", "  if (n == 1) {\n    return 2;\n  } else if (n\
    \ == 2) {\n    return 4;\n  } else {\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2);\n  }", "    assert(n >= 1);\n    long* count = new long[n+1];\n    memset(count,\
    \ 0, sizeof(long)*(n+1));\n    count[1] = 2;\n    count[2] = 3;\n    long MOD\
    \ = 1000000007;\n    for (long i = 3; i <= n; i++) {\n        count[i] = (count[i-1]\
    \ + count[i-2]) % MOD;\n    }\n    long result = (count[n] + MOD - 2) % MOD;\n\
    \    delete[] count;\n    return result;", "  long dp[n + 1];\n  for (int i =\
    \ 0; i <= n; i++) {\n    dp[i] = 0;\n  }\n  dp[1] = 1;\n  long mod = 1e9 + 7;\n\
    \  for (int i = 2; i <= n; i++) {\n    dp[i] = (dp[i - 1] * 10) % mod;\n    dp[i]\
    \ = (dp[i] + 9 * pow(10, i - 2)) % mod;\n  }\n  return dp[n];", "    if (n <=\
    \ 1) {\n        return 1;\n    }\n    long count = 0;\n    for (long i = 1; i\
    \ <= n; i++) {\n        count += pow(2, i - 1);\n    }\n    return count;", " \
    \ // 1 digit numbers are 1 & 0\n  if (n == 1) {\n    return 2;\n  }\n  // 2 digit\
    \ numbers that start with one is ten\n  if (n == 2) {\n    return 10;\n  }\n \
    \ // handle the same way as before\n  long result = 10;\n  long count = 9;\n \
    \ long last = 2;\n  while (last < n) {\n    count *= 10;\n    result += count;\n\
    \    last++;\n  }\n  return result;", "    assert(n > 0);\n    int digits = 0;\n\
    \    while(n>=10) {\n        digits++;\n        n /= 10;\n    }\n    return (digits)*(pow(9,digits))\
    \ + (pow(9,digits) - 1);", "    long count = 0;\n    // The binary representation\
    \ of 5 is 101.\n    // The number of binary digits of every integer > 5 is a multiple\
    \ of 3.\n    for (long i = 1; i <= n; i++) {\n        if (i % 3 == 0) {\n    \
    \        count++;\n        }\n    }\n    return count;", "    if (n == 1) return\
    \ 2;\n    long previous = 2;\n    long count = 3;\n    for (long i = 2; i <= n;\
    \ i++) {\n        long result = previous + count;\n        previous = count;\n\
    \        count = result;\n    }\n    return count;", "    std::vector<long> dp(n\
    \ + 1, 0);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i]\
    \ = 9 * dp[i - 1] + std::pow(10, i - 1);\n    }\n    return dp[n];", "  assert(n\
    \ >= 1);\n  long total_count = 0;\n  // Let's take a brute force approach and\
    \ iterate from 1 to 10^n - 1, and check\n  // if the number contains a 1 at the\
    \ start or the end.\n  for (long i = 1; i < pow(10, n); i++) {\n    long digit\
    \ = i;\n    while (digit > 0) {\n      if (digit % 10 == 1) {\n        total_count++;\n\
    \        break;\n      }\n      digit /= 10;\n    }\n  }\n  return total_count;",
  "  long dp[n+1];\n  memset(dp, 0, sizeof(dp));\n  dp[1] = 1;\n  for (long i = 2;\
    \ i <= n; i++) {\n    dp[i] = dp[i-1] + 9*pow(10, i-2);\n  }\n  return dp[n];",
  "    long ans = 0;\n    for (long i = 1; i <= n; i++) {\n        ans += pow(10,\
    \ i - 1);\n    }\n    return ans;", "  if (n <= 0) {\n    return 0;\n  }\n  return\
    \ n * 9 + 1;", "  if (n == 1) return 2;\n  assert(n > 1);\n  long sum = 0;\n \
    \ for (long i = 1; i < n; ++i) {\n    long ones = 0;\n    for (long j = 1; j <=\
    \ i; ++j) {\n      ones += 9 * std::pow(10, j - 1);\n    }\n    long num = 10\
    \ * std::pow(10, i - 1);\n    sum += ones * num;\n  }\n  sum += 9 * std::pow(10,\
    \ n - 1);\n  return sum;", "    long arr[n];\n    if (n == 1) {\n        return\
    \ 10;\n    }\n    arr[0] = 10;\n    arr[1] = 9 * 9;\n    for (long i = 2; i <\
    \ n; i++) {\n        arr[i] = arr[i - 1] * (9 - i + 1);\n    }\n    long ans =\
    \ 0;\n    for (long i = 0; i < n; i++) {\n        ans += arr[i];\n    }\n    return\
    \ ans;", "  long result = 0;\n  // the numbers starting with 1 will be of the\
    \ form [1] + [2, 3, 4, 5, 6, 7, 8,\n  // 9]{(n-1) times}\n  if (n >= 2) {\n  \
    \  result += 9;  // [2, 3, 4, 5, 6, 7, 8, 9]\n    result *= pow(9, n - 2);\n \
    \ } else {\n    result += 1;\n  }\n  return result;", "    if (n == 1) return\
    \ 2;\n    if (n == 2) return 2 * 5;\n    if (n > 2) {\n        long result = 0;\n\
    \        for (long i = 0; i < n; i++) {\n            result += 9 * pow(10, i)\
    \ * pow(9, n - i - 1);\n        }\n        return result * 2;\n    }\n    return\
    \ 0;", "  long count = 0;\n  if (n == 1) {\n    return 10;\n  }\n  long *start\
    \ = new long[n];\n  long *end = new long[n];\n  start[0] = 1;\n  end[0] = 10;\n\
    \  for (long i = 1; i < n; i++) {\n    start[i] = start[i - 1] * 9;\n    end[i]\
    \ = end[i - 1] * 10;\n  }\n  for (long i = 0; i < n; i++) {\n    count += start[i]\
    \ + end[i];\n  }\n  delete[] start;\n  delete[] end;\n  return count;", "    //\
    \ We are supposed to find all n-digit numbers that start or end with 1\n    //\
    \ We can break them into three groups\n    // 1. Numbers whose first digit is\
    \ 1 and all other digits are not 1\n    // 2. Numbers whose last digit is 1 and\
    \ all other digits are not 1\n    // 3. Numbers whose first and last digit are\
    \ 1 and all other digits are\n    // not 1\n    // For the first case, there are\
    \ 10 choices of first digit and 9 choices\n    // of other digits.\n    // For\
    \ the second case, there are 10 choices of last digit and 9 choices\n    // of\
    \ other digits.\n    // For the third case, there are 10 choices of first digit,\
    \ 8 choices of\n    // second digit, 10 choices of last digit.\n    // So the\
    \ number is 9 * (9 ^ (n - 2)) + 9 * (9 ^ (n - 2)) + 10 * 9 * 8\n    // We use\
    \ long long to store the result because we don't know the return\n    // type\
    \ of ^ operator.\n    return 9 * (long long)pow(9, n - 2) + 9 * (long long)pow(9,\
    \ n - 2) +\n           10 * 9 * 8;", "  long long array[n + 1];\n  array[0] =\
    \ 0;\n  array[1] = 1;\n  array[2] = 1;\n  array[3] = 1;\n  for (long i = 4; i\
    \ <= n; i++) {\n    array[i] = array[i - 1] + array[i - 2];\n  }\n  return array[n];",
  "    assert(n > 0);\n    if (n == 1) return 10;\n    long t = 10;\n    // (l+1)-digit\
    \ numbers that start with 1\n    long l = 1;\n    long ans = 10;\n    while (l\
    \ < n) {\n        t *= 10;\n        l++;\n        ans += 9 * t;\n    }\n    return\
    \ ans;", "  // vectors to hold the answers for n-1, n-2 and n-3\n  std::vector<long>\
    \ a(n);\n  std::vector<long> b(n);\n  std::vector<long> c(n);\n  // seed the initial\
    \ values\n  a[0] = 1;\n  b[0] = 1;\n  c[0] = 1;\n  for (long i = 1; i < n; i++)\
    \ {\n    a[i] = b[i - 1] + c[i - 1];\n    b[i] = a[i - 1];\n    c[i] = a[i - 1]\
    \ + b[i - 1];\n  }\n  // answer is a[n - 1] + b[n - 1] + c[n - 1]\n  return a[n\
    \ - 1] + b[n - 1] + c[n - 1];", "  // Write your code here\n  // use recursion\
    \ to solve this problem\n  if (n == 1) {\n    return 2;\n  }\n  return 9 * (starts_one_ends(n\
    \ - 1));", "    long count = 0;\n    if (n == 1) {\n        return 2;\n    } else\
    \ if (n == 2) {\n        return 3;\n    } else {\n        count = starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2);\n    }\n    return count;", "  // 2^n - 2\n \
    \ // 2^n - 2^(n-1)\n  long ans = pow(2, n) - pow(2, n-1);\n  return ans;", " \
    \   if (n == 1) {\n        return 1;\n    } else if (n == 2) {\n        return\
    \ 10;\n    } else {\n        long count = 10;\n        for (long i = 3; i <= n;\
    \ i++) {\n            count += 9 * pow(10, i - 2);\n        }\n        return\
    \ count;\n    }", "  if (n == 1) {\n    return 2;\n  }\n  return (9 * (std::pow(10,\
    \ n - 1) - std::pow(9, n - 1)));", "  long dp[n + 1];\n  dp[0] = 1;\n  dp[1] =\
    \ 1;\n  for (long i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n\
    \  }\n  return dp[n];", "    if (n < 2) return 0;\n    std::vector<long> counts(n,\
    \ 0);\n    counts[0] = 0;\n    counts[1] = 10;\n    for (long i = 2; i < n; ++i)\
    \ {\n        counts[i] = 10 * counts[i - 1] - counts[i - 2];\n    }\n    return\
    \ counts[n - 1];", "  if (n == 1) {\n    return 10;\n  }\n  long digits = 1;\n\
    \  long num = 10;\n  long ans = 0;\n  long pre = 10;\n  while (digits < n) {\n\
    \    ans += num;\n    pre = num;\n    num = 9 * pre + pre;\n    digits++;\n  }\n\
    \  return ans;", "  if (n == 1) {\n    return 2;\n  }\n  if (n == 2) {\n    return\
    \ 2;\n  }\n  long s = 1, e = 1;\n  for (int i = 3; i <= n; i++) {\n    long a\
    \ = s + e;\n    long b = e;\n    s = a;\n    e = b;\n  }\n  return s + e;", " \
    \   long dp[n+1];\n    dp[0] = 0;\n    dp[1] = 1;\n    for(long i = 2; i <= n;\
    \ i++) {\n        dp[i] = 9*dp[i-1] + pow(10, i-1);\n    }\n    return dp[n];",
  "    long dp[n][10];\n    // printf(\"%ld\\n\", dp[2][2]);\n    for (long i = 0;\
    \ i < n; i++) {\n        for (long j = 0; j < 10; j++) {\n            dp[i][j]\
    \ = 0;\n        }\n    }\n    dp[0][1] = 1;\n    dp[0][2] = 1;\n    dp[0][3] =\
    \ 1;\n    dp[0][4] = 1;\n    dp[0][5] = 1;\n    dp[0][6] = 1;\n    dp[0][7] =\
    \ 1;\n    dp[0][8] = 1;\n    dp[0][9] = 1;\n    for (long i = 1; i < n; i++) {\n\
    \        for (long j = 0; j < 10; j++) {\n            if (j == 0) {\n        \
    \        dp[i][j] = dp[i - 1][j + 1];\n            } else if (j == 9) {\n    \
    \            dp[i][j] = dp[i - 1][j - 1];\n            } else {\n            \
    \    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];\n            }\n        }\n\
    \    }\n    long ans = 0;\n    for (long i = 0; i < 10; i++) {\n        ans +=\
    \ dp[n - 1][i];\n    }\n    return ans;", "  if (n < 1) return 0;\n  if (n ==\
    \ 1) return 1;\n  if (n == 2) return 10;\n  long count = 9;\n  for (long i = 0;\
    \ i < n - 2; i++) {\n    count *= 9;\n  }\n  count *= 10;\n  return count;", " \
    \   if (n == 1) {\n        return 2;\n    }\n    if (n == 2) {\n        return\
    \ 4;\n    }\n    long *dp = new long[n + 1];\n    dp[0] = 0;\n    dp[1] = 2;\n\
    \    dp[2] = 4;\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1]\
    \ + dp[i - 2];\n    }\n    return dp[n];", "  std::cout << n << std::endl;\n \
    \ std::string str = std::to_string(n);\n  long count = 0;\n  for (size_t i = 0;\
    \ i < str.size(); i++) {\n    if (str[i] == '1') {\n      count++;\n    }\n  }\n\
    \  return count;", "  if (n == 1) {\n    return 1;\n  }\n  if (n < 10) {\n   \
    \ return 0;\n  }\n  long answer = 0;\n  if (n % 2 == 0) {\n    long count_ten\
    \ = 2 * std::pow(10, n / 2 - 1);\n    answer += count_ten + starts_one_ends(n\
    \ - 1);\n  } else {\n    long count_ten = std::pow(10, n / 2);\n    answer +=\
    \ count_ten + starts_one_ends(n - 1);\n  }\n  return answer;", "  long result\
    \ = 0;\n  long pow10 = 1;\n  long power = 1;\n  while (pow10 <= n) {\n    if (n/pow10\
    \ >= 1) {\n      result += pow10;\n    }\n    pow10 *= 10;\n    power++;\n  }\n\
    \  return result;", "    long cnt = 0;\n    for (long i = 1; i <= n; i++) {\n\
    \        long temp = i;\n        bool has_one = false;\n        while (temp >\
    \ 0) {\n            if (temp % 10 == 1) {\n                has_one = true;\n \
    \               break;\n            }\n            temp /= 10;\n        }\n  \
    \      if (has_one) {\n            cnt++;\n        }\n    }\n    return cnt;",
  "  // Base case\n  if (n == 1) {\n    return 1;\n  }\n\n  // If n is even, the number\
    \ of integers which start with 1 and end with 1\n  // will be equal to the number\
    \ of integers with n-1 digits.\n  if (n % 2 == 0) {\n    return pow(10, n / 2)\
    \ - 1;\n  }\n\n  // If n is odd, the number of integers which start with 1 and\
    \ end with 1\n  // will be equal to the number of integers with n-1 digits plus\
    \ 9\n  // additional possibilities.\n  else {\n    return pow(10, (n - 1) / 2)\
    \ - 1 + 9;\n  }", "  assert(n > 0);\n  if (n == 1) return 1;\n  if (n == 2) return\
    \ 10;\n  if (n == 3) return 19;\n  long *a = new long[n];\n  long *b = new long[n];\n\
    \  a[0] = 1;\n  b[0] = 9;\n  a[1] = 10;\n  b[1] = 90;\n  for (long i = 2; i <\
    \ n; i++) {\n    a[i] = b[i - 1] + a[i - 1];\n    b[i] = (b[i - 1] + a[i - 1])\
    \ * 9;\n  }\n  return a[n - 1] + b[n - 1];", "    std::vector<long> dp(n + 1,\
    \ 0);\n    dp[1] = 10;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = (9\
    \ * pow(10, i - 1)) + dp[i - 1];\n    }\n    return dp[n];", '  return n * (n
    + 1) / 2;', "  std::vector<long> dp(n + 1, 0);\n  dp[1] = 1;\n  if (n < 2) return\
    \ 1;\n  dp[2] = 2;\n  if (n < 3) return 2;\n  dp[3] = 3;\n  if (n < 4) return\
    \ 3;\n  for (long i = 4; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n\
    \  }\n  return dp[n];", "    assert(n > 0);\n    if (n == 1) return 1;\n    else\
    \ if (n == 2) return 10;\n    else {\n        long count = starts_one_ends(n -\
    \ 1) + 9 * std::pow(10, n - 2);\n        return count;\n    }", "  // The number\
    \ of n-digit numbers that start or end with 1\n  // is the sum of the number of\
    \ n-digit numbers that start or end with 1\n  // and the number of n-digit numbers\
    \ that do not start with 1.\n  long sum = 1;\n  // We use a sliding window to\
    \ generate the next digit-length numbers\n  // that start with 1.\n  // A number\
    \ can start with 1 followed by any n-1 digits\n  // i.e. 10, 11, 12, ..., 1(n-1)\
    \ digits.\n  // A number can end with 1 followed by any n-1 digits\n  // i.e.\
    \ 10, 11, 12, ..., 1(n-1) digits.\n  for (int i = 1; i < n; ++i) {\n    sum +=\
    \ (9 * std::pow(10, i - 1));\n  }\n  return sum;", "  if (n == 1) {\n    return\
    \ 10;\n  }\n  long t = starts_one_ends(n - 1);\n  long tmp = std::pow(10, n -\
    \ 1);\n  long ans = 9 * t;\n  ans += tmp;\n  return ans;", "  std::vector<long>\
    \ dp(n+1, 1);\n  for (long i = 1; i < n; ++i) {\n    for (long j = 1; j <= i;\
    \ ++j) {\n      dp[i] += dp[j-1] * std::pow(10, (i-j));\n    }\n  }\n  return\
    \ dp[n-1];", "    long count = 0;\n    if (n == 1) {\n        return 2;\n    }\n\
    \    long arr[n];\n    arr[0] = 2;\n    arr[1] = 3;\n    count = 2;\n    for (long\
    \ i = 2; i < n; i++) {\n        arr[i] = arr[i - 1] + arr[i - 2];\n        count\
    \ += arr[i];\n    }\n    return count;", "    long n_dp[n];\n    n_dp[0] = 1;\n\
    \    n_dp[1] = 2;\n    for (long i = 2; i < n; i++) {\n        n_dp[i] = n_dp[i\
    \ - 1] + n_dp[i - 2];\n    }\n    return n_dp[n - 1];", "    if (n <= 1) return\
    \ 0;\n    if (n == 2) return 1;\n    if (n == 3) return 2;\n    long dp[n+1];\n\
    \    memset(dp, 0, sizeof(dp));\n    dp[1] = 0;\n    dp[2] = 1;\n    dp[3] = 2;\n\
    \    for (long i = 4; i <= n; i++) {\n        // Count of numbers starting with\
    \ 0s.\n        long count_zero = 10*dp[i-1];\n        // Count of numbers starting\
    \ with 1s.\n        long count_one = 9*dp[i-1];\n        dp[i] = count_zero +\
    \ count_one;\n    }\n    return dp[n];", "    long ret = 0;\n    for (int i =\
    \ 1; i <= n; i++) {\n        long rem = 1;\n        for (int j = 1; j < i; j++)\
    \ {\n            rem *= 10;\n        }\n        ret += 9 * rem;\n    }\n    return\
    \ ret;", "    long count = 0;\n    // Count the number of numbers of n-digit positive\
    \ integers that ends with 1\n    for (long i = 0; i < n - 1; i++) {\n        count\
    \ += std::pow(10, i);\n    }\n    // Count the number of numbers of n-digit positive\
    \ integers that starts with 1\n    count += std::pow(10, n - 1);\n    return count;",
  "    if (n == 1) return 2;\n    if (n == 2) return 3;\n    long *dp = new long[n\
    \ + 1];\n    memset(dp, 0, (n + 1) * sizeof(long));\n    dp[1] = 2;\n    dp[2]\
    \ = 3;\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i\
    \ - 2];\n    }\n    long res = dp[n];\n    delete[] dp;\n    return res;", " \
    \   if (n == 1) return 10;\n    if (n == 2) return 55;\n    long m = n / 2;\n\
    \    long p = 1;\n    long c = 9;\n    while (m--) {\n        p *= 10;\n     \
    \   c *= 10;\n    }\n    if (n % 2 == 0) {\n        c /= 10;\n    }\n    return\
    \ c * p;", "  long dp[n + 1][2];\n  memset(dp, 0, sizeof(dp));\n  dp[1][0] = 0;\n\
    \  dp[1][1] = 1;\n  for (long i = 2; i <= n; i++) {\n    dp[i][0] = dp[i - 1][0]\
    \ + dp[i - 1][1];\n    dp[i][1] = dp[i - 1][0];\n  }\n  return dp[n][0] + dp[n][1];",
  "  if (n < 1) return 0;\n  if (n == 1) return 1;\n  return (long)(9*pow(10, n-1)-1);",
  "    if (n == 1) {\n        return 10;\n    } else if (n == 2) {\n        return\
    \ 19;\n    } else {\n        return (9 * pow(10, n - 2) + 9 * pow(10, n - 3));\n\
    \    }", "    long dp[n+1];\n    dp[0] = 0;\n    dp[1] = 1;\n    for(long i =\
    \ 2; i <= n; i++) {\n        dp[i] = 9*dp[i-1] + (i-1)*(int)pow(10, i-2);\n  \
    \  }\n    return dp[n];", "    long count = 1;\n    for (int i = 1; i < n; i++)\
    \ {\n        count *= 10;\n    }\n    return (long)n * 9 * count;", "    long\
    \ dp[n + 1];\n    std::memset(dp, 0, sizeof(dp));\n    dp[1] = 1;\n    for (long\
    \ i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] * 9 + std::pow(10, i - 1);\n\
    \    }\n    return dp[n];", "  if (n == 1) {\n    return 10;\n  } else if (n ==\
    \ 2) {\n    return 90;\n  } else {\n    // Every n-digit number has 2 ways of\
    \ ending, either 0 or 1.\n    return 9 * pow(10, n - 1) + starts_one_ends(n -\
    \ 1);\n  }", "    long dp[2][n + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][1]\
    \ = dp[1][1] = 1;\n    for (long i = 2; i <= n; i++) {\n        dp[0][i] = dp[0][i\
    \ - 1] + dp[1][i - 1];\n        dp[1][i] = dp[0][i - 1];\n    }\n    return dp[0][n]\
    \ + dp[1][n];", "  // F(n) = F(n-1) + F(n-2)\n  // F(1) = 2 , F(2) = 3\n  long\
    \ a = 2, b = 3, c;\n  long i;\n  if (n == 1)\n    return a;\n  if (n == 2)\n \
    \   return b;\n  for (i = 2; i < n; i++) {\n    c = a + b;\n    a = b;\n    b\
    \ = c;\n  }\n  return c;", "  if (n == 1) return 1;\n  long count = 10;\n  long\
    \ pow = 10;\n  for (long i = 2; i <= n; i++) {\n    pow *= 10;\n    count += pow;\n\
    \  }\n  return count;", "  std::vector<long> all_digits(n, 0);\n  for (long i\
    \ = 0; i < n; i++) {\n    if (i == 0) {\n      all_digits[i] = 9;\n    } else\
    \ {\n      all_digits[i] = (all_digits[i - 1] * 10) - pow(10, i - 1);\n    }\n\
    \  }\n  long sum = 0;\n  for (auto i : all_digits) {\n    sum += i;\n  }\n  return\
    \ sum * 2;", "    assert(n > 0);\n    // TODO: Implement this function yourself\n\
    \    long res = 1;\n    for (long i = 2; i <= n; i++) {\n        res *= 10;\n\
    \        res -= res / 9;\n    }\n    return res;", "  if (n < 2) {\n    return\
    \ n;\n  }\n  long last_digit = n % 10;\n  long remaining_digits = n / 10;\n  if\
    \ (last_digit == 0) {\n    return starts_one_ends(remaining_digits);\n  }\n  long\
    \ result = starts_one_ends(remaining_digits);\n  if (remaining_digits == 0) {\n\
    \    return result + 1;\n  }\n  return result + 9;", "    if (n == 1) return 1;\n\
    \    if (n == 2) return 2;\n    long result = starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2);\n    return result;", "    if (n == 1) return 1;\n    if (n == 2) return\
    \ 10;\n    if (n == 3) return 19;\n    if (n == 4) return 28;\n    return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2);", "  long dp[n + 1];\n  memset(dp, 0, sizeof(dp));\n\
    \  dp[1] = 10;\n  for (long i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] * 9 +\
    \ pow(10, i - 1);\n  }\n  return dp[n];", '  return std::pow(10, n - 1) + 9 *
    std::pow(10, n - 2);', "  long result = 0;\n  for (long i = 1; i <= n; i++) {\n\
    \    long n_digits = pow(10, i);\n    long first_digit = pow(10, i - 1);\n   \
    \ result += 9 * first_digit * (i - 1);\n    result += first_digit;\n  }\n  return\
    \ result;", "    if (n == 1) {\n        return 2;\n    } else if (n < 1) {\n \
    \       return 0;\n    } else {\n        // Consider the last digit.\n       \
    \ // Case 1: The last digit is 1.\n        // In this case, we have n-1 digits\
    \ to fill. So, there are\n        // (n-1) * (2 * (n-1)^(n-2)) options.\n    \
    \    // Case 2: The last digit is not 1.\n        // In this case, there are (n-1)^(n-1)\
    \ options.\n        return (n-1) * (2 * pow(n-1, n-2)) + pow(n-1, n-1);\n    }",
  "  // base case\n  if (n == 1) {\n    return 2;\n  }\n  long count = 0;\n  // if\
    \ we choose to start and end with 1, then the remaining digits\n  // can be anything\
    \ but 1 (this is what the minus 1 is for), so\n  // we have 10^(n-2) choices.\n\
    \  count += (long) pow(10, n - 2) - 1;\n  // next case is to start with 1, but\
    \ not end with 1, we have 10\n  // choices here.\n  count += 10 * starts_one_ends(n\
    \ - 1);\n  // the last case is to not start with 1, but end with 1, so we have\n\
    \  // 9 choices for the first digit, and then the rest of the digits\n  // can\
    \ be anything but 1\n  count += 9 * (long) pow(10, n - 2);\n  return count;",
  "    if (n == 1) {\n        return 2;\n    }\n    long max_num = std::pow(10, n);\n\
    \    long min_num = std::pow(10, n - 1);\n    long count = 0;\n    while (min_num\
    \ < max_num) {\n        long temp = min_num;\n        while (temp) {\n       \
    \     long rem = temp % 10;\n            if (rem == 1) {\n                count++;\n\
    \                break;\n            }\n            temp /= 10;\n        }\n \
    \       min_num++;\n    }\n    return count;", "    if (n == 1) {\n        return\
    \ 2;\n    }\n    if (n == 2) {\n        return 3;\n    }\n    long dp[n + 1] =\
    \ {0};\n    dp[1] = 2;\n    dp[2] = 3;\n    for (long i = 3; i <= n; i++) {\n\
    \        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];", "  long dp[n\
    \ + 1];\n  memset(dp, 0, sizeof(dp));\n  dp[1] = 10;\n  dp[2] = 100;\n  for (long\
    \ i = 3; i <= n; i++) {\n    dp[i] = 10 * dp[i - 1] - pow(10, i - 2);\n  }\n \
    \ return dp[n];", "  long sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum +=\
    \ (long) pow(10, i);\n  }\n  return sum;", "  long a[n + 1], b[n + 1];\n  a[0]\
    \ = 1;\n  b[0] = 1;\n  for (long i = 1; i <= n; i++) {\n    a[i] = a[i - 1] +\
    \ b[i - 1];\n    b[i] = a[i - 1];\n  }\n  return a[n] + b[n];", "  long count_zero\
    \ = 0;\n  long count_one = 0;\n  for (long i = 1; i <= n; i++) {\n    if (i ==\
    \ 1) {\n      count_one = 1;\n      count_zero = 1;\n    } else {\n      count_one\
    \ = count_one + count_zero;\n      count_zero = count_one + count_zero;\n    }\n\
    \  }\n  return count_one;", "    long count = 0;\n    long zero_count = 0;\n \
    \   for (long i = 1; i <= n; i++) {\n        zero_count += log10(i);\n    }\n\
    \    count = pow(10, zero_count);\n    return count;", "  if (n == 1) {\n    return\
    \ 2;\n  }\n  long output = (9 * pow(10, n - 1)) - (pow(10, n - 1) - 1);\n  return\
    \ output;", "    if (n == 1) {\n        return 2;\n    } else if (n == 2) {\n\
    \        return 4;\n    } else {\n        return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2);\n    }", "  assert(n >= 1);\n  assert(n <= 16);\n  // Base case\n  if\
    \ (n == 1) {\n    return 1;\n  }\n  // Recursive case\n  return starts_one_ends(n\
    \ - 1) + 1 + 9 * std::pow(10, n - 2);", "  // DP[i] stores the count of n-digit\
    \ integers ending with 1 where n = i\n  long DP[n+1];\n  DP[1] = 1;\n  long pow\
    \ = 1;\n  for (long i = 2; i <= n; i++) {\n    pow *= 10;\n    DP[i] = pow + 9*std::accumulate(DP,\
    \ DP+i, 0L);\n  }\n  return std::accumulate(DP, DP+n+1, 0L);", "  if (n == 1)\
    \ return 1;\n  return (pow(10, n - 1) - 1) + starts_one_ends(n - 1);", "  long\
    \ dp[n + 1];\n  std::memset(dp, 0, sizeof(dp));\n  dp[1] = 1;\n  for (int i =\
    \ 2; i <= n; i++) {\n    dp[i] = (10 * dp[i - 1]) % 1000000007;\n  }\n  return\
    \ dp[n];", '    return (n * (n + 1)) / 2;', "  if (n == 1) return 2;\n  long dp[n+1];\n\
    \  dp[0] = 0;\n  dp[1] = 2;\n  for (long i = 2; i <= n; i++) {\n    dp[i] = (dp[i-1]\
    \ + dp[i-2]);\n  }\n  return dp[n];", "    // Code goes here.\n    // convert\
    \ it to binary number\n    std::vector<long> v;\n    long num = n;\n    while\
    \ (num > 0) {\n        long reminder = num % 2;\n        v.push_back(reminder);\n\
    \        num = num / 2;\n    }\n    std::reverse(v.begin(), v.end());\n    long\
    \ count = 0;\n    bool start = false;\n    bool end = false;\n    for (int i =\
    \ 0; i < v.size(); i++) {\n        if (v[i] == 1) {\n            if (i == 0) {\n\
    \                start = true;\n            }\n            if (i == v.size() -\
    \ 1) {\n                end = true;\n            }\n            count++;\n   \
    \     }\n    }\n    if (start && end) {\n        return (1 << count) - 1;\n  \
    \  } else if (start) {\n        return (1 << count) - 2;\n    } else if (end)\
    \ {\n        return (1 << count) - 1;\n    } else {\n        return (1 << count)\
    \ - 2;\n    }", "  long sum = 0;\n  for (long i = 0; i < n; i++) {\n    sum +=\
    \ (i+1) * 9 * pow(10, i);\n  }\n  return sum;", "    if (n < 2) return 1;\n  \
    \  long base = 10;\n    long base_n = 10;\n    long answer = 2;\n    for (long\
    \ i = 2; i < n; ++i) {\n        base_n *= base;\n        answer += 2 * base_n\
    \ - base;\n    }\n    return answer;", "    if (n < 1) return 0;\n    if (n <\
    \ 3) return 2;\n    long len = n/2;\n    std::vector<long> a;\n    long prev =\
    \ 1;\n    for (long i = 0; i < len; ++i) {\n        long this_len = 10*prev;\n\
    \        a.push_back(this_len);\n        prev = this_len;\n    }\n    long ans\
    \ = prev;\n    for (long i = 0; i < len; ++i) {\n        ans += a[i];\n    }\n\
    \    ans += n&1 ? ans : ans-1;\n    return ans;", "    long num = n - 1;\n   \
    \ long last_term = 1;\n    long first_term = 1;\n    long sum_first_last = 2;\n\
    \    for (long i = 1; i < n; i++) {\n        last_term = (last_term * 10) % 1000000007;\n\
    \        first_term = (first_term * 9) % 1000000007;\n        sum_first_last =\
    \ (sum_first_last * 10) % 1000000007;\n    }\n    long ans = ((num * sum_first_last)\
    \ % 1000000007 + first_term + last_term) % 1000000007;\n    return ans;", "  \
    \  long dp[2][2][n+1];\n    // dp[i][j][k] = no. of k digit positive integers,\
    \ of which i digits are\n    // occupied and the integer ends with j.\n    //\
    \ i = 0 means no digits are occupied.\n    // i = 1 means 1 digit is occupied.\n\
    \    // j = 0 means the number does not end with 1.\n    // j = 1 means the number\
    \ ends with 1.\n    // initially all the arrays are 0.\n    for(long i = 0; i\
    \ < 2; i++) {\n        for(long j = 0; j < 2; j++) {\n            for(long k =\
    \ 0; k <= n; k++) {\n                dp[i][j][k] = 0;\n            }\n       \
    \ }\n    }\n    // fill the first column.\n    // i = 0;\n    dp[0][0][0] = 1;\n\
    \    // i = 1;\n    dp[1][0][1] = 1;\n    dp[1][1][1] = 1;\n    for(long i = 0;\
    \ i < 2; i++) {\n        for(long j = 0; j < 2; j++) {\n            for(long k\
    \ = 1; k <= n; k++) {\n                if(i == 0 && j == 0) continue;\n      \
    \          if(i == 1 && j == 1) continue;\n                if(i == 0) {\n    \
    \                dp[i][j][k] = dp[i][0][k-1] + dp[i][1][k-1];\n              \
    \  } else {\n                    if(j == 0) {\n                        dp[i][j][k]\
    \ = dp[i-1][j][k-1] + dp[i-1][1][k-1];\n                    } else {\n       \
    \                 dp[i][j][k] = dp[i-1][j][k-1] + dp[i-1][0][k-1];\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ dp[1][0][n] + dp[1][1][n];", "    if (n == 1) {\n        return 2;\n    }\n\
    \    long x = 10;\n    for (long i = 2; i < n; i++) {\n        x *= 10;\n    }\n\
    \    return (x - 1)*2;", "  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n\
    \    return 1;\n  }\n  // use dynamic programming\n  long dp[n + 1];\n  dp[0]\
    \ = 0;\n  dp[1] = 1;\n  dp[2] = 10;\n  for (long i = 3; i <= n; i++) {\n    dp[i]\
    \ = 9 + dp[i - 1];\n  }\n  return dp[n];", "    long dp[n][2];\n    dp[0][0] =\
    \ 0;\n    dp[0][1] = 1;\n    for (long i = 1; i < n; i++) {\n        dp[i][0]\
    \ = (dp[i - 1][0] * 10) + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0] + dp[i\
    \ - 1][1];\n    }\n    return dp[n - 1][0] + dp[n - 1][1];", "  if (n <= 1) {\n\
    \    return 1;\n  }\n  long sum = 1;\n  for (int i = 2; i <= n; i++) {\n    sum\
    \ += 9 * sum;\n  }\n  return sum;", "    if (n == 1) {\n        return 2;\n  \
    \  } else if (n == 2) {\n        return 3;\n    } else {\n        return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2);\n    }", "    if (n == 1) return 1;\n    if (n\
    \ == 2) return 2;\n    long dp[n][10];\n    memset(dp, 0, sizeof(dp));\n    for\
    \ (int i = 0; i < 10; i++) dp[0][i] = 1;\n    for (int i = 1; i < n; i++) {\n\
    \        dp[i][0] = dp[i-1][1];\n        for (int j = 1; j < 9; j++) {\n     \
    \       dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1];\n        }\n        dp[i][9] =\
    \ dp[i-1][8];\n    }\n    long result = 0;\n    for (int i = 0; i < 10; i++) {\n\
    \        result += dp[n-1][i];\n    }\n    return result;", "  if (n == 1) return\
    \ 2;\n  long prev = 2;\n  long prev_prev = 1;\n  long curr = 3;\n  long sum =\
    \ 0;\n  for (long i = 2; i < n; i++) {\n    sum = prev + prev_prev;\n    prev_prev\
    \ = prev;\n    prev = sum;\n  }\n  return (sum * 2) + (prev_prev * 2);", "   \
    \ // TODO: implement this function\n    if(n <= 1)\n        return 1;\n    if(n\
    \ == 2)\n        return 10;\n    long N = 10;\n    long max = std::pow(10, n);\n\
    \    long count = 1;\n    for(long i = 1; i < n; i++) {\n        count *= 9;\n\
    \        N += count;\n    }\n    return N;", "    if (n == 1) {\n        return\
    \ 2;\n    } else if (n == 2) {\n        return 3;\n    } else {\n        return\
    \ starts_one_ends(n - 1) + starts_one_ends(n - 2);\n    }", "    if (n == 1) return\
    \ 1;\n    long ans = 9;\n    for (long i = 1; i < n - 1; i++)\n        ans *=\
    \ 10;\n    return ans;", "    long a = 9, b = 0, c = 9;\n    long sum = 0;\n \
    \   // dynamic programming like approach.\n    // for this problem we use 2 states,\n\
    \    // state 1: dp[i][0] = no. of n-digit number starting with 1.\n    // state\
    \ 2: dp[i][1] = no. of n-digit number ending with 1.\n    // For i = 1,\n    //\
    \ dp[1][0] = 9\n    // dp[1][1] = 0\n    // For i = 2,\n    // dp[2][0] = 9*9\
    \ + 1*9\n    // dp[2][1] = 9\n    // For i = 3,\n    // dp[3][0] = 9*9*9 + 9*1*9\
    \ + 9*9*1\n    // dp[3][1] = 9*9 + 9*1\n    // For i = n,\n    // dp[n][0] = 9*9*9...9*9\
    \ + 9*1*9...9*9 + ... + 9*9*9...9*1\n    // dp[n][1] = 9*9*9...9*9 + 9*1*9...9*9\
    \ + ... + 9*9*9...9*1\n    for (long i = 1; i <= n; i++) {\n        if (i == 1)\
    \ {\n            // since no. of digits is 1, that one digit must be 1.\n    \
    \        sum += 1;\n        } else {\n            a = 9;\n            b = 0;\n\
    \            c = 9;\n            // n-digit number starting with 1.\n        \
    \    // 1*9*9...9*9 + 1*1*9...9*9 + ... + 1*9*9...9*1\n            sum += a *\
    \ pow(c, i - 2) + a * pow(c, i - 2) + b * pow(c, i - 2);\n            // n-digit\
    \ number ending with 1.\n            // 9*9*9...9*1 + 9*1*9...9*1 + ... + 9*9*9...1*1\n\
    \            sum += a * pow", "  assert(n >= 1);\n  if (n == 1) {\n    return\
    \ 2;\n  }\n  if (n == 2) {\n    return 10;\n  }\n  long count = starts_one_ends(n\
    \ - 1) + 9 * (long)pow(10, n - 2);\n  return count;", "  assert(n > 0);\n  long\
    \ i, j, count = 0;\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= 9; j++)\
    \ {\n      if (i == 1)\n        count++;\n      else if (i == n)\n        count++;\n\
    \      else\n        count += pow(9, i - 2);\n    }\n  }\n  return count;", " \
    \ long result = 0;\n  // We first count for the number of numbers that start with\
    \ 1 and end with 1\n  // i.e. 11 ... 11 (n digits)\n  // For this we have (n-1)\
    \ options for the numbers between 11 and 11\n  result += pow(9, n - 1);\n  //\
    \ We then count for the number of numbers that start with 1 and end with 2\n \
    \ // i.e. 11 ... 12 (n digits)\n  // For this we have (n-1) options for the numbers\
    \ between 11 and 12\n  result += pow(9, n - 1);\n  // Similarly we have these\
    \ numbers starting with 1 and ending with 3, 4, ...,\n  // 9 respectively. So\
    \ all in all we have 8 * pow(9, n - 1) more numbers.\n  result += 8 * pow(9, n\
    \ - 1);\n  // In the same way, we have the numbers that start with 2, 3, ...,\
    \ 9 and end\n  // with 1. We have 8 * pow(9, n - 1) more numbers.\n  result +=\
    \ 8 * pow(9, n - 1);\n  // So, we have (17 * 8 * pow(9, n - 1)) more numbers.\n\
    \  result += 17 * 8 * pow(9, n - 1);\n  return result;", "  assert(n > 0);\n \
    \ // 1-9 is the basis case, and there are 9 of them\n  if (n == 1) {\n    return\
    \ 9;\n  }\n  if (n == 2) {\n    return 180;\n  }\n  // If n > 2, then a number\
    \ can start with 1, or end with 1\n  // An n-digit number starting with 1 is all\
    \ numbers from 10 to 10^(n-1)\n  // which is n-1 places for the rest of the digits\n\
    \  // An n-digit number ending with 1 is all numbers from 1 to 9, with\n  // n-1\
    \ places for the other digits\n  long start = starts_one_ends(n - 1);\n  long\
    \ end = starts_one_ends(n - 2);\n  return start + end;", "  long result = 1;\n\
    \  if (n > 1) {\n    result = (std::pow(10, n - 1) + std::pow(10, n - 2)) % 1000000007;\n\
    \  }\n  return result;", "  assert(n > 0);\n  std::queue<std::string> to_expand;\n\
    \  to_expand.push(\"1\");\n  long count = 0;\n  while (!to_expand.empty()) {\n\
    \    std::string curr = to_expand.front();\n    to_expand.pop();\n    if (curr.size()\
    \ == n) {\n      if (curr[0] == '1' || curr[curr.size() - 1] == '1') {\n     \
    \   ++count;\n      }\n    } else {\n      to_expand.push(curr + \"0\");\n   \
    \   to_expand.push(curr + \"1\");\n    }\n  }\n  return count;", "  if (n == 1)\
    \ {\n    return 10;\n  }\n  long dp[n + 1];\n  memset(dp, 0, sizeof(dp));\n  dp[1]\
    \ = 10;\n  for (long i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] * 9 + pow(10,\
    \ i - 1);\n  }\n  return dp[n];", "  long count = 0;\n  for (int i = 1; i <= 9;\
    \ i++) {\n    count = count + pow(9, n - 1);\n  }\n  return count;", "    long\
    \ *F = new long[n+1];\n    F[0] = 0;\n    F[1] = 1;\n    for(long i = 2; i <=\
    \ n; i++) {\n        F[i] = (10*F[i-1]) - F[i-2];\n    }\n    long result = F[n];\n\
    \    delete [] F;\n    return result;", "    long *dp = new long[n + 1];\n   \
    \ dp[0] = 0;\n    dp[1] = 1;\n    for (long i = 2; i <= n; i++) {\n        dp[i]\
    \ = 2 * dp[i - 1] + pow(10, i - 1);\n    }\n    return dp[n];", "    // f(4) =\
    \ 4 * f(3) + 3 * f(2)\n    // f(3) = 3 * f(2) + 2 * f(1)\n    // f(2) = 2 * f(1)\
    \ + 1 * f(0)\n    // f(1) = 1 * f(0)\n    // f(0) = 1\n    if (n < 2) {\n    \
    \    return n;\n    }\n    long num_ending_in_1 = 1;\n    long num_ending_in_others\
    \ = 1;\n    for (long i = 2; i <= n; i++) {\n        long num_ending_in_1_till_i\
    \ = (i - 1) * num_ending_in_others +\n                                      (i\
    \ - 1) * num_ending_in_1;\n        long num_ending_in_others_till_i = num_ending_in_1;\n\
    \        num_ending_in_1 = num_ending_in_1_till_i;\n        num_ending_in_others\
    \ = num_ending_in_others_till_i;\n    }\n    return num_ending_in_1 + num_ending_in_others;",
  "  if (n == 1) {\n    return 2;\n  } else if (n == 2) {\n    return 3;\n  } else\
    \ {\n    long dp[n + 1];\n    dp[0] = 1;\n    dp[1] = 2;\n    dp[2] = 3;\n   \
    \ for (long i = 3; i <= n; i++) {\n      dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\
    \    return dp[n] * 2 - 2;\n  }", "  if (n == 1) {\n    return 2;\n  } else if\
    \ (n == 2) {\n    return 6;\n  } else {\n    // f(n) = 2 * f(n-1) + 2 * f(n-2)\n\
    \    long long a = 2, b = 6, i = 3;\n    while (i <= n) {\n      long long temp\
    \ = 2 * b + 2 * a;\n      a = b;\n      b = temp;\n      i++;\n    }\n    return\
    \ b;\n  }", "    assert(n > 0);\n    if (n == 1) return 1;\n    long cnt = 0;\n\
    \    for (long i = 1; i < n; i++) {\n        cnt += pow(10, i - 1);\n    }\n \
    \   return cnt * 2;", "  long dp[n + 1];\n  dp[0] = 0;\n  dp[1] = 1;\n  for (long\
    \ i = 2; i <= n; i++) {\n    if (i == 2) {\n      dp[i] = 2;\n    } else {\n \
    \     dp[i] = dp[i - 1] + dp[i - 2];\n    }\n  }\n  return dp[n];", '    return
    9 * std::pow(10, n - 1);', "  if (n == 1) {\n    return 2;\n  }\n  if (n == 2)\
    \ {\n    return 5;\n  }\n  long count = 0;\n  for (long i = 0; i < n - 1; i++)\
    \ {\n    count += starts_one_ends(i);\n  }\n  count *= 2;\n  long count2 = 0;\n\
    \  for (long i = 0; i < n - 2; i++) {\n    count2 += starts_one_ends(i);\n  }\n\
    \  count += count2 * 2;\n  count += 9;\n  return count;", "    assert(n > 0);\n\
    \    // The solution is the sum of the binomial coefficients:\n    //\n    //\
    \ C(n-1,k) = n!/((n-k)!k!)\n    //\n    // as k goes from 0 to n-1. The reason\
    \ is that C(n-1,k) is the number of\n    // ways to choose k digits from n-1 that\
    \ are not the first digit of the\n    // positive number.\n    //\n    // The\
    \ bionomial coefficient can be calculated as the product of\n    //\n    //  \
    \ n(n-1)...(n-k+1)/k!\n    //\n    // and\n    //\n    //   (n-k)(n-k-1)...n-2\n\
    \    //\n    // For example, for n=5 and k=2, we can choose a 2 digit prefix from\n\
    \    // 4 digits, and then choose a 3 digit prefix from 3 digits. This gives us\n\
    \    // 4 * 3 * 2 * 1 * 3 * 2 * 1 = 144.\n    //\n    // Then we can choose a\
    \ 2 digit suffix from 4 digits, and then choose a 3\n    // digit suffix from\
    \ 3 digits. So this gives us another 144.\n    //\n    // So the total ways to\
    \ choose k digits are 2 * C(n-1,k).\n    //\n    // Now we have to add the ways\
    \ to choose a 1 digit number. This is just n,\n    // since this is just the same\
    \ as the number of ways to choose a 0 digit\n    // number.\n    //\n    // Since\
    \ the total number of ways is the sum of the binomial coefficients,\n    // and\
    \ there are 2 * C(n-1,k) ways to choose k digits, the total number of\n    //\
    \ ways is the sum of 2 * C(n-1,k) + n = (n+1)*2^(n-1)\n    //\n    // This is\
    \ O(1).\n\n    return (n+1)*pow(2,n-1);"]
stop_tokens:
- "\n}"
