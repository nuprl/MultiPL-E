name: HumanEval_148_bf
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in\
  \ our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus,\
  \ then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function\
  \ that takes two planet names as strings planet1 and planet2. \n// The function\
  \ should return a tuple containing all planets whose orbits are \n// located between\
  \ the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to\
  \ the sun. \n// The function should return an empty tuple if planet1 or planet2\n\
  // are not correct planet names. \n// Examples\n// bf(\"Jupiter\", \"Neptune\")\
  \ ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n\
  // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
  , \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1, std::string planet2)\
  \ {\n"
tests: "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
  ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
  Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
  Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
  Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
  Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
  Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
  Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
  Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
  }\n"
completions: ["\tstd::map<std::string, int> mp = {{\"Mercury\", 0}, {\"Venus\", 1},\
    \ \n\t{\"Earth\", 2}, {\"Mars\", 3}, {\"Jupiter\", 4}, {\"Saturn\", 5}, \n\t{\"\
    Uranus\", 6}, {\"Neptune\", 7}};\n\tif (mp.find(planet1) == mp.end() || mp.find(planet2)\
    \ == mp.end())\n\t\treturn std::make_tuple();\n\tint first = mp[planet1];\n\t\
    int second = mp[planet2];\n\tif (first > second)\n\t\tstd::swap(first, second);\n\
    \tstd::vector<std::string> vc = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string>\
    \ ans;\n\tfor (int i = first + 1; i < second; i++)\n\t\tans.push_back(vc[i]);\n\
    \treturn std::make_tuple(ans[0], ans[1], ans[2], ans[3], ans[4]);", "    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result{};\n    int index1\
    \ = -1;\n    int index2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n\
    \        if (planets[i] == planet1) {\n            index1 = i;\n        }\n  \
    \      if (planets[i] == planet2) {\n            index2 = i;\n        }\n    }\n\
    \    if (index1 > index2) {\n        index1 = index1 + index2;\n        index2\
    \ = index1 - index2;\n        index1 = index1 - index2;\n    }\n    if (index1\
    \ == -1 || index2 == -1) {\n        return {};\n    }\n    for (int i = index1\
    \ + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return\
    \ std::make_tuple(result[0], result[1], result[2], result[3], result[4]);", " \
    \ std::map<std::string, int> planets{ {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\"\
    , 3}, {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\"\
    , 8} };\n  std::tuple<std::string, > result;\n  if (planets.find(planet1) == planets.end()\
    \ || planets.find(planet2) == planets.end()) {\n    return result;\n  }\n  if\
    \ (planets[planet1] < planets[planet2]) {\n    for (int i = planets[planet1] +\
    \ 1; i < planets[planet2]; i++) {\n      for (auto &p : planets) {\n        if\
    \ (p.second == i) {\n          std::string s = p.first;\n          std::tuple<std::string,\
    \ > t(s);\n          result = std::tuple_cat(result, t);\n        }\n      }\n\
    \    }\n  } else {\n    for (int i = planets[planet2] + 1; i < planets[planet1];\
    \ i++) {\n      for (auto &p : planets) {\n        if (p.second == i) {\n    \
    \      std::string s = p.first;\n          std::tuple<std::string, > t(s);\n \
    \         result = std::tuple_cat(result, t);\n        }\n      }\n    }\n  }\n\
    \  return result;", "    // your code here\n    std::vector<std::string> planets;\n\
    \    planets.push_back(\"Mercury\");\n    planets.push_back(\"Venus\");\n    planets.push_back(\"\
    Earth\");\n    planets.push_back(\"Mars\");\n    planets.push_back(\"Jupiter\"\
    );\n    planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\");\n \
    \   planets.push_back(\"Neptune\");\n    int p1 = -1;\n    int p2 = -1;\n    for(int\
    \ i = 0; i < planets.size(); i++){\n        if(planets[i] == planet1){\n     \
    \       p1 = i;\n        }\n        if(planets[i] == planet2){\n            p2\
    \ = i;\n        }\n    }\n    if(p1 == -1 || p2 == -1){\n        return std::make_tuple();\n\
    \    }\n    std::vector<std::string> res;\n    int lower = std::min(p1, p2);\n\
    \    int upper = std::max(p1, p2);\n    for(int i = lower + 1; i < upper; i++){\n\
    \        res.push_back(planets[i]);\n    }\n    return std::make_tuple(res);",
  "  // Your Code\n  return {}", "    std::tuple<std::string, > bf;\n    if (planet1\
    \ == \"Mercury\") {\n        if (planet2 == \"Venus\") {\n            bf = std::make_tuple(\"\
    Venus\");\n        }\n        else if (planet2 == \"Earth\") {\n            bf\
    \ = std::make_tuple(\"Venus\", \"Earth\");\n        }\n        else if (planet2\
    \ == \"Mars\") {\n            bf = std::make_tuple(\"Venus\", \"Earth\", \"Mars\"\
    );\n        }\n        else if (planet2 == \"Jupiter\") {\n            bf = std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\");\n        }\n        else if (planet2\
    \ == \"Saturn\") {\n            bf = std::make_tuple(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\");\n        }\n        else if (planet2 == \"Uranus\"\
    ) {\n            bf = std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\");\n        }\n        else if (planet2 == \"Neptune\"\
    ) {\n            bf = std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n        }\n        else if (planet2 ==\
    \ \"Mercury\") {\n            bf = std::make_tuple();\n        }\n    }\n    else\
    \ if (planet1 == \"Venus\") {\n        if (planet2 == \"Mercury\") {\n       \
    \     bf = std::make_tuple();\n        }\n        else if (planet2 == \"Earth\"\
    ) {\n            bf = std::make_tuple(\"Earth\");\n        }\n        else if\
    \ (planet2 == \"Mars\") {\n            bf = std::make_tuple(\"Earth\", \"Mars\"\
    );\n        }\n        else if (planet2 == \"Jupiter\") {\n            bf = std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\");\n        }\n        else if (planet2 == \"Saturn\"\
    ) {\n            bf = std::make_tuple", '    // Your code here', '    return std::make_tuple("");',
  "    std::tuple<std::string, > answer = std::make_tuple();\n    // Write your code\
    \ here\n    return answer;", "    std::map<std::string, int> m;\n    m[\"Mercury\"\
    ] = 1;\n    m[\"Venus\"] = 2;\n    m[\"Earth\"] = 3;\n    m[\"Mars\"] = 4;\n \
    \   m[\"Jupiter\"] = 5;\n    m[\"Saturn\"] = 6;\n    m[\"Uranus\"] = 7;\n    m[\"\
    Neptune\"] = 8;\n    std::vector<std::string> v;\n    v.push_back(\"Mercury\"\
    );\n    v.push_back(\"Venus\");\n    v.push_back(\"Earth\");\n    v.push_back(\"\
    Mars\");\n    v.push_back(\"Jupiter\");\n    v.push_back(\"Saturn\");\n    v.push_back(\"\
    Uranus\");\n    v.push_back(\"Neptune\");\n    std::vector<std::string> res;\n\
    \    if (m.find(planet1) == m.end() || m.find(planet2) == m.end())\n        return\
    \ std::make_tuple();\n    else if (m[planet1] > m[planet2]) {\n        int i =\
    \ m[planet2];\n        while (i < m[planet1]) {\n            res.push_back(v[i\
    \ - 1]);\n            i++;\n        }\n    }\n    else {\n        int i = m[planet1];\n\
    \        while (i < m[planet2]) {\n            res.push_back(v[i - 1]);\n    \
    \        i++;\n        }\n    }\n    std::tuple<std::string, std::string, std::string,\
    \ std::string, std::string> t(res[0], res[1], res[2], res[3], res[4]);\n    return\
    \ t;", "    std::vector<std::string> planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n    // your code\
    \ here\n    return std::make_tuple();", "\t// variables to store the indices of\
    \ the planets\n\tint index1, index2;\n\tstd::vector<std::string> planets;\n\t\
    planets.push_back(\"Mercury\");\n\tplanets.push_back(\"Venus\");\n\tplanets.push_back(\"\
    Earth\");\n\tplanets.push_back(\"Mars\");\n\tplanets.push_back(\"Jupiter\");\n\
    \tplanets.push_back(\"Saturn\");\n\tplanets.push_back(\"Uranus\");\n\tplanets.push_back(\"\
    Neptune\");\n\t// find the indices of the two planets\n\tfor (int i = 0; i < planets.size();\
    \ i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i]\
    \ == planet2) {\n\t\t\tindex2 = i;\n\t\t}\n\t}\n\tif (index1 > index2) {\n\t\t\
    return std::make_tuple();\n\t}\n\tstd::tuple<std::string, std::string, std::string,\
    \ std::string, std::string, std::string> r_tuple;\n\tif (index1 + 1 == index2)\
    \ {\n\t\treturn std::make_tuple(planets[index1 + 1]);\n\t}\n\tif (index1 + 2 ==\
    \ index2) {\n\t\treturn std::make_tuple(planets[index1 + 1], planets[index1 +\
    \ 2]);\n\t}\n\tif (index1 + 3 == index2) {\n\t\treturn std::make_tuple(planets[index1\
    \ + 1], planets[index1 + 2], planets[index1 + 3]);\n\t}\n\tif (index1 + 4 == index2)\
    \ {\n\t\treturn std::make_tuple(planets[index1 + 1], planets[index1 + 2], planets[index1\
    \ + 3], planets[index1 + 4]);\n\t}\n\tif (index1 + 5 == index2) {\n\t\treturn\
    \ std::make_tuple(planets[index1 + 1], planets[index1 + 2], planets[index1 + 3],\
    \ planets[index1 + 4], planets", "    std::tuple<std::string, > ret;\n    //TODO:\n\
    \    return ret;", "\t// 0 Mercury\n\t// 1 Venus\n\t// 2 Earth\n\t// 3 Mars\n\t\
    // 4 Jupiter\n\t// 5 Saturn\n\t// 6 Uranus\n\t// 7 Neptune\n\tstd::string planet_array[8]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n\t// 0 Venus\n\t// 1 Earth\n\t// 2 Mars\n\t// 3 Jupiter\n\
    \t// 4 Saturn\n\t// 5 Uranus\n\t// 6 Neptune\n\tstd::string planet_array2[7] =\
    \ {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tint planet1_index = 0;\n\tint planet2_index = 0;\n\tfor (int i = 0; i <\
    \ 8; i++) {\n\t\tif (planet_array[i] == planet1) {\n\t\t\tplanet1_index = i;\n\
    \t\t}\n\t\tif (planet_array[i] == planet2) {\n\t\t\tplanet2_index = i;\n\t\t}\n\
    \t}\n\tstd::tuple<std::string, > planets_array;\n\tif (planet1_index == 0 && planet2_index\
    \ == 0) {\n\t\treturn planets_array;\n\t}\n\telse if (planet1_index == 0 && planet2_index\
    \ == 7) {\n\t\tstd::string planets_array[7] = {\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\treturn planets_array;\n\
    \t}\n\telse if (planet1_index == 1 && planet2_index == 1) {\n\t\tstd::string planets_array[0]\
    \ = {};\n\t\treturn planets_array;\n\t}\n\telse if (planet1_index == 1 && planet2_index\
    \ == 7) {\n\t\tstd::string planets_array[6] = {\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\treturn planets_array;\n\t}\n\telse\
    \ if (planet1_index == 2 && planet", "  std::unordered_map<std::string, int> map;\n\
    \  map[\"Mercury\"] = 1;\n  map[\"Venus\"] = 2;\n  map[\"Earth\"] = 3;\n  map[\"\
    Mars\"] = 4;\n  map[\"Jupiter\"] = 5;\n  map[\"Saturn\"] = 6;\n  map[\"Uranus\"\
    ] = 7;\n  map[\"Neptune\"] = 8;\n  std::tuple<std::string, > ret;\n  std::vector<std::string>\
    \ arr = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  return ret;", "    std::string planets[] = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n    std::vector<std::string> answer;\n    int start = -1, end\
    \ = -1;\n    for (int i = 0; i < 8; i++) {\n        if (planet1 == planets[i])\
    \ start = i;\n        if (planet2 == planets[i]) end = i;\n    }\n    if (start\
    \ == -1 || end == -1) return std::make_tuple(answer);\n    if (start > end) {\n\
    \        int temp = start;\n        start = end;\n        end = temp;\n    }\n\
    \    for (int i = start + 1; i < end; i++) {\n        answer.push_back(planets[i]);\n\
    \    }\n    return std::make_tuple(answer);", "  std::map<std::string, std::string>\
    \ solar = {\n    {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"}\n  };\n  return 0;", "\treturn std::make_tuple<std::string,\
    \ >();", "\tstd::vector<std::string> planets{\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string>\
    \ res;\n\tstd::tuple<std::string, > tup;\n\tbool f1 = false, f2 = false;\n\tfor\
    \ (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) f1 =\
    \ true;\n\t\tif (planets[i] == planet2) f2 = true;\n\t}\n\tif (!f1 || !f2) return\
    \ tup;\n\tint ind1 = 0, ind2 = 0;\n\tfor (int i = 0; i < planets.size(); i++)\
    \ {\n\t\tif (planets[i] == planet1) ind1 = i;\n\t\tif (planets[i] == planet2)\
    \ ind2 = i;\n\t}\n\tif (ind1 > ind2) {\n\t\tint tmp = ind1;\n\t\tind1 = ind2;\n\
    \t\tind2 = tmp;\n\t}\n\tfor (int i = ind1 + 1; i < ind2; i++) {\n\t\tres.push_back(planets[i]);\n\
    \t}\n\ttup = std::make_tuple(res[0], res[1], res[2], res[3], res[4]);\n\treturn\
    \ tup;", "    if(planet1 == \"Mercury\") {\n        if(planet2 == \"Venus\") {\n\
    \            return std::make_tuple(\"Mercury\", \"Venus\");\n        } else if(planet2\
    \ == \"Earth\") {\n            return std::make_tuple(\"Mercury\", \"Venus\",\
    \ \"Earth\");\n        } else if(planet2 == \"Mars\") {\n            return std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\");\n        } else if(planet2 == \"Jupiter\"\
    ) {\n            return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\");\n        } else if(planet2 == \"Saturn\") {\n          \
    \  return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\");\n        } else if(planet2 == \"Uranus\") {\n            return\
    \ std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\");\n        } else if(planet2 == \"Neptune\") {\n        \
    \    return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n        } else {\n            return\
    \ std::make_tuple();\n        }\n    } else if(planet1 == \"Venus\") {\n     \
    \   if(planet2 == \"Earth\") {\n            return std::make_tuple(\"Venus\",\
    \ \"Earth\");\n        } else if(planet2 == \"Mars\") {\n            return std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\");\n        } else if(planet2 == \"Jupiter\") {\n\
    \            return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    );\n        } else if(planet2 == \"Saturn\") {\n            return std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n        } else if(planet2\
    \ == \"Uranus\") {\n            return std::make_tuple(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Sat", "  std::vector<std::string> planets { \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \n      \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\" };\n  std::tuple<std::string, > result;\n  return result;", "  \
    \  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \n        \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int i;\n \
    \   for (i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            break;\n        }\n    }\n    if (i == planets.size()) {\n  \
    \      return {};\n    }\n    std::vector<std::string> ret;\n    for (; i < planets.size();\
    \ i++) {\n        if (planets[i] == planet2) {\n            break;\n        }\n\
    \        ret.push_back(planets[i]);\n    }\n    if (i == planets.size()) {\n \
    \       return {};\n    }\n    return {ret[0], ret[1]};", "    std::string planets[8]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \n        \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::map<std::string, int> m;\n    for (int i\
    \ = 0; i < 8; i++)\n        m[planets[i]] = i;\n    int index1 = m[planet1];\n\
    \    int index2 = m[planet2];\n    if (index1 > index2)\n        std::swap(index1,\
    \ index2);\n    std::vector<std::string> v;\n    for (int i = index1+1; i < index2;\
    \ i++)\n        v.push_back(planets[i]);\n    return std::make_tuple(v.begin(),\
    \ v.end());", "    // TODO: Implement this function\n    return std::make_tuple<std::string,\
    \ >();", "    std::vector<std::string> planets;\n    for (int i = 0; i < 8; i++)\n\
    \        planets.push_back(\"\");\n    planets[0] = \"Mercury\";\n    planets[1]\
    \ = \"Venus\";\n    planets[2] = \"Earth\";\n    planets[3] = \"Mars\";\n    planets[4]\
    \ = \"Jupiter\";\n    planets[5] = \"Saturn\";\n    planets[6] = \"Uranus\";\n\
    \    planets[7] = \"Neptune\";\n    int i = 0;\n    for (; planets[i] != planet1;\
    \ i++);\n    int j = i;\n    for (; planets[j] != planet2; j++);\n    std::vector<std::string>\
    \ res;\n    if (i < j)\n        for (int k = i + 1; k < j; k++)\n            res.push_back(planets[k]);\n\
    \    else\n        for (int k = j + 1; k < i; k++)\n            res.push_back(planets[k]);\n\
    \    return std::make_tuple(res);", "    std::vector<std::string> planets = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n    std::vector<std::string> result;\n    auto first = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto second = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if(first != planets.end() && second != planets.end()){\n    \
    \    if(first > second){\n            std::swap(first, second);\n        }\n \
    \       for(auto it = first; it != second; it++){\n            result.push_back(*it);\n\
    \        }\n    }\n    return std::make_tuple(result);", '    // your code here',
  "  // your code here\n  ", "    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    // place your code here\n    std::tuple<std::string, > sol;\n    return\
    \ sol;", "\tstd::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tauto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n\tauto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n\tif(it1 == planets.end() || it2 == planets.end()) return std::make_tuple();\n\
    \treturn std::make_tuple();", "  std::vector<std::string> planets;\n  planets.push_back(\"\
    Mercury\");\n  planets.push_back(\"Venus\");\n  planets.push_back(\"Earth\");\n\
    \  planets.push_back(\"Mars\");\n  planets.push_back(\"Jupiter\");\n  planets.push_back(\"\
    Saturn\");\n  planets.push_back(\"Uranus\");\n  planets.push_back(\"Neptune\"\
    );\n  std::vector<std::string> planets_mid;\n  int pos1 = -1;\n  int pos2 = -1;\n\
    \  for (int i = 0; i < planets.size(); i++) {\n    if (planets[i] == planet1)\
    \ pos1 = i;\n    if (planets[i] == planet2) pos2 = i;\n  }\n  if (pos1 == -1 ||\
    \ pos2 == -1) return std::make_tuple();\n  if (pos1 > pos2) {\n    int temp =\
    \ pos1;\n    pos1 = pos2;\n    pos2 = temp;\n  }\n  for (int i = pos1+1; i < pos2;\
    \ i++) {\n    planets_mid.push_back(planets[i]);\n  }\n  return std::make_tuple(planets_mid);",
  "    // your code here\n    return std::make_tuple();", "    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::vector<std::string>::iterator first_pos,\
    \ second_pos;\n    first_pos = find(planets.begin(), planets.end(), planet1);\n\
    \    second_pos = find(planets.begin(), planets.end(), planet2);\n    if(first_pos\
    \ == planets.end() || second_pos == planets.end()) {\n        return std::make_tuple();\n\
    \    }\n    else {\n        if(first_pos < second_pos) {\n            planets.erase(first_pos);\n\
    \            planets.erase(second_pos);\n        }\n        else {\n         \
    \   planets.erase(second_pos);\n            planets.erase(first_pos);\n      \
    \  }\n        return std::make_tuple(planets);\n    }", "\t// Write your code\
    \ here\n\tstd::vector<std::string> planets {\n\t\t\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \n\t\t\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n\t};\n\tbool\
    \ check1 = false, check2 = false;\n\tint index1, index2;\n\tfor (int i = 0; i\
    \ < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tcheck1 = true;\n\
    \t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tcheck2 = true;\n\
    \t\t\tindex2 = i;\n\t\t}\n\t}\n\tif (!check1 || !check2) return std::make_tuple();\n\
    \tstd::vector<std::string> res;\n\tif (index1 > index2) {\n\t\tint temp = index1;\n\
    \t\tindex1 = index2;\n\t\tindex2 = temp;\n\t}\n\tfor (int i = index1 + 1; i <\
    \ index2; i++) res.push_back(planets[i]);\n\treturn std::make_tuple(res);", "\t\n\
    \treturn std::make_tuple<std::string, >();", "    std::vector<std::string> planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(),\
    \ planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\
    \    if(it1 == planets.end() || it2 == planets.end())\n        return std::make_tuple();\n\
    \    std::vector<std::string> planets_bf(it1, it2);\n    return std::make_tuple(planets_bf.begin(),\
    \ planets_bf.end());", "  //your code here\n  ", "\tassert(planet1 != \"\" ||\
    \ planet2 != \"\");\n\tstd::vector<std::string> planets;\n\tplanets.push_back(\"\
    Mercury\");\n\tplanets.push_back(\"Venus\");\n\tplanets.push_back(\"Earth\");\n\
    \tplanets.push_back(\"Mars\");\n\tplanets.push_back(\"Jupiter\");\n\tplanets.push_back(\"\
    Saturn\");\n\tplanets.push_back(\"Uranus\");\n\tplanets.push_back(\"Neptune\"\
    );\n\tstd::vector<std::string>::iterator itr;\n\tstd::vector<std::string>::iterator\
    \ itr2;\n\tstd::vector<std::string>::iterator itr3;\n\tstd::vector<std::string>::iterator\
    \ itr4;\n\tstd::vector<std::string>::iterator itr5;\n\tfor (itr = planets.begin();\
    \ itr != planets.end(); itr++) {\n\t\tif (*itr == planet1) {\n\t\t\titr2 = itr;\n\
    \t\t}\n\t\tif (*itr == planet2) {\n\t\t\titr3 = itr;\n\t\t}\n\t}\n\tstd::vector<std::string>::iterator\
    \ itr6;\n\titr6 = itr2;\n\titr6++;\n\titr4 = itr3;\n\titr4--;\n\tif (planet1 ==\
    \ \"Mercury\" && planet2 == \"Mercury\") {\n\t\treturn std::make_tuple();\n\t\
    }\n\tif (planet1 == \"Mercury\" && planet2 == \"Venus\") {\n\t\treturn std::make_tuple();\n\
    \t}\n\tif (planet1 == \"Mercury\" && planet2 == \"Earth\") {\n\t\treturn std::make_tuple(\"\
    Venus\");\n\t}\n\tif (planet1 == \"Mercury\" && planet2 == \"Mars\") {\n\t\treturn\
    \ std::make_tuple(\"Venus\", \"Earth\");\n\t}\n\tif (planet1 == \"Mercury\" &&\
    \ planet2 == \"Jupiter\") {\n\t\treturn std::make_tuple(\"Venus\", \"Earth\",\
    \ \"Mars\");", '', "  std::vector<std::string> planets = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  int\
    \ p1, p2;\n  for (int i = 0; i < planets.size(); i++) {\n    if (planets[i] ==\
    \ planet1) {\n      p1 = i;\n    }\n    if (planets[i] == planet2) {\n      p2\
    \ = i;\n    }\n  }\n  std::vector<std::string> res;\n  int start = std::min(p1,\
    \ p2);\n  int end = std::max(p1, p2);\n  for (int i = start + 1; i < end; i++)\
    \ {\n    res.push_back(planets[i]);\n  }\n  return std::make_tuple(res[0], res[1],\
    \ res[2], res[3], res[4]);", "\treturn std::make_tuple(\"\");", "\tstd::tuple<std::string,\
    \ > r;\n\t// write your code here\n\treturn r;", '    ', "    std::tuple<std::string,\
    \ > result;\n    return result;", "    std::unordered_map<std::string, int> planets\
    \ = {\n        {\"Mercury\", 1},\n        {\"Venus\", 2},\n        {\"Earth\"\
    , 3},\n        {\"Mars\", 4},\n        {\"Jupiter\", 5},\n        {\"Saturn\"\
    , 6},\n        {\"Uranus\", 7},\n        {\"Neptune\", 8}\n    };\n    auto it1\
    \ = planets.find(planet1);\n    auto it2 = planets.find(planet2);\n    if (it1\
    \ == planets.end() || it2 == planets.end()) {\n        return std::make_tuple();\n\
    \    }\n    int i1 = it1->second;\n    int i2 = it2->second;\n    if (i1 > i2)\
    \ {\n        std::swap(i1, i2);\n    }\n    std::tuple<std::string, > res;\n \
    \   for (int i = i1 + 1; i < i2; ++i) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;", "  // your code\n  return std::make_tuple(\"\", );",
  "    std::tuple<std::string, > t;\n    return t;", "  std::string planets[] = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n  std::tuple<std::string, > result;\n  bool found_planet1 = false;\n\
    \  bool found_planet2 = false;\n  int i;\n  int j;\n  for (int k = 0; k < 8; k++)\
    \ {\n    if (planets[k] == planet1) {\n      found_planet1 = true;\n      i =\
    \ k;\n    }\n    if (planets[k] == planet2) {\n      found_planet2 = true;\n \
    \     j = k;\n    }\n  }\n  if (found_planet1 && found_planet2) {\n    if (i <\
    \ j) {\n      for (int k = i+1; k < j; k++) {\n        std::tuple<std::string,\
    \ > result(planets[k]);\n      }\n    }\n    else {\n      for (int k = j+1; k\
    \ < i; k++) {\n        std::tuple<std::string, > result(planets[k]);\n      }\n\
    \    }\n  }\n  return result;", '    // your code here', "    std::map<std::string,\
    \ int> planets{ {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4},\
    \ {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8} };\n  \
    \  int p1 = planets[planet1];\n    int p2 = planets[planet2];\n    int start =\
    \ (p1 > p2) ? p2 : p1;\n    int end = (p1 > p2) ? p1 : p2;\n    std::vector<std::string>\
    \ planets_;\n    for (int i = start + 1; i < end; i++) {\n        for (auto& e\
    \ : planets) {\n            if (e.second == i) planets_.push_back(e.first);\n\
    \        }\n    }\n    return std::make_tuple(planets_);", '    return std::make_tuple<std::string,
    >();', "    if(planet1 == \"Mercury\"){\n        if(planet2 == \"Mercury\"){\n\
    \            return std::make_tuple(\"\");\n        }\n        else if(planet2\
    \ == \"Venus\"){\n            return std::make_tuple(\"Venus\");\n        }\n\
    \        else if(planet2 == \"Earth\"){\n            return std::make_tuple(\"\
    Venus\", \"Earth\");\n        }\n        else if(planet2 == \"Mars\"){\n     \
    \       return std::make_tuple(\"Venus\", \"Earth\", \"Mars\");\n        }\n \
    \       else if(planet2 == \"Jupiter\"){\n            return std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\");\n        }\n        else if(planet2\
    \ == \"Saturn\"){\n            return std::make_tuple(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\");\n        }\n        else if(planet2 == \"Uranus\"\
    ){\n            return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\");\n        }\n        else if(planet2 == \"Neptune\"\
    ){\n            return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n        }\n        else{\n          \
    \  return std::make_tuple(\"\");\n        }\n    }\n    else if(planet1 == \"\
    Venus\"){\n        if(planet2 == \"Mercury\"){\n            return std::make_tuple(\"\
    \");\n        }\n        else if(planet2 == \"Venus\"){\n            return std::make_tuple(\"\
    \");\n        }\n        else if(planet2 == \"Earth\"){\n            return std::make_tuple(\"\
    Earth\");\n        }\n        else if(planet2 == \"Mars\"){\n            return\
    \ std::make_tuple(\"Earth\", \"Mars\");\n        }\n        else if(planet2 ==\
    \ \"Jupiter\"){\n            return std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\"\
    );\n        }\n        else if(planet2 == \"Saturn\"){\n            return", '  //
    my code here', "\tstd::vector<std::string> all = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tint index1 =\
    \ std::find(all.begin(), all.end(), planet1) - all.begin();\n\tint index2 = std::find(all.begin(),\
    \ all.end(), planet2) - all.begin();\n\tstd::tuple<std::string, > ans;\n\tint\
    \ index;\n\tif (index1 < index2) {\n\t\tfor (int i = index1; i < index2; i++)\
    \ {\n\t\t\tstd::get<index>(ans) = all[i];\n\t\t\tindex++;\n\t\t}\n\t} else {\n\
    \t\tfor (int i = index2; i < index1; i++) {\n\t\t\tstd::get<index>(ans) = all[i];\n\
    \t\t\tindex++;\n\t\t}\n\t}\n\treturn ans;", "\t", "\t// your code here\n\treturn\
    \ std::make_tuple(\"Mercury\");", "  std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string>::iterator planet1_it = std::find(planets.begin(),\
    \ planets.end(), planet1);\n  std::vector<std::string>::iterator planet2_it =\
    \ std::find(planets.begin(), planets.end(), planet2);\n  if (planet1_it == planets.end()\
    \ || planet2_it == planets.end())\n    return std::make_tuple();\n  if (planet1_it\
    \ > planet2_it)\n    std::swap(planet1_it, planet2_it);\n  std::vector<std::string>::iterator\
    \ p1 = planet1_it;\n  std::vector<std::string>::iterator p2 = planet2_it;\n  p1++;\n\
    \  p2--;\n  if (p1 > p2)\n    return std::make_tuple();\n  else\n    return std::make_tuple(std::string(\"\
    \"));", '    // Write your code here', "    std::map<std::string, int> mapping\
    \ = {{\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4}, {\"Jupiter\"\
    , 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8}};\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    auto first = mapping.find(planet1);\n    auto\
    \ second = mapping.find(planet2);\n    if (first == mapping.end() || second ==\
    \ mapping.end()) {\n        return std::make_tuple();\n    }\n    std::tuple<std::string,\
    \ > ans;\n    if (first->second > second->second) {\n        for (int i = second->second;\
    \ i < first->second; i++) {\n            std::get<0>(ans) = planets[i - 1];\n\
    \        }\n    } else {\n        for (int i = first->second; i < second->second;\
    \ i++) {\n            std::get<0>(ans) = planets[i - 1];\n        }\n    }\n \
    \   return ans;", "    // your code here\n    if(planet1.size() < 4 || planet2.size()\
    \ < 4)\n        return std::make_tuple(\"\");\n    if(!(planet1[0] == 'M' || planet1[0]\
    \ == 'V' || planet1[0] == 'E' || planet1[0] == 'M' || planet1[0] == 'J' || planet1[0]\
    \ == 'S' || planet1[0] == 'U' || planet1[0] == 'N'))\n        return std::make_tuple(\"\
    \");\n    if(!(planet2[0] == 'M' || planet2[0] == 'V' || planet2[0] == 'E' ||\
    \ planet2[0] == 'M' || planet2[0] == 'J' || planet2[0] == 'S' || planet2[0] ==\
    \ 'U' || planet2[0] == 'N'))\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'M' && planet2[0] == 'M')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'V' && planet2[0] == 'V')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'E' && planet2[0] == 'E')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'M' && planet2[0] == 'M')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'J' && planet2[0] == 'J')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'S' && planet2[0] == 'S')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'U' && planet2[0] == 'U')\n        return std::make_tuple(\"\");\n    if(planet1[0]\
    \ == 'N' && planet2[0] == 'N')\n        return std::make_tuple(\"\");\n    \n\
    \    bool first = true;", '    // your code here', "  // your code here\n  std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  if(planet1 > planet2)\n      std::swap(planet1,\
    \ planet2);\n  \n  auto p1 = std::find(planets.begin(), planets.end(), planet1);\n\
    \  auto p2 = std::find(planets.begin(), planets.end(), planet2);\n  if(p1 != planets.end()\
    \ && p2 != planets.end())\n      return std::make_tuple(p1 + 1, p2);\n  return\
    \ std::make_tuple();", "\t// Write your code here\n\treturn 0;", '', "  std::vector<std::string>\
    \ v = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n  ", "  std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  auto pl1 = std::find(planets.begin(), planets.end(), planet1);\n  auto pl2\
    \ = std::find(planets.begin(), planets.end(), planet2);\n  if(pl1 == planets.end()\
    \ || pl2 == planets.end())\n    return std::make_tuple<std::string>();\n  if(pl1\
    \ > pl2)\n    std::swap(pl1, pl2);\n  std::vector<std::string> res(pl1, pl2);\n\
    \  return std::make_tuple(res.begin(), res.end());", "  std::vector<std::string>\
    \ planets;\n  if (planet1 == \"Mercury\") planets.push_back(\"Mercury\");\n  if\
    \ (planet1 == \"Venus\") planets.push_back(\"Venus\");\n  if (planet1 == \"Earth\"\
    ) planets.push_back(\"Earth\");\n  if (planet1 == \"Mars\") planets.push_back(\"\
    Mars\");\n  if (planet1 == \"Jupiter\") planets.push_back(\"Jupiter\");\n  if\
    \ (planet1 == \"Saturn\") planets.push_back(\"Saturn\");\n  if (planet1 == \"\
    Uranus\") planets.push_back(\"Uranus\");\n  if (planet1 == \"Neptune\") planets.push_back(\"\
    Neptune\");\n  if (planet2 == \"Mercury\") planets.push_back(\"Mercury\");\n \
    \ if (planet2 == \"Venus\") planets.push_back(\"Venus\");\n  if (planet2 == \"\
    Earth\") planets.push_back(\"Earth\");\n  if (planet2 == \"Mars\") planets.push_back(\"\
    Mars\");\n  if (planet2 == \"Jupiter\") planets.push_back(\"Jupiter\");\n  if\
    \ (planet2 == \"Saturn\") planets.push_back(\"Saturn\");\n  if (planet2 == \"\
    Uranus\") planets.push_back(\"Uranus\");\n  if (planet2 == \"Neptune\") planets.push_back(\"\
    Neptune\");\n  for (int i = 0; i < planets.size(); i++) {\n    for (int j = i\
    \ + 1; j < planets.size(); j++) {\n      if (planets[i] > planets[j]) {\n    \
    \    std::string temp = planets[i];\n        planets[i] = planets[j];\n      \
    \  planets[j] = temp;\n      }\n    }\n  }\n  std::vector<std::string> planets2;\n\
    \  for (int i = 0; i < planets.size(); i++) {\n    if (planets[i] != planet1 &&\
    \ planets[i] != planet2) planets2.push_back(planets[i]);\n  }\n  std::tuple<std::string,\
    \ > answer;\n  return answer;\n", "    //TODO : \n    std::string planetList[]\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n    std::tuple<std::string, > result;\n    for(int i\
    \ = 0; i < 8; i++) {\n        //TODO:\n    }\n    return result;", "\t// your\
    \ code here", "    std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::unordered_map<std::string,\
    \ int> um;\n    for (int i = 0; i < 8; i++)\n        um[planets[i]] = i;\n   \
    \ if (um.find(planet1) == um.end() || um.find(planet2) == um.end())\n        return\
    \ std::make_tuple();\n    int low = std::min(um[planet1], um[planet2]);\n    int\
    \ high = std::max(um[planet1], um[planet2]);\n    std::tuple<std::string, std::string,\
    \ std::string, std::string, std::string> res;\n    auto[a, b, c, d, e] = res;\n\
    \    int k = 0;\n    for (int i = low + 1; i < high; i++) {\n        switch (k)\
    \ {\n            case 0: a = planets[i]; break;\n            case 1: b = planets[i];\
    \ break;\n            case 2: c = planets[i]; break;\n            case 3: d =\
    \ planets[i]; break;\n            case 4: e = planets[i]; break;\n        }\n\
    \        k++;\n    }\n    return res;", "    std::tuple<std::string, > t = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n    return t;", '    // your code', '  //your code here', '    return
    std::make_tuple<std::string, >("");', "\tchar planets[8][10] = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tint  index1, index2;\n\tstd::tuple<std::string, > res;\n\tfor(int i = 0;\
    \ i < 8; i++)\n\t{\n\t\tif(strcmp(planets[i], planet1) == 0)\n\t\t\tindex1 = i;\n\
    \t\tif(strcmp(planets[i], planet2) == 0)\n\t\t\tindex2 = i;\n\t}\n\tif(index1\
    \ < index2)\n\t{\n\t\tfor(int i = index1 + 1; i < index2; i++)\n\t\t{\n\t\t\t\
    std::get<>(res) = std::get<>(res) + \", \" + planets[i];\n\t\t}\n\t}\n\telse\n\
    \t{\n\t\tfor(int i = index2 + 1; i < index1; i++)\n\t\t{\n\t\t\tstd::get<>(res)\
    \ = std::get<>(res) + \", \" + planets[i];\n\t\t}\n\t}\n\treturn res;", "\tif\
    \ (planet1 == \"Mercury\") {\n\t\tif (planet2 == \"Mercury\")\n\t\t\treturn std::make_tuple<std::string>();\n\
    \t\telse if (planet2 == \"Venus\")\n\t\t\treturn std::make_tuple<std::string>(\"\
    Venus\");\n\t\telse if (planet2 == \"Earth\")\n\t\t\treturn std::make_tuple<std::string>(\"\
    Venus\", \"Earth\");\n\t\telse if (planet2 == \"Mars\")\n\t\t\treturn std::make_tuple<std::string>(\"\
    Venus\", \"Earth\", \"Mars\");\n\t\telse if (planet2 == \"Jupiter\")\n\t\t\treturn\
    \ std::make_tuple<std::string>(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\");\n\
    \t\telse if (planet2 == \"Saturn\")\n\t\t\treturn std::make_tuple<std::string>(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n\t\telse if (planet2\
    \ == \"Uranus\")\n\t\t\treturn std::make_tuple<std::string>(\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n\t\telse if (planet2 == \"\
    Neptune\")\n\t\t\treturn std::make_tuple<std::string>(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\t\telse\n\t\t\treturn\
    \ std::make_tuple<std::string>();\n\t}\n\telse if (planet1 == \"Venus\") {\n\t\
    \tif (planet2 == \"Mercury\")\n\t\t\treturn std::make_tuple<std::string>();\n\t\
    \telse if (planet2 == \"Venus\")\n\t\t\treturn std::make_tuple<std::string>();\n\
    \t\telse if (planet2 == \"Earth\")\n\t\t\treturn std::make_tuple<std::string>(\"\
    Earth\");\n\t\telse if (planet2 == \"Mars\")\n\t\t\treturn std::make_tuple<std::string>(\"\
    Earth\", \"Mars\");\n\t\t", "    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> output;\n    auto planet1_index = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto planet2_index = std::find(planets.begin(),\
    \ planets.end(), planet2);\n    auto planet1_distance = std::distance(planets.begin(),\
    \ planet1_index);\n    auto planet2_distance = std::distance(planets.begin(),\
    \ planet2_index);\n    if (planet1_index == planets.end() || planet2_index ==\
    \ planets.end()) {\n        return std::make_tuple();\n    } else if (planet1_distance\
    \ < planet2_distance) {\n        for (auto i = planet1_index + 1; i != planet2_index;\
    \ i++) {\n            output.push_back(*i);\n        }\n    } else {\n       \
    \ for (auto i = planet2_index + 1; i != planet1_index; i++) {\n            output.push_back(*i);\n\
    \        }\n    }\n    return std::make_tuple(output);", '', "    if(planet1 ==\
    \ \"Mercury\") {\n        if(planet2 == \"Venus\") {\n            return std::make_tuple(\"\
    Mercury\", \"Venus\");\n        }\n        if(planet2 == \"Earth\") {\n      \
    \      return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\");\n        }\n\
    \        if(planet2 == \"Mars\") {\n            return std::make_tuple(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\");\n        }\n        if(planet2 == \"Jupiter\"\
    ) {\n            return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\");\n        }\n        if(planet2 == \"Saturn\") {\n      \
    \      return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\");\n        }\n        if(planet2 == \"Uranus\") {\n    \
    \        return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\");\n        }\n        if(planet2 == \"Neptune\"\
    ) {\n            return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        }\n    }\n\
    \    if(planet1 == \"Venus\") {\n        if(planet2 == \"Earth\") {\n        \
    \    return std::make_tuple(\"Venus\", \"Earth\");\n        }\n        if(planet2\
    \ == \"Mars\") {\n            return std::make_tuple(\"Venus\", \"Earth\", \"\
    Mars\");\n        }\n        if(planet2 == \"Jupiter\") {\n            return\
    \ std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\");\n        }\n \
    \       if(planet2 == \"Saturn\") {\n            return std::make_tuple(\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n        }\n        if(planet2\
    \ == \"Uranus\") {\n            return std::make_tuple(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"U", "    const std::map<std::string, int> order\
    \ = {\n      {\"Mercury\", 1},\n      {\"Venus\", 2},\n      {\"Earth\", 3},\n\
    \      {\"Mars\", 4},\n      {\"Jupiter\", 5},\n      {\"Saturn\", 6},\n     \
    \ {\"Uranus\", 7},\n      {\"Neptune\", 8}\n    };\n    auto p1 = order.find(planet1);\n\
    \    auto p2 = order.find(planet2);\n    if (p1 == order.end() || p2 == order.end())\
    \ {\n      return std::make_tuple();\n    }\n    std::vector<std::string> res;\n\
    \    if (p1->second > p2->second) {\n      std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1->second + 1; i < p2->second; ++i) {\n      for (auto &p : order)\
    \ {\n        if (p.second == i) {\n          res.push_back(p.first);\n       \
    \ }\n      }\n    }\n    return std::make_tuple(res[0], res[1], res[2], res[3],\
    \ res[4]);", "\tstd::vector<std::string> planets = { \"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n\tif (std::find(planets.begin(),\
    \ planets.end(), planet1) == planets.end() || std::find(planets.begin(), planets.end(),\
    \ planet2) == planets.end())\n\t\treturn std::make_tuple();\n\tstd::vector<std::string>\
    \ result;\n\tint i1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \tint i2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \tif (i1 < i2) {\n\t\twhile (i1 <= i2) {\n\t\t\tresult.push_back(planets[i1]);\n\
    \t\t\ti1++;\n\t\t}\n\t}\n\telse {\n\t\twhile (i1 <= 7) {\n\t\t\tresult.push_back(planets[i1]);\n\
    \t\t\ti1++;\n\t\t}\n\t\ti1 = 0;\n\t\twhile (i1 <= i2) {\n\t\t\tresult.push_back(planets[i1]);\n\
    \t\t\ti1++;\n\t\t}\n\t}\n\tstd::tuple<std::string, > t(result.begin(), result.end());\n\
    \treturn t;", "    static const std::string planets[] = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \n                                          \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1;\n    for\
    \ (int i = 0; i < 8; i++) {\n        if (planets[i] == planet1) {\n          \
    \  pos1 = i;\n        }\n        if (planets[i] == planet2) {\n            pos2\
    \ = i;\n        }\n    }\n    if (pos1 == -1 || pos2 == -1) {\n        return\
    \ std::make_tuple();\n    }\n    std::tuple<std::string, > res;\n    int pos;\n\
    \    if (pos1 < pos2) {\n        pos = pos1 + 1;\n        while (pos < pos2) {\n\
    \            res.push_back(planets[pos]);\n            pos++;\n        }\n   \
    \ } else {\n        pos = pos1 - 1;\n        while (pos > pos2) {\n          \
    \  res.push_back(planets[pos]);\n            pos--;\n        }\n    }\n    return\
    \ res;", "  std::tuple<std::string, > t;\n  return t;", "\tstd::vector<std::string>\
    \ planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n\t\"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\" };\n\tint ind1 = 0, ind2 = 0;\n\tfor (int i\
    \ = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1)\n\t\t\tind1\
    \ = i;\n\t\tif (planets[i] == planet2)\n\t\t\tind2 = i;\n\t}\n\tif (ind1 == 0\
    \ && ind2 == 0) {\n\t\tstd::tuple<std::string, > tpl;\n\t\treturn tpl;\n\t}\n\t\
    if (ind1 > ind2) {\n\t\tint tmp = ind1;\n\t\tind1 = ind2;\n\t\tind2 = tmp;\n\t\
    }\n\tstd::tuple<std::string, > tpl(planets[ind1 + 1],\n\t\t\tplanets[ind2 - 1]);\n\
    \treturn tpl;", "\tstd::vector<std::string> planets = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\
    std::tuple<std::string, > result;\n\tstd::vector<std::string>::iterator pos1,\
    \ pos2;\n\tpos1 = std::find(planets.begin(), planets.end(), planet1);\n\tpos2\
    \ = std::find(planets.begin(), planets.end(), planet2);\n\tif(pos1 == planets.end()\
    \ || pos2 == planets.end()) return result;\n\tif(pos1 < pos2) {\n\t\tstd::copy(pos1+1,\
    \ pos2, result.begin());\n\t} else {\n\t\tstd::copy(pos2+1, pos1, result.begin());\n\
    \t}\n\treturn result;", "\tstd::string planet[] = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string>\
    \ data;\n\tstd::vector<std::string> result;\n\tint i, j;\n\tbool a = false, b\
    \ = false;\n\tfor(i = 0; i < sizeof(planet)/sizeof(planet[0]); i++) {\n\t\tif(planet[i]\
    \ == planet1) a = true;\n\t\tif(planet[i] == planet2) b = true;\n\t\tdata.push_back(planet[i]);\n\
    \t}\n\tif(a && b) {\n\t\tif(std::find(data.begin(), data.end(), planet1) - data.begin()\
    \ > std::find(data.begin(), data.end(), planet2) - data.begin()) {\n\t\t\tfor(i\
    \ = std::find(data.begin(), data.end(), planet2) - data.begin(); i < std::find(data.begin(),\
    \ data.end(), planet1) - data.begin(); i++) {\n\t\t\t\tresult.push_back(data[i]);\n\
    \t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(i = std::find(data.begin(), data.end(),\
    \ planet1) - data.begin(); i < std::find(data.begin(), data.end(), planet2) -\
    \ data.begin(); i++) {\n\t\t\t\tresult.push_back(data[i]);\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\treturn std::make_tuple(result);", '    // your code here', "    std::vector<std::string>\
    \ v = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n    std::vector<std::string> planets;\n    auto it1 =\
    \ std::find(v.begin(), v.end(), planet1);\n    auto it2 = std::find(v.begin(),\
    \ v.end(), planet2);\n    if (it1 == v.end() || it2 == v.end())\n        return\
    \ std::make_tuple();\n    if (std::distance(it1, it2) > 0)\n        std::copy(it1\
    \ + 1, it2, std::back_inserter(planets));\n    else\n        std::copy(it2 + 1,\
    \ it1, std::back_inserter(planets));\n    return std::make_tuple(planets);", '    //
    your code here', "    auto convert = [](const std::string& planet) {\n       \
    \ const auto all_planets = {\n            \"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n        };\n       \
    \ auto it = std::find(all_planets.begin(), all_planets.end(), planet);\n     \
    \   return (it == all_planets.end()) ? std::tuple<std::string, >() : std::tuple<std::string,\
    \ >(it, it + 1);\n    };\n    auto p1 = convert(planet1);\n    auto p2 = convert(planet2);\n\
    \    if (p1.empty() || p2.empty()) {\n        return std::tuple<std::string, >();\n\
    \    }\n    return p1 < p2 ? std::tuple<std::string, >(p1, p2) : std::tuple<std::string,\
    \ >(p2, p1);", "  std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  int p1 = -1,\
    \ p2 = -1;\n  for (int i = 0; i < 8; i++) {\n    if (planets[i] == planet1) {\n\
    \      p1 = i;\n    }\n    if (planets[i] == planet2) {\n      p2 = i;\n    }\n\
    \  }\n  if (p1 == -1 || p2 == -1) {\n    return std::make_tuple();\n  }\n  if\
    \ (p1 > p2) {\n    std::swap(p1, p2);\n  }\n  std::vector<std::string> v;\n  for\
    \ (int i = p1 + 1; i < p2; i++) {\n    v.push_back(planets[i]);\n  }\n  return\
    \ std::make_tuple(v[0], v[1], v[2], v[3], v[4]);", "\tstd::vector<std::string>\
    \ planets{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string> result{};\n\tbool p1 =\
    \ false, p2 = false;\n\tfor (auto i = 0; i < planets.size(); i++) {\n\t\tif (planets[i]\
    \ == planet1) p1 = true;\n\t\tif (planets[i] == planet2) p2 = true;\n\t}\n\tif\
    \ (!p1 || !p2) return std::make_tuple();\n\telse {\n\t\tfor (auto i = 0; i < planets.size();\
    \ i++) {\n\t\t\tif (planets[i] == planet1) {\n\t\t\t\tfor (auto j = i + 1; j <\
    \ planets.size(); j++) {\n\t\t\t\t\tif (planets[j] == planet2) break;\n\t\t\t\t\
    \tresult.push_back(planets[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tauto res_tuple\
    \ = std::make_tuple(result[0], result[1], result[2], result[3], result[4]);\n\t\
    return res_tuple;", "  // your code here\n  return {};", "    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::tuple<std::string, > no_answer;\n    std::tuple<std::string,\
    \ > answer;\n    int start_index = -1;\n    int end_index = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          start_index = i;\n        } else if (planets[i] == planet2) {\n   \
    \         end_index = i;\n        }\n    }\n    if (start_index == -1 || end_index\
    \ == -1) {\n        return no_answer;\n    }\n    for (int i = start_index; i\
    \ < end_index; i++) {\n        std::get<0>(answer) = planets[i];\n    }\n    return\
    \ answer;", "\tstd::unordered_map<std::string, int> map = {\n\t\t{\"Mercury\"\
    , 0},\n\t\t{\"Venus\", 1},\n\t\t{\"Earth\", 2},\n\t\t{\"Mars\", 3},\n\t\t{\"Jupiter\"\
    , 4},\n\t\t{\"Saturn\", 5},\n\t\t{\"Uranus\", 6},\n\t\t{\"Neptune\", 7}\n\t};\n\
    \tstd::tuple<std::string, > result;\n\tif (map.find(planet1) == map.end() || map.find(planet2)\
    \ == map.end())\n\t\treturn result;\n\tif (map[planet1] > map[planet2]) {\n\t\t\
    for (int i = map[planet2] + 1; i < map[planet1]; i++) {\n\t\t\tfor (auto pair\
    \ : map) {\n\t\t\t\tif (pair.second == i) {\n\t\t\t\t\tresult.push_back(pair.first);\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = map[planet1]\
    \ + 1; i < map[planet2]; i++) {\n\t\t\tfor (auto pair : map) {\n\t\t\t\tif (pair.second\
    \ == i) {\n\t\t\t\t\tresult.push_back(pair.first);\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn result;", "\t// your code", '    return std::make_tuple();',
  "    assert(planet1 != \"\" && planet2 != \"\");\n    std::unordered_map<std::string,\
    \ int> planets;\n    planets[\"Mercury\"] = 1;\n    planets[\"Venus\"] = 2;\n\
    \    planets[\"Earth\"] = 3;\n    planets[\"Mars\"] = 4;\n    planets[\"Jupiter\"\
    ] = 5;\n    planets[\"Saturn\"] = 6;\n    planets[\"Uranus\"] = 7;\n    planets[\"\
    Neptune\"] = 8;\n    int p1 = planets[planet1];\n    int p2 = planets[planet2];\n\
    \    int min = (p1 < p2) ? p1 : p2;\n    int max = (p1 > p2) ? p1 : p2;\n    std::tuple<std::string,\
    \ > res;\n    for (int i = min; i <= max; i++) {\n        switch (i) {\n     \
    \       case 1:\n                res.push_back(\"Mercury\");\n               \
    \ break;\n            case 2:\n                res.push_back(\"Venus\");\n   \
    \             break;\n            case 3:\n                res.push_back(\"Earth\"\
    );\n                break;\n            case 4:\n                res.push_back(\"\
    Mars\");\n                break;\n            case 5:\n                res.push_back(\"\
    Jupiter\");\n                break;\n            case 6:\n                res.push_back(\"\
    Saturn\");\n                break;\n            case 7:\n                res.push_back(\"\
    Uranus\");\n                break;\n            case 8:\n                res.push_back(\"\
    Neptune\");\n                break;\n        }\n    }\n    return res;", "   \
    \ std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    std::string r[] = {};\n    if\
    \ (p1 > p2)\n        return std::make_tuple(r);\n    return std::make_tuple(r);",
  '  return make_tuple();', "    std::string planets[] = {\"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::string newPlanets[];\n    int i = 0;\n    int j = 0;\n    int position\
    \ = 0;\n    for(int i = 0; i < 8; i++){\n        if(planets[i] == planet1){\n\
    \            position = i;\n        }\n    }\n    int position2 = 0;\n    for(int\
    \ i = 0; i < 8; i++){\n        if(planets[i] == planet2){\n            position2\
    \ = i;\n        }\n    }\n    int x = position2 - position;\n    for(int i = 0;\
    \ i < x; i++){\n        newPlanets[i] = planets[position];\n        position++;\n\
    \    }\n    return newPlanets;", '    // your code here', "    // your code here\n\
    \    \n    ", "    std::vector<std::string> planets = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::vector<std::string> ret;\n    bool f1 = false, f2 = false;\n    std::vector<std::string>::iterator\
    \ it;\n    for (it = planets.begin(); it != planets.end(); it++) {\n        if\
    \ (planet1 == *it) {\n            f1 = true;\n            break;\n        }\n\
    \    }\n    for (it = planets.begin(); it != planets.end(); it++) {\n        if\
    \ (planet2 == *it) {\n            f2 = true;\n            break;\n        }\n\
    \    }\n    if (f1 && f2) {\n        std::vector<std::string>::iterator it1, it2;\n\
    \        for (it1 = planets.begin(); it1 != planets.end(); it1++) {\n        \
    \    if (planet1 == *it1) {\n                break;\n            }\n        }\n\
    \        for (it2 = planets.begin(); it2 != planets.end(); it2++) {\n        \
    \    if (planet2 == *it2) {\n                break;\n            }\n        }\n\
    \        if (it1 > it2) {\n            std::swap(it1, it2);\n        }\n     \
    \   it1++;\n        while (it1 != it2) {\n            ret.push_back(*it1);\n \
    \           it1++;\n        }\n    }\n    std::tuple<std::string, > ret1(ret);\n\
    \    return ret1;", "    std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::string\
    \ p1, p2;\n    int i, j;\n    for (i = 0; i < 8; i++) {\n        if (planets[i]\
    \ == planet1) {\n            p1 = planet1;\n            break;\n        }\n  \
    \  }\n    for (j = 0; j < 8; j++) {\n        if (planets[j] == planet2) {\n  \
    \          p2 = planet2;\n            break;\n        }\n    }\n    std::tuple<std::string,\
    \ > result;\n    if (i > j) {\n        for (int k = j; k < i; k++) {\n       \
    \     result = {result, planets[k]};\n        }\n    } else {\n        for (int\
    \ k = i; k < j; k++) {\n            result = {result, planets[k]};\n        }\n\
    \    }\n    return result;", "    vector<string> planet;\n    planet.push_back(\"\
    Mercury\");\n    planet.push_back(\"Venus\");\n    planet.push_back(\"Earth\"\
    );\n    planet.push_back(\"Mars\");\n    planet.push_back(\"Jupiter\");\n    planet.push_back(\"\
    Saturn\");\n    planet.push_back(\"Uranus\");\n    planet.push_back(\"Neptune\"\
    );\n    vector<string> ans;\n    int a = -1, b = -1;\n    for(int i = 0; i < planet.size();\
    \ i++) {\n        if(planet[i] == planet1) {\n            a = i;\n        }\n\
    \        if(planet[i] == planet2) {\n            b = i;\n        }\n    }\n  \
    \  int minn = min(a, b);\n    int maxx = max(a, b);\n    for(int i = minn + 1;\
    \ i < maxx; i++) {\n        ans.push_back(planet[i]);\n    }\n    if(a == -1 ||\
    \ b == -1) {\n        return {};\n    }\n    else if(a > b) {\n        return\
    \ {ans[0], ans[1], ans[2], ans[3], ans[4]};\n    }\n    else {\n        return\
    \ {ans[4], ans[3], ans[2], ans[1], ans[0]};\n    }", "    std::vector<std::string>\
    \ names={\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::map<std::string, int> m;\n    for(int i=0;i<names.size();i++)\n\
    \        m[names[i]]=i;\n    std::vector<std::string> result;\n    if(m.find(planet1)==m.end()\
    \ || m.find(planet2)==m.end())\n        return std::make_tuple();\n    int start=m[planet1];\n\
    \    int end=m[planet2];\n    if(start>end)\n        std::swap(start, end);\n\
    \    for(int i=start+1;i<end;i++)\n        result.push_back(names[i]);\n    return\
    \ std::make_tuple(result);", "  if (planet1 == \"Mercury\") {\n    if (planet2\
    \ == \"Venus\") {\n      return std::make_tuple(planet2);\n    } else if (planet2\
    \ == \"Earth\") {\n      return std::make_tuple(planet2);\n    } else if (planet2\
    \ == \"Mars\") {\n      return std::make_tuple(planet2);\n    } else if (planet2\
    \ == \"Jupiter\") {\n      return std::make_tuple(planet2);\n    } else if (planet2\
    \ == \"Saturn\") {\n      return std::make_tuple(planet2);\n    } else if (planet2\
    \ == \"Uranus\") {\n      return std::make_tuple(planet2);\n    } else if (planet2\
    \ == \"Neptune\") {\n      return std::make_tuple(planet2);\n    } else {\n  \
    \    return std::make_tuple();\n    }\n  } else if (planet1 == \"Venus\") {\n\
    \    if (planet2 == \"Earth\") {\n      return std::make_tuple(planet2);\n   \
    \ } else if (planet2 == \"Mars\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Jupiter\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Saturn\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Uranus\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Neptune\") {\n      return std::make_tuple(planet2);\n\
    \    } else {\n      return std::make_tuple();\n    }\n  } else if (planet1 ==\
    \ \"Earth\") {\n    if (planet2 == \"Mars\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Jupiter\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Saturn\") {\n      return std::make_tuple(planet2);\n\
    \    } else if (planet2 == \"Uran", "\tstd::vector<std::string> planets = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \n\t\t\t\t\t\t\t\t\t\t\"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"};\n\tstd::vector<std::string> res;\n\tint\
    \ idx1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \tint idx2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \tif (idx1 < 0 || idx2 < 0) return std::make_tuple();\n\tif (idx1 > idx2) std::swap(idx1,\
    \ idx2);\n\tfor (int i = idx1 + 1; i < idx2; i++)\n\t\tres.push_back(planets[i]);\n\
    \treturn std::make_tuple(res);", '', '  ', "    const std::vector<std::string>\
    \ planets {\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"\n    };\n    auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if (it1 == planets.end() || it2 == planets.end()) {\n       \
    \ return std::make_tuple();\n    }\n    auto planets_between = std::vector<std::string>\
    \ {};\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(planets_between));\n\
    \    } else {\n        std::copy(it2 + 1, it1, std::back_inserter(planets_between));\n\
    \    }\n    return std::make_tuple(planets_between);", "\tstd::vector<std::string>\
    \ planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" };\n\tauto it1 = std::find(planets.begin(), planets.end(),\
    \ planet1);\n\tauto it2 = std::find(planets.begin(), planets.end(), planet2);\n\
    \tif (it1 == planets.end() || it2 == planets.end()) {\n\t\treturn std::make_tuple();\n\
    \t}\n\tstd::vector<std::string> between;\n\tif (it1 < it2) {\n\t\tstd::copy(it1\
    \ + 1, it2, std::back_inserter(between));\n\t}\n\telse {\n\t\tstd::copy(it2 +\
    \ 1, it1, std::back_inserter(between));\n\t}\n\treturn std::make_tuple(between);",
  '', '    return std::make_tuple();', "    std::tuple<std::string, > result;\n  \
    \  //your code here\n    return result;", "  std::vector<std::string> planets;\n\
    \  // Write code here\n  return std::make_tuple(planets);", "\tstd::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\tstd::string p1 = \"\";\n\tstd::string p2 = \"\"\
    ;\n\tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1)\
    \ {\n\t\t\tp1 = planet1;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tp2 =\
    \ planet2;\n\t\t}\n\t}\n\tif (p1 == \"\" || p2 == \"\") {\n\t\treturn std::make_tuple();\n\
    \t}\n\tif (p1 == planet1 && p2 == planet2) {\n\t\tstd::vector<std::string> planetsInOrder\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n\t\tint indexOfP1 = -1;\n\t\tint indexOfP2 = -1;\n\t\t\
    for (int i = 0; i < planetsInOrder.size(); i++) {\n\t\t\tif (planetsInOrder[i]\
    \ == planet1) {\n\t\t\t\tindexOfP1 = i;\n\t\t\t}\n\t\t\tif (planetsInOrder[i]\
    \ == planet2) {\n\t\t\t\tindexOfP2 = i;\n\t\t\t}\n\t\t}\n\t\tif (indexOfP1 < indexOfP2)\
    \ {\n\t\t\treturn std::make_tuple(planetsInOrder[indexOfP1+1], planetsInOrder[indexOfP2-1]);\n\
    \t\t}\n\t\telse {\n\t\t\treturn std::make_tuple(planetsInOrder[indexOfP2+1], planetsInOrder[indexOfP1-1]);\n\
    \t\t}\n\t}\n\telse {\n\t\tstd::vector<std::string> planetsInOrder = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n", "    std::vector<std::string> planets;\n    planets.push_back(\"Mercury\"\
    );\n    planets.push_back(\"Venus\");\n    planets.push_back(\"Earth\");\n   \
    \ planets.push_back(\"Mars\");\n    planets.push_back(\"Jupiter\");\n    planets.push_back(\"\
    Saturn\");\n    planets.push_back(\"Uranus\");\n    planets.push_back(\"Neptune\"\
    );\n    std::vector<std::string>::iterator it1, it2;\n    it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    std::vector<std::string>::iterator it3, it4;\n    if (it1 ==\
    \ planets.end() || it2 == planets.end())\n        return std::make_tuple();\n\
    \    it3 = std::min_element(it1, it2);\n    it4 = std::max_element(it1, it2);\n\
    \    if (it3 == it1)\n        it3 = it3 + 1;\n    else\n        it4 = it4 - 1;\n\
    \    std::vector<std::string> ret(it3, it4);\n    return std::make_tuple(ret.begin(),\
    \ ret.end());", "    std::vector<std::string> planets = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  \
    \  std::vector<std::string> planets_in_order;\n    std::string planet;\n    std::tuple<std::string,\
    \ > planets_in_range;\n    int i1 = 0;\n    int i2 = 0;\n    for (int i = 0; i\
    \ < planets.size(); i++) {\n        if (planets[i] == planet1) {\n           \
    \ i1 = i;\n        }\n        if (planets[i] == planet2) {\n            i2 = i;\n\
    \        }\n    }\n    if (i1 > i2) {\n        for (int i = i2; i <= i1; i++)\
    \ {\n            planet = planets[i];\n            planets_in_order.push_back(planet);\n\
    \        }\n    }\n    else {\n        for (int i = i1; i <= i2; i++) {\n    \
    \        planet = planets[i];\n            planets_in_order.push_back(planet);\n\
    \        }\n    }\n    if (i1 > i2) {\n        std::reverse(planets_in_order.begin(),\
    \ planets_in_order.end());\n    }\n    int count = 0;\n    for (int i = 0; i <\
    \ planets_in_order.size(); i++) {\n        if (planets_in_order[i] != planet1\
    \ && planets_in_order[i] != planet2) {\n            planets_in_range[count] =\
    \ planets_in_order[i];\n            count++;\n        }\n    }\n    return planets_in_range;",
  "  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Make your code here", "  std::vector<std::string>\
    \ planets = {\n    \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"\n  };\n  std::tuple<std::string, > result;\n\
    \  return result;", "  std::map<std::string, int> planet_map = {\n    {\"Mercury\"\
    , 1},\n    {\"Venus\", 2},\n    {\"Earth\", 3},\n    {\"Mars\", 4},\n    {\"Jupiter\"\
    , 5},\n    {\"Saturn\", 6},\n    {\"Uranus\", 7},\n    {\"Neptune\", 8}\n  };\n\
    \  if (planet_map.find(planet1) == planet_map.end() || planet_map.find(planet2)\
    \ == planet_map.end())\n    return std::make_tuple();\n  int start = planet_map[planet1];\n\
    \  int end = planet_map[planet2];\n  std::vector<std::string> ret;\n  for (int\
    \ i = start; i < end; i++) {\n    for (auto& p : planet_map) {\n      if (p.second\
    \ == i) {\n        ret.push_back(p.first);\n        break;\n      }\n    }\n \
    \ }\n  return std::make_tuple(ret[0], ret[1], ret[2], ret[3], ret[4]);", '    ',
  "    // your code here\n    std::tuple<std::string, > ret;\n    return ret;", " \
    \   std::unordered_map<std::string, int> map;\n    map[\"Mercury\"] = 1;\n   \
    \ map[\"Venus\"] = 2;\n    map[\"Earth\"] = 3;\n    map[\"Mars\"] = 4;\n    map[\"\
    Jupiter\"] = 5;\n    map[\"Saturn\"] = 6;\n    map[\"Uranus\"] = 7;\n    map[\"\
    Neptune\"] = 8;\n    int idx1 = map[planet1];\n    int idx2 = map[planet2];\n\
    \    if(idx1 == 0 || idx2 == 0) return std::make_tuple();\n    std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    if(idx1 < idx2) {\n        std::vector<std::string>\
    \ res;\n        for(int i = idx1 + 1; i < idx2; i++) {\n            res.push_back(planets[i]);\n\
    \        }\n        return std::make_tuple(res);\n    } else {\n        std::vector<std::string>\
    \ res;\n        for(int i = idx2 + 1; i < idx1; i++) {\n            res.push_back(planets[i]);\n\
    \        }\n        return std::make_tuple(res);\n    }", '  ', "\tstd::map<std::string,\
    \ int> planets;\n\tplanets[\"Mercury\"] = 1;\n\tplanets[\"Venus\"] = 2;\n\tplanets[\"\
    Earth\"] = 3;\n\tplanets[\"Mars\"] = 4;\n\tplanets[\"Jupiter\"] = 5;\n\tplanets[\"\
    Saturn\"] = 6;\n\tplanets[\"Uranus\"] = 7;\n\tplanets[\"Neptune\"] = 8;\n\tif\
    \ (planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end())\n\
    \t\treturn std::make_tuple();\n\tstd::vector<std::string> result;\n\tfor (auto\
    \ p : planets) {\n\t\tif (p.second > planets[planet1] && p.second < planets[planet2])\n\
    \t\t\tresult.push_back(p.first);\n\t}\n\treturn std::make_tuple(result[0], result[1],\
    \ result[2], result[3], result[4]);", '', "  std::vector<std::string> planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"};\n  int idx1 = -1, idx2 = -1;\n  for (int i = 0; i < planets.size();\
    \ i++) {\n    if (planets[i] == planet1) {\n      idx1 = i;\n    }\n    if (planets[i]\
    \ == planet2) {\n      idx2 = i;\n    }\n  }\n  std::vector<std::string> result;\n\
    \  if (idx1 == -1 || idx2 == -1) {\n    return std::make_tuple(result.begin(),\
    \ result.end());\n  }\n  int min = std::min(idx1, idx2);\n  int max = std::max(idx1,\
    \ idx2);\n  for (int i = min + 1; i < max; i++) {\n    result.push_back(planets[i]);\n\
    \  }\n  return std::make_tuple(result.begin(), result.end());", "\t// YOUR CODE\
    \ GOES HERE", "    std::vector<std::string> planets = {\n        \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \n    };\n    return make_tuple();", "    std::vector<std::string> planets;\n\
    \    if (planet1 == \"Mercury\") {\n        if (planet2 == \"Mercury\") {\n  \
    \          planets.push_back(\"Mercury\");\n        } else if (planet2 == \"Venus\"\
    ) {\n            planets.push_back(\"Mercury\");\n            planets.push_back(\"\
    Venus\");\n        } else if (planet2 == \"Earth\") {\n            planets.push_back(\"\
    Mercury\");\n            planets.push_back(\"Venus\");\n            planets.push_back(\"\
    Earth\");\n        } else if (planet2 == \"Mars\") {\n            planets.push_back(\"\
    Mercury\");\n            planets.push_back(\"Venus\");\n            planets.push_back(\"\
    Earth\");\n            planets.push_back(\"Mars\");\n        } else if (planet2\
    \ == \"Jupiter\") {\n            planets.push_back(\"Mercury\");\n           \
    \ planets.push_back(\"Venus\");\n            planets.push_back(\"Earth\");\n \
    \           planets.push_back(\"Mars\");\n            planets.push_back(\"Jupiter\"\
    );\n        } else if (planet2 == \"Saturn\") {\n            planets.push_back(\"\
    Mercury\");\n            planets.push_back(\"Venus\");\n            planets.push_back(\"\
    Earth\");\n            planets.push_back(\"Mars\");\n            planets.push_back(\"\
    Jupiter\");\n            planets.push_back(\"Saturn\");\n        } else if (planet2\
    \ == \"Uranus\") {\n            planets.push_back(\"Mercury\");\n            planets.push_back(\"\
    Venus\");\n            planets.push_back(\"Earth\");\n            planets.push_back(\"\
    Mars\");\n            planets.push_back(\"Jupiter\");\n            planets.push_back(\"\
    Saturn\");\n            planets.push_back(\"Uranus\");\n        } else if (planet2\
    \ == \"Neptune\") {\n            planets.push_back(\"Mercury\");\n           \
    \ planets.push_back(\"Venus\");\n            planets.push_back(\"Earth\");\n \
    \           planets.push_back(\"Mars\");\n            planets.push_back(\"Jupiter\"\
    );\n            planets.push_back(\"Saturn\");\n            planets.push_back(\"\
    Uranus\");\n           ", "  std::vector<std::string> planetList;\n  // Your code\
    \ here.\n  return {};", "\t//write your code here\n\t", "  const std::map<std::string,\
    \ int> planets {\n    {\"Mercury\", 1},\n    {\"Venus\", 2},\n    {\"Earth\",\
    \ 3},\n    {\"Mars\", 4},\n    {\"Jupiter\", 5},\n    {\"Saturn\", 6},\n    {\"\
    Uranus\", 7},\n    {\"Neptune\", 8}\n  };\n  const auto begin = planets.find(planet1);\n\
    \  const auto end = planets.find(planet2);\n  if (begin == planets.end() || end\
    \ == planets.end()) {\n    return {};\n  }\n  const int min = std::min(begin->second,\
    \ end->second);\n  const int max = std::max(begin->second, end->second);\n  std::vector<std::string>\
    \ planetsBetween;\n  for (const auto& planet : planets) {\n    if (planet.second\
    \ > min && planet.second < max) {\n      planetsBetween.push_back(planet.first);\n\
    \    }\n  }\n  return std::make_tuple(planetsBetween[0], planetsBetween[1]);",
  "\tstd::unordered_map<std::string, int> solar_system = {\n\t\t{ \"Mercury\", 1 },\n\
    \t\t{ \"Venus\", 2 },\n\t\t{ \"Earth\", 3 },\n\t\t{ \"Mars\", 4 },\n\t\t{ \"Jupiter\"\
    , 5 },\n\t\t{ \"Saturn\", 6 },\n\t\t{ \"Uranus\", 7 },\n\t\t{ \"Neptune\", 8 }\n\
    \t};\n\tif (solar_system.find(planet1) == solar_system.end() || solar_system.find(planet2)\
    \ == solar_system.end()) {\n\t\treturn {};\n\t}\n\tstd::vector<std::string> names\
    \ = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\" };\n\tstd::tuple<std::string, > res;\n\tint start = std::min(solar_system[planet1],\
    \ solar_system[planet2]);\n\tint end = std::max(solar_system[planet1], solar_system[planet2]);\n\
    \tfor (int i = start; i <= end; i++) {\n\t\tres.push_back(names[i - 1]);\n\t}\n\
    \treturn res;", '  return std::make_tuple();', "    std::vector<std::string> planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \n                         \
    \               \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1\
    \ = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(),\
    \ planets.end(), planet2);\n    if (it1 != planets.end() && it2 != planets.end())\
    \ {\n        auto low = std::min(it1, it2);\n        auto high = std::max(it1,\
    \ it2);\n        std::vector<std::string> ret(low + 1, high);\n        return\
    \ ret;\n    }\n    return {};", "    // your code here\n    std::tuple<std::string,\
    \ > result;\n    return result;", "\treturn std::make_tuple();", '    ', "  std::unordered_map<std::string,\
    \ int> planets = \n  {\n      {\"Mercury\", 0},\n      {\"Venus\", 1},\n     \
    \ {\"Earth\", 2},\n      {\"Mars\", 3},\n      {\"Jupiter\", 4},\n      {\"Saturn\"\
    , 5},\n      {\"Uranus\", 6},\n      {\"Neptune\", 7}\n  };\n  \n  std::vector<std::string>\
    \ result;\n  if(planets.find(planet1) == planets.end() || planets.find(planet2)\
    \ == planets.end())\n  {\n    return std::make_tuple();\n  }\n  else\n  {\n  \
    \  int first = planets[planet1];\n    int second = planets[planet2];\n    if(first\
    \ > second)\n    {\n      int temp = first;\n      first = second;\n      second\
    \ = temp;\n    }\n    for(int i = first + 1; i < second; i++)\n    {\n      result.push_back(planets.find(i)->first);\n\
    \    }\n  }\n  std::tuple<std::string, > res;\n  return res;", "\t// Good luck!",
  "    if (planet1 == \"Mercury\") {\n        if (planet2 == \"Venus\") return std::make_tuple(\"\
    Mercury\", \"Venus\");\n        if (planet2 == \"Earth\") return std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\");\n        if (planet2 == \"Mars\") return std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\");\n        if (planet2 == \"Jupiter\"\
    ) return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    );\n        if (planet2 == \"Saturn\") return std::make_tuple(\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n        if (planet2 ==\
    \ \"Uranus\") return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\");\n        if (planet2 == \"Neptune\") return\
    \ std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\");\n    }\n    if (planet1 == \"Venus\") {\n\
    \        if (planet2 == \"Earth\") return std::make_tuple(\"Venus\", \"Earth\"\
    );\n        if (planet2 == \"Mars\") return std::make_tuple(\"Venus\", \"Earth\"\
    , \"Mars\");\n        if (planet2 == \"Jupiter\") return std::make_tuple(\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\");\n        if (planet2 == \"Saturn\") return\
    \ std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n\
    \        if (planet2 == \"Uranus\") return std::make_tuple(\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n        if (planet2 == \"Neptune\"\
    ) return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\");\n    }\n    if (planet1 == \"Earth\") {\n        if\
    \ (planet", '  ', "    std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::tuple<std::string,>\
    \ ret_val;\n    return ret_val;", '', '    // your code here', '  return {};',
  "\t//SOLUTION GOES HERE\n\tstd::vector<std::string> planets = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\t\
    std::tuple<std::string, > result;\n\tint i1 = -1, i2 = -1;\n\tfor (int i = 0;\
    \ i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\ti1 = i;\n\
    \t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\ti2 = i;\n\t\t}\n\t}\n\tif (i1 ==\
    \ -1 || i2 == -1) {\n\t\treturn result;\n\t}\n\tif (i1 < i2) {\n\t\ti1++;\n\t\t\
    while (i1 < i2) {\n\t\t\tstd::get<0>(result) = planets[i1];\n\t\t\ti1++;\n\t\t\
    }\n\t} else {\n\t\ti2++;\n\t\twhile (i2 < i1) {\n\t\t\tstd::get<0>(result) = planets[i2];\n\
    \t\t\ti2++;\n\t\t}\n\t}\n\treturn result;", "\t", '  // your code here', "\tstd::tuple<std::string,\
    \ > res;\n\treturn res;", "    std::vector<std::string> planets{\n        \"Mercury\"\
    ,\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\"\
    ,\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    };\n   \
    \ int p1 = std::find(planets.begin(), planets.end(), planet1) - planets.begin();\n\
    \    int p2 = std::find(planets.begin(), planets.end(), planet2) - planets.begin();\n\
    \    if (p1 == 8 || p2 == 8) {\n        return std::make_tuple();\n    }\n   \
    \ if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    std::tuple<std::string,\
    \ > result;\n    for (int i = p1 + 1; i < p2; ++i) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;", "    std::vector<std::string> vec;\n    vec.push_back(\"\
    Mercury\");\n    vec.push_back(\"Venus\");\n    vec.push_back(\"Earth\");\n  \
    \  vec.push_back(\"Mars\");\n    vec.push_back(\"Jupiter\");\n    vec.push_back(\"\
    Saturn\");\n    vec.push_back(\"Uranus\");\n    vec.push_back(\"Neptune\");\n\
    \    if(find(vec.begin(), vec.end(), planet1) != vec.end()){\n        if(find(vec.begin(),\
    \ vec.end(), planet2) != vec.end()){\n            int one = find(vec.begin(),\
    \ vec.end(), planet1) - vec.begin();\n            int two = find(vec.begin(),\
    \ vec.end(), planet2) - vec.begin();\n            std::tuple<std::string, > res;\n\
    \            if(one > two){\n                return res;\n            }\n    \
    \        while(one <= two){\n                res = std::tuple_cat(res, std::make_tuple(vec[one]));\n\
    \                one++;\n            }\n            return res;\n        }\n \
    \   }\n    std::tuple<std::string, > res;\n    return res;", '    // your code
    here', '    // Write your code here', '    ', "\t// your code here\n\treturn std::make_tuple();",
  '    // your code here', "    std::tuple<std::string, > ans;\n    return ans;",
  "\tstd::unordered_map<std::string, int> plan = {\n\t{\"Mercury\",1},\n\t{\"Venus\"\
    ,2},\n\t{\"Earth\",3},\n\t{\"Mars\",4},\n\t{\"Jupiter\",5},\n\t{\"Saturn\",6},\n\
    \t{\"Uranus\",7},\n\t{\"Neptune\",8}\n\t};\n\tstd::vector<std::string> v;\n\t\
    int n1 = plan[planet1];\n\tint n2 = plan[planet2];\n\tstd::unordered_map<int,\
    \ std::string> planet;\n\tstd::vector<std::string> reverse;\n\tif(n1 > n2){\n\t\
    \tfor(auto i : plan){\n\t\t\tif(i.second >= n2 && i.second <= n1){\n\t\t\t\tplanet[i.second]\
    \ = i.first;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n2; i <= n1; i++){\n\t\t\treverse.push_back(planet[i]);\n\
    \t\t}\n\t}\n\telse if(n1 < n2){\n\t\tfor(auto i : plan){\n\t\t\tif(i.second >=\
    \ n1 && i.second <= n2){\n\t\t\t\tplanet[i.second] = i.first;\n\t\t\t}\n\t\t}\n\
    \t\tfor(int i = n1; i <= n2; i++){\n\t\t\treverse.push_back(planet[i]);\n\t\t\
    }\n\t}\n\tif(reverse.size() == 0){\n\t\treturn {};\n\t}\n\tstd::tuple<std::string,\
    \ std::string, std::string, std::string, std::string, std::string, std::string>\
    \ t{reverse[0], reverse[1], reverse[2], reverse[3], reverse[4], reverse[5], reverse[6]};\n\
    \treturn t;", "    std::string planets[] = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string>\
    \ vp(std::begin(planets), std::end(planets));\n    int pos1 = std::find(vp.begin(),\
    \ vp.end(), planet1) - vp.begin();\n    int pos2 = std::find(vp.begin(), vp.end(),\
    \ planet2) - vp.begin();\n    if (pos1 == vp.size() || pos2 == vp.size())\n  \
    \      return std::make_tuple();\n    if (pos1 > pos2) {\n        std::reverse(vp.begin()\
    \ + pos2, vp.begin() + pos1 + 1);\n        return std::make_tuple(vp.begin() +\
    \ pos2, vp.begin() + pos1 + 1);\n    }\n    else {\n        return std::make_tuple(vp.begin()\
    \ + pos1, vp.begin() + pos2 + 1);\n    }", "    std::map<std::string, int> planets\
    \ = {{\"Mercury\", 1},\n                                          {\"Venus\",\
    \ 2},\n                                          {\"Earth\", 3},\n           \
    \                               {\"Mars\", 4},\n                             \
    \             {\"Jupiter\", 5},\n                                          {\"\
    Saturn\", 6},\n                                          {\"Uranus\", 7},\n  \
    \                                        {\"Neptune\", 8}};\n    std::vector<std::string>\
    \ solarsystem = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n  \
    \  int p1 = planets[planet1];\n    int p2 = planets[planet2];\n    if (p1 == 0\
    \ || p2 == 0) {\n        return std::make_tuple();\n    }\n    if (p1 > p2) {\n\
    \        std::swap(p1, p2);\n    }\n    for (int i = p1; i <= p2; i++) {\n   \
    \     result.push_back(solarsystem[i - 1]);\n    }\n    return std::make_tuple(result[0],\
    \ result[1], result[2], result[3], result[4], result[5]);", "\t//write your code\
    \ here", "    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \n                                        \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int i =\
    \ 0;\n    for (; i < planets.size(); i++)\n        if (planets[i] == planet1)\n\
    \            break;\n    if (i == planets.size())\n        return std::make_tuple();\n\
    \    for (int j = 0; j < planets.size(); j++)\n        if (planets[j] == planet2)\n\
    \            i = j;\n    if (i == planets.size())\n        return std::make_tuple();\n\
    \    for (int j = i + 1; j < planets.size(); j++)\n        result.push_back(planets[j]);\n\
    \    return std::make_tuple(result);", "  std::vector<std::string> v = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> a;\n  std::tuple<std::string, > b;\n  std::vector<std::string>::iterator\
    \ it, it2;\n  for(int i = 0; i < 8; i++){\n      if(v[i] == planet1) it = v.begin()\
    \ + i;\n      if(v[i] == planet2) it2 = v.begin() + i;\n  }\n  std::sort(it, it2);\n\
    \  if(it > it2) std::reverse(it, it2);\n  return b;", "\t//TODO", "    std::vector<std::string>\
    \ planets;\n    planets.push_back(\"Mercury\");\n    planets.push_back(\"Venus\"\
    );\n    planets.push_back(\"Earth\");\n    planets.push_back(\"Mars\");\n    planets.push_back(\"\
    Jupiter\");\n    planets.push_back(\"Saturn\");\n    planets.push_back(\"Uranus\"\
    );\n    planets.push_back(\"Neptune\");\n    auto start_idx = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto end_idx = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    std::tuple<std::string, > t;\n    return t;", "\tconst char *\
    \ planets[8] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\t// check if the planet names are valid\n\tbool\
    \ exists1 = false;\n\tbool exists2 = false;\n\tfor (int i = 0; i < 8; i++) {\n\
    \t\tif (planet1 == planets[i]) {\n\t\t\texists1 = true;\n\t\t}\n\t\tif (planet2\
    \ == planets[i]) {\n\t\t\texists2 = true;\n\t\t}\n\t}\n\t// Return an empty tuple\
    \ if planet1 or planet2 are not correct planet names.\n\tif (!exists1 || !exists2)\
    \ {\n\t\treturn std::make_tuple();\n\t}\n\t// Find the starting index and ending\
    \ index\n\tint start_index = -1;\n\tint end_index = -1;\n\tfor (int i = 0; i <\
    \ 8; i++) {\n\t\tif (planet1 == planets[i]) {\n\t\t\tstart_index = i;\n\t\t}\n\
    \t\tif (planet2 == planets[i]) {\n\t\t\tend_index = i;\n\t\t}\n\t}\n\t// check\
    \ if start_index > end_index\n\t// if so, swap them\n\tif (start_index > end_index)\
    \ {\n\t\tint temp = start_index;\n\t\tstart_index = end_index;\n\t\tend_index\
    \ = temp;\n\t}\n\t// Create a vector to store result\n\tstd::vector<std::string>\
    \ res;\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tres.push_back(planets[i]);\n\
    \t}\n\treturn std::make_tuple(res);", "    std::vector<std::string> planets =\
    \ {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"};\n    std::vector<std::string> ans;\n    bool start = false;\n\
    \    bool end = false;\n    for (int i = 0; i < planets.size(); i++) {\n     \
    \   if (planets[i] == planet1) {\n            start = true;\n        }\n     \
    \   if (planets[i] == planet2) {\n            end = true;\n        }\n       \
    \ if (start) {\n            ans.push_back(planets[i]);\n        }\n        if\
    \ (end) {\n            break;\n        }\n    }\n    std::tuple<std::string, >\
    \ result;\n    for (int i = 0; i < ans.size(); i++) {\n        std::get<i>(result)\
    \ = ans[i];\n    }\n    return result;", "    std::tuple<std::string, > res;\n\
    \    // insert your code here\n    return res;", '    ', "  // Write your code\
    \ here\n  int position_of_planet1 = 0;\n  int position_of_planet2 = 0;\n  std::string\
    \ array_of_planets[8] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"};\n  for(int i = 0; i < 8; i++) {\n    if(array_of_planets[i]\
    \ == planet1) {\n      position_of_planet1 = i;\n    }\n    if(array_of_planets[i]\
    \ == planet2) {\n      position_of_planet2 = i;\n    }\n  }\n  std::tuple<std::string,\
    \ > list_of_planets_between;\n  if(position_of_planet1 > position_of_planet2)\
    \ {\n    for(int i = position_of_planet2 + 1; i < position_of_planet1; i++) {\n\
    \      list_of_planets_between.push_back(array_of_planets[i]);\n    }\n  } else\
    \ {\n    for(int i = position_of_planet1 + 1; i < position_of_planet2; i++) {\n\
    \      list_of_planets_between.push_back(array_of_planets[i]);\n    }\n  }\n \
    \ return list_of_planets_between;", "    static const std::vector<std::string>\
    \ solar_system = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"};\n    static const std::unordered_map<std::string,\
    \ int> solar_system_num_to_index = {\n        {\"Mercury\", 0},\n        {\"Venus\"\
    , 1},\n        {\"Earth\", 2},\n        {\"Mars\", 3},\n        {\"Jupiter\",\
    \ 4},\n        {\"Saturn\", 5},\n        {\"Uranus\", 6},\n        {\"Neptune\"\
    , 7}\n    };\n    int planet1_index = solar_system_num_to_index.find(planet1)->second;\n\
    \    int planet2_index = solar_system_num_to_index.find(planet2)->second;\n  \
    \  std::string planet1_name = solar_system[planet1_index];\n    std::string planet2_name\
    \ = solar_system[planet2_index];\n    int start_index = std::min(planet1_index,\
    \ planet2_index);\n    int end_index = std::max(planet1_index, planet2_index);\n\
    \    std::vector<std::string> planets;\n    for (int i = start_index + 1; i <\
    \ end_index; i++) {\n        planets.push_back(solar_system[i]);\n    }\n    return\
    \ std::make_tuple(planets);", "    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string>::iterator it1 = std::find(planets.begin(), planets.end(),\
    \ planet1);\n    std::vector<std::string>::iterator it2 = std::find(planets.begin(),\
    \ planets.end(), planet2);\n    if (it1 == planets.end() || it2 == planets.end())\n\
    \        return std::make_tuple();\n    else if (it1 < it2)\n        return std::make_tuple(*it1);\n\
    \    else\n        return std::make_tuple(*it2);", '  ', "    // your code here\n\
    \    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    std::cout << p1 << \" \" <<\
    \ p2 << std::endl;\n    if (p1 == 8 || p2 == 8) {\n        return std::make_tuple();\n\
    \    }\n    std::vector<std::string> res;\n    if (p1 > p2) {\n        std::swap(p1,\
    \ p2);\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return std::make_tuple(res);", "  const std::vector<std::string> planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n    \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  std::tuple<std::string, > result;\n  int idx1 =\
    \ -1, idx2 = -1;\n  for (int i = 0; i < planets.size(); i++) {\n    if (planets[i]\
    \ == planet1) idx1 = i;\n    if (planets[i] == planet2) idx2 = i;\n  }\n  if (idx1\
    \ > idx2) std::swap(idx1, idx2);\n  if (idx1 < 0 || idx2 < 0) return result;\n\
    \  for (int i = idx1 + 1; i < idx2; i++)\n    result = std::tuple_cat(result,\
    \ std::make_tuple(planets[i]));\n  return result;", "  std::vector<std::string>\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n  std::vector<std::string>::iterator it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n  std::vector<std::string>::iterator it2 = std::find(planets.begin(),\
    \ planets.end(), planet2);\n  if(it1 == planets.end() || it2 == planets.end())\n\
    \  {\n    return std::make_tuple();\n  }\n  if(it1 > it2)\n  {\n    std::vector<std::string>::iterator\
    \ temp = it1;\n    it1 = it2;\n    it2 = temp;\n  }\n  it1++;\n  std::vector<std::string>\
    \ res(it1, it2);\n  return std::make_tuple(res[0], res[1], res[2], res[3], res[4]);",
  "  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::string* it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n  std::string* it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n  std::vector<std::string> res;\n  if (it1 > it2) {\n    std::swap(it1,\
    \ it2);\n  }\n  std::copy(it1, it2, std::back_inserter(res));\n  return std::make_tuple(res);",
  "  std::map<std::string, int> m = {{\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\"\
    , 3}, {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\"\
    , 8}};\n  std::vector<std::string> v = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  if (m.find(planet1)\
    \ == m.end() || m.find(planet2) == m.end()) {\n    return std::make_tuple();\n\
    \  }\n  if (m[planet1] > m[planet2]) {\n    return std::make_tuple();\n  }\n \
    \ std::vector<std::string> ans;\n  for (int i = m[planet1] - 1; i < m[planet2]\
    \ - 1; i++) {\n    ans.push_back(v[i]);\n  }\n  return std::make_tuple(ans[0],\
    \ ans[1], ans[2], ans[3], ans[4]);", "\t", '    return std::make_tuple<std::string,
    >("Venus");', "    auto p1 = distance(begin(planets), find(begin(planets), end(planets),\
    \ planet1));\n    auto p2 = distance(begin(planets), find(begin(planets), end(planets),\
    \ planet2));\n    if (p1 == p2 || p1 == 8 || p2 == 8) return {};\n    if (p1 >\
    \ p2) swap(p1, p2);\n    return make_tuple(planets[p1 + 1], planets[p2 - 1]);",
  "    std::tuple<std::string, > t;\n    return t;", "    std::vector<std::string>\
    \ planets = {\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"\n    };\n    int pos1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int pos2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (pos1 == -1 || pos2 == -1)\
    \ return {};\n    std::vector<std::string> ans;\n    if (pos1 > pos2) {\n    \
    \    for (int i = pos2 + 1; i < pos1; i++) {\n            ans.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = pos1 + 1; i < pos2; i++) {\n  \
    \          ans.push_back(planets[i]);\n        }\n    }\n    return std::make_tuple(ans[0],\
    \ ans[1], ans[2], ans[3], ans[4]);", '  return {"", };', "  // your code here\n\
    \  std::tuple<std::string, > no_planet;\n  if(planet1 == \"Mercury\"){\n    if(planet2\
    \ == \"Mercury\"){\n      return no_planet;\n    }else if(planet2 == \"Venus\"\
    ){\n      return no_planet;\n    }else if(planet2 == \"Earth\"){\n      return\
    \ no_planet;\n    }else if(planet2 == \"Mars\"){\n      return no_planet;\n  \
    \  }else if(planet2 == \"Jupiter\"){\n      return no_planet;\n    }else if(planet2\
    \ == \"Saturn\"){\n      return no_planet;\n    }else if(planet2 == \"Uranus\"\
    ){\n      return no_planet;\n    }else if(planet2 == \"Neptune\"){\n      return\
    \ no_planet;\n    }else{\n      return no_planet;\n    }\n  }else if(planet1 ==\
    \ \"Venus\"){\n    if(planet2 == \"Mercury\"){\n      return std::make_tuple(\"\
    Venus\");\n    }else if(planet2 == \"Venus\"){\n      return no_planet;\n    }else\
    \ if(planet2 == \"Earth\"){\n      return no_planet;\n    }else if(planet2 ==\
    \ \"Mars\"){\n      return no_planet;\n    }else if(planet2 == \"Jupiter\"){\n\
    \      return no_planet;\n    }else if(planet2 == \"Saturn\"){\n      return no_planet;\n\
    \    }else if(planet2 == \"Uranus\"){\n      return no_planet;\n    }else if(planet2\
    \ == \"Neptune\"){\n      return no_planet;\n    }else{\n      return no_planet;\n\
    \    }\n  }else if(planet1 == \"Earth\"){\n    if(planet2 == \"Mercury\"){\n \
    \     return std::make_tuple(\"Venus\", \"Earth\");\n    }else if(planet2 == \"\
    Venus\"){\n      return std::make_tuple(\"Venus\");\n    }else if(planet2 == \"\
    Earth\"){\n      return no_planet;\n    }else if(planet2", "    std::vector<std::string>\
    \ planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" };\n    std::map<std::string, int> planet_index;\n \
    \   for (int i = 0; i < planets.size(); i++) {\n        planet_index[planets[i]]\
    \ = i;\n    }\n    if (planet_index.find(planet1) == planet_index.end() || planet_index.find(planet2)\
    \ == planet_index.end()) {\n        return std::make_tuple<std::string>();\n \
    \   }\n    std::string& first = planet_index[planet1] < planet_index[planet2]\
    \ ? planet1 : planet2;\n    std::string& second = planet_index[planet1] < planet_index[planet2]\
    \ ? planet2 : planet1;\n    std::tuple<std::string, > ret;\n    for (int i = planet_index[first]\
    \ + 1; i < planet_index[second]; i++) {\n        ret.push_back(planets[i]);\n\
    \    }\n    return ret;", '  // Your code here', '', "  \n  std::vector<std::string>\
    \ planets = { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\" };\n  std::vector<std::string> result;\n  if( std::find(planets.begin(),\
    \ planets.end(), planet1) == planets.end() ||\n      std::find(planets.begin(),\
    \ planets.end(), planet2) == planets.end() ) return {};\n  int start = -1, end\
    \ = -1;\n  int n = planets.size();\n  for(int i = 0; i < n; i++) {\n    if(planets[i]\
    \ == planet1) start = i;\n    if(planets[i] == planet2) end = i;\n  }\n  if(start\
    \ > end) std::swap(start, end);\n  for(int i = start + 1; i < end; i++) {\n  \
    \  result.push_back(planets[i]);\n  }\n  return {result.begin(), result.end()};",
  "    const std::vector<std::string> planets{ \"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n    std::tuple<std::string,\
    \ > res;\n    int idx1 = -1, idx2 = -1;\n    for (int i = 0; i < planets.size();\
    \ i++) {\n        if (planets[i] == planet1) idx1 = i;\n        if (planets[i]\
    \ == planet2) idx2 = i;\n    }\n    if (idx1 != -1 && idx2 != -1) {\n        std::vector<std::string>\
    \ t;\n        if (idx1 > idx2) std::swap(idx1, idx2);\n        for (int i = idx1\
    \ + 1; i < idx2; i++) t.push_back(planets[i]);\n        std::sort(t.begin(), t.end());\n\
    \        res = std::make_tuple(t[0], t[1], t[2], t[3], t[4]);\n    }\n    return\
    \ res;", "\tstd::map<std::string, int> planet_map;\n\tplanet_map[\"Mercury\"]\
    \ = 1;\n\tplanet_map[\"Venus\"] = 2;\n\tplanet_map[\"Earth\"] = 3;\n\tplanet_map[\"\
    Mars\"] = 4;\n\tplanet_map[\"Jupiter\"] = 5;\n\tplanet_map[\"Saturn\"] = 6;\n\t\
    planet_map[\"Uranus\"] = 7;\n\tplanet_map[\"Neptune\"] = 8;\n\tif (planet_map.find(planet1)\
    \ == planet_map.end() || planet_map.find(planet2) == planet_map.end())\n\t\treturn\
    \ std::make_tuple();\n\tauto planet1_idx = planet_map[planet1];\n\tauto planet2_idx\
    \ = planet_map[planet2];\n\tstd::vector<std::string> ret_planets;\n\tstd::vector<std::string>\
    \ planet_names{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n\tif (planet1_idx < planet2_idx) {\n\t\tfor (auto\
    \ i = planet1_idx; i < planet2_idx; ++i)\n\t\t\tret_planets.push_back(planet_names[i]);\n\
    \t} else {\n\t\tfor (auto i = planet2_idx; i < planet1_idx; ++i)\n\t\t\tret_planets.push_back(planet_names[i]);\n\
    \t}\n\treturn std::make_tuple(ret_planets);", "    std::map<std::string, int>\
    \ planet_map;\n    planet_map[\"Mercury\"] = 1;\n    planet_map[\"Venus\"] = 2;\n\
    \    planet_map[\"Earth\"] = 3;\n    planet_map[\"Mars\"] = 4;\n    planet_map[\"\
    Jupiter\"] = 5;\n    planet_map[\"Saturn\"] = 6;\n    planet_map[\"Uranus\"] =\
    \ 7;\n    planet_map[\"Neptune\"] = 8;\n    std::tuple<std::string, > res;\n \
    \   if (planet_map.find(planet1) == planet_map.end() or planet_map.find(planet2)\
    \ == planet_map.end()) {\n        return res;\n    }\n    if (planet_map[planet1]\
    \ < planet_map[planet2]) {\n        std::swap(planet1, planet2);\n    }\n    for\
    \ (auto it = planet_map.begin(); it != planet_map.end(); it++) {\n        if (it->second\
    \ > planet_map[planet1] and it->second < planet_map[planet2]) {\n            res\
    \ = std::tuple_cat(res, std::make_tuple(it->first));\n        }\n    }\n    return\
    \ res;", "    std::tuple<std::string, > answer;\n    // Your code here\n    return\
    \ answer;", '    // your code', '    // your code here']
stop_tokens:
- "\n}"
