name: HumanEval_127_intersection
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n\
  // where each interval is a pair of integers. For example, interval = (start, end)\
  \ = (1, 2).\n// The given intervals are closed which means that the interval (start,\
  \ end)\n// includes both start and end.\n// For each given interval, it is assumed\
  \ that its start is less or equal its end.\n// Your task is to determine whether\
  \ the length of intersection of these two \n// intervals is a prime number.\n//\
  \ Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which\
  \ its length is 1, which not a prime number.\n// If the length of the intersection\
  \ is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two\
  \ intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// intersection((1,\
  \ 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==> \"NO\"\n// intersection((-3,\
  \ -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long, long> interval1,\
  \ std::tuple<long, long> interval2) {\n"
tests: "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1,\
  \ 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1,\
  \ 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3,\
  \ -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2,\
  \ 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11,\
  \ 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
  \ 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1,\
  \ 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2,\
  \ -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
completions: ["    // TODO your code here\n    int start1 = std::get<0>(interval1);\n\
    \    int end1 = std::get<1>(interval1);\n    int start2 = std::get<0>(interval2);\n\
    \    int end2 = std::get<1>(interval2);\n    if (start1 < start2) {\n        if\
    \ (end1 < start2) {\n            return \"NO\";\n        } else {\n          \
    \  if (end1 <= end2) {\n                int length = end1 - start2 + 1;\n    \
    \            if (length > 1) {\n                    bool isPrime = true;\n   \
    \                 for (int i = 2; i < length; i++) {\n                       \
    \ if (length % i == 0) {\n                            isPrime = false;\n     \
    \                       break;\n                        }\n                  \
    \  }\n                    if (isPrime) {\n                        return \"YES\"\
    ;\n                    } else {\n                        return \"NO\";\n    \
    \                }\n                } else {\n                    return \"NO\"\
    ;\n                }\n            } else {\n                int length = end2\
    \ - start2 + 1;\n                if (length > 1) {\n                    bool isPrime\
    \ = true;\n                    for (int i = 2; i < length; i++) {\n          \
    \              if (length % i == 0) {\n                            isPrime = false;\n\
    \                            break;\n                        }\n             \
    \       }\n                    if (isPrime) {\n                        return\
    \ \"YES\";\n                    } else {\n                        return \"NO\"\
    ;\n                    }\n                } else {\n                    return\
    \ \"NO\";\n                }\n            }\n        }\n    } else {\n       \
    \ if (end2 < start1) {\n            return \"NO\";\n        } else {\n       \
    \     if (end2 <= end1) {\n                int length = end2 - start1 + 1;\n \
    \               if (length > 1) {\n                    bool isPrime = true;\n\
    \                    for (int i = 2; i < length; i++) {\n                    \
    \    if (length % i == 0) {\n                            isPrime = false;\n  \
    \                          break;\n                        }\n               \
    \     }\n                    if (isPrime) {\n                        return \"\
    YES\";\n                    } else {\n                        return \"NO\";\n\
    \                    }\n                } else {\n                   ", "    auto\
    \ [start1, end1] = interval1;\n    auto [start2, end2] = interval2;\n    // if\
    \ the two intervals don't intersect\n    if (end1 < start2 || end2 < start1) {\n\
    \        return \"NO\";\n    }\n    auto intersection_start = std::max(start1,\
    \ start2);\n    auto intersection_end = std::min(end1, end2);\n    auto intersection_length\
    \ = intersection_end - intersection_start + 1;\n    if (intersection_length ==\
    \ 1) {\n        return \"NO\";\n    }\n    auto upper_bound = std::sqrt(intersection_length);\n\
    \    for (auto i = 2; i <= upper_bound; ++i) {\n        if (intersection_length\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;", "    auto result = std::make_tuple(std::max(std::get<0>(interval1), std::get<0>(interval2)),\n\
    \                                  std::min(std::get<1>(interval1), std::get<1>(interval2)));\n\
    \    auto difference = std::get<1>(result) - std::get<0>(result);\n    if (difference\
    \ < 0) {\n        return \"NO\";\n    }\n    for (int i = 2; i < difference; i++)\
    \ {\n        if (difference % i == 0) {\n            return \"NO\";\n        }\n\
    \    }\n    return \"YES\";", "\tauto a = std::get<0>(interval1);\n\tauto b =\
    \ std::get<1>(interval1);\n\tauto c = std::get<0>(interval2);\n\tauto d = std::get<1>(interval2);\n\
    \t// {a, b} {c, d}\n\t// if they do not intersect\n\tif (b < c || d < a) {\n\t\
    \treturn \"NO\";\n\t}\n\tauto intersect = std::min(b, d) - std::max(a, c) + 1;\n\
    \tif (intersect == 1) {\n\t\treturn \"NO\";\n\t}\n\tif (intersect == 2) {\n\t\t\
    return \"YES\";\n\t}\n\t// check if it is a prime number\n\t// only need to check\
    \ for divisibility upto the square root of the number\n\tauto sqrt_intersect =\
    \ sqrt(intersect);\n\tfor (auto i = 2; i <= sqrt_intersect; ++i) {\n\t\tif (intersect\
    \ % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\treturn \"YES\";", "    long\
    \ start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    long start3 = max(start1, start2);\n    long end3 = min(end1, end2);\n  \
    \  if (start3 > end3) {\n        return \"NO\";\n    }\n    long diff = end3 -\
    \ start3 + 1;\n    if (diff == 1) {\n        return \"NO\";\n    }\n    for (long\
    \ i = 2; i < diff; i++) {\n        if (diff % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";", "    //0. Find intersection start,\
    \ end\n    long a_start = std::get<0>(interval1);\n    long a_end = std::get<1>(interval1);\n\
    \    long b_start = std::get<0>(interval2);\n    long b_end = std::get<1>(interval2);\n\
    \    long intersection_start = std::max(a_start, b_start);\n    long intersection_end\
    \ = std::min(a_end, b_end);\n    if (intersection_start > intersection_end) {\n\
    \        return \"NO\";\n    }\n    //1. Check if prime\n    std::vector<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n    if (std::find(primes.begin(), primes.end(),\
    \ intersection_end - intersection_start + 1) != primes.end()) {\n        return\
    \ \"YES\";\n    }\n    return \"NO\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    long len = end - start;\n    if (len < 0) {\n        return \"NO\";\n   \
    \ }\n    if (len <= 2) {\n        return \"NO\";\n    }\n    for (long i = 2;\
    \ i < len; i++) {\n        if (len % i == 0) {\n            return \"NO\";\n \
    \       }\n    }\n    return \"YES\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) return \"NO\";\n    std::vector<bool> is_prime(end - start\
    \ + 1, true);\n    for (int i = 2; i * i <= end; ++i) {\n        for (int j =\
    \ start / i; j * i <= end; ++j) {\n            if (j * i >= start) {\n       \
    \         is_prime[j * i - start] = false;\n            }\n        }\n    }\n\
    \    for (int i = 0; i < is_prime.size(); ++i) {\n        if (is_prime[i]) return\
    \ \"YES\";\n    }\n    return \"NO\";", '    // your code here', "    std::vector<long>\
    \ a;\n    a.push_back(std::get<0>(interval1));\n    a.push_back(std::get<1>(interval1));\n\
    \    a.push_back(std::get<0>(interval2));\n    a.push_back(std::get<1>(interval2));\n\
    \    std::sort(a.begin(), a.end());\n    long l = a[2] - a[1];\n    if (l <= 0)\
    \ return \"NO\";\n    for (long i = 2; i <= l / 2; i++) {\n        if (l % i ==\
    \ 0) return \"NO\";\n    }\n    return \"YES\";", "  std::string res = \"NO\"\
    ;\n  long int s1 = std::get<0>(interval1);\n  long int e1 = std::get<1>(interval1);\n\
    \  long int s2 = std::get<0>(interval2);\n  long int e2 = std::get<1>(interval2);\n\
    \  long int si = std::max(s1, s2);\n  long int ei = std::min(e1, e2);\n  // std::cout\
    \ << si << \" \" << ei << std::endl;\n  if (si <= ei) {\n    long int len = ei\
    \ - si + 1;\n    if (len == 2) {\n      res = \"YES\";\n    } else if (len % 2\
    \ == 1) {\n      bool flag = true;\n      for (long int i = 3; i <= sqrt(len);\
    \ i+=2) {\n        if (len % i == 0) {\n          flag = false;\n          break;\n\
    \        }\n      }\n      if (flag) {\n        res = \"YES\";\n      }\n    }\n\
    \  }\n  return res;", "    bool flag=true;\n    long start1=std::get<0>(interval1);\n\
    \    long end1=std::get<1>(interval1);\n    long start2=std::get<0>(interval2);\n\
    \    long end2=std::get<1>(interval2);\n    long start=std::max(start1,start2);\n\
    \    long end=std::min(end1,end2);\n    if(start>end)\n        return \"NO\";\n\
    \    for(long i=2;i<=sqrt(end-start);i++)\n    {\n        if((end-start)%i==0)\n\
    \        {\n            flag=false;\n            break;\n        }\n    }\n  \
    \  if(flag)\n        return \"YES\";\n    else\n        return \"NO\";", "\tlong\
    \ minStart = std::min(std::get<0>(interval1), std::get<0>(interval2));\n\tlong\
    \ maxEnd = std::max(std::get<1>(interval1), std::get<1>(interval2));\n\tif(minStart\
    \ > maxEnd) return \"NO\";\n\tlong length = maxEnd - minStart + 1;\n\tbool prime\
    \ = true;\n\tfor(long i = 2; i * i <= length; i++) {\n\t\tif(length % i == 0)\
    \ {\n\t\t\tprime = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn prime ? \"YES\"\
    \ : \"NO\";", "    int start, end;\n    bool zero = 0;\n    start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    for (int i = 2; i < end - start + 1; i++) {\n        if ((end - start + 1)\
    \ % i == 0) zero = 1;\n    }\n    if (zero == 0) return \"YES\";\n    else return\
    \ \"NO\";", "    std::vector<long> points;\n    points.push_back(std::get<0>(interval1));\n\
    \    points.push_back(std::get<1>(interval1));\n    points.push_back(std::get<0>(interval2));\n\
    \    points.push_back(std::get<1>(interval2));\n    std::sort(points.begin(),\
    \ points.end());\n    long length = points[2] - points[1];\n    if (length < 0)\
    \ {\n        return \"NO\";\n    }\n    for (long i = 2; i < length; i++) {\n\
    \        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";", "\tstd::vector<int> v;\n\tfor (int i = std::get<0>(interval1);\
    \ i <= std::get<1>(interval1); i++)\n\t\tv.push_back(i);\n\tfor (int i = std::get<0>(interval2);\
    \ i <= std::get<1>(interval2); i++)\n\t\tv.push_back(i);\n\tint common = 0;\n\t\
    for (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = i + 1; j < v.size(); j++)\
    \ {\n\t\t\tif (v[i] == v[j]) {\n\t\t\t\tcommon++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\
    \t}\n\t}\n\tif (common == 0) return \"NO\";\n\tfor (int i = 2; i <= common / 2;\
    \ i++) {\n\t\tif (common % i == 0) return \"NO\";\n\t}\n\treturn \"YES\";", "\t\
    int lengthOfIntersection = 0;\n\tint start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\tint end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \tif (start <= end)\n\t\tlengthOfIntersection = end - start + 1;\n\tbool prime\
    \ = true;\n\tfor (int i = 2; i <= sqrt(lengthOfIntersection); i++) {\n\t\tif (lengthOfIntersection\
    \ % i == 0) {\n\t\t\tprime = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (prime)\n\t\
    \treturn \"YES\";\n\telse\n\t\treturn \"NO\";", "\tint start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\tint end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \tstd::string result = \"NO\";\n\tif (start > end) {\n\t\treturn result;\n\t}\n\
    \tif (start == end) {\n\t\tif (start == 1) {\n\t\t\treturn result;\n\t\t}\n\t\t\
    return \"YES\";\n\t}\n\tfor (int num = 2; num < end; num++) {\n\t\tif (end % num\
    \ == 0) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn \"YES\";", "  std::string\
    \ result = \"NO\";\n  long start_1 = std::get<0>(interval1);\n  long end_1 = std::get<1>(interval1);\n\
    \  long start_2 = std::get<0>(interval2);\n  long end_2 = std::get<1>(interval2);\n\
    \  long start = std::max(start_1, start_2);\n  long end = std::min(end_1, end_2);\n\
    \  if (start > end) {\n    return result;\n  }\n  int counter = 0;\n  for (long\
    \ i = 2; i < end; i++) {\n    if (end % i == 0) {\n      counter++;\n    }\n \
    \ }\n  if (counter == 0) {\n    result = \"YES\";\n  }\n  return result;", "\t\
    //declare some variables\n\tlong start, end;\n\t//find the beginning of the intersection\n\
    \tstart = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\t//find\
    \ the end of the intersection\n\tend = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \t//if the start and end variables are the same, it means that there is no intersection\n\
    \tif (start == end) {\n\t\treturn \"NO\";\n\t}\n\t//if the difference between\
    \ the start and end is equal to 1, it means that the difference is equal to 1\n\
    \t//so we can return \"NO\"\n\tif (start - end == 1) {\n\t\treturn \"NO\";\n\t\
    }\n\t//if the difference between the start and end is equal to 0, it means that\
    \ the difference is equal to 0\n\t//so we can return \"NO\"\n\tif (start - end\
    \ == 0) {\n\t\treturn \"NO\";\n\t}\n\t//start with 2, and check if the difference\
    \ between the start and end variables is divisible by\n\t//any number between\
    \ 2 and half of the difference between the start and end variables\n\tfor (long\
    \ i = 2; i <= (start - end) / 2; i++) {\n\t\t//if the difference between the start\
    \ and end variables is divisible by the current i, it means that\n\t\t//the length\
    \ of the intersection is not a prime number, so we can return \"NO\"\n\t\tif ((start\
    \ - end) % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\t//if none of the conditions\
    \ above is met, it means that the length of the intersection is a prime number,\n\
    \t//so we can return \"YES\"\n\treturn \"YES\";", "    // add your code here\n\
    \    int start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n \
    \   int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n    int\
    \ diff = end - start;\n    if (diff <= 0) {\n        return \"NO\";\n    }\n \
    \   std::string ans = \"NO\";\n    bool prime = true;\n    for (int i = 2; i <=\
    \ diff / 2; i++) {\n        if (diff % i == 0) {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if (prime) {\n        ans = \"YES\"\
    ;\n    }\n    return ans;", "  if (std::get<0>(interval1) > std::get<1>(interval2)\
    \ ||\n      std::get<0>(interval2) > std::get<1>(interval1)) {\n    return \"\
    NO\";\n  }\n  long max_start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \  long min_end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \  long diff = min_end - max_start;\n  if (diff == 1) {\n    return \"NO\";\n\
    \  }\n  for (long i = 2; i < diff; i++) {\n    if (diff % i == 0) {\n      return\
    \ \"NO\";\n    }\n  }\n  return \"YES\";", "    bool is_prime = true;\n    long\
    \ start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n    long\
    \ end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n    if (start\
    \ > end) {\n        return \"NO\";\n    }\n    long diff = end - start;\n    if\
    \ (diff == 0) {\n        return \"NO\";\n    }\n    for (long i = 2; i <= sqrt(diff);\
    \ i++) {\n        if (diff % i == 0) {\n            is_prime = false;\n      \
    \      break;\n        }\n    }\n    if (is_prime) {\n        return \"YES\";\n\
    \    }\n    return \"NO\";", "  std::tuple<long, long> x = interval1;\n  std::tuple<long,\
    \ long> y = interval2;\n  std::tuple<long, long> inx, iny;\n  // Make sure x is\
    \ the smaller one\n  if (std::get<0>(x) > std::get<0>(y)) {\n    std::tuple<long,\
    \ long> tmp = x;\n    x = y;\n    y = tmp;\n  }\n  long x_size = std::get<1>(x)\
    \ - std::get<0>(x) + 1;\n  long y_size = std::get<1>(y) - std::get<0>(y) + 1;\n\
    \  // If the two intervals don't intersect, return \"NO\".\n  if (std::get<1>(x)\
    \ < std::get<0>(y)) {\n    return \"NO\";\n  }\n  if (std::get<0>(x) >= std::get<0>(y))\
    \ {\n    inx = y;\n  } else {\n    inx = std::make_tuple(std::get<0>(x), std::get<1>(y));\n\
    \  }\n  if (std::get<1>(x) >= std::get<1>(y)) {\n    iny = x;\n  } else {\n  \
    \  iny = std::make_tuple(std::get<0>(y), std::get<1>(x));\n  }\n  long inx_size\
    \ = std::get<1>(inx) - std::get<0>(inx) + 1;\n  long iny_size = std::get<1>(iny)\
    \ - std::get<0>(iny) + 1;\n  if (inx_size == iny_size) {\n    // Do something\
    \ special\n    return \"NO\";\n  }\n  if (x_size == inx_size || y_size == iny_size)\
    \ {\n    return \"NO\";\n  }\n  if (inx_size > iny_size) {\n    return \"YES\"\
    ;\n  }\n  // Calculate the size of the intersection\n  long int_size = std::get<1>(inx)\
    \ - std::get<0", "  auto [start1, end1] = interval1;\n  auto [start2, end2] =\
    \ interval2;\n  if (start1 > end1 || start2 > end2)\n    throw std::invalid_argument(\"\
    invalid interval\");\n  std::vector<long> interval;\n  interval.push_back(start1);\n\
    \  interval.push_back(end1);\n  interval.push_back(start2);\n  interval.push_back(end2);\n\
    \  std::sort(interval.begin(), interval.end());\n  long commonStart = interval[1];\n\
    \  long commonEnd = interval[2];\n  if (commonStart >= commonEnd)\n    return\
    \ \"NO\";\n  long size = commonEnd - commonStart;\n  if (size == 1)\n    return\
    \ \"NO\";\n  // [2, 3]\n  if (size == 2)\n    return \"YES\";\n  if (size == 3)\n\
    \    return \"NO\";\n  long divisor = 3;\n  while (divisor * divisor <= size)\
    \ {\n    if (size % divisor == 0)\n      return \"NO\";\n    divisor += 2;\n \
    \ }\n  return \"YES\";", "\t//find intersecting interval\n\tlong intStart, intEnd;\n\
    \tif (std::get<0>(interval1) > std::get<0>(interval2)) {\n\t\tintStart = std::get<0>(interval1);\n\
    \t}\n\telse {\n\t\tintStart = std::get<0>(interval2);\n\t}\n\tif (std::get<1>(interval1)\
    \ < std::get<1>(interval2)) {\n\t\tintEnd = std::get<1>(interval1);\n\t}\n\telse\
    \ {\n\t\tintEnd = std::get<1>(interval2);\n\t}\n\t//check if intervals intersect\n\
    \tif (intStart > intEnd) {\n\t\treturn \"NO\";\n\t}\n\t//find length of intersection\n\
    \tlong intLength = intEnd - intStart + 1;\n\t//check if length is prime\n\tif\
    \ (intLength < 2) {\n\t\treturn \"NO\";\n\t}\n\tfor (long i = 2; i < intLength;\
    \ i++) {\n\t\tif (intLength % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\t\
    return \"YES\";", "\tint s1 = std::get<0>(interval1);\n\tint e1 = std::get<1>(interval1);\n\
    \tint s2 = std::get<0>(interval2);\n\tint e2 = std::get<1>(interval2);\n\t// let's\
    \ calculate the length of the intersection between the two intervals\n\tint length\
    \ = 0;\n\tif (s1 <= s2 && e1 >= s2) {\n\t\t// intersection starts at s2\n\t\t\
    if (e1 <= e2) {\n\t\t\t// intersection ends at e1\n\t\t\tlength = e1 - s2 + 1;\n\
    \t\t}\n\t\telse {\n\t\t\t// intersection ends at e2\n\t\t\tlength = e2 - s2 +\
    \ 1;\n\t\t}\n\t}\n\telse if (s2 <= s1 && e2 >= s1) {\n\t\t// intersection starts\
    \ at s1\n\t\tif (e2 <= e1) {\n\t\t\t// intersection ends at e2\n\t\t\tlength =\
    \ e2 - s1 + 1;\n\t\t}\n\t\telse {\n\t\t\t// intersection ends at e1\n\t\t\tlength\
    \ = e1 - s1 + 1;\n\t\t}\n\t}\n\telse {\n\t\t// no intersection\n\t\treturn \"\
    NO\";\n\t}\n\t// now let's check if the length is a prime number\n\tif (length\
    \ < 2) return \"NO\";\n\tfor (int i = 2; i < length; i++) {\n\t\tif (length %\
    \ i == 0) return \"NO\";\n\t}\n\treturn \"YES\";", "\tint start1 = std::get<0>(interval1);\n\
    \tint end1 = std::get<1>(interval1);\n\tint start2 = std::get<0>(interval2);\n\
    \tint end2 = std::get<1>(interval2);\n\t//assert(start1 <= end1);\n\t//assert(start2\
    \ <= end2);\n\t\n\t//int s = start1 < start2 ? start2 : start1;\n\t//int e = end1\
    \ < end2 ? end1 : end2;\n\tint s = std::max(start1, start2);\n\tint e = std::min(end1,\
    \ end2);\n\t\n\tif (s > e) {\n\t\treturn \"NO\";\n\t}\n\t\n\tif (s == e) {\n\t\
    \tif (s == 2) {\n\t\t\treturn \"YES\";\n\t\t}\n\t\tif (s <= 1) {\n\t\t\treturn\
    \ \"NO\";\n\t\t}\n\t\tif (s % 2 == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t\tfor\
    \ (int i = 3; i < s; i += 2) {\n\t\t\tif (s % i == 0) {\n\t\t\t\treturn \"NO\"\
    ;\n\t\t\t}\n\t\t}\n\t\treturn \"YES\";\n\t}\n\t\n\t//e > s\n\tint len = e - s\
    \ + 1;\n\tif (len == 2) {\n\t\treturn \"YES\";\n\t}\n\tif (len <= 1) {\n\t\treturn\
    \ \"NO\";\n\t}\n\tif (len % 2 == 0) {\n\t\treturn \"NO\";\n\t}\n\tfor (int i =\
    \ 3; i < len; i += 2) {\n\t\tif (len % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\
    \t}\n\treturn \"YES\";", "    long x1 = std::get<0>(interval1);\n    long y1 =\
    \ std::get<1>(interval1);\n    long x2 = std::get<0>(interval2);\n    long y2\
    \ = std::get<1>(interval2);\n    if (x1 > y1 || x2 > y2) {\n        return \"\
    NO\";\n    }\n    // overlap intervals\n    if (x1 <= x2 && x2 <= y1) {\n    \
    \    if (y1 <= y2) {\n            return (y1 - x2 + 1) > 1 && (y1 - x2 + 1) <\
    \ 4 ? \"YES\" : \"NO\";\n        } else {\n            return (y2 - x2 + 1) >\
    \ 1 && (y2 - x2 + 1) < 4 ? \"YES\" : \"NO\";\n        }\n    }\n    // overlap\
    \ intervals\n    if (x2 <= x1 && x1 <= y2) {\n        if (y2 <= y1) {\n      \
    \      return (y2 - x1 + 1) > 1 && (y2 - x1 + 1) < 4 ? \"YES\" : \"NO\";\n   \
    \     } else {\n            return (y1 - x1 + 1) > 1 && (y1 - x1 + 1) < 4 ? \"\
    YES\" : \"NO\";\n        }\n    }\n    return \"NO\";", "    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    long start = std::max(a, c);\n    long\
    \ end = std::min(b, d);\n    if (start > end) {\n        return \"NO\";\n    }\n\
    \    // 3 is the prime number of interest\n    if (end - start == 2) {\n     \
    \   return \"YES\";\n    }\n    return \"NO\";", "    std::vector<int> isPrime\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997};\n    std::vector<int>::iterator iter;\n    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    long a_temp = a;\n    long b", "  int\
    \ a = std::get<0>(interval1);\n  int b = std::get<1>(interval1);\n  int c = std::get<0>(interval2);\n\
    \  int d = std::get<1>(interval2);\n  if(d < a || b < c)\n  {\n    return \"NO\"\
    ;\n  }\n  int len = std::min(b, d) - std::max(a, c) + 1;\n  for(int i = 2; i <\
    \ len; i++)\n  {\n    if(len % i == 0)\n    {\n      return \"NO\";\n    }\n \
    \ }\n  return \"YES\";", "    long int start, end;\n    if (std::get<0>(interval1)\
    \ < std::get<0>(interval2)) {\n        start = std::get<0>(interval2);\n    }\
    \ else {\n        start = std::get<0>(interval1);\n    }\n    if (std::get<1>(interval1)\
    \ < std::get<1>(interval2)) {\n        end = std::get<1>(interval1);\n    } else\
    \ {\n        end = std::get<1>(interval2);\n    }\n    if (start >= end) {\n \
    \       return \"NO\";\n    }\n    if (start == 0 && end == 0) {\n        return\
    \ \"YES\";\n    }\n    if (start < 0) {\n        start = -start;\n    }\n    if\
    \ (end < 0) {\n        end = -end;\n    }\n    std::vector<bool> isPrime(end +\
    \ 1, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i\
    \ = 2; i <= end; i++) {\n        if (isPrime[i]) {\n            for (int j = 2;\
    \ i * j <= end; j++) {\n                isPrime[i * j] = false;\n            }\n\
    \        }\n    }\n    return isPrime[end - start] ? \"YES\" : \"NO\";", "   \
    \ // Your code here!\n    // TODO:\n    // 1. get the overlap interval\n    //\
    \ 2. compare the length with the prime\n    // 3. if yes, then return \"YES\"\
    , otherwise, return \"NO\"\n    bool is_prime = true;\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    // std::cout << \"start: \" << start << std::endl;\n    // std::cout << \"\
    end: \" << end << std::endl;\n    if (start > end)\n        return \"NO\";\n \
    \   long length = end - start + 1;\n    // std::cout << \"length: \" << length\
    \ << std::endl;\n    if (length == 2)\n        return \"YES\";\n    if (length\
    \ == 1)\n        return \"NO\";\n    for (long i = 2; i <= length/2; i++) {\n\
    \        if (length % i == 0) {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if (is_prime)\n        return \"YES\";\n    else\n    \
    \    return \"NO\";", "\tlong int a = std::get<0>(interval1);\n\tlong int b =\
    \ std::get<1>(interval1);\n\tlong int c = std::get<0>(interval2);\n\tlong int\
    \ d = std::get<1>(interval2);\n\tlong int e,f;\n\tif(a<c)\n\t\te = c;\n\telse\n\
    \t\te = a;\n\tif(b<d)\n\t\tf = b;\n\telse\n\t\tf = d;\n\tif(e<=f)\n\t{\n\t\tif(e==f)\n\
    \t\t\treturn \"YES\";\n\t\telse\n\t\t{\n\t\t\tif(f-e==1)\n\t\t\t\treturn \"YES\"\
    ;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(f-e==2)\n\t\t\t\t\treturn \"YES\";\n\t\t\t\t\
    else\n\t\t\t\t{\n\t\t\t\t\tif(f-e==3)\n\t\t\t\t\t\treturn \"YES\";\n\t\t\t\t\t\
    else\n\t\t\t\t\t{\n\t\t\t\t\t\tif(f-e==5)\n\t\t\t\t\t\t\treturn \"YES\";\n\t\t\
    \t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(f-e==7)\n\t\t\t\t\t\t\t\treturn\
    \ \"YES\";\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(f-e==11)\n\
    \t\t\t\t\t\t\t\t\treturn \"YES\";\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\
    \t\t\t\t\t\t\t\tif(f-e==13)\n\t\t\t\t\t\t\t\t\t\treturn \"YES\";\n\t\t\t\t\t\t\
    \t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(f-e==17)\n\t\t\t\t\t\t\
    \t\t\t\t\treturn \"YES\";\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t", "    //x,y,z\n\
    \    //x,y,z\n    //x,y\n    //x,y\n    std::vector<long> points{std::get<0>(interval1),std::get<1>(interval1),std::get<0>(interval2),std::get<1>(interval2)};\n\
    \    std::sort(points.begin(),points.end());\n    // x,x,y,z\n\n    long first{0},second{0};\n\
    \    //intersects\n    if(points[1] < points[2]){\n        first = points[1];\n\
    \        second = points[2];\n    }\n    else if(points[1] == points[2]){\n  \
    \      return \"YES\";\n    }\n    //not intersects\n    else{\n        return\
    \ \"NO\";\n    }\n    long diff = second - first;\n    if(diff == 0){\n      \
    \  return \"YES\";\n    }\n    bool isPrime = true;\n    for(long i = 2; i < sqrt(diff)\
    \ + 1; ++i){\n        if(diff % i == 0){\n            isPrime = false;\n     \
    \       break;\n        }\n    }\n    if(isPrime){\n        return \"YES\";\n\
    \    }\n    return \"NO\";", "\t\tif (std::get<0>(interval1) <= std::get<0>(interval2)\
    \ && std::get<0>(interval2) <= std::get<1>(interval1)) {\n\t\t\t\tif (std::get<1>(interval1)\
    \ >= std::get<1>(interval2)) {\n\t\t\t\t\t\tlong len = std::get<1>(interval2)\
    \ - std::get<0>(interval2) + 1;\n\t\t\t\t\t\treturn isPrime(len) ? \"YES\" : \"\
    NO\";\n\t\t\t\t} else {\n\t\t\t\t\t\tlong len = std::get<1>(interval1) - std::get<0>(interval2)\
    \ + 1;\n\t\t\t\t\t\treturn isPrime(len) ? \"YES\" : \"NO\";\n\t\t\t\t}\n\t\t}\
    \ else if (std::get<0>(interval2) <= std::get<0>(interval1) && std::get<0>(interval1)\
    \ <= std::get<1>(interval2)) {\n\t\t\t\tif (std::get<1>(interval2) >= std::get<1>(interval1))\
    \ {\n\t\t\t\t\t\tlong len = std::get<1>(interval1) - std::get<0>(interval1) +\
    \ 1;\n\t\t\t\t\t\treturn isPrime(len) ? \"YES\" : \"NO\";\n\t\t\t\t} else {\n\t\
    \t\t\t\t\tlong len = std::get<1>(interval2) - std::get<0>(interval1) + 1;\n\t\t\
    \t\t\t\treturn isPrime(len) ? \"YES\" : \"NO\";\n\t\t\t\t}\n\t\t} else {\n\t\t\
    \t\treturn \"NO\";\n\t\t}", "  auto prime = [](int n) -> bool {\n    if (n <=\
    \ 1) return false;\n    for (int i = 2; i * i <= n; ++i)\n      if (n % i == 0)\
    \ return false;\n    return true;\n  };\n  int start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n  int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \  if (start > end) return \"NO\";\n  return prime(end - start + 1) ? \"YES\"\
    \ : \"NO\";", "\tlong a, b, c, d;\n\ta = std::get<0>(interval1);\n\tb = std::get<1>(interval1);\n\
    \tc = std::get<0>(interval2);\n\td = std::get<1>(interval2);\n\tlong intersection_length\
    \ = std::max(std::min(b, d) - std::max(a, c) + 1, 0L);\n\tif (intersection_length\
    \ <= 1) return \"NO\";\n\tfor (long i = 2; i * i <= intersection_length; i++)\
    \ {\n\t\tif (intersection_length % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t\
    }\n\treturn \"YES\";", "    long start1 = std::get<0>(interval1);\n    long end1\
    \ = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long\
    \ end2 = std::get<1>(interval2);\n    if(end1 < start2 || end2 < start1)\n   \
    \     return \"NO\";\n    long start = std::max(start1, start2);\n    long end\
    \ = std::min(end1, end2);\n    long diff = end - start + 1;\n    return isPrime(diff)\
    \ ? \"YES\" : \"NO\";", "\t// Get the start and end\n\tlong start1 = std::get<0>(interval1);\n\
    \tlong end1 = std::get<1>(interval1);\n\tlong start2 = std::get<0>(interval2);\n\
    \tlong end2 = std::get<1>(interval2);\n\t// Check if they are intersecting\n\t\
    if (end1 < start2 || end2 < start1) {\n\t\treturn \"NO\";\n\t}\n\t// They are\
    \ intersecting, check if the length is prime.\n\t// Get the intersection interval\
    \ and get its length\n\tlong intersection_start = std::max(start1, start2);\n\t\
    long intersection_end = std::min(end1, end2);\n\tlong length = intersection_end\
    \ - intersection_start + 1;\n\t// Check if the length is prime\n\tif (length ==\
    \ 1) {\n\t\treturn \"NO\";\n\t}\n\tfor (long i = 2; i * i <= length; i++) {\n\t\
    \tif (length % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\treturn \"YES\";",
  "  auto left = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  auto\
    \ right = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  if (left\
    \ > right) return \"NO\";\n  auto diff = right - left + 1;\n  if (diff == 1) return\
    \ \"NO\";\n  return std::string((diff > 2 && diff % 2 == 0) ? \"NO\" : \"YES\"\
    );", "    long first=std::get<0>(interval1);\n    long second=std::get<1>(interval1);\n\
    \    long third=std::get<0>(interval2);\n    long fourth=std::get<1>(interval2);\n\
    \    if(first>second || third>fourth)\n        return \"NO\";\n    if(first>third)\n\
    \        std::swap(first,third);\n    if(second>fourth)\n        std::swap(second,fourth);\n\
    \    if(second<=third)\n        return \"NO\";\n    if(fourth<=second)\n     \
    \   std::swap(second,fourth);\n    long length=std::abs(second-third)+1;\n   \
    \ if(length==2)\n        return \"YES\";\n    if(length==3)\n        return \"\
    NO\";\n    for(long i=3;i<=std::sqrt(length);i+=2)\n        if(length%i==0)\n\
    \            return \"NO\";\n    return \"YES\";", "    long s1, e1, s2, e2;\n\
    \    std::tie(s1, e1) = interval1;\n    std::tie(s2, e2) = interval2;\n    bool\
    \ any_intersection = (s1 <= e2 && s2 <= e1);\n    if (!any_intersection) {\n \
    \       return \"NO\";\n    }\n    long intersection_start = std::max(s1, s2);\n\
    \    long intersection_end = std::min(e1, e2);\n    long intersection_length =\
    \ intersection_end - intersection_start + 1;\n    bool not_prime = (intersection_length\
    \ == 1);\n    for (long i = 2; i * i <= intersection_length; ++i) {\n        if\
    \ (intersection_length % i == 0) {\n            not_prime = true;\n          \
    \  break;\n        }\n    }\n    return not_prime ? \"NO\" : \"YES\";", "    long\
    \ start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n    long\
    \ end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n    if (start\
    \ >= end) return \"NO\";\n    long diff = end - start;\n    if (diff < 2) return\
    \ \"NO\";\n    if (diff == 2) return \"YES\";\n    for (long i = 2; i < diff;\
    \ i++) {\n        if (diff % i == 0) return \"NO\";\n    }\n    return \"YES\"\
    ;", "\tlong begin = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \tlong end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\tlong\
    \ dif = end - begin;\n\tif (dif <= 0) return \"NO\";\n\tif (dif == 1) return \"\
    NO\";\n\tfor (long i = 2; i < dif; i++) {\n\t\tif (dif % i == 0) return \"NO\"\
    ;\n\t}\n\treturn \"YES\";", "\tauto [x1, y1] = interval1;\n\tauto [x2, y2] = interval2;\n\
    \tstd::vector<int> arr{};\n\tfor (int i = std::max(x1, x2); i <= std::min(y1,\
    \ y2); i++) {\n\t\tarr.push_back(i);\n\t}\n\tstd::sort(arr.begin(), arr.end());\n\
    \tfor (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] - arr[i - 1] > 1) {\n\
    \t\t\treturn \"NO\";\n\t\t}\n\t}\n\tif (arr.size() == 1 && arr[0] == 1) {\n\t\t\
    return \"NO\";\n\t}\n\treturn \"YES\";", "    int a = std::get<0>(interval1);\n\
    \    int b = std::get<1>(interval1);\n    int c = std::get<0>(interval2);\n  \
    \  int d = std::get<1>(interval2);\n    std::vector<int> arr = {a, b, c, d};\n\
    \    std::sort(arr.begin(), arr.end());\n    int len = arr[2] - arr[1];\n    bool\
    \ flag = false;\n    if (len < 2) {\n        return \"NO\";\n    }\n    else {\n\
    \        for (int i = 2; i <= len / 2; i++) {\n            if (len % i == 0) {\n\
    \                flag = true;\n                break;\n            }\n       \
    \ }\n        if (flag) {\n            return \"NO\";\n        }\n        else\
    \ {\n            return \"YES\";\n        }\n    }", "    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long start = std::max(start1, start2);\n\
    \    long end = std::min(end1, end2);\n    if (start >= end) {\n        return\
    \ \"NO\";\n    }\n    long length = end - start;\n    for (long i = 2; i <= length\
    \ / 2; i++) {\n        if (length % i == 0) {\n            return \"NO\";\n  \
    \      }\n    }\n    return \"YES\";", "    long left = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long right = std::min(std::get<1>(interval1),\
    \ std::get<1>(interval2));\n    if (left > right) {\n        return \"NO\";\n\
    \    }\n    return (right - left == 2) ? \"YES\" : \"NO\";", "  long maxi = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n  long mini = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \  if (maxi > mini) return \"NO\";\n  long intersect = mini - maxi + 1;\n  for\
    \ (long i = 2; i <= sqrt(intersect); i++)\n    if (intersect % i == 0) return\
    \ \"NO\";\n  return \"YES\";", "    long n1, n2, n3, n4;\n    n1 = std::get<0>(interval1);\n\
    \    n2 = std::get<1>(interval1);\n    n3 = std::get<0>(interval2);\n    n4 =\
    \ std::get<1>(interval2);\n    long start = std::max(n1, n3);\n    long end =\
    \ std::min(n2, n4);\n    if (start > end) return \"NO\";\n    bool prime = true;\n\
    \    for (long i = 2; i < end; i++) {\n        if (end % i == 0) {\n         \
    \   prime = false;\n            break;\n        }\n    }\n    if (prime) return\
    \ \"YES\";\n    return \"NO\";", "\tlong intStart = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\tlong intEnd = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \tif (intStart > intEnd) return \"NO\";\n\tif (intStart == intEnd) return \"YES\"\
    ;\n\tfor (long i = 2; i <= sqrt(intEnd - intStart); i++)\n\t\tif ((intEnd - intStart)\
    \ % i == 0) return \"NO\";\n\treturn \"YES\";", "    // sort\n    if (std::get<0>(interval1)\
    \ > std::get<0>(interval2)) {\n        std::swap(interval1, interval2);\n    }\n\
    \    if (std::get<1>(interval1) < std::get<0>(interval2)) {\n        return \"\
    NO\";\n    }\n    long start = std::get<0>(interval2);\n    long end = std::get<1>(interval1);\n\
    \    if (std::get<1>(interval2) < std::get<1>(interval1)) {\n        end = std::get<1>(interval2);\n\
    \    }\n    if (start == end) {\n        return \"NO\";\n    }\n    for (long\
    \ i = 2; i <= sqrt(end - start); i++) {\n        if ((end - start) % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";", "\tbool prime\
    \ = true;\n\tauto min = std::get<0>(interval1) > std::get<0>(interval2) ? std::get<0>(interval1)\
    \ : std::get<0>(interval2);\n\tauto max = std::get<1>(interval1) < std::get<1>(interval2)\
    \ ? std::get<1>(interval1) : std::get<1>(interval2);\n\tfor (auto i = min; i <=\
    \ max; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tprime = false;\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\tif (prime)\n\t\treturn \"YES\";\n\telse\n\t\treturn \"NO\";", "    long\
    \ start1, start2, end1, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2,\
    \ end2) = interval2;\n    if(start1 > end1) {\n        long temp = start1;\n \
    \       start1 = end1;\n        end1 = temp;\n    }\n    if(start2 > end2) {\n\
    \        long temp = start2;\n        start2 = end2;\n        end2 = temp;\n \
    \   }\n    if(start1 > end2 || start2 > end1) {\n        return \"NO\";\n    }\n\
    \    if(start1 <= start2 && end1 >= end2) {\n        if(start2 == end2) {\n  \
    \          return \"YES\";\n        }\n        long intervalLength = end2 - start2;\n\
    \        if(isPrime(intervalLength)) {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    if(start2 <= start1 && end2 >= end1) {\n \
    \       if(start1 == end1) {\n            return \"YES\";\n        }\n       \
    \ long intervalLength = end1 - start1;\n        if(isPrime(intervalLength)) {\n\
    \            return \"YES\";\n        }\n        return \"NO\";\n    }\n    if(start1\
    \ <= start2 && end1 <= end2) {\n        if(start1 == end1) {\n            return\
    \ \"YES\";\n        }\n        long intervalLength = end1 - start2;\n        if(isPrime(intervalLength))\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if(start2 <= start1 && end2 <= end1) {\n        if(start2 == end2) {\n   \
    \         return \"YES\";\n        }\n        long intervalLength = end2 - start1;\n\
    \        if(isPrime(intervalLength)) {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    return \"NO\";", "    auto start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    auto end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    return start <= end && is_prime(end - start + 1) ? \"YES\" : \"NO\";", " \
    \ int start = max(get<0>(interval1), get<0>(interval2));\n  int end = min(get<1>(interval1),\
    \ get<1>(interval2));\n  if (start <= end) {\n    for (int i = 2; i < end - start\
    \ + 1; i++) {\n      if ((end - start + 1) % i == 0) return \"NO\";\n    }\n \
    \   return \"YES\";\n  }\n  return \"NO\";", "  long s1 = std::get<0>(interval1);\n\
    \  long e1 = std::get<1>(interval1);\n  long s2 = std::get<0>(interval2);\n  long\
    \ e2 = std::get<1>(interval2);\n  if (e1 < s2 || e2 < s1) return \"NO\";\n  long\
    \ common_start = std::max(s1, s2);\n  long common_end = std::min(e1, e2);\n  long\
    \ common_len = common_end - common_start + 1;\n  if (common_len == 0) return \"\
    NO\";\n  for (long i = 2; i * i <= common_len; ++i) {\n    if (common_len % i\
    \ == 0) return \"NO\";\n  }\n  return \"YES\";", "\tbool isIntersect = false;\n\
    \tlong start1 = std::get<0>(interval1);\n\tlong end1 = std::get<1>(interval1);\n\
    \tlong start2 = std::get<0>(interval2);\n\tlong end2 = std::get<1>(interval2);\n\
    \tif (end1 >= start2 && end2 >= start1) {\n\t\tisIntersect = true;\n\t}\n\tlong\
    \ len = 0;\n\tif (isIntersect) {\n\t\tif (start1 >= start2 && end1 <= end2) {\n\
    \t\t\tlen = end1 - start1 + 1;\n\t\t}\n\t\telse if (start1 <= start2 && end1 >=\
    \ end2) {\n\t\t\tlen = end2 - start2 + 1;\n\t\t}\n\t\telse if (start1 >= start2\
    \ && end1 >= end2) {\n\t\t\tlen = end2 - start1 + 1;\n\t\t}\n\t\telse if (start1\
    \ <= start2 && end1 <= end2) {\n\t\t\tlen = end1 - start2 + 1;\n\t\t}\n\t}\n\t\
    if (len == 0) {\n\t\treturn \"NO\";\n\t}\n\telse {\n\t\tfor (long j = 2; j < len;\
    \ j++) {\n\t\t\tif (len % j == 0) {\n\t\t\t\treturn \"NO\";\n\t\t\t}\n\t\t}\n\t\
    \treturn \"YES\";\n\t}", "\tlong lower, upper;\n\tif (std::get<0>(interval1) <\
    \ std::get<0>(interval2)) {\n\t\tlower = std::get<0>(interval2);\n\t}\n\telse\
    \ {\n\t\tlower = std::get<0>(interval1);\n\t}\n\tif (std::get<1>(interval1) <\
    \ std::get<1>(interval2)) {\n\t\tupper = std::get<1>(interval1);\n\t}\n\telse\
    \ {\n\t\tupper = std::get<1>(interval2);\n\t}\n\tlong len = upper - lower;\n\t\
    if (len < 0) {\n\t\treturn \"NO\";\n\t}\n\telse {\n\t\tfor (long i = 2; i <= sqrt(len);\
    \ i++) {\n\t\t\tif (len % i == 0) {\n\t\t\t\treturn \"NO\";\n\t\t\t}\n\t\t}\n\t\
    \treturn \"YES\";\n\t}", "    if (std::get<0>(interval1) > std::get<1>(interval2)\
    \ || std::get<0>(interval2) > std::get<1>(interval1)) {\n        return \"NO\"\
    ;\n    }\n    if (std::get<0>(interval1) > std::get<0>(interval2)) {\n       \
    \ std::swap(interval1, interval2);\n    }\n    long start = std::get<0>(interval2);\n\
    \    long end = std::get<1>(interval1);\n    long length = end - start + 1;\n\
    \    if (length <= 1) {\n        return \"NO\";\n    }\n    bool isPrime = true;\n\
    \    long sqrtLength = std::sqrt(length);\n    for (long i = 2; i <= sqrtLength;\
    \ ++i) {\n        if (length % i == 0) {\n            isPrime = false;\n     \
    \       break;\n        }\n    }\n    return isPrime ? \"YES\" : \"NO\";", " \
    \ long lower = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  long\
    \ upper = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  if (lower\
    \ > upper) return \"NO\";\n  int length = std::abs(upper - lower) + 1;\n  return\
    \ std::string(\"YES\");", "\tint A = std::get<0>(interval1);\n\tint B = std::get<1>(interval1);\n\
    \tint C = std::get<0>(interval2);\n\tint D = std::get<1>(interval2);\n\tif(A >\
    \ B) {\n\t\tint temp = A;\n\t\tA = B;\n\t\tB = temp;\n\t}\n\tif(C > D) {\n\t\t\
    int temp = C;\n\t\tC = D;\n\t\tD = temp;\n\t}\n\tif(A > D || B < C) {\n\t\treturn\
    \ \"NO\";\n\t}\n\tint E = A < C ? C : A;\n\tint F = B < D ? B : D;\n\tif(E > F)\
    \ {\n\t\treturn \"NO\";\n\t}\n\tint G = F - E + 1;\n\tif(G <= 1) {\n\t\treturn\
    \ \"NO\";\n\t}\n\tfor(int i = 2; i < G; i++) {\n\t\tif(G % i == 0) {\n\t\t\treturn\
    \ \"NO\";\n\t\t}\n\t}\n\treturn \"YES\";", "    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if(start1 > end1) {\n        std::swap(start1,\
    \ end1);\n    }\n    if(start2 > end2) {\n        std::swap(start2, end2);\n \
    \   }\n    long intersectionStart = std::max(start1, start2);\n    long intersectionEnd\
    \ = std::min(end1, end2);\n    long length = intersectionEnd - intersectionStart\
    \ + 1;\n    if(length <= 0) {\n        return \"NO\";\n    }\n    for(long i =\
    \ 2; i <= sqrt(length); i++) {\n        if(length % i == 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";", "    long start1, end1, start2,\
    \ end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2, end2) =\
    \ interval2;\n    // No intersection\n    if (start1 > end2 || start2 > end1)\
    \ {\n        return \"NO\";\n    }\n    auto intersectionStart = std::max(start1,\
    \ start2);\n    auto intersectionEnd = std::min(end1, end2);\n    auto length\
    \ = intersectionEnd - intersectionStart + 1;\n    if (length == 1) {\n       \
    \ return \"NO\";\n    }\n    bool isPrime = true;\n    for (int i = 2; i < length;\
    \ i++) {\n        if (length % i == 0) {\n            isPrime = false;\n     \
    \       break;\n        }\n    }\n    return isPrime ? \"YES\" : \"NO\";", " \
    \   long a, b, c, d;\n    int left, right;\n    a = std::get<0>(interval1);\n\
    \    b = std::get<1>(interval1);\n    c = std::get<0>(interval2);\n    d = std::get<1>(interval2);\n\
    \    if(a > c) {\n        left = a;\n    } else {\n        left = c;\n    }\n\
    \    if(b < d) {\n        right = b;\n    } else {\n        right = d;\n    }\n\
    \    if(left <= right) {\n        int count = 0;\n        for(int i = left; i\
    \ <= right; i++) {\n            count++;\n        }\n        for(int i = 2; i\
    \ <= count/2; i++) {\n            if(count % i == 0) {\n                return\
    \ \"NO\";\n            }\n        }\n        return \"YES\";\n    } else {\n \
    \       return \"NO\";\n    }", "  long start1 = std::get<0>(interval1);\n  long\
    \ end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long\
    \ end2 = std::get<1>(interval2);\n  if (end1 < start2 || end2 < start1) return\
    \ \"NO\";\n  long start = std::max(start1, start2);\n  long end = std::min(end1,\
    \ end2);\n  for (long i = 2; i <= end; i++) {\n    if (start % i == 0 && end %\
    \ i == 0) return \"NO\";\n  }\n  return \"YES\";", "    int a = std::get<0>(interval1);\n\
    \    int b = std::get<1>(interval1);\n    int c = std::get<0>(interval2);\n  \
    \  int d = std::get<1>(interval2);\n    int l = std::max(a, c);\n    int r = std::min(b,\
    \ d);\n    if (l > r) return \"NO\";\n    int len = r - l + 1;\n    if (len ==\
    \ 1) return \"NO\";\n    if (len == 2) return \"YES\";\n    for (int i = 2; i\
    \ * i <= len; ++i) {\n        if (len % i == 0) return \"NO\";\n    }\n    return\
    \ \"YES\";", "    long min1 = std::get<0>(interval1);\n    long max1 = std::get<1>(interval1);\n\
    \    long min2 = std::get<0>(interval2);\n    long max2 = std::get<1>(interval2);\n\
    \    long len = -1;\n    if (min1 > max2 || min2 > max1)\n        return \"NO\"\
    ;\n    else {\n        if (min1 < min2) {\n            if (max1 < max2)\n    \
    \            len = max1 - min2 + 1;\n            else\n                len = max2\
    \ - min2 + 1;\n        }\n        else {\n            if (max1 < max2)\n     \
    \           len = max1 - min1 + 1;\n            else\n                len = max2\
    \ - min1 + 1;\n        }\n    }\n    assert(len >= 0);\n    std::vector<long>\
    \ primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97};\n    for (long prime : primes) {\n        if (len ==\
    \ prime)\n            return \"YES\";\n    }\n    return \"NO\";", "    auto n1\
    \ = std::get<0>(interval1);\n    auto n2 = std::get<1>(interval1);\n    auto m1\
    \ = std::get<0>(interval2);\n    auto m2 = std::get<1>(interval2);\n    auto bigger\
    \ = (n1 > m1) ? n1 : m1;\n    auto smaller = (n2 < m2) ? n2 : m2;\n    if (bigger\
    \ <= smaller) {\n        auto common = std::abs(bigger - smaller) + 1;\n     \
    \   if (common <= 1) {\n            return \"NO\";\n        }\n        for (auto\
    \ i = 2; i < common; ++i) {\n            if (common % i == 0) {\n            \
    \    return \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n\
    \    return \"NO\";", "  long start1 = std::get<0>(interval1);\n  long end1 =\
    \ std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2\
    \ = std::get<1>(interval2);\n  long start = std::max(start1, start2);\n  long\
    \ end = std::min(end1, end2);\n  if (start > end) {\n    return \"NO\";\n  }\n\
    \  long length = end - start + 1;\n  if (length <= 1) {\n    return \"NO\";\n\
    \  }\n  if (length % 2 == 0) {\n    return \"NO\";\n  }\n  for (long i = 3; i\
    \ <= std::sqrt(length); i+=2) {\n    if (length % i == 0) {\n      return \"NO\"\
    ;\n    }\n  }\n  return \"YES\";", "  std::string result = \"NO\";\n  long start1\
    \ = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2\
    \ = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n  long start,\
    \ end;\n  if (start1 <= start2) {\n    start = start2;\n  } else {\n    start\
    \ = start1;\n  }\n  if (end1 >= end2) {\n    end = end2;\n  } else {\n    end\
    \ = end1;\n  }\n  if (start < end) {\n    bool is_prime = true;\n    for (long\
    \ i = 2; i <= sqrt(end-start); i++) {\n      if ((end-start) % i == 0) {\n   \
    \     is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n\
    \      result = \"YES\";\n    }\n  } else {\n    result = \"NO\";\n  }\n  return\
    \ result;", "    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    long start = start1 > start2 ? start1 : start2;\n    long end = end1 < end2\
    \ ? end1 : end2;\n    if (start > end) {\n        return \"NO\";\n    }\n    long\
    \ length = end - start + 1;\n    return length <= 1 ? \"NO\" : length == 2 ? \"\
    YES\" : length % 2 == 0 ? \"NO\" : \"YES\";", "\tif (std::get<0>(interval1) >=\
    \ std::get<1>(interval2) || std::get<0>(interval2) >= std::get<1>(interval1))\
    \ {\n\t\treturn \"NO\";\n\t}\n\tlong start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\tlong end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \tlong length = end - start;\n\tbool isPrime = true;\n\tfor (long i = 2; i < length\
    \ / 2; i++) {\n\t\tif (length % i == 0) {\n\t\t\tisPrime = false;\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn isPrime ? \"YES\" : \"NO\";", "    // Write your code here\n\
    \    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  \
    \  if (start > end) return \"NO\";\n    std::set<long> primes = {2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97};\n    return primes.find(end - start + 1) != primes.end() ? \"YES\" : \"\
    NO\";", "    long start = max(get<0>(interval1), get<0>(interval2));\n    long\
    \ end = min(get<1>(interval1), get<1>(interval2));\n    if (start > end) return\
    \ \"NO\";\n    for (long i = 2; i <= (end - start); i++) {\n        if ((end -\
    \ start) % i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";", "    long a = std::get<0>(interval1);\n    long b = std::get<1>(interval1);\n\
    \    long c = std::get<0>(interval2);\n    long d = std::get<1>(interval2);\n\
    \    if(a>b || c>d){\n        return \"wrong intervals\";\n    }\n    // int min\
    \ = std::min(b,d);\n    // int max = std::max(a,c);\n    // int intersection =\
    \ min-max;\n    // int flag = 0;\n    // std::cout<<intersection<<std::endl;\n\
    \    // if(intersection<=1){\n    //     return \"NO\";\n    // }\n    // for(int\
    \ i=2;i<intersection;i++){\n    //     if(intersection%i==0){\n    //        \
    \ flag = 1;\n    //         break;\n    //     }\n    // }\n    // if(flag==1){\n\
    \    //     return \"NO\";\n    // }\n    // else{\n    //     return \"YES\"\
    ;\n    // }\n    long start = std::max(a,c);\n    long end = std::min(b,d);\n\
    \    if(start>end){\n        return \"NO\";\n    }\n    else{\n        if(start==1){\n\
    \            return \"NO\";\n        }\n        for(int i=2;i<start;i++){\n  \
    \          if(start%i==0){\n                return \"NO\";\n            }\n  \
    \      }\n        return \"YES\";\n    }\n", "    int start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    return (end < start) ? \"NO\" : (end - start == 1 || end - start == 2) ?\
    \ \"YES\" : \"NO\";", "\t//interval 1 start, interval 1 end, interval 2 start,\
    \ interval 2 end\n\t//intersection start intersection end\n\tint is, ie;\n\tif\
    \ (std::get<0>(interval1) <= std::get<0>(interval2))\n\t\tis = std::get<0>(interval2);\n\
    \telse\n\t\tis = std::get<0>(interval1);\n\tif (std::get<1>(interval1) <= std::get<1>(interval2))\n\
    \t\tie = std::get<1>(interval1);\n\telse\n\t\tie = std::get<1>(interval2);\n\t\
    int difference = ie - is;\n\tif (difference == 0)\n\t\treturn \"NO\";\n\tfor (int\
    \ i = 2; i <= difference; i++)\n\t{\n\t\tif (difference % i == 0)\n\t\t\treturn\
    \ \"NO\";\n\t}\n\treturn \"YES\";", "    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 > end1)\n        std::swap(start1,\
    \ end1);\n    if (start2 > end2)\n        std::swap(start2, end2);\n    if (start1\
    \ > end2 || start2 > end1)\n        return \"NO\";\n    std::vector<long> arr;\n\
    \    arr.push_back(start1);\n    arr.push_back(end1);\n    arr.push_back(start2);\n\
    \    arr.push_back(end2);\n    std::sort(arr.begin(), arr.end());\n    long start\
    \ = arr[1], end = arr[2];\n    long res = end - start + 1;\n    std::vector<bool>\
    \ prime(res, true);\n    prime[0] = prime[1] = false;\n    for (long i = 2; i\
    \ < res; i++) {\n        if (prime[i]) {\n            for (long j = i * i; j <\
    \ res; j += i)\n                prime[j] = false;\n        }\n    }\n    return\
    \ prime[res - 1] ? \"YES\" : \"NO\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long len = end - start\
    \ + 1;\n    if (len == 2) {\n        return \"YES\";\n    }\n    for (long i =\
    \ 2; i * i <= len; i++) {\n        if (len % i == 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";", "\tlong i1start = std::get<0>(interval1);\n\
    \tlong i1end = std::get<1>(interval1);\n\tlong i2start = std::get<0>(interval2);\n\
    \tlong i2end = std::get<1>(interval2);\n\tlong a = std::max(i1start, i2start);\n\
    \tlong b = std::min(i1end, i2end);\n\tif (a > b) return \"NO\";\n\tlong c = b\
    \ - a + 1;\n\treturn (c <= 1) ? \"NO\" : (c <= 3) ? \"YES\" : ((c % 2 == 0) ||\
    \ (c % 3 == 0)) ? \"NO\" : \"YES\";", "    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long intersect_len = 0;\n    if\
    \ (start1 > end2 || start2 > end1) {\n        intersect_len = 0;\n    } else {\n\
    \        if (start1 > start2) {\n            intersect_len = end1 - start1 + 1;\n\
    \        } else {\n            intersect_len = end2 - start2 + 1;\n        }\n\
    \    }\n    bool is_prime = false;\n    if (intersect_len == 0) {\n        is_prime\
    \ = false;\n    } else if (intersect_len == 1) {\n        is_prime = true;\n \
    \   } else {\n        for (long j = 2; j <= intersect_len / 2; j++) {\n      \
    \      if (intersect_len % j == 0) {\n                is_prime = false;\n    \
    \            break;\n            } else {\n                is_prime = true;\n\
    \            }\n        }\n    }\n    if (is_prime) {\n        return \"YES\"\
    ;\n    } else {\n        return \"NO\";\n    }", "    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    long start = std::max(a, c);\n    long\
    \ end = std::min(b, d);\n    std::cout << start << \" \" << end << std::endl;\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start == end)\
    \ {\n        return \"YES\";\n    }\n    long len = end - start + 1;\n    for\
    \ (long i = 2; i <= sqrt(len); i++) {\n        if (len % i == 0) {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";", "    std::string str\
    \ = \"NO\";\n    if(std::get<0>(interval1) > std::get<1>(interval2) || std::get<0>(interval2)\
    \ > std::get<1>(interval1)) {\n        return str;\n    }\n    else {\n      \
    \  int start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n   \
    \     int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  \
    \      if(start == end || start == end - 1) {\n            return str;\n     \
    \   }\n        else {\n            int count = 0;\n            for(int i = start\
    \ + 1; i < end; i++) {\n                count++;\n            }\n            if(count\
    \ == 2 || count == 3 || count == 5 || count == 7) {\n                str = \"\
    YES\";\n            }\n        }\n    }\n    return str;", "  int i1s = std::get<0>(interval1);\n\
    \  int i1e = std::get<1>(interval1);\n  int i2s = std::get<0>(interval2);\n  int\
    \ i2e = std::get<1>(interval2);\n  if(i1e < i2s || i2e < i1s) {\n    return \"\
    NO\";\n  }\n  int resultStart = std::max(i1s, i2s);\n  int resultEnd = std::min(i1e,\
    \ i2e);\n  int intersectionLen = resultEnd - resultStart + 1;\n  if(intersectionLen\
    \ == 2) {\n    return \"YES\";\n  }\n  for(int i = 2; i < intersectionLen; i++)\
    \ {\n    if(intersectionLen % i == 0) {\n      return \"NO\";\n    }\n  }\n  return\
    \ \"YES\";", "    long start1, end1, start2, end2;\n    std::tie(start1, end1)\
    \ = interval1;\n    std::tie(start2, end2) = interval2;\n    if (end1 < start2\
    \ || end2 < start1) return \"NO\";\n    long l = std::max(start1, start2);\n \
    \   long r = std::min(end1, end2);\n    if (l == r) return \"YES\";\n    int len\
    \ = r - l + 1;\n    for (int i = 2; i < len; i++) {\n        if (len % i == 0)\
    \ return \"NO\";\n    }\n    return \"YES\";", "    // Write your code here\n\
    \    long a = std::get<0>(interval1);\n    long b = std::get<1>(interval1);\n\
    \    long c = std::get<0>(interval2);\n    long d = std::get<1>(interval2);\n\
    \    long mx = std::max(a, c);\n    long mn = std::min(b, d);\n    if (mn < mx)\
    \ {\n        return \"NO\";\n    }\n    long res = mn - mx + 1;\n    if (res <=\
    \ 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i < res; i++) {\n\
    \        if (res % i == 0) {\n            return \"NO\";\n        }\n    }\n \
    \   return \"YES\";", "    long left = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \    long right = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    // or use std::minmax\n    // long left = std::minmax(std::get<0>(interval1),\
    \ std::get<0>(interval2)).second;\n    // long right = std::minmax(std::get<1>(interval1),\
    \ std::get<1>(interval2)).first;\n    if (left > right) return \"NO\";\n    long\
    \ res = right - left + 1;\n    if (res < 2) return \"NO\";\n    bool flag = true;\n\
    \    for (long i = 2; i * i <= res; ++i) {\n        if (res % i == 0) {\n    \
    \        flag = false;\n            break;\n        }\n    }\n    return flag\
    \ ? \"YES\" : \"NO\";", "  int start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \  int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  int\
    \ range = end - start;\n  if (range <= 0) {\n    return \"NO\";\n  }\n  if (range\
    \ == 1) {\n    return \"YES\";\n  }\n  for (int i = start + 1; i < end; i++) {\n\
    \    if (i % start == 0 && i % end == 0) {\n      return \"NO\";\n    }\n  }\n\
    \  return \"YES\";", "    long x1 = std::get<0>(interval1);\n    long y1 = std::get<1>(interval1);\n\
    \    long x2 = std::get<0>(interval2);\n    long y2 = std::get<1>(interval2);\n\
    \    long x = std::max(x1, x2);\n    long y = std::min(y1, y2);\n    if (x > y)\
    \ return \"NO\";\n    if (x == y) return \"YES\";\n    if (x == 1) return \"NO\"\
    ;\n    if (x == 2) return \"YES\";\n    for (long i = 2; i <= sqrt(y); i++) {\n\
    \        if (x % i == 0 || y % i == 0) {\n            return \"NO\";\n       \
    \ }\n    }\n    return \"YES\";", "    std::string isPrime = \"NO\";\n    long\
    \ start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    if (start > end) {\n        return isPrime;\n    }\n    for (long i = 2;\
    \ i < end - start + 1; i++) {\n        if ((end - start + 1) % i == 0) {\n   \
    \         return isPrime;\n        }\n    }\n    isPrime = \"YES\";\n    return\
    \ isPrime;", "  long a1 = std::get<0>(interval1);\n  long b1 = std::get<1>(interval1);\n\
    \  long a2 = std::get<0>(interval2);\n  long b2 = std::get<1>(interval2);\n  long\
    \ intersection_length = 0;\n  if (a1 < a2) {\n    if (b1 < a2) {\n      intersection_length\
    \ = 0;\n    } else if (b1 < b2) {\n      intersection_length = b1 - a2 + 1;\n\
    \    } else {\n      intersection_length = b2 - a2 + 1;\n    }\n  } else {\n \
    \   if (b2 < a1) {\n      intersection_length = 0;\n    } else if (b2 < b1) {\n\
    \      intersection_length = b2 - a1 + 1;\n    } else {\n      intersection_length\
    \ = b1 - a1 + 1;\n    }\n  }\n  if (intersection_length <= 1) {\n    return \"\
    NO\";\n  }\n  long sqrt_of_intersection_length = (long) std::sqrt(intersection_length);\n\
    \  for (long i = 2; i <= sqrt_of_intersection_length; i++) {\n    if (intersection_length\
    \ % i == 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";", "\tint start\
    \ = max(get<0>(interval1), get<0>(interval2));\n\tint end = min(get<1>(interval1),\
    \ get<1>(interval2));\n\tif (start > end) return \"NO\";\n\tint cnt = end - start\
    \ + 1;\n\tif (cnt <= 1) return \"NO\";\n\tfor (int i = 2; i < cnt; i++) {\n\t\t\
    if (cnt % i == 0) return \"NO\";\n\t}\n\treturn \"YES\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start <= end) {\n        for (long i = 2; i < end - start + 1; i++) {\n\
    \            if ((end - start + 1) % i == 0) {\n                return \"NO\"\
    ;\n            }\n        }\n        return \"YES\";\n    }\n    return \"NO\"\
    ;", "  long start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \  long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  if\
    \ (start > end) {\n    return \"NO\";\n  }\n  bool is_prime = true;\n  if (start\
    \ == 1) {\n    is_prime = false;\n  }\n  for (long i = 2; i <= std::sqrt(end);\
    \ i++) {\n    if (start % i == 0 || end % i == 0) {\n      is_prime = false;\n\
    \      break;\n    }\n  }\n  return is_prime ? \"YES\" : \"NO\";", "    std::vector<int>v1\
    \ = {std::get<0>(interval1), std::get<1>(interval1)};\n    std::vector<int>v2\
    \ = {std::get<0>(interval2), std::get<1>(interval2)};\n    std::sort(v1.begin(),\
    \ v1.end());\n    std::sort(v2.begin(), v2.end());\n    int si = 0, ei = 0;\n\
    \    if (v1[0] > v2[0]) {\n        si = v1[0];\n    } else {\n        si = v2[0];\n\
    \    }\n    if (v1[1] < v2[1]) {\n        ei = v1[1];\n    } else {\n        ei\
    \ = v2[1];\n    }\n    int count = 0;\n    if (si > ei) {\n        return \"NO\"\
    ;\n    }\n    for (int i = si; i <= ei; i++) {\n        count++;\n    }\n    if\
    \ (count == 1) {\n        return \"NO\";\n    }\n    bool found = false;\n   \
    \ for (int i = 2; i <= count / 2; i++) {\n        if (count % i == 0) {\n    \
    \        found = true;\n            break;\n        }\n    }\n    if (found) {\n\
    \        return \"NO\";\n    } else {\n        return \"YES\";\n    }", "  long\
    \ start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  long end\
    \ = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  if (start > end)\
    \ {\n    return \"NO\";\n  }\n  long length = end - start + 1;\n  for (long i\
    \ = 2; i < length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n\
    \    }\n  }\n  return \"YES\";", "    long a = std::get<0>(interval1);\n    long\
    \ b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n    long\
    \ d = std::get<1>(interval2);\n    // The intervals don't intersect:\n    if (b\
    \ < c || d < a) {\n        return \"NO\";\n    }\n\n    // Length of the intersection:\n\
    \    long prime_candidate = abs(std::max(a, c) - std::min(b, d));\n\n    // A\
    \ prime number:\n    if (prime_candidate < 2) {\n        return \"NO\";\n    }\n\
    \    for (long i = 2; i * i <= prime_candidate; ++i) {\n        if (prime_candidate\
    \ % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;", "\tlong left, right;\n\tleft = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \tright = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\t// assert\
    \ (left <= right);\n\tlong length = right - left + 1;\n\tif (length < 2) return\
    \ \"NO\";\n\tfor (long i = 2; i < length; i++) {\n\t\tif (length % i == 0) return\
    \ \"NO\";\n\t}\n\treturn \"YES\";", "    // your code here\n    long start, end;\n\
    \    int length;\n    if(std::get<0>(interval1) <= std::get<0>(interval2)){\n\
    \        start = std::get<0>(interval2);\n    }else{\n        start = std::get<0>(interval1);\n\
    \    }\n    if(std::get<1>(interval1) <= std::get<1>(interval2)){\n        end\
    \ = std::get<1>(interval1);\n    }else{\n        end = std::get<1>(interval2);\n\
    \    }\n    length = end - start;\n    if(length < 1){\n        return \"NO\"\
    ;\n    }\n    for(int i = 2; i < length / 2; i++){\n        if(length % i == 0){\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";", "    long\
    \ start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n    long\
    \ end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n    if (start\
    \ > end) return \"NO\";\n    std::vector<long> arr;\n    for (long i = 2; i <=\
    \ end; i++) {\n        for (long j = 2; j <= i; j++) {\n            if (i % j\
    \ == 0) {\n                arr.push_back(j);\n            }\n        }\n    }\n\
    \    std::set<long> uni_arr(arr.begin(), arr.end());\n    for (auto i : uni_arr)\
    \ {\n        if (i >= start && i <= end) return \"YES\";\n    }\n    return \"\
    NO\";", "    long a, b, c, d;\n    std::tie(a, b) = interval1;\n    std::tie(c,\
    \ d) = interval2;\n    std::vector<long> ranges = {a, b, c, d};\n    std::sort(ranges.begin(),\
    \ ranges.end());\n    if (ranges[2] - ranges[1] < 2) {\n        return \"NO\"\
    ;\n    }\n    long intersection = ranges[2] - ranges[1];\n    bool is_prime =\
    \ true;\n    for (long i = 2; i < intersection; i++) {\n        if (intersection\
    \ % i == 0) {\n            is_prime = false;\n            break;\n        }\n\
    \    }\n    return is_prime ? \"YES\" : \"NO\";", "    bool prime = true;\n  \
    \  long low, high;\n    if (std::get<0>(interval1) > std::get<0>(interval2)) {\n\
    \        low = std::get<0>(interval1);\n    } else {\n        low = std::get<0>(interval2);\n\
    \    }\n    if (std::get<1>(interval1) < std::get<1>(interval2)) {\n        high\
    \ = std::get<1>(interval1);\n    } else {\n        high = std::get<1>(interval2);\n\
    \    }\n    long diff = std::abs(high - low) + 1;\n    if (diff == 1) {\n    \
    \    return \"NO\";\n    }\n    if (diff == 2) {\n        return \"YES\";\n  \
    \  }\n    for (long i = 2; i <= diff / 2; i++) {\n        if (diff % i == 0) {\n\
    \            prime = false;\n            break;\n        }\n    }\n    if (prime)\
    \ {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }", " \
    \   long a = std::get<0>(interval1);\n    long b = std::get<1>(interval1);\n \
    \   long c = std::get<0>(interval2);\n    long d = std::get<1>(interval2);\n \
    \   if(a > b) std::swap(a, b);\n    if(c > d) std::swap(c, d);\n    // overlap\n\
    \    if(a <= c && c <= b) {\n        if(d <= b) {\n            return (d - c +\
    \ 1) % 2 ? \"YES\" : \"NO\";\n        } else {\n            return (b - c + 1)\
    \ % 2 ? \"YES\" : \"NO\";\n        }\n    } else if(c <= a && a <= d) {\n    \
    \    if(d <= b) {\n            return (d - a + 1) % 2 ? \"YES\" : \"NO\";\n  \
    \      } else {\n            return (b - a + 1) % 2 ? \"YES\" : \"NO\";\n    \
    \    }\n    } else {\n        return \"NO\";\n    }", "  std::vector<long> values;\n\
    \  long start1, end1, start2, end2;\n  std::tie(start1, end1) = interval1;\n \
    \ std::tie(start2, end2) = interval2;\n  for (long i = start1; i <= end1; i++)\
    \ {\n    for (long j = start2; j <= end2; j++) {\n      if (i == j) {\n      \
    \  values.push_back(i);\n      }\n    }\n  }\n  if (values.size() == 0) {\n  \
    \  return \"NO\";\n  }\n  long intersection = abs(values[values.size() - 1] -\
    \ values[0]) + 1;\n  if (intersection == 1) {\n    return \"NO\";\n  }\n  for\
    \ (long k = 2; k < intersection; k++) {\n    if (intersection % k == 0) {\n  \
    \    return \"NO\";\n    }\n  }\n  return \"YES\";", "    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    int maxStart = std::max(a, c);\n  \
    \  int minEnd = std::min(b, d);\n    if (maxStart > minEnd) {\n        return\
    \ \"NO\";\n    }\n    int len = minEnd - maxStart + 1;\n    if (len == 1) {\n\
    \        return \"NO\";\n    }\n    if (len == 2) {\n        return \"YES\";\n\
    \    }\n    int len_sq = static_cast<int>(sqrt(len));\n    for (int i = 2; i <=\
    \ len_sq; i++) {\n        if (len % i == 0) {\n            return \"NO\";\n  \
    \      }\n    }\n    return \"YES\";", "    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    long l = 0;\n    if(a > b)\n      \
    \  std::swap(a, b);\n    if(c > d)\n        std::swap(c, d);\n    if(a > c)\n\
    \        std::swap(a, c);\n    if(b > d)\n        std::swap(b, d);\n    if(a >\
    \ b)\n        std::swap(a, b);\n    if(c > d)\n        std::swap(c, d);\n    if(a\
    \ > c)\n        std::swap(a, c);\n    if(b > d)\n        std::swap(b, d);\n  \
    \  if(a > b)\n        std::swap(a, b);\n    if(c > d)\n        std::swap(c, d);\n\
    \    if(a > c)\n        std::swap(a, c);\n    if(b > d)\n        std::swap(b,\
    \ d);\n    if(a > b)\n        std::swap(a, b);\n    if(c > d)\n        std::swap(c,\
    \ d);\n    if(a > c)\n        std::swap(a, c);\n    if(b > d)\n        std::swap(b,\
    \ d);\n    if(a > b)\n        std::swap(a, b);\n    if(c > d)\n        std::swap(c,\
    \ d);\n    if(a > c)\n        std::swap(a, c);\n    if(b > d)\n        std::swap(b,\
    \ d);\n    if(a > b)\n        std::swap(a, b);\n    if(c > d)\n        std::swap(c,\
    \ d);\n    if(a > c)\n        std::swap(a, c);\n    if(b > d)", "    int start\
    \ = std::max(std::get<0>(interval1), std::get<0>(interval2));\n    int end = std::min(std::get<1>(interval1),\
    \ std::get<1>(interval2));\n    if (start >= end) return \"NO\";\n    int diff\
    \ = end - start;\n    if (diff == 1) return \"YES\";\n    for (int i = 2; i <\
    \ diff; i++) {\n        if (diff % i == 0) return \"NO\";\n    }\n    return \"\
    YES\";", "\tlong int start1 = std::get<0>(interval1);\n\tlong int end1 = std::get<1>(interval1);\n\
    \tlong int start2 = std::get<0>(interval2);\n\tlong int end2 = std::get<1>(interval2);\n\
    \tlong int start_i = std::max(start1, start2);\n\tlong int end_i = std::min(end1,\
    \ end2);\n\tlong int length = end_i - start_i;\n\tbool is_prime = false;\n\tif\
    \ (start_i >= end_i) {\n\t\treturn \"NO\";\n\t}\n\tfor (long int i = 2; i < length;\
    \ i++) {\n\t\tif (length % i == 0) {\n\t\t\tis_prime = false;\n\t\t\tbreak;\n\t\
    \t}\n\t\telse {\n\t\t\tis_prime = true;\n\t\t}\n\t}\n\tif (is_prime) {\n\t\treturn\
    \ \"YES\";\n\t}\n\telse {\n\t\treturn \"NO\";\n\t}", "  // your code here\n  long\
    \ lower_bound = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  long\
    \ upper_bound = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  if\
    \ (lower_bound > upper_bound) return \"NO\";\n  if (upper_bound == lower_bound)\
    \ return \"YES\";\n  if (upper_bound - lower_bound == 1) return \"YES\";\n  if\
    \ (upper_bound - lower_bound == 2) return \"NO\";\n  for (long i = 2; i < upper_bound;\
    \ i++) {\n    if ((upper_bound - lower_bound) % i == 0) return \"NO\";\n  }\n\
    \  return \"YES\";", "\t// your code here\n\tlong st, end;\n\tif (std::get<0>(interval1)\
    \ <= std::get<0>(interval2))\n\t\tst = std::get<0>(interval2);\n\telse\n\t\tst\
    \ = std::get<0>(interval1);\n\tif (std::get<1>(interval1) <= std::get<1>(interval2))\n\
    \t\tend = std::get<1>(interval1);\n\telse\n\t\tend = std::get<1>(interval2);\n\
    \tif (st > end)\n\t\treturn \"NO\";\n\telse {\n\t\tint c = 0;\n\t\tfor (int i\
    \ = 2; i <= (end - st); i++) {\n\t\t\tif ((end - st) % i == 0)\n\t\t\t\tc++;\n\
    \t\t}\n\t\tif (c == 1)\n\t\t\treturn \"YES\";\n\t\telse\n\t\t\treturn \"NO\";\n\
    \t}", "    long a = std::get<0>(interval1);\n    long b = std::get<1>(interval1);\n\
    \    long c = std::get<0>(interval2);\n    long d = std::get<1>(interval2);\n\
    \    if(a>d || b<c) return \"NO\";\n    long start = std::max(a,c);\n    long\
    \ end = std::min(b,d);\n    int count = 0;\n    for(long i=start;i<=end;i++){\n\
    \        if(i<2) continue;\n        bool isPrime = true;\n        for(long j=2;j<=i/2;j++){\n\
    \            if(i%j==0){\n                isPrime = false;\n                break;\n\
    \            }\n        }\n        if(isPrime){\n            count++;\n      \
    \  }\n    }\n    return count == 1 ? \"YES\" : \"NO\";", "\tlong start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\tlong end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \tif (start > end) return \"NO\";\n\tif (start == end) return \"YES\";\n\tfor\
    \ (int i = 2; i <= end / 2; i++)\n\t\tif (end % i == 0) return \"NO\";\n\treturn\
    \ \"YES\";", "    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\
    \    if (start <= end) {\n        long length = end - start + 1;\n        if (length\
    \ <= 2) {\n            return \"NO\";\n        }\n        if (length % 2 == 0)\
    \ {\n            return \"NO\";\n        }\n        long divisor = 3;\n      \
    \  while (divisor <= length) {\n            if (length % divisor == 0) {\n   \
    \             return \"NO\";\n            }\n            divisor += 2;\n     \
    \   }\n        return \"YES\";\n    }\n    return \"NO\";", "    int start1 =\
    \ std::get<0>(interval1);\n    int end1 = std::get<1>(interval1);\n    int start2\
    \ = std::get<0>(interval2);\n    int end2 = std::get<1>(interval2);\n    if (start1\
    \ > end1 || start2 > end2) {\n        return \"NO\";\n    }\n    if (start1 >\
    \ start2) {\n        start1 = start2;\n    }\n    if (end1 < end2) {\n       \
    \ end1 = end2;\n    }\n    int length = end1 - start1;\n    if (length == 1) {\n\
    \        return \"NO\";\n    }\n    for (int i = 2; i <= length/2; i++) {\n  \
    \      if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";", "    long i1 = std::get<0>(interval1);\n    long i2 = std::get<1>(interval1);\n\
    \    long j1 = std::get<0>(interval2);\n    long j2 = std::get<1>(interval2);\n\
    \    long intersectionLength = std::max(0L, std::min(i2, j2) - std::max(i1, j1)\
    \ + 1);\n    return isPrime(intersectionLength) ? \"YES\" : \"NO\";", "    long\
    \ s1 = std::get<0>(interval1);\n    long e1 = std::get<1>(interval1);\n    long\
    \ s2 = std::get<0>(interval2);\n    long e2 = std::get<1>(interval2);\n    if\
    \ (s1 > e1) {\n        std::swap(s1, e1);\n    }\n    if (s2 > e2) {\n       \
    \ std::swap(s2, e2);\n    }\n    long count = std::max(s1, s2) - std::min(e1,\
    \ e2);\n    if (count <= 0) {\n        return \"NO\";\n    }\n    if (count <=\
    \ 1) {\n        return \"YES\";\n    }\n    for (int i = 2; i <= sqrt(count);\
    \ i++) {\n        if (count % i == 0) {\n            return \"NO\";\n        }\n\
    \    }\n    return \"YES\";", "    // Check whether they intersect or not\n  \
    \  if (std::get<0>(interval1) > std::get<1>(interval2) || std::get<0>(interval2)\
    \ > std::get<1>(interval1)) {\n        return \"NO\";\n    }\n\n    long intersection_start\
    \ = std::max(std::get<0>(interval1), std::get<0>(interval2));\n    long intersection_end\
    \ = std::min(std::get<1>(interval1), std::get<1>(interval2));\n    long intersection_length\
    \ = intersection_end - intersection_start + 1;\n\n    // Check whether the length\
    \ is prime or not\n    for (long i = 2; i * i <= intersection_length; i++) {\n\
    \        if (intersection_length % i == 0) {\n            return \"NO\";\n   \
    \     }\n    }\n\n    return \"YES\";", "  long L = max(get<0>(interval1), get<0>(interval2));\n\
    \  long R = min(get<1>(interval1), get<1>(interval2));\n  if (L > R) return \"\
    NO\";\n  if (L == R) return isPrime(1) ? \"YES\" : \"NO\";\n  for (long i = L;\
    \ i <= R; i++) {\n    if (isPrime(i - L + 1)) return \"YES\";\n  }\n  return \"\
    NO\";", "  bool isPrime = true;\n  long firstStart = std::get<0>(interval1);\n\
    \  long firstEnd = std::get<1>(interval1);\n  long secondStart = std::get<0>(interval2);\n\
    \  long secondEnd = std::get<1>(interval2);\n  long maxEnd = firstEnd > secondEnd\
    \ ? firstEnd : secondEnd;\n  long minStart = firstStart < secondStart ? firstStart\
    \ : secondStart;\n  long lengthIntersection = maxEnd - minStart;\n  if (lengthIntersection\
    \ <= 0) {\n    return \"NO\";\n  }\n  for (int i = 2; i < lengthIntersection;\
    \ i++) {\n    if (lengthIntersection % i == 0) {\n      isPrime = false;\n   \
    \   break;\n    }\n  }\n  return isPrime ? \"YES\" : \"NO\";", "    long minx,\
    \ miny, maxx, maxy;\n    if (std::get<0>(interval1) > std::get<0>(interval2))\
    \ {\n        minx = std::get<0>(interval2);\n        maxx = std::get<0>(interval1);\n\
    \    } else {\n        minx = std::get<0>(interval1);\n        maxx = std::get<0>(interval2);\n\
    \    }\n    if (std::get<1>(interval1) > std::get<1>(interval2)) {\n        miny\
    \ = std::get<1>(interval2);\n        maxy = std::get<1>(interval1);\n    } else\
    \ {\n        miny = std::get<1>(interval1);\n        maxy = std::get<1>(interval2);\n\
    \    }\n    if (minx > maxy || miny > maxx) return \"NO\";\n    if (minx == maxx\
    \ || miny == maxy) return \"NO\";\n    std::vector<long> numbers;\n    for (long\
    \ i = minx; i <= maxx; i++) {\n        numbers.push_back(i);\n    }\n    for (long\
    \ i = miny; i <= maxy; i++) {\n        numbers.push_back(i);\n    }\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    numbers.erase(std::unique(numbers.begin(), numbers.end()),\
    \ numbers.end());\n    if (numbers.size() == 1) return \"NO\";\n    if (numbers.size()\
    \ == 2) return \"YES\";\n    for (long i = 2; i < numbers.size(); i++) {\n   \
    \     if (numbers[i] % 2 == 0 || numbers[i] % 3 == 0 || numbers[i] % 5 == 0) return\
    \ \"NO\";\n    }\n    return \"YES\";", "    // check if the intervals intersect\n\
    \    // (1, 2) (2, 3) - NO\n    // (-1, 1) (0, 4) - NO\n    // (-3, -1) (-5, 5)\
    \ - YES\n    if (std::get<0>(interval1) > std::get<1>(interval2) || std::get<0>(interval2)\
    \ > std::get<1>(interval1)) return \"NO\";\n    // find the boundary of the intersection\n\
    \    // (1, 2) (2, 3) - (2, 2)\n    // (-1, 1) (0, 4) - (0, 1)\n    // (-3, -1)\
    \ (-5, 5) - (-3, -1)\n    long st = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \    long en = std::min(std::get<1>(interval1), std::get<1>(interval2));\n   \
    \ long len = en - st + 1;\n    if (len == 0) return \"NO\";\n    // check if the\
    \ length is prime\n    bool isPrime = true;\n    for (long i = 2; i * i <= len;\
    \ i++) {\n        if (len % i == 0) {\n            isPrime = false;\n        \
    \    break;\n        }\n    }\n    return isPrime ? \"YES\" : \"NO\";", "  if\
    \ (std::get<0>(interval1) < std::get<0>(interval2))\n    interval1 = std::tuple<long,\
    \ long>(std::get<0>(interval2), std::get<1>(interval1));\n  if (std::get<1>(interval1)\
    \ > std::get<1>(interval2))\n    interval1 = std::tuple<long, long>(std::get<0>(interval1),\
    \ std::get<1>(interval2));\n  return std::get<0>(interval1) <= std::get<1>(interval1)\
    \ ?\n    (std::get<1>(interval1) - std::get<0>(interval1) > 1 ? \"NO\" : \"YES\"\
    ) : \"NO\";", "\tstd::string msg = \"NO\";\n\tint start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\tint end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \tint length = end - start;\n\tif (length < 2) {\n\t\treturn msg;\n\t}\n\tfor\
    \ (int i = 2; i < length; i++) {\n\t\tif (length % i == 0) {\n\t\t\treturn msg;\n\
    \t\t}\n\t}\n\treturn \"YES\";", "  // Interval (1,3) start = 1, end = 3\n  //\
    \ Interval (2,4) start = 2, end = 4\n  // Interval intersection is (2,3) start\
    \ = 2, end = 3\n  // (1,3) and (2,4) do not intersect\n  // (1,2) and (2,3) intersect\
    \ at (2,2)\n  // (2,3) and (1,2) intersect at (2,2)\n  // (1,3) and (1,2) intersect\
    \ at (1,2)\n  // (1,2) and (1,3) intersect at (1,2)\n  // (1,3) and (3,4) intersect\
    \ at (3,3)\n  // (3,4) and (1,3) intersect at (3,3)\n  // (1,3) and (0,4) intersect\
    \ at (1,3)\n  // (0,4) and (1,3) intersect at (1,3)\n  // (1,3) and (0,2) intersect\
    \ at (1,2)\n  // (0,2) and (1,3) intersect at (1,2)\n  // (1,3) and (2,4) intersect\
    \ at (2,3)\n  // (2,4) and (1,3) intersect at (2,3)\n  long s1 = std::get<0>(interval1);\n\
    \  long e1 = std::get<1>(interval1);\n  long s2 = std::get<0>(interval2);\n  long\
    \ e2 = std::get<1>(interval2);\n  long start = std::max(s1, s2);\n  long end =\
    \ std::min(e1, e2);\n  if (start > end) {\n    return \"NO\";\n  }\n  if (start\
    \ <= 2 && end >= 2) {\n    return \"YES\";\n  }\n  if (start <= 3 && end >= 3)\
    \ {\n    return \"YES\";\n  }\n  for (long i = start; i <= end; i++) {\n    if\
    \ (i % 2 == 0 || i % 3 == 0) {\n", "    long a = std::get<0>(interval1);\n   \
    \ long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n   \
    \ long d = std::get<1>(interval2);\n    long min = std::max(a, c);\n    long max\
    \ = std::min(b, d);\n    if (min > max) return \"NO\";\n    int i = 2;\n    while\
    \ (i < max) {\n        if (max % i == 0) return \"NO\";\n        i++;\n    }\n\
    \    return \"YES\";", "    int start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \    int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n   \
    \ //if end < start, it means intervals don't intersect\n    if(end < start) return\
    \ \"NO\";\n    int len = end - start + 1;\n    //for 0,1 it will be 1, so not\
    \ prime number\n    if(len == 1) return \"NO\";\n    //i*i <= len\n    for(int\
    \ i = 2; i*i <= len; i++){\n        if(len % i == 0) return \"NO\";\n    }\n \
    \   return \"YES\";", "    long start1 = std::get<0>(interval1);\n    long end1\
    \ = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long\
    \ end2 = std::get<1>(interval2);\n    long range = end1 - start1;\n    // \u533A\
    \u95F4\u6CA1\u6709\u4EA4\u96C6\n    if(start1 > end2 || start2 > end1) {\n   \
    \     return \"NO\";\n    }\n    std::vector<long> range1;\n    std::vector<long>\
    \ range2;\n    for(long i = start1; i <= end1; i++) {\n        range1.push_back(i);\n\
    \    }\n    for(long i = start2; i <= end2; i++) {\n        range2.push_back(i);\n\
    \    }\n    std::sort(range1.begin(), range1.end());\n    std::sort(range2.begin(),\
    \ range2.end());\n    // \u533A\u95F4\u7684\u4EA4\u96C6\n    std::vector<long>\
    \ range3;\n    for(long i = 0; i < range1.size(); i++) {\n        for(long j =\
    \ 0; j < range2.size(); j++) {\n            if(range1[i] == range2[j]) {\n   \
    \             range3.push_back(range1[i]);\n            }\n        }\n    }\n\
    \    std::sort(range3.begin(), range3.end());\n    long range3_len = range3.size();\n\
    \    std::cout << \"range3_len: \" << range3_len << std::endl;\n    if(range3_len\
    \ == 0) {\n        return \"NO\";\n    } else {\n        // \u5982\u679C\u662F\
    \u8D28\u6570,\u8FD4\u56DEYES\n        bool is_prime = true;\n        for(long\
    \ i = 2; i < range3_len; i++) {\n            if(range3_len % i == 0) {\n     \
    \           is_prime = false;\n                break;\n            }\n       \
    \ }\n        if(is_prime) {\n            return \"YES\";\n       ", "\t\n\t//\
    \ find begining point\n\tlong start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \t// find end point\n\tlong end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \t// if start is greater than end, then the intervals don't intersect\n\tif (start\
    \ > end) return \"NO\";\n\t// check if the distance between start and end is a\
    \ prime number\n\tfor (long i = 2; i < end - start; i++)\n\t\tif ((end - start)\
    \ % i == 0) return \"NO\";\n\treturn \"YES\";", "\tlong start = max(get<0>(interval1),\
    \ get<0>(interval2));\n\tlong end = min(get<1>(interval1), get<1>(interval2));\n\
    \tif (start > end) return \"NO\";\n\tlong len = end - start + 1;\n\tif (len ==\
    \ 1) return \"NO\";\n\tif (len == 2) return \"YES\";\n\tif (len % 2 == 0) return\
    \ \"NO\";\n\tfor (long i = 3; i * i <= len; i += 2)\n\t\tif (len % i == 0) return\
    \ \"NO\";\n\treturn \"YES\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) return \"NO\";\n    for (int i = 2; i <= sqrt(end - start);\
    \ i++) {\n        if ((end - start) % i == 0) return \"NO\";\n    }\n    return\
    \ \"YES\";", '    std::vector<int> prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
    31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,
    113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,
    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
    293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,
    397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,
    491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
    601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,
    701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
    821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,
    929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,
    1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103,
    1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201', "   \
    \ auto [min1, max1] = interval1;\n    auto [min2, max2] = interval2;\n    if (max1\
    \ < min2 || max2 < min1) return \"NO\";\n    auto [minLength, maxLength] = std::minmax(max1\
    \ - min2, max2 - min1);\n    if (minLength < 2) return \"NO\";\n    for (int i\
    \ = 2; i < minLength; i++) {\n        if (minLength % i == 0) return \"NO\";\n\
    \    }\n    return \"YES\";", "  if (std::get<0>(interval1) <= std::get<0>(interval2)\
    \ && std::get<0>(interval2) <= std::get<1>(interval1)) {\n    int len = std::get<1>(interval1)\
    \ - std::get<0>(interval2) + 1;\n    for (int i = 2; i < len; i++) {\n      if\
    \ (len % i == 0) {\n        return \"NO\";\n      }\n    }\n    return \"YES\"\
    ;\n  }\n  if (std::get<0>(interval2) <= std::get<0>(interval1) && std::get<0>(interval1)\
    \ <= std::get<1>(interval2)) {\n    int len = std::get<1>(interval2) - std::get<0>(interval1)\
    \ + 1;\n    for (int i = 2; i < len; i++) {\n      if (len % i == 0) {\n     \
    \   return \"NO\";\n      }\n    }\n    return \"YES\";\n  }\n  return \"NO\";",
  "    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    if(end1 < start2 || end2 < start1)\n        return \"NO\";\n    long length\
    \ = abs(std::max(start1, start2) - std::min(end1, end2)) + 1;\n    if(length <\
    \ 2)\n        return \"NO\";\n    if(length == 2)\n        return \"YES\";\n \
    \   if(length % 2 == 0)\n        return \"NO\";\n    for(long i = 3; i < length;\
    \ i+=2)\n        if(length % i == 0)\n            return \"NO\";\n    return \"\
    YES\";", "    bool isPrime = true;\n    int start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    int diff = std::abs(end - start) + 1;\n    for (int i = 2; i <= sqrt(diff);\
    \ i++) {\n        if (diff % i == 0) {\n            isPrime = false;\n       \
    \     break;\n        }\n    }\n    return isPrime ? \"YES\" : \"NO\";", "   \
    \ long start, end;\n    bool intersectionExists = false;\n    long start1 = std::get<0>(interval1);\n\
    \    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    if (start1 <= start2) {\n      \
    \  if (end1 >= start2) {\n            intersectionExists = true;\n           \
    \ start = start2;\n        }\n    } else {\n        if (end2 >= start1) {\n  \
    \          intersectionExists = true;\n            start = start1;\n        }\n\
    \    }\n    if (intersectionExists) {\n        if (end1 < end2) {\n          \
    \  end = end1;\n        } else {\n            end = end2;\n        }\n       \
    \ long length = end - start + 1;\n        if (length <= 0) {\n            return\
    \ \"NO\";\n        }\n        long sq = sqrt(length);\n        for (long i = 2;\
    \ i <= sq; i++) {\n            if (length % i == 0) {\n                return\
    \ \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n    return\
    \ \"NO\";", "    long min = std::get<0>(interval1) > std::get<0>(interval2) ?\
    \ std::get<0>(interval1) : std::get<0>(interval2);\n    long max = std::get<1>(interval1)\
    \ < std::get<1>(interval2) ? std::get<1>(interval1) : std::get<1>(interval2);\n\
    \    std::string ret = \"NO\";\n    if (min <= max) {\n        if (max - min ==\
    \ 1 || max - min == 2) {\n            ret = \"YES\";\n        }\n    }\n    return\
    \ ret;", "\tint left = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \tint right = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\tif\
    \ (left > right) {\n\t\treturn \"NO\";\n\t}\n\tif (left == 1) {\n\t\treturn \"\
    NO\";\n\t}\n\tfor (int i = 2; i <= sqrt(left); i++) {\n\t\tif (left % i == 0)\
    \ {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\treturn \"YES\";", "  // Do your magic\
    \ here\n\n  std::string result;\n  long start, end;\n  start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n  end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \  if (start > end) return \"NO\";\n  if (start == end) return \"YES\";\n  for\
    \ (int i = 2; i < start; i++) {\n    if (start % i == 0) {\n      result = \"\
    NO\";\n      break;\n    }\n    else {\n      result = \"YES\";\n    }\n  }\n\
    \  return result;", "    int interStart = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \    int interEnd = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (interStart > interEnd) return \"NO\";\n    if (interStart == interEnd)\
    \ return (interStart > 1) ? \"YES\" : \"NO\";\n    if (interStart <= 1 && interEnd\
    \ >= 1) return \"NO\";\n    bool ans = true;\n    for (int i = 2; i <= interEnd;\
    \ i++) {\n        if (i < interStart) continue;\n        if (interEnd % i == 0)\
    \ {\n            ans = false;\n            break;\n        }\n    }\n    return\
    \ ans ? \"YES\" : \"NO\";", "\tlong int a, b, c, d;\n\ta = std::get<0>(interval1);\n\
    \tb = std::get<1>(interval1);\n\tc = std::get<0>(interval2);\n\td = std::get<1>(interval2);\n\
    \tif (a > b) {\n\t\tlong int temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\tif (c\
    \ > d) {\n\t\tlong int temp = c;\n\t\tc = d;\n\t\td = temp;\n\t}\n\tif (a < c)\
    \ {\n\t\tif (c < b) {\n\t\t\ta = c;\n\t\t}\n\t\telse {\n\t\t\treturn \"NO\";\n\
    \t\t}\n\t}\n\tif (d < b) {\n\t\tif (d > a) {\n\t\t\tb = d;\n\t\t}\n\t\telse {\n\
    \t\t\treturn \"NO\";\n\t\t}\n\t}\n\tif (b <= a) {\n\t\treturn \"NO\";\n\t}\n\t\
    for (long int j = 2; j <= b / 2; j++) {\n\t\tif (b % j == 0) {\n\t\t\treturn \"\
    NO\";\n\t\t}\n\t}\n\treturn \"YES\";", "  long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n  long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \  if (start > end) {\n    return \"NO\";\n  }\n  bool is_prime = true;\n  for\
    \ (long i = 2; i <= end; i++) {\n    if (end % i == 0) {\n      is_prime = false;\n\
    \      break;\n    }\n  }\n  return is_prime ? \"YES\" : \"NO\";", "    long start\
    \ = std::max(std::get<0>(interval1), std::get<0>(interval2));\n    long end =\
    \ std::min(std::get<1>(interval1), std::get<1>(interval2));\n    long length =\
    \ end - start;\n    if (length < 1) return \"NO\";\n    // We know the length\
    \ has to be greater than 1, so we can skip that\n    for (long i = 2; i <= length\
    \ / 2; i++) {\n        if (length % i == 0) return \"NO\";\n    }\n    return\
    \ \"YES\";", "    using namespace std;\n    long a = get<0>(interval1);\n    long\
    \ b = get<1>(interval1);\n    long c = get<0>(interval2);\n    long d = get<1>(interval2);\n\
    \    long start = max(a, c);\n    long end = min(b, d);\n    long delta = end\
    \ - start;\n    if (delta < 0) return \"NO\";\n    if (delta == 0) return \"YES\"\
    ;\n    bool isPrime = true;\n    for (long i = 2; i < delta; i++) {\n        if\
    \ (delta % i == 0) {\n            isPrime = false;\n            break;\n     \
    \   }\n    }\n    return isPrime ? \"YES\" : \"NO\";", "\tbool isPrime(int n)\
    \ {\n\t\tfor (int i = 2; i <= std::sqrt(n); i++) {\n\t\t\tif (n % i == 0) {\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t// check if two\
    \ ranges intersect\n\tif (std::get<0>(interval1) > std::get<1>(interval2) || std::get<0>(interval2)\
    \ > std::get<1>(interval1)) {\n\t\treturn \"NO\";\n\t}\n\t// if ranges intersect,\
    \ find their intersection\n\t// the start of the intersection is the maximum of\
    \ the starts of the intervals\n\tint start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n\t// the end of the intersection is the minimum of\
    \ the ends of the intervals\n\tint end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \t// check if the length of the intersection is a prime number\n\treturn isPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";", "    long start1, end1, start2, end2;\n \
    \   std::tie(start1, end1) = interval1;\n    std::tie(start2, end2) = interval2;\n\
    \    if (end1 < start2 || end2 < start1) {\n        return \"NO\";\n    }\n  \
    \  long start, end;\n    start = start1 > start2 ? start1 : start2;\n    end =\
    \ end1 < end2 ? end1 : end2;\n    long diff = end - start + 1;\n    if (diff ==\
    \ 1) {\n        return \"NO\";\n    }\n    for (long i = 2; i < diff; i++) {\n\
    \        if (diff % i == 0) {\n            return \"NO\";\n        }\n    }\n\
    \    return \"YES\";", "  long start1, start2, end1, end2;\n  std::tie(start1,\
    \ end1) = interval1;\n  std::tie(start2, end2) = interval2;\n  std::vector<long>\
    \ limits {start1, end1, start2, end2};\n  std::sort(limits.begin(), limits.end());\n\
    \  if(limits[2] < limits[1]) return \"NO\";\n  if(limits[3] == limits[2]) return\
    \ \"YES\";\n  long diff = limits[3] - limits[2];\n  if(diff == 1) return \"YES\"\
    ;\n  for(long i = 2; i <= diff/2; i++)\n    if(diff % i == 0) return \"NO\";\n\
    \  return \"YES\";", "    // Write your code here.\n    int start1,end1,start2,end2;\n\
    \    std::tie(start1,end1)=interval1;\n    std::tie(start2,end2)=interval2;\n\
    \    // std::cout<<start1<<\" \"<<end1<<\" \"<<start2<<\" \"<<end2<<\"\\n\";\n\
    \    if(start1>start2)\n    {\n        std::swap(start1,start2);\n        std::swap(end1,end2);\n\
    \    }\n    int len=(end1<end2)?end1:end2;\n    len-=start2;\n    if(len<=0)\n\
    \        return \"NO\";\n    return ((len==1 or len==2 or len==3 or len==5 or\
    \ len==7 or len==11 or len==13)?\"YES\":\"NO\");", "    // TODO: Implement solution\n\
    \tauto start1 = std::get<0>(interval1);\n\tauto end1 = std::get<1>(interval1);\n\
    \tauto start2 = std::get<0>(interval2);\n\tauto end2 = std::get<1>(interval2);\n\
    \tlong new_start = std::max(start1, start2);\n\tlong new_end = std::min(end1,\
    \ end2);\n\tstd::cout << new_start << \" \" << new_end << std::endl;\n\tif (new_start\
    \ > new_end)\n\t\treturn \"NO\";\n\tlong length = new_end - new_start + 1;\n\t\
    for (long i = 2; i < length; i++)\n\t\tif (length % i == 0)\n\t\t\treturn \"NO\"\
    ;\n\treturn \"YES\";", "    long start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  \
    \  if (start >= end) {\n        return \"NO\";\n    }\n    bool prime = true;\n\
    \    for (long i = 2; i < end - start; i++) {\n        if ((end - start) % i ==\
    \ 0) {\n            prime = false;\n            break;\n        }\n    }\n   \
    \ return prime ? \"YES\" : \"NO\";", "    long a = std::get<0>(interval1);\n \
    \   long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n \
    \   long d = std::get<1>(interval2);\n    if (b < c || d < a) return \"NO\";\n\
    \    long start = std::max(a, c);\n    long end = std::min(b, d);\n    int isPrime\
    \ = 1;\n    for (long i = 2; i * i <= end; i++) {\n        if (start <= i && i\
    \ <= end) isPrime = 0;\n    }\n    return isPrime ? \"YES\" : \"NO\";", "  long\
    \ a, b, c, d;\n  std::tie(a, b) = interval1;\n  std::tie(c, d) = interval2;\n\
    \  std::cout << a << ' ' << b << ' ' << c << ' ' << d << '\\n';\n  if (b < c ||\
    \ d < a) {\n    return \"NO\";\n  }\n  std::cout << \"in \" << std::max(a, c)\
    \ << ' ' << std::min(b, d) << '\\n';\n  long e = std::max(a, c);\n  long f = std::min(b,\
    \ d);\n  int count = 0;\n  for (long i = e; i <= f; i++) {\n    count++;\n  }\n\
    \  std::cout << count << '\\n';\n  if (count == 1) {\n    return \"YES\";\n  }\n\
    \  for (long i = 2; i < count / 2; i++) {\n    if (count % i == 0) {\n      return\
    \ \"NO\";\n    }\n  }\n  return \"YES\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start + 1;\n    if (length == 2) {\n        return \"YES\";\n    }\n    if\
    \ (length == 1) {\n        return \"NO\";\n    }\n    long sqrt_length = (long)std::sqrt(length);\n\
    \    for (long i = 2; i <= sqrt_length; i++) {\n        if (length % i == 0) {\n\
    \            return \"NO\";\n        }\n    }\n    return \"YES\";", "\tlong start\
    \ = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\tlong end = std::min(std::get<1>(interval1),\
    \ std::get<1>(interval2));\n\tstd::vector<long> primeNumbers;\n\tif (start > end)\
    \ {\n\t\treturn \"NO\";\n\t}\n\tprimeNumbers.push_back(2);\n\tfor (long i = 3;\
    \ i <= end - start; i++) {\n\t\tbool isPrime = true;\n\t\tfor (long x : primeNumbers)\
    \ {\n\t\t\tif (i % x == 0) {\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t\tif (isPrime) {\n\t\t\tprimeNumbers.push_back(i);\n\t\t}\n\t}\n\t\
    if (start < 0) {\n\t\treturn std::find(primeNumbers.begin(), primeNumbers.end(),\
    \ -start) != primeNumbers.end() ? \"YES\" : \"NO\";\n\t}\n\telse {\n\t\treturn\
    \ std::find(primeNumbers.begin(), primeNumbers.end(), start) != primeNumbers.end()\
    \ ? \"YES\" : \"NO\";\n\t}", "    long start1 = std::get<0>(interval1);\n    long\
    \ end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n\
    \    long end2 = std::get<1>(interval2);\n    long maxStart = start1 > start2\
    \ ? start1 : start2;\n    long minEnd = end1 < end2 ? end1 : end2;\n    long commonLength\
    \ = minEnd - maxStart;\n    if (commonLength <= 0) return \"NO\";\n    long sqrtOfCommonLength\
    \ = sqrt(commonLength);\n    for (long i = 2; i <= sqrtOfCommonLength; i++) {\n\
    \        if (commonLength % i == 0) return \"NO\";\n    }\n    return \"YES\";",
  "    auto check = [](int val)->bool{\n        int cnt = 0;\n        for(int i =\
    \ 1; i <= val; i++)\n            if(val % i == 0)\n                cnt++;\n  \
    \      return cnt == 2;\n    };\n    long s1 = std::get<0>(interval1);\n    long\
    \ e1 = std::get<1>(interval1);\n    long s2 = std::get<0>(interval2);\n    long\
    \ e2 = std::get<1>(interval2);\n    long si = std::max(s1, s2);\n    long ei =\
    \ std::min(e1, e2);\n    if(si > ei) return \"NO\";\n    long len = ei - si +\
    \ 1;\n    return check(len) ? \"YES\" : \"NO\";", "  // start of both intervals\n\
    \  long s1 = std::get<0>(interval1);\n  long s2 = std::get<0>(interval2);\n  //\
    \ end of both intervals\n  long e1 = std::get<1>(interval1);\n  long e2 = std::get<1>(interval2);\n\
    \  // if they do not intersect, return \"NO\"\n  if(s1 > e2 || s2 > e1) return\
    \ \"NO\";\n  // we need to find the start and end of their intersection\n  long\
    \ is = std::max(s1, s2);\n  long ie = std::min(e1, e2);\n  // find the length\
    \ of the intersection\n  long len = ie - is + 1;\n  // if length is 1, return\
    \ \"NO\"\n  if(len == 1) return \"NO\";\n  // if length is a prime, return \"\
    YES\"\n  for(long i = 2; i * i <= len; i++) {\n    if(len % i == 0) return \"\
    NO\";\n  }\n  return \"YES\";", "\tlong start1, end1, start2, end2;\n\tstd::tie(start1,\
    \ end1) = interval1;\n\tstd::tie(start2, end2) = interval2;\n\tif(start1 > end1\
    \ || start2 > end2) {\n\t\treturn \"NO\";\n\t}\n\tstd::vector<long> v;\n\tfor(long\
    \ i = start1; i <= end1; i++) {\n\t\tfor(long j = start2; j <= end2; j++) {\n\t\
    \t\tif(i == j) {\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tif(v.size()\
    \ == 0) {\n\t\treturn \"NO\";\n\t}\n\tlong min = *std::min_element(v.begin(),\
    \ v.end());\n\tlong max = *std::max_element(v.begin(), v.end());\n\tlong c = max\
    \ - min + 1;\n\tif(c == 1) {\n\t\treturn \"NO\";\n\t}\n\tfor(long i = 2; i < c;\
    \ i++) {\n\t\tif(c % i == 0) {\n\t\t\treturn \"NO\";\n\t\t}\n\t}\n\treturn \"\
    YES\";", "  // your code here\n  long start1, start2, end1, end2;\n  std::tie(start1,\
    \ end1) = interval1;\n  std::tie(start2, end2) = interval2;\n  std::vector<long>\
    \ intersect = {std::max(start1, start2), std::min(end1, end2)};\n  if (intersect[0]\
    \ <= intersect[1]) {\n    if (intersect[1] - intersect[0] == 1) return \"YES\"\
    ;\n    bool isPrime = true;\n    for (long i = 2; i <= sqrt(intersect[1]); i++)\
    \ {\n      if ((intersect[1] - intersect[0]) % i == 0) {\n        isPrime = false;\n\
    \        break;\n      }\n    }\n    if (isPrime) return \"YES\";\n  }\n  return\
    \ \"NO\";", "\tlong num1_start = std::get<0>(interval1);\n\tlong num1_end = std::get<1>(interval1);\n\
    \tlong num2_start = std::get<0>(interval2);\n\tlong num2_end = std::get<1>(interval2);\n\
    \tlong lower, higher;\n\tif (num1_start > num2_start) {\n\t\tlower = num1_start;\n\
    \t}\n\telse {\n\t\tlower = num2_start;\n\t}\n\tif (num1_end < num2_end) {\n\t\t\
    higher = num1_end;\n\t}\n\telse {\n\t\thigher = num2_end;\n\t}\n\tif (lower >\
    \ higher) {\n\t\treturn \"NO\";\n\t}\n\telse {\n\t\tlong length = higher - lower\
    \ + 1;\n\t\tif (length == 1) {\n\t\t\treturn \"NO\";\n\t\t}\n\t\tif (length ==\
    \ 2) {\n\t\t\treturn \"YES\";\n\t\t}\n\t\tif (length % 2 == 0) {\n\t\t\treturn\
    \ \"NO\";\n\t\t}\n\t\tfor (long i = 3; i * i <= length; i += 2) {\n\t\t\tif (length\
    \ % i == 0) {\n\t\t\t\treturn \"NO\";\n\t\t\t}\n\t\t}\n\t\treturn \"YES\";\n\t\
    }", "\tstd::set<long> interval1_set;\n\tstd::set<long> interval2_set;\n\tint count_prime\
    \ = 0;\n\tint counter_prime = 0;\n\tstd::vector<long> prime_vec;\n\tbool flag\
    \ = false;\n\tfor (long i = std::get<0>(interval1); i <= std::get<1>(interval1);\
    \ i++) {\n\t\tinterval1_set.insert(i);\n\t}\n\tfor (long i = std::get<0>(interval2);\
    \ i <= std::get<1>(interval2); i++) {\n\t\tinterval2_set.insert(i);\n\t}\n\tstd::set<long>::iterator\
    \ it;\n\tfor (it = interval1_set.begin(); it != interval1_set.end(); it++) {\n\
    \t\tif (interval2_set.find(*it) != interval2_set.end()) {\n\t\t\tflag = true;\n\
    \t\t\tprime_vec.push_back(*it);\n\t\t}\n\t}\n\tif (flag == false)\n\t\treturn\
    \ \"NO\";\n\tfor (long i = 0; i < prime_vec.size(); i++) {\n\t\tcounter_prime\
    \ = 0;\n\t\tfor (long j = 1; j <= prime_vec[i]; j++) {\n\t\t\tif (prime_vec[i]\
    \ % j == 0)\n\t\t\t\tcounter_prime++;\n\t\t}\n\t\tif (counter_prime == 2)\n\t\t\
    \tcount_prime++;\n\t}\n\tif (count_prime == 0)\n\t\treturn \"NO\";\n\treturn \"\
    YES\";", "   long a, b, c, d;\n   std::tie(a, b) = interval1;\n   std::tie(c,\
    \ d) = interval2;\n   std::string result = \"NO\";\n   if (c <= b && d >= a){\n\
    \      if (c < a) c = a;\n      if (d > b) d = b;\n      if (c < d){\n       \
    \  // calculate prime numbers up to d\n         std::vector<long> primes;\n  \
    \       primes.push_back(2);\n         for (long i = 3; i <= d; i++){\n      \
    \      bool isPrime = true;\n            for (auto n : primes){\n            \
    \   if (i % n == 0){\n                  isPrime = false;\n                  break;\n\
    \               }\n            }\n            if (isPrime) primes.push_back(i);\n\
    \         }\n         // check if d - c + 1 is a prime number\n         for (auto\
    \ p : primes){\n            if (p == d - c + 1){\n               result = \"YES\"\
    ;\n               break;\n            }\n         }\n      }\n   }\n   return\
    \ result;", "    long start1, start2, end1, end2;\n    long i, j;\n    std::tie(start1,\
    \ end1) = interval1;\n    std::tie(start2, end2) = interval2;\n    i = std::max(start1,\
    \ start2);\n    j = std::min(end1, end2);\n    if (i >= j) return \"NO\";\n  \
    \  else if (i == j) return \"YES\";\n    long cnt = 0;\n    for (long k = 2; k\
    \ <= j - i; k++) {\n        if ((j - i) % k == 0) cnt++;\n    }\n    if (cnt >\
    \ 0) return \"NO\";\n    else return \"YES\";", "    int first_interval_start\
    \ = std::get<0>(interval1);\n    int first_interval_end = std::get<1>(interval1);\n\
    \    int second_interval_start = std::get<0>(interval2);\n    int second_interval_end\
    \ = std::get<1>(interval2);\n    int start, end;\n    if (first_interval_start\
    \ <= second_interval_start && first_interval_end <= second_interval_end) {\n \
    \       start = second_interval_start;\n        end = first_interval_end;\n  \
    \  } else if (first_interval_start >= second_interval_start && first_interval_end\
    \ >= second_interval_end) {\n        start = first_interval_start;\n        end\
    \ = second_interval_end;\n    } else if (first_interval_start <= second_interval_start\
    \ && first_interval_end >= second_interval_end) {\n        start = second_interval_start;\n\
    \        end = second_interval_end;\n    } else if (first_interval_start >= second_interval_start\
    \ && first_interval_end <= second_interval_end) {\n        start = first_interval_start;\n\
    \        end = first_interval_end;\n    }\n    if (end <= start) return \"NO\"\
    ;\n    int length = end - start;\n    int counter = 0;\n    for (int i = 1; i\
    \ <= length; i++) {\n        if (length % i == 0) counter++;\n    }\n    if (counter\
    \ == 2) return \"YES\";\n    return \"NO\";", "\tint x1, x2, y1, y2;\n\tstd::tie(x1,\
    \ x2) = interval1;\n\tstd::tie(y1, y2) = interval2;\n\t//std::vector<long> v1,\
    \ v2;\n\t//v1.push_back(x1); v1.push_back(x2);\n\t//v2.push_back(y1); v2.push_back(y2);\n\
    \t//std::sort(v1.begin(), v1.end());\n\t//std::sort(v2.begin(), v2.end());\n\t\
    //if (v1[1] < v2[0] || v2[1] < v1[0]) {\n\t//\treturn \"NO\";\n\t//}\n\t//long\
    \ min = v1[1];\n\t//long max = v2[0];\n\t//if (v1[1] > v2[1]) {\n\t//\tmin = v2[1];\n\
    \t//}\n\t//if (v1[0] < v2[0]) {\n\t//\tmax = v1[0];\n\t//}\n\tif ((x1 <= y1 &&\
    \ y1 <= x2) || (y1 <= x1 && x1 <= y2)) {\n\t\tlong min = std::min(x2, y2);\n\t\
    \tlong max = std::max(x1, y1);\n\t\tif (min - max + 1 <= 1) {\n\t\t\treturn \"\
    NO\";\n\t\t}\n\t\telse {\n\t\t\tint count = 0;\n\t\t\tfor (long i = min; i >=\
    \ max; i--) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count == 2) {\n\t\t\t\treturn\
    \ \"YES\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (long i = 2; i <= sqrt(count);\
    \ i++) {\n\t\t\t\t\tif (count % i == 0) {\n\t\t\t\t\t\treturn \"NO\";\n\t\t\t\t\
    \t}\n\t\t\t\t}\n\t\t\t\treturn \"YES\";\n\t\t\t}\n\t\t", "    // the intervals\
    \ don't intersect.\n    if (std::get<0>(interval1) > std::get<1>(interval2) ||\
    \ std::get<0>(interval2) > std::get<1>(interval1)) return \"NO\";\n    if (std::get<0>(interval1)\
    \ > std::get<0>(interval2)) std::swap(interval1, interval2);\n    long i1_end\
    \ = std::get<1>(interval1);\n    long i2_start = std::get<0>(interval2);\n   \
    \ long i2_end = std::get<1>(interval2);\n    long len = i2_start - i1_end;\n \
    \   if (len < 2) return \"NO\";\n    if (len == 2) return \"YES\";\n    else {\n\
    \        if (len % 2 == 0) return \"NO\";\n        else {\n            for (long\
    \ i = 3; i <= sqrt(len); i += 2) {\n                if (len % i == 0) return \"\
    NO\";\n            }\n            return \"YES\";\n        }\n    }", "  long\
    \ left = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  long right\
    \ = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  long x = right\
    \ - left;\n  if (x <= 0) return \"NO\";\n  for (long i = 2; i * i <= x; i++)\n\
    \    if (x % i == 0) return \"NO\";\n  return \"YES\";", "  long start1, end1,\
    \ start2, end2;\n  start1 = std::get<0>(interval1);\n  end1 = std::get<1>(interval1);\n\
    \  start2 = std::get<0>(interval2);\n  end2 = std::get<1>(interval2);\n  bool\
    \ isPrime = true;\n  long intersectionLength = 0;\n  if(start1 <= start2 && end1\
    \ >= start2) {\n    if(end1 <= end2) {\n      intersectionLength = end1 - start2\
    \ + 1;\n    } else {\n      intersectionLength = end2 - start2 + 1;\n    }\n \
    \ } else if(start2 <= start1 && end2 >= start1) {\n    if(end2 <= end1) {\n  \
    \    intersectionLength = end2 - start1 + 1;\n    } else {\n      intersectionLength\
    \ = end1 - start1 + 1;\n    }\n  } else {\n    return \"NO\";\n  }\n  for(long\
    \ i = 2; i <= intersectionLength / 2; i++) {\n    if(intersectionLength % i ==\
    \ 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  if(isPrime) {\n  \
    \  return \"YES\";\n  } else {\n    return \"NO\";\n  }", "    long a = std::get<0>(interval1);\n\
    \    long b = std::get<1>(interval1);\n    long c = std::get<0>(interval2);\n\
    \    long d = std::get<1>(interval2);\n    // check if no intersection\n    if\
    \ (a > d || b < c) {\n        return \"NO\";\n    }\n    std::vector<long> v =\
    \ {a, b, c, d};\n    std::sort(v.begin(), v.end());\n    long start = v[1];\n\
    \    long end = v[2];\n    if (start >= end) {\n        return \"NO\";\n    }\n\
    \    long len = end - start;\n    long p = 2;\n    while (p * p <= len) {\n  \
    \      if (len % p == 0) {\n            return \"NO\";\n        }\n        p++;\n\
    \    }\n    return \"YES\";", "    std::vector<int> v;\n    long a1, b1, a2, b2;\n\
    \    std::tie(a1, b1) = interval1;\n    std::tie(a2, b2) = interval2;\n    for\
    \ (int i = a1; i <= b1; i++)\n        for (int j = a2; j <= b2; j++)\n       \
    \     if (i == j)\n                v.push_back(i);\n    int c = 0;\n    for (int\
    \ i = 0; i < v.size(); i++)\n        if (v[i] > 1)\n            for (int j = 2;\
    \ j <= v[i] / 2; j++)\n                if (v[i] % j == 0)\n                  \
    \  c++;\n    if (c > 1)\n        return \"NO\";\n    else\n        return \"YES\"\
    ;", "\t//cout << get<0>(interval1) << \" \" << get<1>(interval1) << endl;\n\t\
    //cout << get<0>(interval2) << \" \" << get<1>(interval2) << endl;\n\tif (get<0>(interval1)\
    \ < get<0>(interval2)) {\n\t\tif (get<1>(interval1) < get<0>(interval2))\n\t\t\
    \treturn \"NO\";\n\t\tif (get<1>(interval1) < get<1>(interval2)) {\n\t\t\tint\
    \ l1 = get<1>(interval1) - get<0>(interval2) + 1;\n\t\t\tif (l1 == 1)\n\t\t\t\t\
    return \"NO\";\n\t\t\tif (l1 == 2)\n\t\t\t\treturn \"YES\";\n\t\t\tif (l1 % 2\
    \ == 0)\n\t\t\t\treturn \"NO\";\n\t\t\tfor (int i = 3; i <= sqrt(l1); i++) {\n\
    \t\t\t\tif (l1 % i == 0)\n\t\t\t\t\treturn \"NO\";\n\t\t\t}\n\t\t\treturn \"YES\"\
    ;\n\t\t}\n\t\tif (get<1>(interval1) == get<1>(interval2)) {\n\t\t\treturn \"NO\"\
    ;\n\t\t}\n\t\tint l1 = get<1>(interval2) - get<0>(interval2) + 1;\n\t\tif (l1\
    \ == 1)\n\t\t\treturn \"NO\";\n\t\tif (l1 == 2)\n\t\t\treturn \"YES\";\n\t\tif\
    \ (l1 % 2 == 0)\n\t\t\treturn \"NO\";\n\t\tfor (int i = 3; i <= sqrt(l1); i++)\
    \ {\n\t\t\tif (l1 % i == 0)\n\t\t\t\treturn \"NO\";\n\t\t}\n\t\treturn \"YES\"\
    ;\n\t}\n\tif (get<0>(interval1) == get<0>(interval2)) {\n\t\tif (get<1>(interval1)\
    \ < get<1>(interval2)) {\n\t\t\t", "\t//(2, 3), (1, 4)\n\t//(3, 4), (1, 2)\n\t\
    //(1, 2), (4, 5)\n\tstd::cout << \"interval1: (\" << std::get<0>(interval1) <<\
    \ \", \" << std::get<1>(interval1) << \")\" << std::endl;\n\tstd::cout << \"interval2:\
    \ (\" << std::get<0>(interval2) << \", \" << std::get<1>(interval2) << \")\" <<\
    \ std::endl;\n\tif (std::get<0>(interval1) > std::get<1>(interval2) || std::get<0>(interval2)\
    \ > std::get<1>(interval1))\n\t\treturn \"NO\";\n\tstd::vector<int> v;\n\tv.push_back(std::get<0>(interval1));\n\
    \tv.push_back(std::get<1>(interval1));\n\tv.push_back(std::get<0>(interval2));\n\
    \tv.push_back(std::get<1>(interval2));\n\tstd::sort(v.begin(), v.end());\n\tstd::cout\
    \ << \"intersection: (\" << v[1] << \", \" << v[2] << \")\" << std::endl;\n\t\
    int x = v[2] - v[1];\n\tif (x <= 1)\n\t\treturn \"NO\";\n\tfor (int i = 2; i <\
    \ x; i++) {\n\t\tif (x % i == 0)\n\t\t\treturn \"NO\";\n\t}\n\treturn \"YES\";",
  "    long num1 = std::get<0>(interval1);\n    long num2 = std::get<1>(interval1);\n\
    \    long num3 = std::get<0>(interval2);\n    long num4 = std::get<1>(interval2);\n\
    \    long min_num1 = std::min(num1, num2);\n    long max_num1 = std::max(num1,\
    \ num2);\n    long min_num2 = std::min(num3, num4);\n    long max_num2 = std::max(num3,\
    \ num4);\n    if (min_num1 > max_num2 || min_num2 > max_num1)\n        return\
    \ \"NO\";\n    long len = std::min(max_num1, max_num2) - std::max(min_num1, min_num2)\
    \ + 1;\n    if (len == 1)\n        return \"NO\";\n    else {\n        for (long\
    \ i = 2; i <= sqrt(len); i++) {\n            if (len % i == 0)\n             \
    \   return \"NO\";\n        }\n        return \"YES\";\n    }", "  // your code\
    \ here!\n  long start1, start2, end1, end2;\n  std::tie(start1, end1) = interval1;\n\
    \  std::tie(start2, end2) = interval2;\n  std::set<long> s;\n  // std::cout <<\
    \ start1 << \", \" << end1 << \" | \" << start2 << \", \" << end2 << \"\\n\";\n\
    \  for (int i = start1; i <= end1; i++) {\n    s.insert(i);\n  }\n  for (int i\
    \ = start2; i <= end2; i++) {\n    s.insert(i);\n  }\n  long start = std::max(start1,\
    \ start2);\n  long end = std::min(end1, end2);\n  long len = end - start + 1;\n\
    \  // std::cout << start << \", \" << end << \" | \" << len << \"\\n\";\n  if\
    \ (len < 0) {\n    return \"NO\";\n  }\n  if (len == 0) {\n    return \"YES\"\
    ;\n  }\n  for (int i = 2; i * i <= len; i++) {\n    if (len % i == 0) {\n    \
    \  return \"NO\";\n    }\n  }\n  return \"YES\";", "    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start > end) {\n        return \"NO\";\n    } else {\n        if (start\
    \ == end) {\n            return \"YES\";\n        } else {\n            return\
    \ (std::__gcd(start, end) == 1) ? \"YES\" : \"NO\";\n        }\n    }", "    long\
    \ start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n\
    \    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\
    \    if(start1 > end1 || start2 > end2) return \"NO\";\n    long is = std::max(start1,\
    \ start2);\n    long ie = std::min(end1, end2);\n    if(is <= ie) {\n        return\
    \ (ie - is + 1) % 2 == 0 ? \"NO\" : \"YES\";\n    }\n    return \"NO\";", "  std::string\
    \ result;\n  std::tuple<long, long> unionInterval;\n  // Note that this function\
    \ calculates the union of the intervals,\n  // but we can use it to calculate\
    \ the intersection.\n  // If the range is [-3, -1] and [-5, 5], the union of these\
    \ two intervals is [-5, 5]\n  // And the intersection is [-3, -1].\n  unionInterval\
    \ = std::tuple<long, long>(std::max(std::get<0>(interval1), std::get<0>(interval2)),\
    \ std::min(std::get<1>(interval1), std::get<1>(interval2)));\n  // Check if the\
    \ range is negative.\n  if(std::get<0>(unionInterval) > std::get<1>(unionInterval))\n\
    \    return \"NO\";\n  // If the interval is just one number (1, 1), then the\
    \ length of intersection is 1.\n  if(std::get<0>(unionInterval) == std::get<1>(unionInterval))\n\
    \    return \"YES\";\n  long rangeLength = std::get<1>(unionInterval) - std::get<0>(unionInterval)\
    \ + 1;\n  for(long i = 2; i < rangeLength; i++) {\n    if(rangeLength % i == 0)\n\
    \      return \"NO\";\n  }\n  return \"YES\";", "    long a1 = std::get<0>(interval1);\n\
    \    long b1 = std::get<1>(interval1);\n    long a2 = std::get<0>(interval2);\n\
    \    long b2 = std::get<1>(interval2);\n    long x = std::max(a1, a2);\n    long\
    \ y = std::min(b1, b2);\n    if (x >= y) {\n        return \"NO\";\n    }\n  \
    \  long n = y - x;\n    for (long i = 2; i * i <= n; i++) {\n        if (n % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";",
  "    std::vector<long> ints;\n    std::vector<long> primes = {2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\
    \ 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179,\
    \ 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269,\
    \ 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367,\
    \ 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\
    \ 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,\
    \ 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,\
    \ 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773,\
    \ 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883,\
    \ 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n\
    \    ints.push_back(std::get<0>(interval1));\n    ints.push_back(std::get<1>(interval1));\n\
    \    ints.push_back(std::get<0>(interval2));\n    ints.push_back(std::get<1>(interval",
  "  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n\
    \  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\
    \  if(start1 > end1 || start2 > end2) {\n    return \"NO\";\n  }\n  if(start1\
    \ > start2) {\n    std::swap(start1, start2);\n    std::swap(end1, end2);\n  }\n\
    \  if(start2 > end1) {\n    return \"NO\";\n  }\n  long len = std::min(end1, end2)\
    \ - start2 + 1;\n  if(len <= 1) {\n    return \"NO\";\n  }\n  for(long i = 2;\
    \ i * i <= len; ++i) {\n    if(len % i == 0) {\n      return \"NO\";\n    }\n\
    \  }\n  return \"YES\";", "    bool flag = true;\n    long start = std::max(std::get<0>(interval1),\
    \ std::get<0>(interval2));\n    long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\
    \    if (start >= end) {\n        return \"NO\";\n    }\n    long length = end\
    \ - start;\n    for (long i = 2; i <= length / 2; i++) {\n        if (length %\
    \ i == 0) {\n            flag = false;\n            break;\n        }\n    }\n\
    \    if (flag) {\n        return \"YES\";\n    }\n    return \"NO\";", "\tlong\
    \ a = std::get<0>(interval1);\n\tlong b = std::get<1>(interval1);\n\tlong c =\
    \ std::get<0>(interval2);\n\tlong d = std::get<1>(interval2);\n\tstd::vector<long>\
    \ nums = {a, b, c, d};\n\tstd::sort(nums.begin(), nums.end());\n\tstd::string\
    \ ans = \"NO\";\n\tif(nums[2] - nums[1] > 1) {\n\t\tlong intersectionLength =\
    \ nums[2] - nums[1] - 1;\n\t\tfor(long i = 2; i <= intersectionLength; i++) {\n\
    \t\t\tif(intersectionLength % i == 0) {\n\t\t\t\tans = \"NO\";\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\tans = \"YES\";\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;",
  "    long int start1 = std::get<0>(interval1);\n    long int end1 = std::get<1>(interval1);\n\
    \    long int start2 = std::get<0>(interval2);\n    long int end2 = std::get<1>(interval2);\n\
    \    long int lc = 0;\n    if (start1 <= start2) {\n        if (end1 < start2)\
    \ {\n            return \"NO\";\n        }\n        lc = end1 - start2 + 1;\n\
    \    } else {\n        if (end2 < start1) {\n            return \"NO\";\n    \
    \    }\n        lc = end2 - start1 + 1;\n    }\n    bool prime = true;\n    if\
    \ (lc > 1) {\n        for (long int i = 2; i <= sqrt(lc); i++) {\n           \
    \ if (lc % i == 0) {\n                prime = false;\n                break;\n\
    \            }\n        }\n    } else {\n        prime = false;\n    }\n    if\
    \ (prime) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n \
    \   }", "    std::vector<long> points;\n    points.push_back(std::get<0>(interval1));\n\
    \    points.push_back(std::get<1>(interval1));\n    points.push_back(std::get<0>(interval2));\n\
    \    points.push_back(std::get<1>(interval2));\n    std::sort(points.begin(),\
    \ points.end());\n    if (points[0] == points[1] || points[2] == points[3]) {\n\
    \        return \"NO\";\n    }\n    int diff = points[2] - points[1];\n    if\
    \ (diff <= 1) {\n        return \"NO\";\n    }\n    int sqrt_diff = std::sqrt(diff);\n\
    \    for (int i = 2; i <= sqrt_diff; i++) {\n        if (diff % i == 0) {\n  \
    \          return \"NO\";\n        }\n    }\n    return \"YES\";", "  int firstStart\
    \ = std::get<0>(interval1);\n  int firstEnd = std::get<1>(interval1);\n  int secondStart\
    \ = std::get<0>(interval2);\n  int secondEnd = std::get<1>(interval2);\n  if (secondStart\
    \ > firstEnd || firstStart > secondEnd) return \"NO\";\n  int firstInterval =\
    \ firstEnd - firstStart;\n  int secondInterval = secondEnd - secondStart;\n  if\
    \ (firstInterval == 1 || secondInterval == 1) return \"NO\";\n  bool firstIsPrime\
    \ = false;\n  bool secondIsPrime = false;\n  for (int i = 2; i < firstInterval;\
    \ i++) {\n    if (firstInterval % i == 0) {\n      firstIsPrime = true;\n    \
    \  break;\n    }\n  }\n  for (int i = 2; i < secondInterval; i++) {\n    if (secondInterval\
    \ % i == 0) {\n      secondIsPrime = true;\n      break;\n    }\n  }\n  if (firstIsPrime\
    \ == false || secondIsPrime == false) return \"YES\";\n  return \"NO\";", "  \
    \  long start, end;\n    std::tie(start, end) = interval1;\n    if (start > end)\n\
    \        std::swap(start, end);\n    long start2, end2;\n    std::tie(start2,\
    \ end2) = interval2;\n    if (start2 > end2)\n        std::swap(start2, end2);\n\
    \    if (end < start2 || end2 < start)\n        return \"NO\";\n    long intsectStart\
    \ = std::max(start, start2);\n    long intsectEnd = std::min(end, end2);\n   \
    \ long length = intsectEnd - intsectStart + 1;\n    long sqrtLength = sqrt(length);\n\
    \    for (long i = 2; i <= sqrtLength; i++) {\n        if (length % i == 0)\n\
    \            return \"NO\";\n    }\n    return \"YES\";", "    // Your code here!\n\
    \    // todo\n    return \"NO\";", "    // your code here\n    bool flag=0;\n\
    \    long len=0;\n    if(std::get<0>(interval1)>std::get<0>(interval2))\n    {\n\
    \        flag=1;\n    }\n    // std::cout<<flag<<std::endl;\n    if(flag==0)\n\
    \    {\n        if(std::get<1>(interval1)<std::get<0>(interval2))\n        {\n\
    \            return \"NO\";\n        }\n        else if(std::get<1>(interval1)>=std::get<0>(interval2)\
    \ && std::get<1>(interval1)<=std::get<1>(interval2))\n        {\n            len=std::get<1>(interval1)-std::get<0>(interval2)+1;\n\
    \        }\n        else if(std::get<1>(interval1)>std::get<1>(interval2))\n \
    \       {\n            len=std::get<1>(interval2)-std::get<0>(interval2)+1;\n\
    \        }\n    }\n    else\n    {\n        if(std::get<1>(interval2)<std::get<0>(interval1))\n\
    \        {\n            return \"NO\";\n        }\n        else if(std::get<1>(interval2)>=std::get<0>(interval1)\
    \ && std::get<1>(interval2)<=std::get<1>(interval1))\n        {\n            len=std::get<1>(interval2)-std::get<0>(interval1)+1;\n\
    \        }\n        else if(std::get<1>(interval2)>std::get<1>(interval1))\n \
    \       {\n            len=std::get<1>(interval1)-std::get<0>(interval1)+1;\n\
    \        }\n    }\n    // std::cout<<len<<std::endl;\n    if(len<2)\n    {\n \
    \       return \"NO\";\n    }\n    else\n    {\n        for(long i=2;i<=len/2;i++)\n\
    \        {\n", "\tauto [start1, end1] = interval1;\n\tauto [start2, end2] = interval2;\n\
    \t// The two intervals don't intersect\n\tif (end1 < start2 || end2 < start1)\
    \ {\n\t\treturn \"NO\";\n\t}\n\tauto start = std::max(start1, start2);\n\tauto\
    \ end = std::min(end1, end2);\n\t// The length of the intersection is 0\n\tif\
    \ (start > end) {\n\t\treturn \"NO\";\n\t}\n\t// Check whether the length of the\
    \ intersection is a prime number\n\t// The length of the intersection is in range\
    \ [1, 2^64 - 1]\n\t// which is a large number, therefore we can't use\n\t// all\
    \ primes lower than 2^64 to find whether it is a prime number\n\tif (start ==\
    \ 1) {\n\t\treturn \"YES\";\n\t}\n\tauto length = end - start + 1;\n\t// The length\
    \ of the intersection is a prime number\n\tif (length == 2 || length == 3 || length\
    \ == 5 || length == 7) {\n\t\treturn \"YES\";\n\t}\n\t// Now we know that the\
    \ length of the intersection is greater than 7\n\t// and it can be a prime number\
    \ if it is not divisible by 2, 3, 5, 7\n\t// To check it we need to check it only\
    \ with primes\n\t// which are less than or equal to its square root\n\tlong sqrt_length\
    \ = std::sqrt(length);\n\tif (length % 2 == 0 || length % 3 == 0 || length % 5\
    \ == 0 || length % 7 == 0 || length % sqrt_length == 0) {\n\t\treturn \"NO\";\n\
    \t}\n\t// Now we know that the length of the intersection is greater than 7\n\t\
    // and it can be a prime number if it is not divisible by any prime numbers\n\t\
    // which are in range [11, 2^64 - 1] and less than or equal to its square root\n\
    \t// To check it we need to check it only with primes\n\t// which are in range\
    \ [11, 2^64 - 1] and less than or equal to its square root\n\tauto check_length\
    \ = length;\n\tauto check_sqrt_", "  long s1 = std::get<0>(interval1);\n  long\
    \ e1 = std::get<1>(interval1);\n  long s2 = std::get<0>(interval2);\n  long e2\
    \ = std::get<1>(interval2);\n  // if the intervals dont intersect\n  if (s1 >\
    \ e2 || s2 > e1) return \"NO\";\n  long len = std::min(e1, e2) - std::max(s1,\
    \ s2) + 1;\n  if (len == 2) return \"YES\";\n  else if (len % 2 == 0) return \"\
    NO\";\n  else {\n    long sq = std::sqrt(len);\n    for (long i = 3; i <= sq;\
    \ i += 2) {\n      if (len % i == 0) return \"NO\";\n    }\n    return \"YES\"\
    ;\n  }", "    long intstart1 = std::get<0>(interval1);\n    long intend1 = std::get<1>(interval1);\n\
    \    long intstart2 = std::get<0>(interval2);\n    long intend2 = std::get<1>(interval2);\n\
    \    bool isPrime = true;\n    bool intersects = false;\n    long x, y;\n    x\
    \ = std::max(intstart1, intstart2);\n    y = std::min(intend1, intend2);\n   \
    \ if (x<=y)\n    {\n        for (long i = 2; i <= sqrt(y-x+1); i++)\n        {\n\
    \            if ((y-x+1)%i==0)\n            {\n                isPrime = false;\n\
    \                break;\n            }\n        }\n        intersects = true;\n\
    \    }\n    else\n    {\n        isPrime = false;\n    }\n    if (intersects &&\
    \ isPrime)\n    {\n        return \"YES\";\n    }\n    else\n    {\n        return\
    \ \"NO\";\n    }", "\tconst long start1 = std::get<0>(interval1);\n\tconst long\
    \ end1 = std::get<1>(interval1);\n\tconst long start2 = std::get<0>(interval2);\n\
    \tconst long end2 = std::get<1>(interval2);\n\tconst long startIntersection =\
    \ std::max(start1, start2);\n\tconst long endIntersection = std::min(end1, end2);\n\
    \tif (startIntersection >= endIntersection) {\n\t\treturn \"NO\";\n\t}\n\tconst\
    \ long len = endIntersection - startIntersection;\n\t// Function to check if a\
    \ number is prime\n\tbool isPrime(long n) {\n\t\tif (n <= 1) return false;\n\t\
    \tfor (long i = 2; i < n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn isPrime(len) ? \"YES\" : \"NO\"\
    ;", "\tlong start = max(get<0>(interval1), get<0>(interval2));\n\tlong end = min(get<1>(interval1),\
    \ get<1>(interval2));\n\tlong prime = end - start + 1;\n\tif (prime <= 0) return\
    \ \"NO\";\n\tif (prime == 1) return \"YES\";\n\tif (prime == 2) return \"YES\"\
    ;\n\tif (prime == 3) return \"YES\";\n\tif (prime % 2 == 0) return \"NO\";\n\t\
    if (prime % 3 == 0) return \"NO\";\n\tfor (long i = 5; i * i <= prime; i += 6)\
    \ {\n\t\tif (prime % i == 0) return \"NO\";\n\t\tif (prime % (i + 2) == 0) return\
    \ \"NO\";\n\t}\n\treturn \"YES\";", "    if(std::get<0>(interval1) > std::get<1>(interval2)\
    \ || std::get<0>(interval2) > std::get<1>(interval1))\n        return \"NO\";\n\
    \    std::tuple<long, long> intersect;\n    intersect = std::get<0>(interval1)\
    \ > std::get<0>(interval2) ? interval1 : interval2;\n    intersect = std::get<1>(intersect)\
    \ < std::get<1>(interval1) ? std::make_tuple(std::get<0>(intersect), std::get<1>(intersect))\
    \ : std::make_tuple(std::get<0>(intersect), std::get<1>(interval1));\n    intersect\
    \ = std::get<1>(intersect) < std::get<1>(interval2) ? std::make_tuple(std::get<0>(intersect),\
    \ std::get<1>(intersect)) : std::make_tuple(std::get<0>(intersect), std::get<1>(interval2));\n\
    \    if(std::get<1>(intersect) - std::get<0>(intersect) <= 0)\n        return\
    \ \"NO\";\n    if(std::get<1>(intersect) - std::get<0>(intersect) == 1)\n    \
    \    return \"YES\";\n    for(int i = std::get<0>(intersect); i < std::get<1>(intersect);\
    \ i++)\n        if(std::get<1>(intersect) % i == 0)\n            return \"NO\"\
    ;\n    return \"YES\";", "  long start1 = std::get<0>(interval1);\n  long end1\
    \ = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2\
    \ = std::get<1>(interval2);\n  bool hasIntersection = start1 < end2 && start2\
    \ < end1;\n  if (!hasIntersection) return \"NO\";\n  long intersectionStart =\
    \ std::max(start1, start2);\n  long intersectionEnd = std::min(end1, end2);\n\
    \  long intersectionLength = std::abs(intersectionEnd - intersectionStart) + 1;\n\
    \  if (intersectionLength == 1) return \"NO\";\n  for (long i = 2; i < std::sqrt(intersectionLength);\
    \ i++) {\n    if (intersectionLength % i == 0) return \"NO\";\n  }\n  return \"\
    YES\";", "\tbool prime=true;\n\tlong min=std::max(std::get<0>(interval1),std::get<0>(interval2));\n\
    \tlong max=std::min(std::get<1>(interval1),std::get<1>(interval2));\n\tlong len=max-min;\n\
    \tif(len<2)\n\t\treturn \"NO\";\n\tfor(long i=2;i<len;i++)\n\t\tif(len%i==0)\n\
    \t\t\tprime=false;\n\tif(prime)\n\t\treturn \"YES\";\n\telse\n\t\treturn \"NO\"\
    ;", "  \n  //assume start is always less than end\n  assert(std::get<0>(interval1)\
    \ < std::get<1>(interval1));\n  assert(std::get<0>(interval2) < std::get<1>(interval2));\n\
    \  \n  int start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n\
    \  int end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  \n \
    \ if(start > end)\n    return \"NO\";\n  \n  return std::is_prime(end - start\
    \ + 1) ? \"YES\" : \"NO\";"]
stop_tokens:
- "\n}"
