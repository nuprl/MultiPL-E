name: HumanEval_158_find_max
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts\
  \ a list of strings.\n// The list contains different words. Return the word with\
  \ maximum number\n// of unique characters. If multiple strings have maximum number\
  \ of unique\n// characters, return the one which comes first in lexicographical\
  \ order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"\
  name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"\
  ]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string> words) {\n"
tests: "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
  name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
  name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
  aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
  abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({\"\
  we\", \"are\", \"gonna\", \"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
  this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
  b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\",\
  \ \"play\", \"play\"}))) == (\"play\"));\n}\n"
completions: ["  // Write your code here\n  std::string max_string = \"\";\n  int\
    \ max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char>\
    \ unique_chars;\n    for (char c : word) {\n      unique_chars.insert(c);\n  \
    \  }\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars\
    \ = unique_chars.size();\n      max_string = word;\n    }\n  }\n  return max_string;",
  "    std::string ans;\n    int max = 0;\n    for (auto w : words) {\n        int\
    \ sz = w.size();\n        int unique_count = 0;\n        std::set<char> unique_chars;\n\
    \        for (auto x : w) {\n            unique_chars.insert(x);\n        }\n\
    \        if (unique_chars.size() > max) {\n            max = unique_chars.size();\n\
    \            ans = w;\n        }\n    }\n    return ans;", "  std::string max_word\
    \ = \"\";\n  std::string max_chars = \"\";\n  int max_count = 0;\n  for (auto\
    \ x : words) {\n    std::string curr_chars = \"\";\n    int curr_count = 0;\n\
    \    for (int i = 0; i < x.length(); i++) {\n      if (curr_chars.find(x[i]) ==\
    \ std::string::npos) {\n        curr_chars += x[i];\n        curr_count++;\n \
    \     }\n    }\n    if (curr_count > max_count) {\n      max_count = curr_count;\n\
    \      max_chars = curr_chars;\n      max_word = x;\n    } else if (curr_count\
    \ == max_count) {\n      if (x < max_word) {\n        max_word = x;\n      }\n\
    \    }\n  }\n  return max_word;", "    std::string ret;\n    int max_size = 0;\n\
    \    for (auto i : words) {\n        std::set<char> s(i.begin(), i.end());\n \
    \       int size = s.size();\n        if (size > max_size) {\n            max_size\
    \ = size;\n            ret = i;\n        }\n    }\n    return ret;", "\tstd::vector<int>\
    \ unique_char_count;\n\tstd::vector<std::string> result;\n\tfor (std::string word\
    \ : words) {\n\t\tstd::set<char> unique_chars;\n\t\tfor (char c : word) {\n\t\t\
    \tunique_chars.insert(c);\n\t\t}\n\t\tif (unique_chars.size() == unique_char_count.size())\
    \ {\n\t\t\tresult.push_back(word);\n\t\t}\n\t\telse if (unique_chars.size() >\
    \ unique_char_count.size()) {\n\t\t\tunique_char_count.clear();\n\t\t\tresult.clear();\n\
    \t\t\tresult.push_back(word);\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end());\n\
    \treturn result[0];", "\tif (words.size() == 0) return \"\";\n\tif (words.size()\
    \ == 1) return words[0];\n\tstd::string maxWord = words[0];\n\tint maxNum = 0;\n\
    \tfor (std::string s : words) {\n\t\tstd::set<char> unique;\n\t\tfor (char c :\
    \ s) {\n\t\t\tunique.insert(c);\n\t\t}\n\t\tif (unique.size() > maxNum) {\n\t\t\
    \tmaxNum = unique.size();\n\t\t\tmaxWord = s;\n\t\t}\n\t}\n\treturn maxWord;",
  "\tauto it = words.begin();\n\tstd::string max_str = \"\";\n\tint count_max = 0;\n\
    \tfor (; it != words.end(); it++) {\n\t\tint count = 0;\n\t\tstd::string str =\
    \ *it;\n\t\tstd::set<char> unique_char;\n\t\tfor (int i = 0; i < str.length();\
    \ i++) {\n\t\t\tif (unique_char.find(str[i]) == unique_char.end()) {\n\t\t\t\t\
    unique_char.insert(str[i]);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count >\
    \ count_max) {\n\t\t\tcount_max = count;\n\t\t\tmax_str = str;\n\t\t}\n\t}\n\t\
    return max_str;", "  std::map<std::string, int> m;\n  int max = 0;\n  std::string\
    \ word = \"\";\n  for (auto w : words) {\n    m[w] = std::set<char>(w.begin(),\
    \ w.end()).size();\n    if (m[w] > max) {\n      max = m[w];\n      word = w;\n\
    \    }\n  }\n  return word;", "    std::string ans;\n    std::map<std::string,\
    \ int> map;\n    for (int i = 0; i < words.size(); i++) {\n        int count =\
    \ 0;\n        std::string t = words[i];\n        std::sort(t.begin(), t.end());\n\
    \        auto it = std::unique(t.begin(), t.end());\n        count = std::distance(t.begin(),\
    \ it);\n        map[words[i]] = count;\n    }\n    int max_count = 0;\n    for\
    \ (auto i = map.begin(); i != map.end(); i++) {\n        if (i->second > max_count)\
    \ {\n            max_count = i->second;\n            ans = i->first;\n       \
    \ }\n    }\n    return ans;", "    int unique = 0;\n    std::string result;\n\
    \    for (int i = 0; i < words.size(); i++) {\n        int count = 0;\n      \
    \  std::string curr = words[i];\n        std::string check_str = \"\";\n     \
    \   for (int j = 0; j < curr.size(); j++) {\n            int temp = curr[j];\n\
    \            if (check_str.find(temp) == std::string::npos) {\n              \
    \  count++;\n                check_str += temp;\n            }\n        }\n  \
    \      if (count > unique) {\n            unique = count;\n            result\
    \ = curr;\n        }\n        else if (count == unique) {\n            if (curr\
    \ < result) {\n                result = curr;\n            }\n        }\n    }\n\
    \    return result;", "    std::unordered_map<char, int> numberOfChars;\n    int\
    \ max = 0;\n    int index = 0;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        for (int j = 0; j < words[i].size(); j++) {\n            if (numberOfChars.find(words[i][j])\
    \ == numberOfChars.end()) {\n                numberOfChars[words[i][j]] = 1;\n\
    \            } else {\n                numberOfChars[words[i][j]]++;\n       \
    \     }\n        }\n        if (numberOfChars.size() > max) {\n            max\
    \ = numberOfChars.size();\n            index = i;\n        }\n        numberOfChars.clear();\n\
    \    }\n    return words[index];", "  // write your code here\n  int max_unique_characters\
    \ = 0;\n  std::string answer;\n  for (const auto &word : words) {\n    std::set<char>\
    \ set_of_characters(word.begin(), word.end());\n    if (set_of_characters.size()\
    \ > max_unique_characters) {\n      max_unique_characters = set_of_characters.size();\n\
    \      answer = word;\n    }\n  }\n  return answer;", "\tstd::string max = \"\"\
    ;\n\tstd::vector<char> unique;\n\tfor (int i = 0; i < words.size(); i++) {\n\t\
    \tstd::string temp = words[i];\n\t\tfor (int j = 0; j < temp.size(); j++) {\n\t\
    \t\tbool flag = false;\n\t\t\tfor (int k = 0; k < unique.size(); k++) {\n\t\t\t\
    \tif (temp[j] == unique[k]) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\
    \t}\n\t\t\t}\n\t\t\tif (flag == false) {\n\t\t\t\tunique.push_back(temp[j]);\n\
    \t\t\t}\n\t\t}\n\t\tif (unique.size() > max.size()) {\n\t\t\tmax = temp;\n\t\t\
    }\n\t\tunique.clear();\n\t}\n\treturn max;", "    int max = -1;\n    std::string\
    \ result = \"\";\n    std::unordered_set<char> unique_chars;\n    for (std::string&\
    \ word : words) {\n        unique_chars.clear();\n        for (char ch : word)\
    \ {\n            unique_chars.insert(ch);\n        }\n        if (unique_chars.size()\
    \ > max) {\n            max = unique_chars.size();\n            result = word;\n\
    \        }\n    }\n    return result;", "    std::string result = \"\";\n    std::unordered_set<char>\
    \ characters;\n    int max = -1;\n    for (std::string word : words) {\n     \
    \   if (word.size() > max) {\n            max = word.size();\n            result\
    \ = word;\n        }\n    }\n    if (max == -1) return \"\";\n    for (int i =\
    \ 0; i < result.size(); i++) {\n        characters.insert(result[i]);\n    }\n\
    \    for (std::string word : words) {\n        if (word.size() == max) {\n   \
    \         std::unordered_set<char> new_set;\n            for (int i = 0; i < word.size();\
    \ i++) {\n                new_set.insert(word[i]);\n            }\n          \
    \  if (new_set.size() > characters.size()) {\n                result = word;\n\
    \                characters = new_set;\n            }\n        }\n    }\n    return\
    \ result;", "    int max_unique_char = 0;\n    std::string result = \"\";\n  \
    \  int flag = 0;\n    for(int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ unique_char;\n        for(int j = 0; j < words[i].size(); j++) {\n         \
    \   unique_char.insert(words[i][j]);\n        }\n        int unique_char_count\
    \ = unique_char.size();\n        if(unique_char_count > max_unique_char) {\n \
    \           max_unique_char = unique_char_count;\n            result = words[i];\n\
    \            flag = 1;\n        }\n        else if(unique_char_count == max_unique_char)\
    \ {\n            if(words[i] < result) {\n                result = words[i];\n\
    \            }\n        }\n    }\n    if(flag == 0) {\n        return \"\";\n\
    \    }\n    return result;", "    std::string res = \"\";\n    int max_ = 0;\n\
    \    for (auto i: words) {\n        std::unordered_set<char> a;\n        int count\
    \ = 0;\n        for (auto j: i) {\n            if (a.find(j) == a.end()) {\n \
    \               a.insert(j);\n                count += 1;\n            }\n   \
    \     }\n        if (count > max_) {\n            max_ = count;\n            res\
    \ = i;\n        }\n    }\n    return res;", "    std::string maxStr = \"\";\n\
    \    int maxStrLen = 0;\n    for (std::string str : words) {\n        std::vector<bool>\
    \ chars(256, false);\n        int uniqueChar = 0;\n        for (int i = 0; i <\
    \ str.length(); i++) {\n            if (!chars[str[i]]) {\n                chars[str[i]]\
    \ = true;\n                uniqueChar++;\n            }\n        }\n        if\
    \ (uniqueChar > maxStrLen) {\n            maxStrLen = uniqueChar;\n          \
    \  maxStr = str;\n        }\n    }\n    return maxStr;", "  // your code here\n\
    \  std::string result = \"\";\n  std::map<char, int> charMap;\n  for (int i =\
    \ 0; i < words.size(); i++) {\n    charMap.clear();\n    for (int j = 0; j < words[i].length();\
    \ j++) {\n      auto it = charMap.find(words[i][j]);\n      if (it == charMap.end())\
    \ {\n        charMap.insert(std::pair<char, int>(words[i][j], 1));\n      }\n\
    \    }\n    if (charMap.size() > result.length()) {\n      result = words[i];\n\
    \    }\n  }\n  return result;", "  std::string maxWord;\n  int maxUniqueChars\
    \ = 0;\n  std::unordered_set<char> uniqueChars;\n  for (auto const& word : words)\
    \ {\n    for (auto const& c : word) {\n      uniqueChars.insert(c);\n    }\n \
    \   if (uniqueChars.size() > maxUniqueChars) {\n      maxUniqueChars = uniqueChars.size();\n\
    \      maxWord = word;\n    }\n    uniqueChars.clear();\n  }\n  return maxWord;",
  "  std::string max = \"\";\n  int max_num = 0;\n  for (int i = 0; i < words.size();\
    \ i++) {\n    std::set<char> letters;\n    for (int j = 0; j < words[i].size();\
    \ j++) {\n      if (letters.find(words[i][j]) == letters.end()) {\n        letters.insert(words[i][j]);\n\
    \      }\n    }\n    if (letters.size() > max_num) {\n      max_num = letters.size();\n\
    \      max = words[i];\n    }\n  }\n  return max;", "  std::string result;\n \
    \ for (int i = 0; i < words.size(); i++) {\n    int index = 0;\n    int count\
    \ = 0;\n    for (int j = i + 1; j < words.size(); j++) {\n      int y_count =\
    \ 0;\n      for (int k = 0; k < words[j].size(); k++) {\n        if (words[i].find(words[j][k])\
    \ == std::string::npos) {\n          y_count++;\n        }\n      }\n      if\
    \ (y_count > count) {\n        count = y_count;\n        index = j;\n      }\n\
    \    }\n    std::string temp = words[i];\n    words[i] = words[index];\n    words[index]\
    \ = temp;\n  }\n  return words[0];", "    std::string max = \"\";\n    int max_len\
    \ = 0;\n    int len = 0;\n    std::string ele;\n    std::set<char> chars;\n  \
    \  std::set<char>::iterator it;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        chars.clear();\n        ele = words[i];\n        for (int j = 0; j <\
    \ ele.length(); j++) {\n            chars.insert(ele[j]);\n        }\n       \
    \ len = chars.size();\n        if (len > max_len) {\n            max_len = len;\n\
    \            max = ele;\n        } else if (len == max_len) {\n            if\
    \ (ele < max) {\n                max = ele;\n            }\n        }\n    }\n\
    \    return max;", "    //\n    // Write your code here\n    //\n    std::string\
    \ max_str = \"\";\n    int max_count = 0;\n    int sz = words.size();\n    for(int\
    \ i = 0; i < sz; i++) {\n        int cnt = 0;\n        std::set<char> mp;\n  \
    \      for(int j = 0; j < words[i].size(); j++) {\n            mp.insert(words[i][j]);\n\
    \        }\n        cnt = mp.size();\n        if(cnt > max_count) {\n        \
    \    max_count = cnt;\n            max_str = words[i];\n        }\n        else\
    \ if(cnt == max_count) {\n            if(words[i] < max_str) {\n             \
    \   max_str = words[i];\n            }\n        }\n    }\n    return max_str;",
  "    // Write your code here\n    int max1 = 0;\n    std::string str;\n    for(int\
    \ i = 0; i < words.size(); i++) {\n        std::set<char> word_set;\n        for(char\
    \ c : words[i])\n            word_set.insert(c);\n        if(word_set.size() >\
    \ max1) {\n            max1 = word_set.size();\n            str = words[i];\n\
    \        }\n    }\n    return str;", "    int max_unique_characters = 0;\n   \
    \ std::string result;\n    for (auto& word : words) {\n        std::set<char>\
    \ unique_chars;\n        for (auto& character : word) {\n            unique_chars.insert(character);\n\
    \        }\n        if (unique_chars.size() > max_unique_characters) {\n     \
    \       max_unique_characters = unique_chars.size();\n            result = word;\n\
    \        }\n    }\n    return result;", "\tint max_count = 0;\n\tstd::string max_word;\n\
    \tfor (int i = 0; i < words.size(); i++) {\n\t\tstd::set<char> chars;\n\t\tfor\
    \ (int j = 0; j < words[i].size(); j++) {\n\t\t\tchars.insert(words[i][j]);\n\t\
    \t}\n\t\tif (chars.size() > max_count) {\n\t\t\tmax_count = chars.size();\n\t\t\
    \tmax_word = words[i];\n\t\t}\n\t}\n\treturn max_word;", "    int n = words.size();\n\
    \    int maxc = -1;\n    int maxi = -1;\n    for(int i = 0; i < n; i++) {\n  \
    \      // Note: unordered_set orders the unique elements in a string\n       \
    \ std::unordered_set<char> s(words[i].begin(), words[i].end());\n        if(s.size()\
    \ > maxc) {\n            maxc = s.size();\n            maxi = i;\n        }\n\
    \    }\n    return words[maxi];", "    std::string uniqueWord;\n    int uniqueSize\
    \ = 0;\n    int count;\n    for (int i = 0; i < words.size(); i++) {\n       \
    \ count = 0;\n        for (int j = 0; j < words[i].size(); j++) {\n          \
    \  if (words[i].find(words[i][j]) == words[i].rfind(words[i][j])) {\n        \
    \        count++;\n            }\n        }\n        if (count > uniqueSize) {\n\
    \            uniqueSize = count;\n            uniqueWord = words[i];\n       \
    \ }\n    }\n    return uniqueWord;", "  std::string max;\n  for (int i = 0; i\
    \ < words.size(); i++) {\n    max = std::max(max, words[i]);\n  }\n  return max;",
  "    // Your code here\n    int max_count = 0;\n    std::string max_word = \"\"\
    ;\n    for (auto &word : words) {\n        std::set<char> unique_chars;\n    \
    \    for (auto &c : word) {\n            unique_chars.insert(c);\n        }\n\
    \        if (unique_chars.size() > max_count) {\n            max_count = unique_chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;", "  //\
    \ your code here\n  std::string max;\n  std::map<char, int> occur;\n  int temp\
    \ = 0;\n  for (int i = 0; i < words.size(); i++) {\n    for (int j = 0; j < words[i].size();\
    \ j++) {\n      occur[words[i][j]] = 1;\n    }\n    if (occur.size() > temp) {\n\
    \      temp = occur.size();\n      max = words[i];\n    }\n    occur.clear();\n\
    \  }\n  return max;", "  // declare a hash table\n  // iterate through the vector\n\
    \  // for each string\n  // iterate through the string\n  // if char is unique,\
    \ add to hash table\n  // if char already in hash table, skip\n  // count number\
    \ of unique characters in hash table\n  // if that number is greater than max,\
    \ then update max\n  // and update max string too\n  // do this for all words\
    \ in vector\n  std::unordered_map<char, int> mymap;\n  int max = 0;\n  std::string\
    \ max_string = \"\";\n  for (auto i : words) {\n    for (auto j : i) {\n     \
    \ mymap[j]++;\n    }\n    if (mymap.size() > max) {\n      max = mymap.size();\n\
    \      max_string = i;\n    }\n    mymap.clear();\n  }\n  return max_string;",
  "    if (words.size() == 0) {\n        return \"\";\n    }\n    else if (words.size()\
    \ == 1) {\n        return words[0];\n    }\n    std::unordered_set<char> char_set;\n\
    \    std::map<int, std::vector<std::string> > map_of_words;\n    for (int i =\
    \ 0; i < words.size(); i++) {\n        std::string temp = words[i];\n        for\
    \ (int j = 0; j < temp.size(); j++) {\n            char_set.insert(temp[j]);\n\
    \        }\n        map_of_words[char_set.size()].push_back(temp);\n        char_set.clear();\n\
    \    }\n    std::map<int, std::vector<std::string> >::iterator itr = map_of_words.end();\n\
    \    --itr;\n    std::sort(itr->second.begin(), itr->second.end());\n    return\
    \ itr->second[0];", "  std::string max = \"\";\n  int max_unique = 0;\n  for (std::string\
    \ s : words) {\n    int count = 0;\n    bool visited[256] = {false};\n    for\
    \ (char c : s) {\n      if (!visited[c]) {\n        visited[c] = true;\n     \
    \   count++;\n      }\n    }\n    if (count > max_unique) {\n      max_unique\
    \ = count;\n      max = s;\n    }\n  }\n  return max;", "    std::string ans =\
    \ \"\";\n    int count = 0;\n    for (int i = 0; i < words.size(); i++) {\n  \
    \      std::set<char> s;\n        int cnt = 0;\n        for (int j = 0; j < words[i].size();\
    \ j++) {\n            s.insert(words[i][j]);\n        }\n        cnt = s.size();\n\
    \        if (count < cnt) {\n            count = cnt;\n            ans = words[i];\n\
    \        }\n    }\n    return ans;", "  // Iterate through each word, check length\n\
    \  int max_len = -1;\n  std::string word;\n  std::unordered_set<char> myset;\n\
    \  for (auto iter : words) {\n    for (auto it : iter) {\n      myset.insert(it);\n\
    \    }\n    if (myset.size() > max_len) {\n      max_len = myset.size();\n   \
    \   word = iter;\n    }\n    myset.clear();\n  }\n  return word;", "    std::string\
    \ ans = \"\";\n    int max_n_uniq = 0;\n    for (auto it = words.begin(); it !=\
    \ words.end(); it++) {\n        std::string word = *it;\n        std::set<char>\
    \ seen;\n        for (int i = 0; i < word.size(); i++) {\n            seen.insert(word[i]);\n\
    \        }\n        int n_uniq = seen.size();\n        if (n_uniq > max_n_uniq)\
    \ {\n            max_n_uniq = n_uniq;\n            ans = word;\n        }\n  \
    \  }\n    return ans;", "    std::string result = \"\";\n    int result_count\
    \ = 0;\n    for (auto word : words) {\n        std::unordered_set<char> seen;\n\
    \        for (char c : word) {\n            seen.insert(c);\n        }\n     \
    \   int curr_count = seen.size();\n        if (curr_count > result_count) {\n\
    \            result = word;\n            result_count = curr_count;\n        }\
    \ else if (curr_count == result_count) {\n            if (word < result) {\n \
    \               result = word;\n            }\n        }\n    }\n    return result;",
  "    std::string str1 = \" \";\n    int max_count = 0;\n    std::unordered_map<char,int>\
    \ mapp;\n    for(int i = 0; i < words.size(); i++) {\n        for(int j = 0; j\
    \ < words[i].size(); j++) {\n            mapp[words[i][j]]++;\n        }\n   \
    \     if(max_count < mapp.size()) {\n            max_count = mapp.size();\n  \
    \          str1 = words[i];\n        }\n        mapp.clear();\n    }\n    return\
    \ str1;", "\tstd::string result;\n\tint max = 0;\n\tfor (std::string str : words)\
    \ {\n\t\tstd::set<char> charset;\n\t\tfor (char c : str) {\n\t\t\tcharset.insert(c);\n\
    \t\t}\n\t\tif (charset.size() > max) {\n\t\t\tmax = charset.size();\n\t\t\tresult\
    \ = str;\n\t\t}\n\t}\n\treturn result;", "  if (words.size() == 0) {\n    return\
    \ \"\";\n  }\n  std::string res = words[0];\n  for (int i = 1; i < words.size();\
    \ i++) {\n    std::string cur = words[i];\n    if (cur.size() > res.size()) {\n\
    \      res = cur;\n    } else if (cur.size() == res.size()) {\n      int unique_count\
    \ = 0;\n      for (int j = 0; j < cur.size(); j++) {\n        if (cur[j] != '.')\
    \ {\n          unique_count++;\n          for (int k = j + 1; k < cur.size();\
    \ k++) {\n            if (cur[k] == cur[j]) {\n              cur[k] = '.';\n \
    \           }\n          }\n        }\n      }\n      if (unique_count > res.size())\
    \ {\n        res = cur;\n      }\n    }\n  }\n  return res;", "    int max_len\
    \ = 0;\n    std::string max_word;\n    for (auto word : words) {\n        std::set<char>\
    \ s;\n        for (auto c : word) {\n            s.insert(c);\n        }\n   \
    \     if (s.size() > max_len) {\n            max_len = s.size();\n           \
    \ max_word = word;\n        }\n    }\n    return max_word;", "  if (words.size()\
    \ == 0) {\n    return \"\";\n  }\n\n  std::map<std::string, std::string> word_to_unique_chars;\n\
    \  int max_num_unique_chars = 0;\n  std::string string_with_max_num_unique_chars\
    \ = \"\";\n\n  for (int i = 0; i < words.size(); i++) {\n    std::string word\
    \ = words[i];\n    if (word_to_unique_chars.find(word) == word_to_unique_chars.end())\
    \ {\n      std::string unique_chars = \"\";\n      for (int j = 0; j < word.size();\
    \ j++) {\n        std::string character = word.substr(j, 1);\n        if (unique_chars.find(character)\
    \ == std::string::npos) {\n          unique_chars += character;\n        }\n \
    \     }\n      word_to_unique_chars[word] = unique_chars;\n    }\n\n    std::string\
    \ unique_chars = word_to_unique_chars[word];\n    if (unique_chars.size() > max_num_unique_chars)\
    \ {\n      max_num_unique_chars = unique_chars.size();\n      string_with_max_num_unique_chars\
    \ = word;\n    } else if (unique_chars.size() == max_num_unique_chars) {\n   \
    \   if (word < string_with_max_num_unique_chars) {\n        string_with_max_num_unique_chars\
    \ = word;\n      }\n    }\n  }\n\n  return string_with_max_num_unique_chars;",
  "    std::string s,max;\n    int unique,max1=0;\n    for(int i=0;i<words.size();i++)\n\
    \    {\n        std::set<char> v;\n        for(int j=0;j<words[i].size();j++)\n\
    \        {\n            v.insert(words[i][j]);\n        }\n        if(v.size()>max1)\n\
    \        {\n            max1=v.size();\n            max=words[i];\n        }\n\
    \    }\n    return max;", "  std::string result = \"\";\n  std::map<char, int>\
    \ unique_chars;\n  for (auto &elem : words) {\n    for (auto &ch : elem) {\n \
    \     unique_chars[ch]++;\n    }\n    if (unique_chars.size() > result.size())\
    \ {\n      result = elem;\n    }\n    unique_chars.clear();\n  }\n  return result;",
  "  std::map<char, int> chars_count;\n  // remove repeated characters of each word\
    \ in the list\n  for (int i = 0; i < words.size(); i++) {\n    for (int j = 0;\
    \ j < words[i].size(); j++) {\n      chars_count[words[i][j]]++;\n    }\n  }\n\
    \  // find the word with max unique characters\n  int max_index = 0;\n  int max_num_chars\
    \ = 0;\n  for (int i = 0; i < words.size(); i++) {\n    if (chars_count[words[i]]\
    \ > max_num_chars) {\n      max_num_chars = chars_count[words[i]];\n      max_index\
    \ = i;\n    }\n  }\n  return words[max_index];", "\tstd::string max_word = \"\"\
    ;\n\tint max_unique_characters = 0;\n\tfor (int i = 0; i < words.size(); i++)\
    \ {\n\t\t// get the word at index i\n\t\tstd::string word = words[i];\n\t\t//\
    \ create a map\n\t\tstd::map<char, int> unique_characters;\n\t\t// iterate over\
    \ the characters of this word\n\t\tfor (int j = 0; j < word.size(); j++) {\n\t\
    \t\t// if we already have this character, ignore it\n\t\t\tif (unique_characters.find(word[j])\
    \ != unique_characters.end()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// else add\
    \ this character to the map\n\t\t\tunique_characters[word[j]] = 1;\n\t\t}\n\t\t\
    // check if this is maximum\n\t\tif (unique_characters.size() > max_unique_characters)\
    \ {\n\t\t\tmax_unique_characters = unique_characters.size();\n\t\t\tmax_word =\
    \ word;\n\t\t}\n\t}\n\treturn max_word;", "\tint max = 0;\n\tint i = 0;\n\tint\
    \ count = 0;\n\tstd::set<char> s;\n\tfor (auto& str : words) {\n\t\tfor (auto&\
    \ c : str) {\n\t\t\ts.insert(c);\n\t\t}\n\t\tif (s.size() > max) {\n\t\t\tmax\
    \ = s.size();\n\t\t\tcount = i;\n\t\t}\n\t\telse if (s.size() == max) {\n\t\t\t\
    if (str < words[count]) {\n\t\t\t\tcount = i;\n\t\t\t}\n\t\t}\n\t\ts.clear();\n\
    \t\ti++;\n\t}\n\treturn words[count];", "    std::string res = \"\";\n    int\
    \ max_unique = 0;\n    for (std::string word : words) {\n        int diff = 0;\n\
    \        int ascii[128] = {0};\n        for (char c : word) {\n            ascii[c]++;\n\
    \            if (ascii[c] == 1)\n                diff++;\n        }\n        if\
    \ (diff > max_unique) {\n            max_unique = diff;\n            res = word;\n\
    \        }\n    }\n    return res;", "    std::string max_word;\n    for (auto\
    \ item : words) {\n        if (item.size() > max_word.size()) {\n            max_word\
    \ = item;\n        }\n    }\n    return max_word;", "  std::string max_str = \"\
    \";\n  int max_count = 0;\n  for (auto word : words) {\n    int count = 0;\n \
    \   int chars[256] = {0};\n    for (auto ch : word) {\n      if (chars[ch] ==\
    \ 0) {\n        count++;\n        chars[ch] = 1;\n      }\n    }\n    if (count\
    \ > max_count) {\n      max_count = count;\n      max_str = word;\n    }\n  }\n\
    \  return max_str;", "    int max = 0;\n    std::string answer;\n    for (int\
    \ i = 0; i < words.size(); i++) {\n        int temp = 0;\n        for (int j =\
    \ 0; j < words[i].size(); j++) {\n            if (words[i].find(words[i][j]) ==\
    \ j) {\n                temp++;\n            }\n        }\n        if (temp >\
    \ max) {\n            max = temp;\n            answer = words[i];\n        }\n\
    \    }\n    return answer;", "\t// Your code here\n\tint max = 0;\n\tstd::string\
    \ max_str = \"\";\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tstd::string\
    \ temp = words[i];\n\t\tint current_max = 0;\n\t\tfor (int j = 0; j < temp.size();\
    \ j++) {\n\t\t\tint count = 0;\n\t\t\tfor (int k = 0; k < temp.size(); k++) {\n\
    \t\t\t\tif (temp[j] == temp[k]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \tif (count == 1) {\n\t\t\t\tcurrent_max++;\n\t\t\t}\n\t\t}\n\t\tif (current_max\
    \ > max) {\n\t\t\tmax = current_max;\n\t\t\tmax_str = temp;\n\t\t}\n\t}\n\treturn\
    \ max_str;", "  size_t max_length = 0;\n  std::string max_word;\n  for (const\
    \ auto& word : words) {\n    size_t length = 0;\n    std::string sorted_word(word);\n\
    \    std::sort(sorted_word.begin(), sorted_word.end());\n    for (auto it = sorted_word.begin();\
    \ it != sorted_word.end();) {\n      auto next = std::find_if(it, sorted_word.end(),\
    \ [&](char c) { return c != *it; });\n      length++;\n      it = next;\n    }\n\
    \    if (length > max_length) {\n      max_length = length;\n      max_word =\
    \ word;\n    }\n  }\n  return max_word;", "  std::string result = \"\";\n  int\
    \ result_chars = 0;\n  for (const auto &word : words) {\n    std::set<char> unique_chars;\n\
    \    for (const auto &c : word) {\n      unique_chars.insert(c);\n    }\n    if\
    \ (unique_chars.size() > result_chars) {\n      result = word;\n      result_chars\
    \ = unique_chars.size();\n    }\n  }\n  return result;", "  int max_unique_characters\
    \ = 0;\n  std::string word_with_max_unique_characters = \"\";\n  for (int i =\
    \ 0; i < words.size(); i++) {\n    std::unordered_set<char> unique_characters;\n\
    \    for (int j = 0; j < words[i].size(); j++) {\n      unique_characters.insert(words[i][j]);\n\
    \    }\n    if (unique_characters.size() > max_unique_characters) {\n      max_unique_characters\
    \ = unique_characters.size();\n      word_with_max_unique_characters = words[i];\n\
    \    }\n  }\n  return word_with_max_unique_characters;", "    if (words.size()\
    \ == 0) return \"\";\n    std::string ans;\n    int max_unique = 0;\n    int max_length\
    \ = 0;\n    for (int i = 0; i < words.size(); i++) {\n        int length = words[i].length();\n\
    \        if (length > max_length) {\n            max_length = length;\n      \
    \      ans = words[i];\n        }\n        std::unordered_set<char> count_set;\n\
    \        for (char j : words[i]) {\n            count_set.insert(j);\n       \
    \ }\n        if (count_set.size() > max_unique) {\n            max_unique = count_set.size();\n\
    \            ans = words[i];\n        }\n    }\n    return ans;", "  assert(words.size()\
    \ >= 1);\n  std::string answer = words[0];\n  int max_counter = 0;\n  for (std::string\
    \ s : words) {\n    std::set<char> counter;\n    for (char c : s) {\n      counter.insert(c);\n\
    \    }\n    if (counter.size() > max_counter) {\n      max_counter = counter.size();\n\
    \      answer = s;\n    }\n  }\n  return answer;", "    if (words.size() == 0)\
    \ return \"\";\n    std::string max_str = words[0];\n    for (std::string s :\
    \ words) {\n        if (max_str.size() < s.size()) max_str = s;\n    }\n    for\
    \ (int i = 0; i < max_str.size(); i++) {\n        for (int j = i + 1; j < max_str.size();\
    \ j++) {\n            if (max_str[i] > max_str[j]) std::swap(max_str[i], max_str[j]);\n\
    \        }\n    }\n    return max_str;", "    // find the maximum length\n   \
    \ int maxLength = 0;\n    for (auto word : words) {\n        maxLength = std::max(maxLength,\
    \ (int)word.length());\n    }\n    // find the number of unique characters for\
    \ each word\n    std::map<std::string, int> occurrences;\n    for (auto word :\
    \ words) {\n        std::set<char> alreadyExist;\n        int uniqueCount = 0;\n\
    \        for (auto ch : word) {\n            if (alreadyExist.find(ch) == alreadyExist.end())\
    \ {\n                uniqueCount++;\n                alreadyExist.insert(ch);\n\
    \            }\n        }\n        occurrences[word] = uniqueCount;\n    }\n \
    \   // find the maximum unique character count\n    int maxUniqueCharCount = 0;\n\
    \    for (auto occur : occurrences) {\n        maxUniqueCharCount = std::max(maxUniqueCharCount,\
    \ occur.second);\n    }\n    // find if there are words with maximum unique character\
    \ count\n    std::vector<std::string> maxLengthWords;\n    for (auto occur : occurrences)\
    \ {\n        if (occur.second == maxUniqueCharCount) {\n            maxLengthWords.push_back(occur.first);\n\
    \        }\n    }\n    if (maxLengthWords.size() == 0) {\n        return \"\"\
    ;\n    }\n    // find if there are words with maximum length\n    std::vector<std::string>\
    \ maxLengthAndMaxUniqueCharWords;\n    for (auto word : maxLengthWords) {\n  \
    \      if (word.length() == maxLength) {\n            maxLengthAndMaxUniqueCharWords.push_back(word);\n\
    \        }\n    }\n    // find which word comes first in lexicographical order\n\
    \    std::string res = maxLengthAndMaxUniqueCharWords[0];\n    for (auto word\
    \ : maxLengthAndMaxUniqueCharWords) {\n        if (word < res) {\n           \
    \ res = word;\n        }\n    }\n    return res;", "  int max = 0;\n  std::string\
    \ max_string;\n  int max_string_length = 0;\n  for (auto &str : words) {\n   \
    \ int unique_char = 0;\n    int length = str.length();\n    if (length > max_string_length)\
    \ {\n      max_string_length = length;\n      max_string = str;\n    }\n    for\
    \ (auto &ch : str) {\n      if (ch != ' ') {\n        int index = std::tolower(ch)\
    \ - 'a';\n        if (index < 26 && index >= 0) {\n          if ((unique_char\
    \ & (1 << index)) == 0) {\n            unique_char |= (1 << index);\n        \
    \  }\n        }\n      }\n    }\n    int count = __builtin_popcount(unique_char);\n\
    \    if (count > max) {\n      max = count;\n      max_string = str;\n    }\n\
    \  }\n  return max_string;", "    int i, j, flag = 0, unique_chars = 0, max_unique_chars\
    \ = 0;\n    std::vector<std::string>::iterator it;\n    std::string max_word;\n\
    \    std::vector<std::string>::iterator it1;\n    for (it = words.begin(); it\
    \ != words.end(); it++) {\n        flag = 0;\n        for (it1 = it + 1; it1 !=\
    \ words.end(); it1++) {\n            if (*it == *it1) {\n                flag\
    \ = 1;\n                break;\n            }\n        }\n        if (flag ==\
    \ 1) {\n            continue;\n        }\n        unique_chars = 0;\n        for\
    \ (i = 0; i < (*it).length(); i++) {\n            flag = 0;\n            for (j\
    \ = 0; j < (*it).length(); j++) {\n                if (i == j) {\n           \
    \         continue;\n                }\n                if ((*it)[i] == (*it)[j])\
    \ {\n                    flag = 1;\n                    break;\n             \
    \   }\n            }\n            if (flag == 0) {\n                unique_chars++;\n\
    \            }\n        }\n        if (unique_chars > max_unique_chars) {\n  \
    \          max_unique_chars = unique_chars;\n            max_word = *it;\n   \
    \     }\n    }\n    return max_word;", "    std::string max_word = \"\";\n   \
    \ int max_uniq_chars = 0;\n    for (auto word : words) {\n        int uniq_chars\
    \ = 0;\n        std::unordered_set<char> chars;\n        for (auto c : word) {\n\
    \            if (chars.find(c) == chars.end()) {\n                chars.insert(c);\n\
    \                uniq_chars++;\n            }\n        }\n        if (uniq_chars\
    \ > max_uniq_chars) {\n            max_uniq_chars = uniq_chars;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;", '  return std::string();',
  "  std::string result;\n  int max_unique_chars = 0;\n  for (const auto& word : words)\
    \ {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size()\
    \ > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n     \
    \ result = word;\n    }\n  }\n  return result;", "    // Write your code here\n\
    \    std::string max_word = \"\";\n    int max_unique_chars = 0;\n    for (std::string\
    \ word : words) {\n        int unique_chars = 0;\n        std::vector<bool> seen(26,\
    \ false);\n        for (char ch : word) {\n            if (!seen[ch - 'a']) {\n\
    \                seen[ch - 'a'] = true;\n                unique_chars++;\n   \
    \         }\n        }\n        if (unique_chars > max_unique_chars) {\n     \
    \       max_unique_chars = unique_chars;\n            max_word = word;\n     \
    \   }\n    }\n    return max_word;", "    int max_unique = 0;\n    std::string\
    \ res = \"\";\n    for (auto &word : words) {\n        std::unordered_set<char>\
    \ s;\n        for (auto &ch : word) {\n            s.insert(ch);\n        }\n\
    \        if (s.size() > max_unique) {\n            max_unique = s.size();\n  \
    \          res = word;\n        }\n    }\n    return res;", "\tstd::string maxStr;\n\
    \tstd::set<char> chars;\n\tint maxCharCount = 0;\n\tfor (std::string word : words)\
    \ {\n\t\tint charCount = 0;\n\t\tfor (char c : word) {\n\t\t\tif (chars.find(c)\
    \ == chars.end()) {\n\t\t\t\tchars.insert(c);\n\t\t\t\tcharCount++;\n\t\t\t}\n\
    \t\t}\n\t\tif (charCount > maxCharCount) {\n\t\t\tmaxCharCount = charCount;\n\t\
    \t\tmaxStr = word;\n\t\t}\n\t\tchars.clear();\n\t}\n\treturn maxStr;", "    std::string\
    \ res = \"\";\n    int max_char = 0;\n    for (std::string word : words) {\n \
    \       std::set<char> unique_char;\n        for (char c : word) {\n         \
    \   unique_char.insert(c);\n        }\n        if (unique_char.size() > max_char)\
    \ {\n            max_char = unique_char.size();\n            res = word;\n   \
    \     }\n    }\n    return res;", "    std::vector<int> unique_chars;\n    int\
    \ count = 0;\n    std::string max_string;\n    for (int i = 0; i < words.size();\
    \ i++) {\n        count = 0;\n        for (int j = 0; j < words[i].size(); j++)\
    \ {\n            for (int k = 0; k < words[i].size(); k++) {\n               \
    \ if (words[i][j] == words[i][k]) {\n                    count++;\n          \
    \      }\n            }\n        }\n        unique_chars.push_back(count/words[i].size());\n\
    \    }\n    int max = unique_chars[0];\n    for (int i = 0; i < unique_chars.size();\
    \ i++) {\n        if (unique_chars[i] > max) {\n            max = unique_chars[i];\n\
    \        }\n    }\n    for (int i = 0; i < unique_chars.size(); i++) {\n     \
    \   if (unique_chars[i] == max) {\n            max_string = words[i];\n      \
    \      break;\n        }\n    }\n    return max_string;", "    auto max_word =\
    \ std::max_element(words.begin(), words.end(), [](const std::string& lhs, const\
    \ std::string& rhs) {\n        auto lhs_unique = std::set<char>(lhs.begin(), lhs.end());\n\
    \        auto rhs_unique = std::set<char>(rhs.begin(), rhs.end());\n        return\
    \ lhs_unique.size() == rhs_unique.size() ? lhs < rhs : lhs_unique.size() < rhs_unique.size();\n\
    \    });\n    return *max_word;", "    std::unordered_map<char, int> unique_chars;\n\
    \    std::string max_word;\n    for (auto const& word : words) {\n        unique_chars.clear();\n\
    \        for (char const& c : word) {\n            unique_chars[c]++;\n      \
    \  }\n        if (unique_chars.size() > max_word.size()) {\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;", "    if (words.size() == 0)\
    \ return \"\";\n    std::string result = words[0];\n    int max_num = unique_chars(words[0]);\n\
    \    for (int i = 1; i < words.size(); i++) {\n        int num = unique_chars(words[i]);\n\
    \        if (num > max_num) {\n            max_num = num;\n            result\
    \ = words[i];\n        }\n    }\n    return result;", '    // your code here',
  "  std::string res = \"\";\n  int max = 0;\n  for (const auto& s : words) {\n  \
    \  int chars = 0;\n    for (auto it = s.begin(); it != s.end(); it++) {\n    \
    \  if (*it == 'a' || *it == 'b' || *it == 'c' || *it == 'd' || *it == 'e' || *it\
    \ == 'f' || *it == 'g' || *it == 'h' || *it == 'i' || *it == 'j' || *it == 'k'\
    \ || *it == 'l' || *it == 'm' || *it == 'n' || *it == 'o' || *it == 'p' || *it\
    \ == 'q' || *it == 'r' || *it == 's' || *it == 't' || *it == 'u' || *it == 'v'\
    \ || *it == 'w' || *it == 'x' || *it == 'y' || *it == 'z') {\n        if (*it\
    \ == 'a') {\n          chars++;\n          while(*it == 'a') {\n            it++;\n\
    \          }\n          it--;\n        }\n        if (*it == 'b') {\n        \
    \  chars++;\n          while(*it == 'b') {\n            it++;\n          }\n \
    \         it--;\n        }\n        if (*it == 'c') {\n          chars++;\n  \
    \        while(*it == 'c') {\n            it++;\n          }\n          it--;\n\
    \        }\n        if (*it == 'd') {\n          chars++;\n          while(*it\
    \ == 'd') {\n            it++;\n          }\n          it--;\n        }\n    \
    \    if (*it == 'e') {\n          chars++;\n          while(*it == 'e') {\n  \
    \          it++;\n          }\n          it--;\n        }\n        if (*it ==\
    \ 'f') {\n          chars++;\n          while(*it == 'f') {\n            it++;\n\
    \          }\n          it--;\n        }\n        if (*it == 'g') {\n        \
    \  chars++;\n          while(*it == 'g') {\n            it++;\n          }\n \
    \         it--;\n       ", "  // your code goes here\n  std::string res = \"\"\
    ;\n  int max_char = -1;\n  for (int i = 0; i < words.size(); i++) {\n    std::unordered_set<char>\
    \ set;\n    for (int j = 0; j < words[i].size(); j++) {\n      set.insert(words[i][j]);\n\
    \    }\n    if (set.size() > max_char) {\n      max_char = set.size();\n     \
    \ res = words[i];\n    }\n  }\n  return res;", "  assert(words.size() > 0);\n\
    \  std::map<char, int> unique_chars;\n  std::string result;\n  for (auto word\
    \ : words) {\n    for (auto ch : word) {\n      unique_chars[ch] = 1;\n    }\n\
    \    if (result.size() < unique_chars.size()) {\n      result = word;\n    }\n\
    \    unique_chars.clear();\n  }\n  return result;", "    std::string res = \"\"\
    ;\n    int max_len = 0;\n    std::set<char> temp;\n    for (std::string s : words)\
    \ {\n        temp.clear();\n        for (char c : s) {\n            temp.insert(c);\n\
    \        }\n        if (temp.size() > max_len) {\n            max_len = temp.size();\n\
    \            res = s;\n        }\n    }\n    return res;", "  std::string max_word\
    \ = \"\";\n  int max_unique_char = 0;\n  int curr_unique_char = 0;\n  for (int\
    \ i = 0; i < words.size(); i++) {\n    curr_unique_char = 0;\n    std::unordered_set<char>\
    \ us;\n    for (int j = 0; j < words[i].size(); j++) {\n      if (us.find(words[i][j])\
    \ == us.end()) {\n        us.insert(words[i][j]);\n        curr_unique_char++;\n\
    \      }\n    }\n    if (curr_unique_char > max_unique_char) {\n      max_unique_char\
    \ = curr_unique_char;\n      max_word = words[i];\n    }\n  }\n  return max_word;",
  "    // write code here\n    int max_len = -1;\n    std::string ans = \"\";\n  \
    \  for (auto word : words) {\n        std::set<char> chars;\n        for (auto\
    \ c : word) {\n            chars.insert(c);\n        }\n        if (chars.size()\
    \ > max_len) {\n            max_len = chars.size();\n            ans = word;\n\
    \        }\n    }\n    return ans;", "    std::unordered_map<char, int> unordered_map;\n\
    \    std::string max_string;\n    int max_unique_char = 0;\n    for (int i = 0;\
    \ i < words.size(); i++) {\n        unordered_map.clear();\n        for (int j\
    \ = 0; j < words[i].size(); j++) {\n            unordered_map[words[i][j]]++;\n\
    \        }\n        if (unordered_map.size() > max_unique_char) {\n          \
    \  max_unique_char = unordered_map.size();\n            max_string = words[i];\n\
    \        }\n    }\n    return max_string;", "\t// write your code here\n\tstd::map<char,\
    \ int> freq;\n\tstd::string maxWord = \"\";\n\tint maxFreq = 0;\n\tfor (int i\
    \ = 0; i < words.size(); i++) {\n\t\tfreq.clear();\n\t\tfor (int j = 0; j < words[i].size();\
    \ j++) {\n\t\t\tfreq[words[i][j]]++;\n\t\t}\n\t\tif (freq.size() > maxFreq) {\n\
    \t\t\tmaxFreq = freq.size();\n\t\t\tmaxWord = words[i];\n\t\t}\n\t}\n\treturn\
    \ maxWord;", "    std::string maxWord = \"\";\n    int maxCount = 0;\n    for\
    \ (auto &word : words) {\n        std::set<char> uniqueChar;\n        for (auto\
    \ c : word) {\n            uniqueChar.insert(c);\n        }\n        if (uniqueChar.size()\
    \ > maxCount) {\n            maxCount = uniqueChar.size();\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;", '  // your code here', "  \
    \  int n = words.size();\n    int maxNum = 0;\n    std::string res;\n    for (int\
    \ i = 0; i < n; i++) {\n        std::string s = words[i];\n        int m = s.size();\n\
    \        int cnt = 0;\n        std::set<char> ss;\n        for (int j = 0; j <\
    \ m; j++) {\n            if (ss.find(s[j]) == ss.end()) {\n                ss.insert(s[j]);\n\
    \                cnt++;\n            }\n        }\n        if (cnt == maxNum)\
    \ {\n            if (res.compare(s) > 0) {\n                res = s;\n       \
    \     }\n        } else if (cnt > maxNum) {\n            maxNum = cnt;\n     \
    \       res = s;\n        }\n    }\n    return res;", "    std::string best_word;\n\
    \    int max_count = 0;\n    for (auto &word : words) {\n        std::unordered_set<char>\
    \ unique_chars;\n        for (auto &ch : word) {\n            unique_chars.insert(ch);\n\
    \        }\n        if (unique_chars.size() > max_count) {\n            max_count\
    \ = unique_chars.size();\n            best_word = word;\n        }\n    }\n  \
    \  return best_word;", "  int unique_chars = 0;\n  int max_unique_chars = 0;\n\
    \  std::string max_word;\n  for (auto word : words) {\n    unique_chars = 0;\n\
    \    for (int i = 0; i < word.length(); i++) {\n      if (word.find(word[i]) ==\
    \ word.rfind(word[i])) {\n        unique_chars++;\n      }\n    }\n    if (unique_chars\
    \ > max_unique_chars) {\n      max_unique_chars = unique_chars;\n      max_word\
    \ = word;\n    }\n  }\n  return max_word;", "\tstd::vector<std::string> v = words;\n\
    \tstd::string s = v[0];\n\tint max = 0;\n\tfor (int i = 0; i < v.size(); i++)\
    \ {\n\t\tstd::string a = v[i];\n\t\tint l = a.length();\n\t\tint unique = 0;\n\
    \t\tfor (int j = 0; j < l; j++) {\n\t\t\tint count = 0;\n\t\t\tfor (int k = 0;\
    \ k < l; k++) {\n\t\t\t\tif (a[j] == a[k]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t\tif (count == 1) {\n\t\t\t\tunique++;\n\t\t\t}\n\t\t}\n\t\tif (unique\
    \ > max) {\n\t\t\tmax = unique;\n\t\t\ts = a;\n\t\t}\n\t}\n\treturn s;", "   \
    \ std::string res;\n    int max = 0;\n    for (auto i : words) {\n        std::sort(i.begin(),\
    \ i.end());\n        std::vector<char> s{i.begin(), i.end()};\n        int counter\
    \ = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (i > 0 &&\
    \ s[i] != s[i - 1]) {\n                counter++;\n            }\n        }\n\
    \        if (counter > max) {\n            max = counter;\n            res = i;\n\
    \        }\n    }\n    return res;", "    int len_words = words.size();\n    if\
    \ (len_words == 0) return \"\";\n    std::vector<int> unique_chars(len_words);\n\
    \    std::string str, temp;\n    int index = 0;\n    for (int i = 0; i < len_words;\
    \ i++) {\n        std::set<char> uniq_chars;\n        str = words[i];\n      \
    \  int len_str = str.length();\n        if (len_str == 0) return \"\";\n     \
    \   for (int j = 0; j < len_str; j++) {\n            uniq_chars.insert(str[j]);\n\
    \        }\n        unique_chars[i] = uniq_chars.size();\n    }\n    int max_unique_chars\
    \ = unique_chars[0];\n    for (int i = 1; i < len_words; i++) {\n        if (unique_chars[i]\
    \ > max_unique_chars) {\n            max_unique_chars = unique_chars[i];\n   \
    \         index = i;\n        }\n    }\n    if (unique_chars[index] == 0) return\
    \ \"\";\n    return words[index];", "    // your code here\n    std::string value;\n\
    \    int max = 0;\n    std::set<char> set;\n    for(std::string word : words)\
    \ {\n        for(char i : word) {\n            set.insert(i);\n        }\n   \
    \     if(set.size() > max) {\n            max = set.size();\n            value\
    \ = word;\n        }\n        set.clear();\n    }\n    return value;", "  unsigned\
    \ long int max = 0;\n  std::string found_word;\n  for (auto it = words.begin();\
    \ it != words.end(); it++) {\n    std::unordered_set<char> set;\n    for (auto\
    \ const &c : *it) {\n      set.insert(c);\n    }\n    if (set.size() > max) {\n\
    \      max = set.size();\n      found_word = *it;\n    }\n  }\n  return found_word;",
  "  std::string word_max;\n  int count_max = 0;\n  for (auto word : words) {\n  \
    \  std::set<char> letters(word.begin(), word.end());\n    int count = letters.size();\n\
    \    if (count > count_max) {\n      count_max = count;\n      word_max = word;\n\
    \    }\n  }\n  return word_max;", "    std::string max_word;\n    int max_chars\
    \ = 0;\n    for (std::string word : words) {\n        std::unordered_set<char>\
    \ chars;\n        for (char c : word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > max_chars) {\n            max_chars = chars.size();\n\
    \            max_word = word;\n        }\n    }\n    return max_word;", "    std::string\
    \ result = \"\";\n    int max_num = 0;\n    for (auto word : words) {\n      \
    \  int num = 0;\n        bool seen[26] = {false};\n        for (auto ch : word)\
    \ {\n            if (!seen[ch - 'a']) {\n                num++;\n            \
    \    seen[ch - 'a'] = true;\n            }\n        }\n        if (num > max_num)\
    \ {\n            max_num = num;\n            result = word;\n        }\n    }\n\
    \    return result;", "\tstd::vector<int> unique_counts;\n\tstd::string max_string;\n\
    \tint u_count = 0;\n\tint max_count = 0;\n\tint max_string_index = 0;\n\tfor (int\
    \ i = 0; i < words.size(); i++) {\n\t\tfor (int j = 0; j < words[i].size(); j++)\
    \ {\n\t\t\tfor (int k = 0; k < words[i].size(); k++) {\n\t\t\t\tif (words[i][j]\
    \ == words[i][k]) {\n\t\t\t\t\tu_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunique_counts.push_back(u_count);\n\
    \t\tu_count = 0;\n\t}\n\tfor (int i = 0; i < unique_counts.size(); i++) {\n\t\t\
    if (unique_counts[i] > max_count) {\n\t\t\tmax_count = unique_counts[i];\n\t\t\
    \tmax_string_index = i;\n\t\t}\n\t}\n\tmax_string = words[max_string_index];\n\
    \treturn max_string;", "    std::string max = \"\";\n    int current_max = 0;\n\
    \    for (std::string s : words) {\n        int unique_chars = 0;\n        std::unordered_set<char>\
    \ unique_chars_set;\n        for (char c : s) {\n            if (unique_chars_set.find(c)\
    \ == unique_chars_set.end()) {\n                unique_chars++;\n            \
    \    unique_chars_set.insert(c);\n            }\n        }\n        if (unique_chars\
    \ > current_max) {\n            current_max = unique_chars;\n            max =\
    \ s;\n        }\n    }\n    return max;", "  int max = 0;\n  std::string result;\n\
    \  for (int i = 0; i < words.size(); i++) {\n    int count = 0;\n    for (int\
    \ j = 0; j < words[i].size(); j++) {\n      if (words[i].substr(j + 1).find(words[i][j])\
    \ == std::string::npos) {\n        count++;\n      }\n    }\n    if (count > max)\
    \ {\n      max = count;\n      result = words[i];\n    }\n  }\n  return result;",
  "    std::string res = \"\";\n    int maxNum = -1;\n    for (int i = 0; i < words.size();\
    \ i++) {\n        int unique = 0;\n        for (int j = 0; j < words[i].size();\
    \ j++) {\n            if (words[i].find(words[i][j]) == words[i].rfind(words[i][j]))\
    \ {\n                unique++;\n            }\n        }\n        if (unique >\
    \ maxNum) {\n            maxNum = unique;\n            res = words[i];\n     \
    \   }\n    }\n    return res;", "  // TODO: implement me\n  int num_words = words.size();\n\
    \  std::string max_word = \"\";\n  int max_word_uniq_chars = 0;\n  for (int i\
    \ = 0; i < num_words; i++) {\n    std::string curr_word = words[i];\n    int curr_word_uniq_chars\
    \ = 0;\n    for (char c : curr_word) {\n      bool already_found = false;\n  \
    \    for (int j = 0; j < curr_word_uniq_chars; j++) {\n        if (c == curr_word[j])\
    \ {\n          already_found = true;\n          break;\n        }\n      }\n \
    \     if (!already_found) {\n        curr_word[curr_word_uniq_chars] = c;\n  \
    \      curr_word_uniq_chars++;\n      }\n    }\n    if (curr_word_uniq_chars >\
    \ max_word_uniq_chars) {\n      max_word = curr_word;\n      max_word_uniq_chars\
    \ = curr_word_uniq_chars;\n    }\n  }\n  return max_word;", "  std::string max\
    \ = \"\";\n  std::unordered_set<char> chars;\n  for (auto word : words) {\n  \
    \  for (auto ch : word) {\n      chars.insert(ch);\n    }\n    if (chars.size()\
    \ > max.size()) {\n      max = word;\n    }\n    chars.clear();\n  }\n  return\
    \ max;", "\tstd::string max = \"\";\n\tint max_count = 0;\n\tfor (int i = 0; i\
    \ < words.size(); i++) {\n\t\tstd::string word = words[i];\n\t\tint count = 0;\n\
    \t\tfor (int j = 0; j < word.size(); j++) {\n\t\t\tif (word[j] == '\\0') continue;\n\
    \t\t\tcount++;\n\t\t\tfor (int k = j + 1; k < word.size(); k++) {\n\t\t\t\tif\
    \ (word[j] == word[k]) {\n\t\t\t\t\tword[k] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t\tif (count > max_count) {\n\t\t\tmax_count = count;\n\t\t\tmax = word;\n\
    \t\t}\n\t}\n\treturn max;", "    std::string maxStr;\n    int maxStrLen = 0;\n\
    \    for (std::string currStr : words) {\n        // Check to see if we have a\
    \ new max string\n        if (currStr.length() > maxStrLen) {\n            //\
    \ If so, update the max string\n            maxStr = currStr;\n            maxStrLen\
    \ = currStr.length();\n        } else if (currStr.length() == maxStrLen) {\n \
    \           // If the length is the same as the current max string length\n  \
    \          // but the current string comes before the max string in\n        \
    \    // lexicographical order, then update the max string\n            if (currStr\
    \ < maxStr)\n                maxStr = currStr;\n        }\n    }\n    return maxStr;",
  "  std::string ans;\n  int unique_count = 0;\n  int max_count = 0;\n  std::set<char>\
    \ unique_chars;\n  for (int i = 0; i < words.size(); i++) {\n    unique_chars.clear();\n\
    \    unique_count = 0;\n    for (int j = 0; j < words[i].size(); j++) {\n    \
    \  if (unique_chars.find(words[i][j]) == unique_chars.end()) {\n        unique_chars.insert(words[i][j]);\n\
    \        unique_count++;\n      }\n    }\n    if (unique_count > max_count) {\n\
    \      max_count = unique_count;\n      ans = words[i];\n    }\n  }\n  return\
    \ ans;", "\tint max_size = 0;\n\tstd::string result = \"\";\n\tfor (auto word\
    \ : words) {\n\t\tstd::set<char> char_set;\n\t\tfor (auto c : word) {\n\t\t\t\
    char_set.insert(c);\n\t\t}\n\t\tif (char_set.size() > max_size) {\n\t\t\tmax_size\
    \ = char_set.size();\n\t\t\tresult = word;\n\t\t}\n\t}\n\treturn result;", " \
    \   int max_unique = 0;\n    std::string result;\n    std::map<char, int> hash;\n\
    \    for (std::string w : words) {\n        for (char c : w) {\n            hash[c]\
    \ = 0;\n        }\n        if (hash.size() > max_unique) {\n            max_unique\
    \ = hash.size();\n            result = w;\n        }\n        hash.clear();\n\
    \    }\n    return result;", "    int maxLength = 0;\n    std::string maxString\
    \ = \"\";\n    for (int i = 0; i < words.size(); i++) {\n        std::vector<char>\
    \ letters;\n        for (int j = 0; j < words[i].length(); j++) {\n          \
    \  if (std::find(letters.begin(), letters.end(), words[i][j]) != letters.end())\
    \ {\n                continue;\n            } else {\n                letters.push_back(words[i][j]);\n\
    \            }\n        }\n        if (letters.size() > maxLength) {\n       \
    \     maxLength = letters.size();\n            maxString = words[i];\n       \
    \ } else if (letters.size() == maxLength) {\n            if (words[i] < maxString)\
    \ {\n                maxString = words[i];\n            }\n        }\n    }\n\
    \    return maxString;", "    std::vector<int> counts;\n    int max_count = 0;\n\
    \    int max_index = 0;\n    for (auto &w : words) {\n        std::vector<bool>\
    \ unique(256, false);\n        int count = 0;\n        for (auto &c : w) {\n \
    \           int code = (int)c;\n            if (!unique[code]) {\n           \
    \     unique[code] = true;\n                count++;\n            }\n        }\n\
    \        counts.push_back(count);\n        if (count > max_count) {\n        \
    \    max_count = count;\n            max_index = words.size() - 1;\n        }\n\
    \    }\n    for (int i = 0; i < words.size(); i++) {\n        if (counts[i] ==\
    \ max_count) {\n            if (words[i] < words[max_index]) {\n             \
    \   max_index = i;\n            }\n        }\n    }\n    return words[max_index];",
  "    std::string result = \"\";\n    int max_num = 0;\n    for (int i = 0; i < words.size();\
    \ i++) {\n        std::string word = words[i];\n        if (result == \"\") {\n\
    \            result = word;\n            max_num = word.size();\n        } else\
    \ {\n            int num = word.size();\n            if (num > max_num) {\n  \
    \              result = word;\n                max_num = num;\n            } else\
    \ if (num == max_num) {\n                if (word < result) {\n              \
    \      result = word;\n                }\n            }\n        }\n    }\n  \
    \  return result;", "    int max_len = 0;\n    std::string str = \"\";\n    for\
    \ (int i = 0; i < words.size(); i++) {\n        if (max_len < words[i].length())\
    \ {\n            max_len = words[i].length();\n            str = words[i];\n \
    \       }\n    }\n    std::cout << str << std::endl;\n    std::vector<char> v;\n\
    \    for (int i = 0; i < str.length(); i++) {\n        int count = 0;\n      \
    \  for (int j = 0; j < v.size(); j++) {\n            if (str[i] == v[j]) {\n \
    \               count++;\n            }\n        }\n        if (count == 0) {\n\
    \            v.push_back(str[i]);\n        }\n    }\n    if (v.size() == max_len)\
    \ {\n        return str;\n    }\n    for (int i = 0; i < words.size(); i++) {\n\
    \        if (max_len == words[i].length()) {\n            v.clear();\n       \
    \     for (int j = 0; j < words[i].length(); j++) {\n                int count\
    \ = 0;\n                for (int k = 0; k < v.size(); k++) {\n               \
    \     if (words[i][j] == v[k]) {\n                        count++;\n         \
    \           }\n                }\n                if (count == 0) {\n        \
    \            v.push_back(words[i][j]);\n                }\n            }\n   \
    \         if (v.size() == max_len) {\n                return words[i];\n     \
    \       }\n        }\n    }\n    return \"\";", "  std::map<char, int> seen;\n\
    \  std::string answer;\n  for (int i = 0; i < words.size(); i++) {\n    for (int\
    \ j = 0; j < words[i].size(); j++) {\n      seen[words[i][j]]++;\n    }\n    if\
    \ (seen.size() > answer.size()) {\n      answer = words[i];\n    }\n    seen.clear();\n\
    \  }\n  return answer;", "    std::string ans;\n    std::string &ref = ans;\n\
    \    int value = 0;\n    for (auto & str : words) {\n        std::sort(str.begin(),\
    \ str.end());\n        std::string::iterator end_pos = std::unique(str.begin(),\
    \ str.end());\n        str.erase(end_pos, str.end());\n        if (str.size()\
    \ >= value) {\n            if (str.size() == value) {\n                if (str\
    \ < ref) {\n                    ref = str;\n                }\n            } else\
    \ {\n                ref = str;\n                value = str.size();\n       \
    \     }\n        }\n    }\n    return ref;", "  std::vector<int> count;\n  for\
    \ (int i = 0; i < words.size(); i++) {\n    std::string word = words[i];\n   \
    \ std::map<char, int> word_count;\n    for (int j = 0; j < word.size(); j++) {\n\
    \      word_count[word[j]]++;\n    }\n    count.push_back(word_count.size());\n\
    \  }\n  int max = 0;\n  for (int i = 0; i < count.size(); i++) {\n    if (count[i]\
    \ > count[max]) {\n      max = i;\n    }\n  }\n  return words[max];", "    std::string\
    \ result = \"\";\n    // get the count of number of unique characters in each\
    \ word\n    std::vector<int> count;\n    for (int i = 0; i < words.size(); i++)\
    \ {\n        std::set<char> char_set;\n        for (int j = 0; j < words[i].size();\
    \ j++) {\n            char_set.insert(words[i][j]);\n        }\n        count.push_back(char_set.size());\n\
    \    }\n    // if there are no words in the given list\n    if (count.size() ==\
    \ 0)\n        return result;\n    // find the word with maximum number of unique\
    \ characters\n    int max = count[0];\n    for (int i = 1; i < count.size(); i++)\
    \ {\n        if (count[i] > max)\n            max = count[i];\n    }\n    // if\
    \ two or more words have the same maximum number of unique characters\n    //\
    \ then return the one which comes first in lexicographical order\n    int index\
    \ = 0;\n    for (int i = 0; i < count.size(); i++) {\n        if (count[i] ==\
    \ max) {\n            index = i;\n            break;\n        }\n    }\n    result\
    \ = words[index];\n    for (int i = index + 1; i < count.size(); i++) {\n    \
    \    if (count[i] == max) {\n            if (words[i] < result)\n            \
    \    result = words[i];\n        }\n    }\n    return result;", "\tstd::string\
    \ s = \"\";\n\tint j = 0;\n\tint max = 0;\n\tfor (int i = 0; i < words.size();\
    \ i++) {\n\t\tint count = 0;\n\t\tfor (int j = 0; j < words[i].size(); j++) {\n\
    \t\t\tif (words[i].find(words[i][j]) == words[i].rfind(words[i][j])) {\n\t\t\t\
    \tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > max) {\n\t\t\tmax = count;\n\t\t\t\
    s = words[i];\n\t\t}\n\t}\n\treturn s;", "   std::string max_word = \"\";\n  \
    \ int max_count = 0;\n   for (auto & word : words) {\n      int word_size = word.size();\n\
    \      std::unordered_set<char> char_set;\n      for (auto & ch : word) {\n  \
    \       char_set.insert(ch);\n      }\n      int char_count = char_set.size();\n\
    \      if (char_count > max_count) {\n         max_count = char_count;\n     \
    \    max_word = word;\n      } else if (char_count == max_count) {\n         if\
    \ (word < max_word) {\n            max_word = word;\n         }\n      }\n   }\n\
    \   return max_word;", "  std::string result = \"\";\n  int max_count = 0;\n \
    \ for (int i = 0; i < words.size(); i++) {\n    std::string word = words[i];\n\
    \    std::set<char> chars;\n    for (int j = 0; j < word.size(); j++) {\n    \
    \  chars.insert(word[j]);\n    }\n    if (chars.size() > max_count) {\n      max_count\
    \ = chars.size();\n      result = word;\n    }\n  }\n  return result;", "  int\
    \ max_n_chars = 0;\n  std::string max_n_chars_word;\n  for (int i = 0; i < words.size();\
    \ i++) {\n    int n_chars = 0;\n    for (int j = 0; j < words[i].size(); j++)\
    \ {\n      if (words[i].find(words[i][j]) == j)\n        n_chars++;\n    }\n \
    \   if (n_chars > max_n_chars) {\n      max_n_chars = n_chars;\n      max_n_chars_word\
    \ = words[i];\n    }\n  }\n  return max_n_chars_word;", "    // Write your code\
    \ here\n    std::string ans;\n    int max = 0;\n    for(int i = 0; i < words.size();\
    \ i++) {\n        std::set<char> s;\n        for(int j = 0; j < words[i].size();\
    \ j++) {\n            s.insert(words[i][j]);\n        }\n        if(s.size() >\
    \ max) {\n            max = s.size();\n            ans = words[i];\n        }\n\
    \    }\n    return ans;", "\tint max = 0;\n\tstd::string result = \"\";\n\tfor\
    \ (int i = 0; i < words.size(); i++) {\n\t\tint numberOfUnique = 0;\n\t\tstd::string\
    \ tmp = words[i];\n\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\tint number\
    \ = 0;\n\t\t\tfor (int k = 0; k < tmp.size(); k++) {\n\t\t\t\tif (tmp[j] == tmp[k])\
    \ {\n\t\t\t\t\tnumber++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (number == 1) {\n\t\t\t\
    \tnumberOfUnique++;\n\t\t\t}\n\t\t}\n\t\tif (numberOfUnique > max) {\n\t\t\tmax\
    \ = numberOfUnique;\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\treturn result;", "   \
    \ std::vector<std::string> result;\n    std::string finalResult;\n    int temp\
    \ = 0;\n    int count = 0;\n    for (int i = 0; i < words.size(); i++) {\n   \
    \     for (int j = 0; j < words[i].size(); j++) {\n            for (int k = 0;\
    \ k < words[i].size(); k++) {\n                if (words[i][j] == words[i][k])\
    \ {\n                    count++;\n                }\n            }\n        \
    \    if (count == 1) {\n                temp++;\n            }\n            count\
    \ = 0;\n        }\n        result.push_back(std::to_string(temp));\n        temp\
    \ = 0;\n    }\n    temp = 0;\n    for (int i = 0; i < result.size(); i++) {\n\
    \        if (std::stoi(result[i]) > temp) {\n            temp = std::stoi(result[i]);\n\
    \        }\n    }\n    for (int i = 0; i < result.size(); i++) {\n        if (std::stoi(result[i])\
    \ == temp) {\n            finalResult = words[i];\n            break;\n      \
    \  }\n    }\n    return finalResult;", "\t// TODO: Your code here\n  int max_size\
    \ = 0;\n  std::string max;\n  for(int i = 0; i < words.size(); i++){\n    std::string\
    \ curr = words[i];\n    if(max_size < curr.size()){\n      max_size = curr.size();\n\
    \      max = curr;\n    }\n  }\n  for(int i = 0; i < words.size(); i++){\n   \
    \ std::string curr = words[i];\n    if(max_size == curr.size()){\n      for(int\
    \ j = 0; j < curr.size(); j++){\n        if(curr[j] < max[j]){\n          max\
    \ = curr;\n          break;\n        }\n      }\n    }\n  }\n  return max;", " \
    \   int max_idx = 0;\n    int max_len = 0;\n    int num_words = words.size();\n\
    \    int length = 0;\n    std::string current;\n    std::unordered_set<char> chars;\n\
    \    std::unordered_set<char>::iterator it;\n    for (int i = 0; i < num_words;\
    \ i++) {\n        current = words[i];\n        length = current.length();\n  \
    \      for (int j = 0; j < length; j++) {\n            chars.insert(current[j]);\n\
    \        }\n        if (chars.size() > max_len) {\n            max_len = chars.size();\n\
    \            max_idx = i;\n        }\n        chars.clear();\n    }\n    return\
    \ words[max_idx];", "  int max = -1;\n  std::string result;\n  for (auto word\
    \ : words) {\n    std::vector<bool> unique(26, false);\n    int unique_letter_count\
    \ = 0;\n    for (auto letter : word) {\n      if (!unique[letter - 'a']) {\n \
    \       unique[letter - 'a'] = true;\n        unique_letter_count++;\n      }\n\
    \    }\n    if (unique_letter_count > max) {\n      max = unique_letter_count;\n\
    \      result = word;\n    }\n  }\n  return result;", "    // Write your code\
    \ here.\n    std::string current_word = \"\";\n    int current_count = 0;\n  \
    \  for (int i = 0; i < words.size(); i++) {\n        std::string current_word\
    \ = words[i];\n        std::set<char> seen;\n        for (int j = 0; j < current_word.size();\
    \ j++) {\n            if (seen.find(current_word[j]) == seen.end()) {\n      \
    \          seen.insert(current_word[j]);\n            }\n        }\n        if\
    \ (seen.size() > current_count) {\n            current_count = seen.size();\n\
    \            current_word = words[i];\n        }\n    }\n    return current_word;",
  "        std::unordered_map<char, int> frequency;\n        std::string max;\n  \
    \      int maxfreq = -1;\n        for (auto word : words) {\n                for\
    \ (char c : word) {\n                        frequency[c]++;\n               \
    \ }\n                if (maxfreq < (int)frequency.size()) {\n                \
    \        maxfreq = frequency.size();\n                        max = word;\n  \
    \              }\n                frequency.clear();\n        }\n        return\
    \ max;", "\tstd::vector<std::string>::iterator it = words.begin();\n\tstd::vector<std::string>::iterator\
    \ it2 = words.begin();\n\tstd::string a;\n\tstd::string b;\n\tstd::string c;\n\
    \tc = *it;\n\tfor (it; it != words.end(); it++) {\n\t\tstd::sort(it->begin(),\
    \ it->end());\n\t\tif (std::adjacent_find(it->begin(), it->end()) == it->end())\
    \ {\n\t\t\tif (it->length() > c.length()) {\n\t\t\t\tc = *it;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn c;", "  std::vector<int> charCount;\n  std::string current_word;\n\
    \  int count = 0;\n  int max_count = 0;\n  int max_index = 0;\n  for (int i =\
    \ 0; i < words.size(); i++) {\n    current_word = words[i];\n    for (int j =\
    \ 0; j < current_word.size(); j++) {\n      for (int k = 0; k < current_word.size();\
    \ k++) {\n        if (current_word[j] == current_word[k]) {\n          count++;\n\
    \        }\n      }\n    }\n    charCount.push_back(count);\n    count = 0;\n\
    \  }\n  for (int i = 0; i < charCount.size(); i++) {\n    if (charCount[i] > max_count)\
    \ {\n      max_count = charCount[i];\n      max_index = i;\n    }\n  }\n  return\
    \ words[max_index];", "    int flag = 0;\n    std::vector<int> tostore;\n    for(auto\
    \ x: words) {\n        std::set<char> s;\n        for(auto c: x)\n           \
    \ s.insert(c);\n        tostore.push_back(s.size());\n    }\n    std::vector<int>\
    \ position;\n    int max = *std::max_element(tostore.begin(), tostore.end());\n\
    \    for(int i = 0; i < tostore.size(); i++) {\n        if(tostore[i] == max)\n\
    \            position.push_back(i);\n    }\n    return words[position[0]];", " \
    \   int max_index=0;\n    int max_unique_characters=0;\n    for(int i=0;i<words.size();i++){\n\
    \        int unique_characters=0;\n        std::string word=words[i];\n      \
    \  std::vector<bool> v(256,false);\n        for(int j=0;j<word.size();j++){\n\
    \            if(v[word[j]]==false){\n                unique_characters++;\n  \
    \              v[word[j]]=true;\n            }\n        }\n        if(unique_characters>max_unique_characters){\n\
    \            max_unique_characters=unique_characters;\n            max_index=i;\n\
    \        }\n    }\n    return words[max_index];", "\tstd::string max = \"\";\n\
    \tfor (int i = 0; i < words.size(); i++) {\n\t\tint max_size = max.size();\n\t\
    \tint unique_size = std::set<char>(words[i].begin(), words[i].end()).size();\n\
    \t\tif (unique_size > max_size) {\n\t\t\tmax = words[i];\n\t\t}\n\t}\n\treturn\
    \ max;", "  std::string max_word = \"\";\n  for (auto word : words) {\n    if\
    \ (max_word.size() == 0 || word.size() > max_word.size()) {\n      max_word =\
    \ word;\n    }\n  }\n  return max_word;", "    int max_val=0;\n    std::string\
    \ max_string;\n    for(int i=0;i<words.size();i++){\n        int count=0;\n  \
    \      for(int j=0;j<words[i].size();j++){\n            for(int k=j+1;k<words[i].size();k++){\n\
    \                if(words[i][j]==words[i][k]){\n                    break;\n \
    \               }\n                else{\n                    count++;\n     \
    \           }\n            }\n        }\n        if(count>max_val){\n        \
    \    max_val=count;\n            max_string=words[i];\n        }\n    }\n    return\
    \ max_string;", "\tint count = 0;\n\tint uniqueCount = 0;\n\tstd::string uniqueStr;\n\
    \tfor (int i = 0; i < words.size(); i++) {\n\t\tstd::vector<char> unique;\n\t\t\
    unique.push_back(words[i][0]);\n\t\tuniqueCount = 1;\n\t\tfor (int j = 1; j <\
    \ words[i].size(); j++) {\n\t\t\tif (words[i][j] != words[i][j - 1]) {\n\t\t\t\
    \tuniqueCount++;\n\t\t\t\tunique.push_back(words[i][j]);\n\t\t\t}\n\t\t}\n\t\t\
    if (uniqueCount >= count) {\n\t\t\tif (uniqueCount == count) {\n\t\t\t\tif (words[i]\
    \ < uniqueStr) {\n\t\t\t\t\tuniqueStr = words[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tuniqueStr = words[i];\n\t\t\t\tcount = uniqueCount;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn uniqueStr;", "    // std::cout << \"size of vector: \" <<\
    \ words.size() << std::endl;\n    std::string lexMaxWord, maxWord;\n    int lexMaxChar\
    \ = INT_MIN, maxChar = INT_MIN;\n    std::vector<std::string>::iterator it;\n\
    \    for (it = words.begin(); it != words.end(); it++) {\n        int charCount\
    \ = 0;\n        std::string tempString = *it;\n        std::sort(tempString.begin(),\
    \ tempString.end());\n        for (size_t i = 0; i < tempString.size(); i++) {\n\
    \            if (tempString[i] != tempString[i + 1]) {\n                charCount++;\n\
    \            }\n        }\n        if (charCount > maxChar) {\n            maxChar\
    \ = charCount;\n            maxWord = *it;\n        }\n        if (charCount ==\
    \ maxChar) {\n            if (tempString < lexMaxWord) {\n                lexMaxWord\
    \ = tempString;\n                lexMaxChar = charCount;\n            }\n    \
    \    }\n    }\n    return maxWord;", "  int longest = 0;\n  std::string longest_word;\n\
    \  std::unordered_set<char> us;\n  for (auto &s : words) {\n    us.clear();\n\
    \    for (auto &c : s) {\n      us.insert(c);\n    }\n    if (us.size() > longest)\
    \ {\n      longest = us.size();\n      longest_word = s;\n    }\n  }\n  return\
    \ longest_word;", "  int max_unique = 0;\n  std::string ans = \"\";\n  for (int\
    \ i = 0; i < words.size(); i++) {\n    int unique = 0;\n    bool is_not_unique[26]\
    \ = {false};\n    for (int j = 0; j < words[i].size(); j++) {\n      if (!is_not_unique[words[i][j]\
    \ - 'a']) {\n        unique++;\n        is_not_unique[words[i][j] - 'a'] = true;\n\
    \      }\n    }\n    if (unique > max_unique) {\n      max_unique = unique;\n\
    \      ans = words[i];\n    }\n  }\n  return ans;", "    int unique_chars = 0;\n\
    \    std::string chosen_word;\n    std::unordered_set<char> character_set;\n \
    \   for (auto &word : words) {\n        for (auto &character : word) {\n     \
    \       character_set.insert(character);\n        }\n        if (character_set.size()\
    \ > unique_chars) {\n            unique_chars = character_set.size();\n      \
    \      chosen_word = word;\n        }\n        character_set.clear();\n    }\n\
    \    return chosen_word;", '', "  int index_max = 0;\n  int max_unique = 0;\n\
    \  for (int i = 0; i < words.size(); i++) {\n    std::string curr_word = words[i];\n\
    \    std::vector<bool> curr_bool_arr(256, false);\n    int curr_unique = 0;\n\
    \    for (int j = 0; j < curr_word.size(); j++) {\n      int curr_char = (int)curr_word[j];\n\
    \      if (curr_bool_arr[curr_char] == false) {\n        curr_unique++;\n    \
    \    curr_bool_arr[curr_char] = true;\n      }\n    }\n    if (curr_unique > max_unique)\
    \ {\n      max_unique = curr_unique;\n      index_max = i;\n    }\n  }\n  return\
    \ words[index_max];", "  std::string max_string = \"\";\n  int max_unique_chars\
    \ = 0;\n  for (const auto& word : words) {\n    std::string temp_word = word;\n\
    \    std::sort(temp_word.begin(), temp_word.end());\n    temp_word.erase(std::unique(temp_word.begin(),\
    \ temp_word.end()), temp_word.end());\n    if (temp_word.size() > max_unique_chars)\
    \ {\n      max_unique_chars = temp_word.size();\n      max_string = word;\n  \
    \  }\n  }\n  return max_string;", "    std::string ans;\n    int length = 0;\n\
    \    for (auto& str : words) {\n        std::set<char>s;\n        for (auto c\
    \ : str) {\n            s.insert(c);\n        }\n        if (s.size() > length)\
    \ {\n            length = s.size();\n            ans = str;\n        }\n    }\n\
    \    return ans;", "    std::string max_word;\n    int max_count = -1;\n    for\
    \ (auto word : words) {\n        std::unordered_set<char> unique_characters;\n\
    \        for (auto c : word) {\n            unique_characters.insert(c);\n   \
    \     }\n        if (unique_characters.size() > max_count) {\n            max_count\
    \ = unique_characters.size();\n            max_word = word;\n        }\n    }\n\
    \    return max_word;", "    std::string word;\n    int max = 0;\n    int i, j;\n\
    \    for (i = 0; i < words.size(); i++) {\n        std::string s = words[i];\n\
    \        int count = 0;\n        std::unordered_set<char> us;\n        for (j\
    \ = 0; j < s.size(); j++) {\n            if (us.find(s[j]) == us.end()) {\n  \
    \              us.insert(s[j]);\n                count++;\n            }\n   \
    \     }\n        if (count > max) {\n            max = count;\n            word\
    \ = s;\n        }\n    }\n    return word;", "\t// put your code here\n\tstd::map<std::string,\
    \ int> wordmap;\n\tfor (auto word : words) {\n\t\twordmap[word] = 0;\n\t\tfor\
    \ (int i = 0; i < word.length(); i++) {\n\t\t\tstd::string temp = word.substr(i,\
    \ 1);\n\t\t\tif (word.find(temp) == i) {\n\t\t\t\twordmap[word]++;\n\t\t\t}\n\t\
    \t}\n\t}\n\tstd::map<std::string, int>::iterator it = wordmap.begin();\n\tstd::string\
    \ max_word = it->first;\n\tit++;\n\tfor (; it != wordmap.end(); it++) {\n\t\t\
    if (it->second > wordmap[max_word]) {\n\t\t\tmax_word = it->first;\n\t\t}\n\t\
    }\n\treturn max_word;", "    int max_len = 0;\n    std::string max_word;\n   \
    \ for (auto word : words) {\n        if (max_len < word.length()) {\n        \
    \    max_len = word.length();\n            max_word = word;\n        }\n    }\n\
    \    return max_word;", "\tstd::string result = \"\";\n\tint max = 0;\n\tfor (auto\
    \ word : words) {\n\t\tstd::set<char> s;\n\t\tfor (auto c : word) {\n\t\t\ts.insert(c);\n\
    \t\t}\n\t\tif (s.size() > max) {\n\t\t\tmax = s.size();\n\t\t\tresult = word;\n\
    \t\t}\n\t}\n\treturn result;", "    std::string s = \"\";\n    int num = 0;\n\
    \    for (auto i = words.begin(); i != words.end(); i++) {\n        std::set<char>\
    \ unique_chars;\n        for (char j : *i) {\n            unique_chars.insert(j);\n\
    \        }\n        if (unique_chars.size() > num) {\n            num = unique_chars.size();\n\
    \            s = *i;\n        }\n    }\n    return s;", "    std::string max_word\
    \ = \"\";\n    int max_count = 0;\n    int count = 0;\n    std::vector<std::string>\
    \ unique_word;\n    std::vector<std::string> temp;\n    std::vector<std::string>\
    \ unique_word_temp;\n    for (int i = 0; i < words.size(); i++) {\n        max_word\
    \ = words[i];\n        for (int j = 0; j < words[i].size(); j++) {\n         \
    \   if (find(unique_word.begin(), unique_word.end(), words[i][j]) == unique_word.end())\
    \ {\n                unique_word.push_back(words[i][j]);\n            }\n    \
    \    }\n        count = unique_word.size();\n        if (count > max_count) {\n\
    \            max_count = count;\n            max_word = words[i];\n        }\n\
    \        if (count == max_count) {\n            temp.push_back(words[i]);\n  \
    \      }\n        unique_word.clear();\n    }\n    if (temp.size() == 1) {\n \
    \       return temp[0];\n    }\n    else {\n        for (int i = 0; i < temp.size();\
    \ i++) {\n            for (int j = 0; j < temp[i].size(); j++) {\n           \
    \     if (find(unique_word_temp.begin(), unique_word_temp.end(), temp[i][j]) ==\
    \ unique_word_temp.end()) {\n                    unique_word_temp.push_back(temp[i][j]);\n\
    \                }\n            }\n            count = unique_word_temp.size();\n\
    \            if (count == max_count) {\n                max_word = temp[i];\n\
    \                break;\n            }\n            unique_word_temp.clear();\n\
    \        }\n    }\n    return max_word;", "  int max = 0;\n  std::string word\
    \ = \"\";\n  std::set<char> chars;\n  for (int i = 0; i < words.size(); i++) {\n\
    \    chars.clear();\n    for (int j = 0; j < words[i].size(); j++) {\n      chars.insert(words[i][j]);\n\
    \    }\n    if (chars.size() > max) {\n      max = chars.size();\n      word =\
    \ words[i];\n    }\n  }\n  return word;", "    int i, j, max_chars = 0, max_chars_index\
    \ = 0;\n    std::string str;\n    for(i = 0; i < words.size(); i++) {\n      \
    \  str = words[i];\n        std::sort(str.begin(), str.end());\n        str.erase(std::unique(str.begin(),\
    \ str.end()), str.end());\n        if(str.size() > max_chars) {\n            max_chars\
    \ = str.size();\n            max_chars_index = i;\n        }\n    }\n    return\
    \ words[max_chars_index];", "\t// Your code here\n\treturn \"\";", "    std::string\
    \ ans = \"\";\n    int max_unique = 0;\n    for (auto s : words) {\n        int\
    \ unique = 0;\n        for (auto c : s) {\n            unique += unique & (1 <<\
    \ (c - 'a'));\n        }\n        if (unique > max_unique || (unique == max_unique\
    \ && s < ans)) {\n            max_unique = unique;\n            ans = s;\n   \
    \     }\n    }\n    return ans;", "  std::string max = \"\";\n  int max_val =\
    \ 0;\n  for (int i = 0; i < words.size(); i++) {\n    std::string curr = words[i];\n\
    \    int unique_char = 0;\n    std::map<char, bool> visited;\n    for (int j =\
    \ 0; j < curr.size(); j++) {\n      if (visited.find(curr[j]) == visited.end())\
    \ {\n        unique_char++;\n        visited[curr[j]] = true;\n      }\n    }\n\
    \    if (unique_char > max_val) {\n      max_val = unique_char;\n      max = curr;\n\
    \    }\n  }\n  return max;", '    // Your code here.', "  unsigned int max_unique_chars\
    \ = 0;\n  std::string max_unique_word;\n  // iterate over each word\n  for (auto\
    \ word : words) {\n    std::unordered_set<char> unique_chars;\n    // for each\
    \ word, iterate over the characters\n    for (auto c : word) {\n      unique_chars.insert(c);\n\
    \    }\n    // if the number of unique characters is more than max_unique_chars,\
    \ update\n    // the max_unique_chars and max_unique_word\n    if (unique_chars.size()\
    \ > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n     \
    \ max_unique_word = word;\n    }\n  }\n  return max_unique_word;", "  std::map<char,int>\
    \ hash_map;\n  int max_unique = 0;\n  std::string ans;\n  for(int i=0;i<words.size();i++){\n\
    \    int unique = 0;\n    for(int j=0;j<words[i].size();j++){\n      if(hash_map.find(words[i][j])==hash_map.end()){\n\
    \        hash_map[words[i][j]]=1;\n        unique++;\n      }\n    }\n    if(unique>max_unique){\n\
    \      max_unique = unique;\n      ans = words[i];\n    }\n    hash_map.clear();\n\
    \  }\n  return ans;", "  std::map<std::string, std::set<char>> word_unique_char_map;\n\
    \  for (auto word : words) {\n    std::set<char> unique_chars;\n    for (auto\
    \ ch : word) {\n      unique_chars.insert(ch);\n    }\n    word_unique_char_map[word]\
    \ = unique_chars;\n  }\n  int max_unique_chars = 0;\n  std::string max_word =\
    \ \"\";\n  for (auto word : words) {\n    if (word_unique_char_map[word].size()\
    \ > max_unique_chars) {\n      max_unique_chars = word_unique_char_map[word].size();\n\
    \      max_word = word;\n    }\n  }\n  return max_word;", "    int max = -1;\n\
    \    std::string ans;\n    for(auto word : words) {\n        int ascii[128] =\
    \ {0};\n        int uni = 0;\n        for(auto ch : word) {\n            if(ascii[ch]\
    \ == 0) {\n                uni++;\n                ascii[ch] = 1;\n          \
    \  }\n        }\n        if(uni > max) {\n            max = uni;\n           \
    \ ans = word;\n        }\n    }\n    return ans;", "  std::string big = \"\";\n\
    \  std::string max = \"\";\n  int c = 0;\n  int maxc = 0;\n  int i = 0;\n  while\
    \ (i < words.size()) {\n    big = words[i];\n    c = 0;\n    for (int j = 0; j\
    \ < big.size(); j++) {\n      if (big[j] == big[j+1]) {\n        c++;\n      }\n\
    \    }\n    if (c > maxc) {\n      maxc = c;\n      max = big;\n    }\n    i++;\n\
    \  }\n  return max;", "  // implement your code here\n  std::map<std::string,\
    \ int> countMap;\n  std::map<std::string, std::string> wordMap;\n  std::string\
    \ temp = \"\";\n  int count = 0;\n  for (int i = 0; i < words.size(); i++) {\n\
    \    temp = words[i];\n    count = countMap[temp];\n    if (countMap.find(temp)\
    \ == countMap.end()) {\n      countMap[temp] = 0;\n    }\n    countMap[temp]++;\n\
    \    wordMap[temp] = temp;\n  }\n  // std::cout << \"countMap:\\n\";\n  // for\
    \ (auto &x : countMap) {\n  //   std::cout << x.first << \": \" << x.second <<\
    \ '\\n';\n  // }\n  // std::cout << \"wordMap:\\n\";\n  // for (auto &x : wordMap)\
    \ {\n  //   std::cout << x.first << \": \" << x.second << '\\n';\n  // }\n  std::string\
    \ maxWord = \"\";\n  int maxCount = 0;\n  for (auto &x : countMap) {\n    if (x.second\
    \ > maxCount) {\n      maxCount = x.second;\n      maxWord = x.first;\n    }\n\
    \  }\n  return maxWord;", "    int max_size = 0;\n    std::string ret = \"\";\n\
    \    for (auto w : words) {\n        std::set<char> st;\n        for (auto c :\
    \ w) {\n            st.insert(c);\n        }\n        if (max_size < st.size())\
    \ {\n            max_size = st.size();\n            ret = w;\n        }\n    }\n\
    \    return ret;", "\tstd::string winner;\n\tfor (auto word : words) {\n\t\tif\
    \ (winner.empty()) {\n\t\t\twinner = word;\n\t\t}\n\t\telse {\n\t\t\tif (winner.length()\
    \ < word.length()) {\n\t\t\t\twinner = word;\n\t\t\t}\n\t\t\telse if (winner.length()\
    \ == word.length()) {\n\t\t\t\tif (winner < word) {\n\t\t\t\t\twinner = word;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn winner;", "    int n = words.size();\n\
    \    int mx = 0;\n    std::string s = \"\";\n    for(int i = 0; i < n; i++) {\n\
    \        std::set<char> unique_chars;\n        int count = 0;\n        for(int\
    \ j = 0; j < words[i].size(); j++) {\n            unique_chars.insert(words[i][j]);\n\
    \        }\n        count = unique_chars.size();\n        if(count > mx) {\n \
    \           mx = count;\n            s = words[i];\n        }\n        else if(count\
    \ == mx) {\n            if(words[i] < s) {\n                s = words[i];\n  \
    \          }\n        }\n    }\n    return s;", "    std::vector<char> seen;\n\
    \    std::string max_len_word;\n    int max_len = 0;\n    for (auto word : words)\
    \ {\n        if (word.length() > max_len) {\n            for (auto character :\
    \ word) {\n                if (std::find(seen.begin(), seen.end(), character)\
    \ == seen.end()) {\n                    seen.push_back(character);\n         \
    \       }\n            }\n            if (seen.size() > max_len) {\n         \
    \       max_len = seen.size();\n                max_len_word = word;\n       \
    \     }\n            seen.clear();\n        }\n    }\n    return max_len_word;",
  "\tstd::string result;\n\tstd::unordered_map<char, int> unique_char_count;\n\tint\
    \ max_count = 0;\n\tfor (auto word : words) {\n\t\tunique_char_count.clear();\n\
    \t\tfor (auto ch : word) {\n\t\t\tif (unique_char_count.find(ch) == unique_char_count.end())\
    \ {\n\t\t\t\tunique_char_count[ch] = 1;\n\t\t\t}\n\t\t}\n\t\tif (unique_char_count.size()\
    \ > max_count) {\n\t\t\tmax_count = unique_char_count.size();\n\t\t\tresult =\
    \ word;\n\t\t}\n\t}\n\treturn result;", "\tsize_t max = 0;\n\tstd::string result;\n\
    \tfor (size_t i = 0; i < words.size(); i++) {\n\t\tstd::set<char> characters;\n\
    \t\tsize_t count = 0;\n\t\tfor (size_t j = 0; j < words[i].size(); j++) {\n\t\t\
    \tif (characters.find(words[i][j]) == characters.end()) {\n\t\t\t\tcharacters.insert(words[i][j]);\n\
    \t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > max) {\n\t\t\tmax = count;\n\
    \t\t\tresult = words[i];\n\t\t}\n\t}\n\treturn result;", "  std::string res;\n\
    \  int max = 0;\n  for (int i = 0; i < words.size(); i++) {\n    int cnt = 0;\n\
    \    for (int j = 0; j < words[i].size(); j++) {\n      for (int k = j + 1; k\
    \ < words[i].size(); k++) {\n        if (words[i][j] == words[i][k]) {\n     \
    \     cnt++;\n          break;\n        }\n      }\n    }\n    if (cnt == 0) {\n\
    \      if (words[i].size() > max) {\n        max = words[i].size();\n        res\
    \ = words[i];\n      }\n    }\n  }\n  return res;", "    if (words.size() == 0)\
    \ {\n        return \"\";\n    }\n    std::string maxWord = words[0];\n    int\
    \ maxCount = 0;\n    for (int i = 0; i < words.size(); i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > maxCount) {\n            maxCount = s.size();\n\
    \            maxWord = words[i];\n        }\n    }\n    return maxWord;", "  \
    \  std::string ans = \"\";\n    int max_unique = 0;\n    for (int i = 0; i < words.size();\
    \ i++) {\n        std::vector<bool> alphabet(26, false);\n        int unique =\
    \ 0;\n        for (int j = 0; j < words[i].size(); j++) {\n            if (!alphabet[words[i][j]\
    \ - 'a']) {\n                unique++;\n                alphabet[words[i][j] -\
    \ 'a'] = true;\n            }\n        }\n        if (unique > max_unique) {\n\
    \            max_unique = unique;\n            ans = words[i];\n        }\n  \
    \      else if (unique == max_unique) {\n            ans = std::min(ans, words[i]);\n\
    \        }\n    }\n    return ans;", "  int max = 0;\n  std::string str;\n  for\
    \ (std::string word : words) {\n    std::set<char> cSet;\n    for (char c : word)\
    \ {\n      cSet.insert(c);\n    }\n    if (cSet.size() > max) {\n      max = cSet.size();\n\
    \      str = word;\n    }\n  }\n  return str;", "  std::string ans = \"\";\n \
    \ int maxCount = 0;\n  for (std::string str : words) {\n    std::set<char> setOfChars;\n\
    \    for (char ch : str) {\n      setOfChars.insert(ch);\n    }\n    if (setOfChars.size()\
    \ > maxCount) {\n      maxCount = setOfChars.size();\n      ans = str;\n    }\n\
    \  }\n  return ans;", "  int max = 0;\n  std::string m_word;\n  for (auto s :\
    \ words) {\n    int len = std::unique(s.begin(), s.end()) - s.begin();\n    if\
    \ (len > max) {\n      max = len;\n      m_word = s;\n    }\n  }\n  return m_word;",
  "  int max = 0;\n  std::string max_word;\n  for (int i = 0; i < words.size(); i++)\
    \ {\n    std::vector<char> chars;\n    for (int j = 0; j < words[i].size(); j++)\
    \ {\n      if (std::find(chars.begin(), chars.end(), words[i][j]) == chars.end())\
    \ {\n        chars.push_back(words[i][j]);\n      }\n    }\n    if (chars.size()\
    \ > max) {\n      max = chars.size();\n      max_word = words[i];\n    }\n  }\n\
    \  return max_word;", "\t// Write your code here\n\tint x,y,z;\n\tx=y=z=0;\n\t\
    std::string max=\"\";\n\tfor(int i=0;i<words.size();i++)\n\t{\n\t\tx=0;\n\t\t\
    if(y<words[i].size())\n\t\t{\n\t\t\ty=words[i].size();\n\t\t\tz=i;\n\t\t}\n\t\t\
    std::set<char> s;\n\t\tfor(int j=0;j<words[i].size();j++)\n\t\t{\n\t\t\ts.insert(words[i][j]);\n\
    \t\t}\n\t\tx=s.size();\n\t\tif(max.size()<=x)\n\t\t{\n\t\t\tmax=words[i];\n\t\t\
    }\n\t}\n\tif(y==max.size())\n\t{\n\t\treturn words[z];\n\t}\n\treturn max;", " \
    \   if (words.size() == 0) return \"\";\n    std::sort(words.begin(), words.end());\n\
    \    std::string w = words[0];\n    int len = w.length();\n    for (int i = 1;\
    \ i < words.size(); i++) {\n        if (len < words[i].length()) {\n         \
    \   w = words[i];\n            len = w.length();\n        }\n    }\n    std::string\
    \ res = \"\";\n    int cnt[26] = {0};\n    for (int i = 0; i < w.length(); i++)\
    \ {\n        cnt[w[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n \
    \       if (cnt[i] > 0) res += (char)(i + 'a');\n    }\n    return res;", "\t\
    std::string max_word;\n\tint max_chars = 0;\n\tfor (std::string word : words)\
    \ {\n\t\tint chars = 0;\n\t\tfor (int i = 0; i < word.size(); i++) {\n\t\t\tfor\
    \ (int j = 0; j < word.size(); j++) {\n\t\t\t\tif (word[i] == word[j]) {\n\t\t\
    \t\t\tchars++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (chars > max_chars) {\n\t\t\t\
    max_chars = chars;\n\t\t\tmax_word = word;\n\t\t}\n\t}\n\treturn max_word;", " \
    \   size_t max_length = 0;\n    int max_index = 0;\n    for (size_t i = 0; i <\
    \ words.size(); i++) {\n        int k = 0;\n        for (size_t j = 0; j < words[i].size();\
    \ j++) {\n            if (words[i].find(words[i][j]) == j)\n                k++;\n\
    \        }\n        if (k > max_length) {\n            max_length = k;\n     \
    \       max_index = i;\n        }\n    }\n    return words[max_index];", "  if\
    \ (words.size() == 0) return \"\";\n  int i, j, max_unique = 0, max_index = 0;\n\
    \  // iterate over all words\n  for (i = 0; i < words.size(); i++) {\n    std::string\
    \ word = words[i];\n    // create a map to store frequency of characters in word\n\
    \    std::map<char, int> char_map;\n    // iterate over all characters of word\
    \ and store frequency in char_map\n    for (j = 0; j < word.size(); j++) {\n \
    \     char_map[word[j]]++;\n    }\n    // if unique characters of word = max_unique\
    \ and word's index is < current\n    // max_index\n    if (char_map.size() ==\
    \ max_unique && i < max_index) {\n      max_index = i; // then make word's index\
    \ as max_index\n    }\n    // if unique characters of word > max_unique\n    if\
    \ (char_map.size() > max_unique) {\n      max_unique = char_map.size(); // then\
    \ make char_map.size() as max_unique\n      max_index = i; // and word's index\
    \ as max_index\n    }\n  }\n  return words[max_index];", "  int num_words = words.size();\n\
    \  int num_characters = 0;\n  int longest_word = 0;\n  int tmp_count;\n  int curr_longest_word\
    \ = 0;\n  std::string answer;\n  for (int i = 0; i < num_words; i++) {\n    num_characters\
    \ = words[i].length();\n    std::set<char> my_set;\n    for (int j = 0; j < num_characters;\
    \ j++) {\n      my_set.insert(words[i][j]);\n    }\n    tmp_count = my_set.size();\n\
    \    if (tmp_count > longest_word) {\n      longest_word = tmp_count;\n      curr_longest_word\
    \ = i;\n    }\n  }\n  if (longest_word == 0) {\n    return \"\";\n  }\n  return\
    \ words[curr_longest_word];", "    // Write your code here\n    std::string res;\n\
    \    int m = 0;\n    for (std::string x : words) {\n        std::unordered_set<char>\
    \ s;\n        for (int i = 0; i < x.size(); i++) {\n            s.insert(x[i]);\n\
    \        }\n        if (s.size() > m) {\n            m = s.size();\n         \
    \   res = x;\n        }\n    }\n    return res;", "\tint max = 0;\n\tint max_index\
    \ = 0;\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i].size() >\
    \ max) {\n\t\t\tmax = words[i].size();\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\tstd::set<char>\
    \ s;\n\tfor (int i = 0; i < words[max_index].size(); i++) {\n\t\ts.insert(words[max_index][i]);\n\
    \t}\n\tif (s.size() == max) {\n\t\treturn words[max_index];\n\t}\n\telse {\n\t\
    \ts.clear();\n\t\tfor (int i = 0; i < words.size(); i++) {\n\t\t\tfor (int j =\
    \ 0; j < words[i].size(); j++) {\n\t\t\t\ts.insert(words[i][j]);\n\t\t\t}\n\t\t\
    \tif (s.size() == max) {\n\t\t\t\treturn words[i];\n\t\t\t}\n\t\t\ts.clear();\n\
    \t\t}\n\t}\n\treturn \"\";", "  std::unordered_map<char,int> unique_char_counter;\n\
    \  int maximum_unique_characters = 0;\n  std::string max_string;\n  for(auto it\
    \ = words.begin(); it != words.end(); it++) {\n    for(auto itr = it->begin();\
    \ itr != it->end(); itr++) {\n      auto it_map = unique_char_counter.find(*itr);\n\
    \      if(it_map == unique_char_counter.end()) {\n        unique_char_counter.insert(std::make_pair(*itr,1));\n\
    \      }\n      else {\n        unique_char_counter[*itr] += 1;\n      }\n   \
    \ }\n    if(unique_char_counter.size() > maximum_unique_characters) {\n      maximum_unique_characters\
    \ = unique_char_counter.size();\n      max_string = *it;\n    }\n    else if(unique_char_counter.size()\
    \ == maximum_unique_characters) {\n      if(max_string.compare(*it) > 0) {\n \
    \       max_string = *it;\n      }\n    }\n    unique_char_counter.clear();\n\
    \  }\n  return max_string;", "    int max = 0;\n    int flag = 0;\n    std::string\
    \ max_string;\n    std::set<char> unique_set;\n    for (auto & word : words) {\n\
    \        for (char & c : word) {\n            unique_set.insert(c);\n        }\n\
    \        if (unique_set.size() > max) {\n            max = unique_set.size();\n\
    \            max_string = word;\n            flag = 1;\n        }\n        else\
    \ if (unique_set.size() == max) {\n            if (word < max_string) {\n    \
    \            max_string = word;\n            }\n        }\n        unique_set.clear();\n\
    \    }\n    if (flag == 0) {\n        max_string = \"\";\n    }\n    return max_string;",
  "  std::string answer = \"\";\n  int maxUnique = 0;\n  int count;\n  std::vector<char>\
    \ letters;\n  for (int i = 0; i < words.size(); i++) {\n    count = 0;\n    for\
    \ (int j = 0; j < words[i].size(); j++) {\n      if (std::find(letters.begin(),\
    \ letters.end(), words[i][j]) == letters.end()) {\n        count++;\n        letters.push_back(words[i][j]);\n\
    \      }\n    }\n    if (count > maxUnique) {\n      maxUnique = count;\n    \
    \  answer = words[i];\n    }\n    else if (count == maxUnique) {\n      if (words[i]\
    \ < answer) {\n        answer = words[i];\n      }\n    }\n    letters.clear();\n\
    \  }\n  return answer;", "  // your code here\n  std::string alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n  // std::string input = \"stackroute\";\n  int max_val = 0;\n  std::string\
    \ result = \"\";\n  std::vector<std::string> unique_words;\n  for (int i = 0;\
    \ i < words.size(); i++) {\n    std::string unique_word = \"\";\n    for (int\
    \ j = 0; j < words[i].length(); j++) {\n      if (unique_word.find(words[i][j])\
    \ == std::string::npos) {\n        unique_word += words[i][j];\n      }\n    }\n\
    \    if (unique_word.length() > max_val) {\n      max_val = unique_word.length();\n\
    \      result = words[i];\n    }\n    if (unique_word.length() == max_val) {\n\
    \      if (words[i] < result) {\n        result = words[i];\n      }\n    }\n\
    \  }\n  return result;", "  // Your code here\n  std::sort(words.begin(), words.end());\n\
    \  std::unordered_map<char, int> my_map;\n  int greatest_size = 0;\n  int biggest_word\
    \ = 0;\n  for (int i = 0; i < words.size(); i++) {\n    for (int j = 0; j < words[i].size();\
    \ j++) {\n      my_map[words[i][j]] = 0;\n    }\n    if (my_map.size() > greatest_size)\
    \ {\n      greatest_size = my_map.size();\n      biggest_word = i;\n    }\n  \
    \  my_map.clear();\n  }\n  return words[biggest_word];", "    int  max_unique=0;\n\
    \    std::string result;\n    for(auto e:words){\n        int unique_num=0;\n\
    \        std::vector<char> unique_chars;\n        for(auto ee:e){\n          \
    \  bool found=false;\n            for(auto eee:unique_chars){\n              \
    \  if(ee==eee){\n                    found=true;\n                    break;\n\
    \                }\n            }\n            if(!found){\n                unique_chars.push_back(ee);\n\
    \                unique_num++;\n            }\n        }\n        if(unique_num>max_unique){\n\
    \            max_unique=unique_num;\n            result=e;\n        }\n    }\n\
    \    return result;", "\tstd::string r = \"\";\n\tint max_unique = 0;\n\tfor (std::string\
    \ word : words) {\n\t\tint unique = 0;\n\t\tstd::set<char> seen;\n\t\tfor (char\
    \ c : word) {\n\t\t\tif (seen.find(c) == seen.end()) {\n\t\t\t\tseen.insert(c);\n\
    \t\t\t\tunique++;\n\t\t\t}\n\t\t}\n\t\tif (unique > max_unique) {\n\t\t\tmax_unique\
    \ = unique;\n\t\t\tr = word;\n\t\t}\n\t}\n\treturn r;", "    std::map<char, bool>\
    \ m;\n    std::string max = \"\";\n    int max_count = 0;\n    for (int i = 0;\
    \ i < words.size(); i++) {\n        m.clear();\n        int count = 0;\n     \
    \   for (int j = 0; j < words[i].size(); j++) {\n            if (m.find(words[i][j])\
    \ == m.end()) {\n                m[words[i][j]] = true;\n                count++;\n\
    \            }\n        }\n        if (count > max_count) {\n            max_count\
    \ = count;\n            max = words[i];\n        }\n    }\n    return max;", " \
    \ if (words.size() == 0) {\n    return \"\";\n  }\n  std::string word_with_most_unique_chars\
    \ = words[0];\n  int max_unique_chars = 0;\n  for (int i = 0; i < words.size();\
    \ i++) {\n    std::string current_word = words[i];\n    std::vector<bool> is_char_seen(256,\
    \ false);\n    for (int j = 0; j < current_word.size(); j++) {\n      if (!is_char_seen[current_word[j]])\
    \ {\n        is_char_seen[current_word[j]] = true;\n      }\n    }\n    int num_unique_chars\
    \ = 0;\n    for (int j = 0; j < 256; j++) {\n      if (is_char_seen[j]) {\n  \
    \      num_unique_chars++;\n      }\n    }\n    if (num_unique_chars > max_unique_chars)\
    \ {\n      max_unique_chars = num_unique_chars;\n      word_with_most_unique_chars\
    \ = current_word;\n    }\n  }\n  return word_with_most_unique_chars;", "    std::string\
    \ result;\n    int max = 0;\n    for (int i = 0; i < words.size(); i++) {\n  \
    \      std::string temp = words[i];\n        int count = 0;\n        bool unique\
    \ = true;\n        for (int j = 0; j < temp.size(); j++) {\n            if (std::find(temp.begin(),\
    \ temp.begin() + j, temp[j]) != temp.begin() + j) {\n                unique =\
    \ false;\n            }\n            else {\n                count++;\n      \
    \      }\n        }\n        if (unique && count >= max) {\n            max =\
    \ count;\n            result = temp;\n        }\n    }\n    return result;", " \
    \ int max_unique_characters = 0;\n  std::string max_word;\n  for (auto word :\
    \ words) {\n    std::set<char> unique_characters;\n    for (auto ch : word) {\n\
    \      unique_characters.insert(ch);\n    }\n    if (unique_characters.size()\
    \ > max_unique_characters) {\n      max_unique_characters = unique_characters.size();\n\
    \      max_word = word;\n    }\n  }\n  return max_word;", "  int max_unique_chars\
    \ = 0;\n  std::string ans;\n  for (int i = 0; i < words.size(); i++) {\n    int\
    \ unique_chars = 0;\n    for (int j = 0; j < words[i].size(); j++) {\n      if\
    \ (words[i].find(words[i][j]) == j)\n        unique_chars++;\n    }\n    if (unique_chars\
    \ > max_unique_chars) {\n      max_unique_chars = unique_chars;\n      ans = words[i];\n\
    \    }\n  }\n  return ans;", "    int n = words.size();\n    int max_n = 0;\n\
    \    std::string res;\n    for (int i = 0; i < n; i++) {\n        std::set<char>\
    \ s;\n        for (int j = 0; j < words[i].size(); j++) {\n            s.insert(words[i][j]);\n\
    \        }\n        if (s.size() > max_n) {\n            max_n = s.size();\n \
    \           res = words[i];\n        }\n    }\n    return res;", "    std::string\
    \ ans = \"\";\n    for (std::string x : words) {\n        if (ans == \"\") {\n\
    \            ans = x;\n        } else {\n            std::set<char> chars;\n \
    \           for (char c : x) {\n                chars.insert(c);\n           \
    \ }\n            if (chars.size() > ans.size()) {\n                ans = x;\n\
    \            } else if (chars.size() == ans.size()) {\n                if (x <\
    \ ans) {\n                    ans = x;\n                }\n            }\n   \
    \     }\n    }\n    return ans;", "    //your code goes here\n    int unique_char_count\
    \ = 0;\n    std::string word_with_max_unique_characters;\n    for (auto word :\
    \ words) {\n        std::set<char> word_set;\n        for (auto character : word)\
    \ {\n            word_set.insert(character);\n        }\n        if (word_set.size()\
    \ > unique_char_count) {\n            unique_char_count = word_set.size();\n \
    \           word_with_max_unique_characters = word;\n        }\n    }\n    return\
    \ word_with_max_unique_characters;", "    std::vector<int> word_char_count(words.size());\n\
    \    std::string result = \"\";\n    for (int i = 0; i < words.size(); i++) {\n\
    \        std::string word = words[i];\n        std::set<char> seen;\n        for\
    \ (int j = 0; j < word.size(); j++) {\n            seen.insert(word[j]);\n   \
    \     }\n        word_char_count[i] = seen.size();\n    }\n    int max_char_count\
    \ = *std::max_element(word_char_count.begin(), word_char_count.end());\n    std::vector<int>\
    \ idx_with_max_char_count;\n    for (int i = 0; i < word_char_count.size(); i++)\
    \ {\n        if (word_char_count[i] == max_char_count) {\n            idx_with_max_char_count.push_back(i);\n\
    \        }\n    }\n    for (int i = 0; i < idx_with_max_char_count.size(); i++)\
    \ {\n        if (result == \"\") {\n            result = words[idx_with_max_char_count[i]];\n\
    \        } else {\n            if (words[idx_with_max_char_count[i]] < result)\
    \ {\n                result = words[idx_with_max_char_count[i]];\n           \
    \ }\n        }\n    }\n    return result;", "    //int count = 0;\n    int max_count\
    \ = 0;\n    std::string result;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        int count = 0;\n        std::string str = words[i];\n        std::set<char>\
    \ chars;\n        for (char letter : str) {\n            chars.insert(letter);\n\
    \        }\n        count = chars.size();\n        if (count > max_count) {\n\
    \            max_count = count;\n            result = str;\n        }\n      \
    \  else if (count == max_count) {\n            if (result.compare(str) > 0) {\n\
    \                result = str;\n            }\n        }\n    }\n    return result;"]
stop_tokens:
- "\n}"
