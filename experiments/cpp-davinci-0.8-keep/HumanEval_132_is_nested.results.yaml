language: cpp
name: HumanEval_132_is_nested
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    for(auto ch : string) {\n        if(ch ==\
    \ '[') {\n            stk.push(ch);\n        }\n        else if(ch == ']') {\n\
    \            if(stk.empty()) {\n                return false;\n            }\n\
    \            else {\n                stk.pop();\n            }\n        }\n  \
    \  }\n    return stk.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpczq5ik5c: /tmp/tmpczq5ik5c.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // create a stack and push first char of string\n    std::stack<char>\
    \ stack;\n    stack.push(string[0]);\n    for(int i = 1; i < string.length();\
    \ i++) {\n        // if stack top has similar bracket as string[i] pop\n     \
    \   if(stack.top() == '[' && string[i] == ']')\n            stack.pop();\n   \
    \     else\n            stack.push(string[i]);\n    }\n    // if stack is empty\
    \ return true else false\n    if(stack.empty())\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint cnt = 0;\n\tint cnt_nested = 0;\n\tfor (int i = 0; i < string.size();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\tcnt++;\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tcnt--;\n\t\t}\n\t\tif (cnt < 0) {\n\t\t\treturn false;\n\t\t\
    }\n\t\tif (cnt == 0) {\n\t\t\tcnt_nested++;\n\t\t}\n\t}\n\tif (cnt != 0) {\n\t\
    \treturn false;\n\t}\n\treturn cnt_nested > 1;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9fq9pv2v: /tmp/tmp9fq9pv2v.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool ret = false;\n    int n = string.length();\n    std::stack<char>\
    \ s;\n    for(int i = 0; i < n; i++) {\n        if(string[i] == '[') {\n     \
    \       s.push(string[i]);\n        }\n        else if(string[i] == ']') {\n \
    \           if(s.size() > 0) {\n                if(s.top() == '[')\n         \
    \           s.pop();\n                else \n                    return false;\n\
    \            }\n            else \n                return false;\n        }\n\
    \    }\n    if(s.size() > 0)\n        return false;\n    return true;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpk6fsr31x: /tmp/tmpk6fsr31x.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count=0;\n\tfor(int i=0;i<string.length();i++)\n\t{\n\t\tif(string[i]=='[')\n\
    \t\t\tcount++;\n\t\telse\n\t\t\tcount--;\n\t\tif(count<0)\n\t\t\treturn false;\n\
    \t}\n\treturn count==0;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp8tm195k4: /tmp/tmp8tm195k4.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int len = string.length();\n    stack<char> s;\n    s.push(string[0]);\n\
    \    for(int i=1;i<len;i++){\n        if(string[i]=='[' || string[i]==']'){\n\
    \            if(string[i]=='['){\n                s.push(string[i]);\n       \
    \     }\n            else{\n                if(s.top()=='['){\n              \
    \      s.pop();\n                }\n                else{\n                  \
    \  s.push(string[i]);\n                }\n            }\n        }\n    }\n  \
    \  if(s.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpb3w_i9d_.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpb3w_i9d_.cpp:14:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   14 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpb3w_i9d_.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpb3w_i9d_.cpp:14:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   14 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpb3w_i9d_.cpp:15:5: error: \u2018s\u2019 was not declared in this scope\n\
    \   15 |     s.push(string[0]);\n      |     ^\n/tmp/tmpb3w_i9d_.cpp:37:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n   37 | }\n      |\
    \ ^\n"
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<char> v;\n    for(int i=0;i<string.length();i++){\n     \
    \   if(string[i]=='['){\n            v.push_back(string[i]);\n        }\n    \
    \    else if(string[i]==']'){\n            if(v.size()>0){\n                if(v[v.size()-1]=='['){\n\
    \                    v.pop_back();\n                }\n                else{\n\
    \                    return false;\n                }\n            }\n       \
    \     else{\n                return false;\n            }\n        }\n    }\n\
    \    if(v.size()==0){\n        return true;\n    }\n    else{\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4btt3gm7: /tmp/tmp4btt3gm7.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif (string == \"\") return false;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == '[' || string[i] == ']') {\n\t\t\tif (string[i]\
    \ == ']' && i == 0) return false;\n\t\t\tif (string[i] == ']' && string[i - 1]\
    \ == '[') return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr7szsb_d: /tmp/tmpr7szsb_d.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count=0;\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n\
    \            count++;\n        }\n        else{\n            count--;\n      \
    \  }\n        if(count<0){\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp7e6n38go: /tmp/tmp7e6n38go.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121178
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(char c : string) {\n\t\tif(c == '[') {\n\t\t\
    \tst.push(c);\n\t\t}\n\t\telse if(c == ']') {\n\t\t\tif(st.empty()) return false;\n\
    \t\t\telse st.pop();\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpb_v4w1xa: /tmp/tmpb_v4w1xa.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    for(int i=0;i<string.length();i++){\n    \
    \    if(string[i]=='['){\n            stk.push(string[i]);\n        }\n      \
    \  else if(string[i]==']'){\n            if(stk.empty()){\n                return\
    \ false;\n            }\n            else if(stk.top()=='['){\n              \
    \  stk.pop();\n            }\n            else{\n                return false;\n\
    \            }\n        }\n    }\n    if(stk.empty()){\n        return true;\n\
    \    }\n    else{\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpmk66pq4t: /tmp/tmpmk66pq4t.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint curr,i,j;\n\tcurr=0;\n\tint flag=0;\n\tfor(i=0;i<string.length();i++)\n\
    \t{\n\t\tif(string[i]=='[')\n\t\t\tcurr++;\n\t\telse if(string[i]==']')\n\t\t\t\
    curr--;\n\t\telse\n\t\t\tcontinue;\n\t\tif(curr<0)\n\t\t\treturn false;\n\t\t\
    if(curr>0)\n\t\t\tflag=1;\n\t}\n\tif(curr==0&&flag==1)\n\t\treturn true;\n\telse\n\
    \t\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpzg74wc6o: /tmp/tmpzg74wc6o.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint cnt = 0;\n\tfor (char i : string) {\n\t\tif (i == '[')\n\t\t\tcnt++;\n\
    \t\telse\n\t\t\tcnt--;\n\t\tif (cnt < 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpqxqka2vt: /tmp/tmpqxqka2vt.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[')\n\t\t\ts.push(string[i]);\n\t\telse if (string[i] == ']')\
    \ {\n\t\t\tif (s.empty())\n\t\t\t\treturn false;\n\t\t\ts.pop();\n\t\t}\n\t}\n\
    \treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpfz77omer: /tmp/tmpfz77omer.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tchar str[200];\n\tint i, top = -1;\n\tif (string.length() % 2 == 1)\n\t\
    \treturn false;\n\tstrcpy(str, string.c_str());\n\tfor (i = 0; i < string.length();\
    \ i++) {\n\t\tif (str[i] == '[')\n\t\t\ttop++;\n\t\telse if (str[i] == ']')\n\t\
    \t\ttop--;\n\t\tif (top < 0)\n\t\t\treturn false;\n\t}\n\tif (top != 0)\n\t\t\
    return false;\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3smrfots: /tmp/tmp3smrfots.cpp:32: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::string stack;\n    for(auto i:string){\n        if(i=='[') stack.push_back(i);\n\
    \        else if(stack.empty()) return false;\n        else stack.pop_back();\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpemha394n: /tmp/tmpemha394n.cpp:25: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t//char ch[100];\n\t//std::cin.getline(ch,100);\n\tstd::stack<char> s;\n\
    \tint n=string.length();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(string[i]=='[')\n\
    \t\t{\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']')\n\t\t{\n\t\
    \t\tif(s.empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\t\
    \t}\n\t}\n\treturn s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp891i7frb: /tmp/tmp891i7frb.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n = string.length();\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++)\
    \ {\n\t\tif (string[i] == '[') {\n\t\t\tcnt++;\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tcnt--;\n\t\t}\n\t\tif (cnt < 0) {\n\t\t\treturn false;\n\t\t\
    }\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmprdzwoce6: /tmp/tmprdzwoce6.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n=string.length();\n\tif(n==0)\n\t\treturn false;\n\tstack<char>st;\n\
    \tbool flag=false;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(string[i]=='[')\n\t\t\t\
    st.push(string[i]);\n\t\telse\n\t\t{\n\t\t\tif(st.empty())\n\t\t\t\treturn false;\n\
    \t\t\telse\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t\
    }\n\tif(flag==true)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcvwyeii0.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpcvwyeii0.cpp:16:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   16 |  stack<char>st;\n     \
    \ |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpcvwyeii0.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpcvwyeii0.cpp:16:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |  stack<char>st;\n      |        ^~~~\n/tmp/tmpcvwyeii0.cpp:21:4:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   21 |    st.push(string[i]);\n      |    ^~\n      |    std\n/tmp/tmpcvwyeii0.cpp:24:7:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   24 |    if(st.empty())\n      |       ^~\n      |       std\n"
  stdout: ''
  timestamp: 1660121176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<char> stack;\n    for(int i = 0; i < string.size(); i++)\
    \ {\n        if(string[i] == '[') {\n            stack.push_back(string[i]);\n\
    \        } else {\n            if(stack.size() == 0) {\n                return\
    \ false;\n            } else {\n                stack.pop_back();\n          \
    \  }\n        }\n    }\n    return stack.size() != 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpejrehgku: /tmp/tmpejrehgku.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    //std::cout<<string<<std::endl;\n    std::vector<char> v;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            v.push_back(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(v.size()==0){\n \
    \               return false;\n            }\n            else{\n            \
    \    v.pop_back();\n            }\n        }\n    }\n    if(v.size()==0){\n  \
    \      return true;\n    }\n    else{\n        return false;\n    }\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp83gxw5sj: /tmp/tmp83gxw5sj.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> brackets;\n    for(auto i: string){\n        if(i ==\
    \ '['){\n            brackets.push(i);\n        }else if(i == ']'){\n        \
    \    if(brackets.empty()){\n                return false;\n            }else{\n\
    \                brackets.pop();\n            }\n        }\n    }\n    return\
    \ brackets.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpw19uz9c2: /tmp/tmpw19uz9c2.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='[')\n\
    \t\t\tst.push(string[i]);\n\t\telse if(string[i]==']'){\n\t\t\tif(st.size()==0)\n\
    \t\t\t\treturn false;\n\t\t\tst.pop();\n\t\t}\n\t}\n\tif(st.size()>0)\n\t\treturn\
    \ false;\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_vo1kw7m: /tmp/tmp_vo1kw7m.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstack<char> s;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\ts.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(s.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn s.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2fwddike.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp2fwddike.cpp:13:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |  stack<char> s;\n     \
    \ |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp2fwddike.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp2fwddike.cpp:13:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |  stack<char> s;\n      |        ^~~~\n/tmp/tmp2fwddike.cpp:16:4:\
    \ error: \u2018s\u2019 was not declared in this scope\n   16 |    s.push(string[i]);\n\
    \      |    ^\n/tmp/tmp2fwddike.cpp:19:7: error: \u2018s\u2019 was not declared\
    \ in this scope\n   19 |    if(s.empty()){\n      |       ^\n/tmp/tmp2fwddike.cpp:22:4:\
    \ error: \u2018s\u2019 was not declared in this scope\n   22 |    s.pop();\n \
    \     |    ^\n/tmp/tmp2fwddike.cpp:25:9: error: \u2018s\u2019 was not declared\
    \ in this scope\n   25 |  return s.empty();\n      |         ^\n"
  stdout: ''
  timestamp: 1660121176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint sum = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[')\n\t\t\tsum++;\n\t\telse if (string[i] == ']')\n\t\t\tsum--;\n\t\tif\
    \ (sum < 0)\n\t\t\treturn false;\n\t}\n\treturn sum == 0;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp526p6j5w: /tmp/tmp526p6j5w.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint start = -1;\n\tint end = -1;\n\tfor (size_t i = 0; i < string.size();\
    \ i++)\n\t{\n\t\tif (string[i] == '[')\n\t\t{\n\t\t\tstart = i;\n\t\t}\n\t\tif\
    \ (string[i] == ']')\n\t\t{\n\t\t\tend = i;\n\t\t}\n\t\tif (start != -1 && end\
    \ != -1)\n\t\t{\n\t\t\tstring.erase(string.begin() + start);\n\t\t\tstring.erase(string.begin()\
    \ + end-1);\n\t\t\tstart = -1;\n\t\t\tend = -1;\n\t\t\ti = 0;\n\t\t}\n\t}\n\t\
    if (string.size() != 0)\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpevucwyj0: /tmp/tmpevucwyj0.cpp:42: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// Create a stack to hold characters\n\tstd::stack<char> brackets;\n\t\
    int countOpen = 0;\n\tint countClose = 0;\n\tfor (char const& c : string) {\n\t\
    \t// if the stack is empty, push the current character to the stack\n\t\tif (brackets.empty())\
    \ {\n\t\t\tbrackets.push(c);\n\t\t\t// if the stack is not empty, and the current\
    \ character is the same as the top of the stack\n\t\t\t// pop the top off of the\
    \ stack\n\t\t} else if (c == brackets.top()) {\n\t\t\tbrackets.pop();\n\t\t\t\
    // otherwise push the current character to the stack\n\t\t} else {\n\t\t\tbrackets.push(c);\n\
    \t\t}\n\t}\n\t// if the stack is empty, the string is nested\n\tif (brackets.empty())\
    \ {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpszm2yrd2: /tmp/tmpszm2yrd2.cpp:44: int main(): Assertion `candidate(("[][][[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint check = 0;\n\tfor (char c : string) {\n\t\tif (c == '[') {\n\t\t\t\
    check++;\n\t\t}\n\t\telse if (c == ']') {\n\t\t\tcheck--;\n\t\t}\n\t\tif (check\
    \ < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn check == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpmerfzl2h: /tmp/tmpmerfzl2h.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   std::stack<char> s;\n    for(auto ch:string){\n        if(ch=='[')\n \
    \       s.push(ch);\n        else if(ch==']'){\n            if(s.empty()) return\
    \ false;\n            else\n            s.pop();\n        }\n    }\n    return\
    \ s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5fhqhe82: /tmp/tmp5fhqhe82.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121178
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int x=0;\n  for(int i=0;i<string.length();i++){\n    if(string[i]=='['){\n\
    \      x+=1;\n    }\n    else if(string[i]==']'){\n      x-=1;\n    }\n    if(x<0){\n\
    \      return false;\n    }\n  }\n  if(x==0){\n    return true;\n  }\n  else{\n\
    \    return false;\n  }\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmps3kpit5_: /tmp/tmps3kpit5_.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tchar ch=string[0];\n\tchar ch1=string[string.length()-1];\n\tif(ch=='['&&ch1==']'){\n\
    \t\tif(string.length()==2){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn\
    \ true;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppzz9ve8_: /tmp/tmppzz9ve8_.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tint i = 0;\n\tfor (i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if\
    \ (string[i] == ']') {\n\t\t\tif (s.empty())\n\t\t\t\treturn false;\n\t\t\telse\n\
    \t\t\t\ts.pop();\n\t\t}\n\t}\n\tif (s.empty())\n\t\treturn true;\n\telse\n\t\t\
    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp73z5pllv: /tmp/tmp73z5pllv.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tfor (size_t i = 0; i < string.size(); i++)\n\t{\n\t\tstring[i] = ' ';\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpw3vd0z22: /tmp/tmpw3vd0z22.cpp:22: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n = string.length();\n\tint closeCount = 0;\n\tfor (int i = 0; i <\
    \ n; i++) {\n\t\tif (string[i] == ']')\n\t\t\tcloseCount++;\n\t\telse\n\t\t\t\
    closeCount--;\n\t\tif (closeCount < 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpj640tq0s: /tmp/tmpj640tq0s.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> st;\n    for(auto i:string){\n        if(i=='[') st.push(i);\n\
    \        else if(i==']'){\n            if(st.empty()) return false;\n        \
    \    else st.pop();\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpi6unb6up: /tmp/tmpi6unb6up.cpp:27: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121178
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> s;\n  for(int i=0;i<string.length();i++){\n    if(string[i]=='['){\n\
    \      s.push(string[i]);\n    }\n    else if(string[i]==']'){\n      if(s.empty()){\n\
    \        return false;\n      }\n      else{\n        s.pop();\n      }\n    }\n\
    \  }\n  if(s.empty()){\n    return true;\n  }\n  else{\n    return false;\n  }\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpjgphg4_5: /tmp/tmpjgphg4_5.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> st;\n    for(int i=0;i<string.length();i++){\n     \
    \   if(string[i]=='['){\n            st.push(string[i]);\n        }\n        else\
    \ if(string[i]==']'){\n            if(st.empty()){\n                return false;\n\
    \            }\n            st.pop();\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpk5r0rpwv: /tmp/tmpk5r0rpwv.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stk;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\
    \tif (string[i] == '[') {\n\t\t\tstk.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (stk.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stk.empty()) {\n\t\treturn\
    \ true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy8hoyrzr: /tmp/tmpy8hoyrzr.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tbool check = true;\n\tint count_open = 0;\n\tint count_close = 0;\n\tint\
    \ len = string.length();\n\tfor (int i = 0; i < len; i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount_open++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\
    \tcount_close++;\n\t\t}\n\t}\n\tif (count_open == 0 || count_close == 0) {\n\t\
    \tcheck = false;\n\t}\n\telse if (count_open == count_close) {\n\t\tcheck = false;\n\
    \t}\n\telse {\n\t\tcheck = true;\n\t}\n\treturn check;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6na7uawu: /tmp/tmp6na7uawu.cpp:38: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> S;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\tS.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (S.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tS.pop();\n\
    \t\t}\n\t}\n\treturn S.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpbwrbccyf: /tmp/tmpbwrbccyf.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int flag = 0;\n    std::stack<char>s;\n    for(int i = 0; i < string.length();\
    \ i++){\n        if(string[i] == '[')\n            s.push(string[i]);\n      \
    \  else if(string[i] == ']'){\n            if(s.empty())\n                return\
    \ false;\n            else{\n                flag = 1;\n                s.pop();\n\
    \            }\n        }\n    }\n    if(flag == 1)\n        return true;\n  \
    \  else\n        return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy076mq0k: /tmp/tmpy076mq0k.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(auto i:string){\n\t\tif(st.empty()){\n\t\t\t\
    st.push(i);\n\t\t}else{\n\t\t\tif(st.top()=='[' && i==']'){\n\t\t\t\tst.pop();\n\
    \t\t\t}else{\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn st.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp7barv6as: /tmp/tmp7barv6as.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121178
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> b;\n  for(auto& c : string) {\n    if(c == '[') b.push(c);\n\
    \    else {\n      if(b.empty()) return false;\n      else b.pop();\n    }\n \
    \ }\n  return b.empty();\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpbsrp7cp0: /tmp/tmpbsrp7cp0.cpp:27: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint str_len = string.length();\n\tstd::stack<char> s;\n\tfor (int i = 0;\
    \ i < str_len; i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpqid4gt6s: /tmp/tmpqid4gt6s.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char>brackets;\n\tfor(auto ch:string){\n\t\tif(ch=='['){\n\t\
    \t\tbrackets.push(ch);\n\t\t}\n\t\telse if(ch==']'){\n\t\t\tif(brackets.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tbrackets.pop();\n\t\t}\n\t}\n\treturn brackets.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpvv7amkpj: /tmp/tmpvv7amkpj.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121178
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n = string.length();\n\tif(n == 0)\n\t\treturn false;\n\tint i = 0;\n\
    \tint j = n-1;\n\twhile(string[i] == ']' && i < n)\n\t\ti++;\n\twhile(string[j]\
    \ == '[' && j >= 0)\n\t\tj--;\n\tif(i > j)\n\t\treturn false;\n\tint left = i;\n\
    \tint right = j;\n\twhile(left <= right) {\n\t\tif(string[left] == ']' && string[right]\
    \ == '[') {\n\t\t\treturn true;\n\t\t}\n\t\tleft++;\n\t\tright--;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpn1oxqx_p: /tmp/tmpn1oxqx_p.cpp:37: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stk;\n\tfor (char c : string) {\n\t\tif (c == '[') {\n\
    \t\t\tstk.push(c);\n\t\t}\n\t\telse if (c == ']') {\n\t\t\tif (stk.empty()) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tstk.pop();\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpjwz200g5: /tmp/tmpjwz200g5.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121179
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Assume valid input, no empty string and no non-square bracket chars\n\
    \    std::vector<char> stack;\n    int size = string.size();\n    for (int i =\
    \ 0; i < size; i++) {\n        if (string[i] == '[') {\n            stack.push_back(string[i]);\n\
    \        } else {\n            if (stack.size() == 0) {\n                return\
    \ false;\n            } else {\n                stack.pop_back();\n          \
    \  }\n        }\n    }\n    return stack.size() > 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm0yn2ahm: /tmp/tmpm0yn2ahm.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// return match(string);\n\treturn (bool)std::regex_match(string, std::regex(\"\
    (\\\\[\\\\])+\"));\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmprk7srmsl: /tmp/tmprk7srmsl.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn true;\n\
    \t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5y1qqxuy: /tmp/tmp5y1qqxuy.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint len = string.length();\n\tint open = 0;\n\tint close = 0;\n\tfor (int\
    \ i = 0; i < len; i++) {\n\t\tif (string[i] == '[')\n\t\t\topen++;\n\t\telse if\
    \ (string[i] == ']')\n\t\t\tclose++;\n\t\tif (close > open)\n\t\t\treturn false;\n\
    \t}\n\tif (open == close)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpeibfqb5y: /tmp/tmpeibfqb5y.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int left_count = 0;\n  int right_count = 0;\n  for (int i = 0; i < string.length();\
    \ i++) {\n    if (string[i] == '[') {\n      left_count++;\n    }\n    if (string[i]\
    \ == ']') {\n      right_count++;\n    }\n    if (right_count > left_count) {\n\
    \      return false;\n    }\n  }\n  if (left_count != right_count) {\n    return\
    \ false;\n  }\n  return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpe9clmz_s: /tmp/tmpe9clmz_s.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   int bracket_count = 0;\n   for (int i = 0; i < string.length(); i++) {\n\
    \      if (string[i] == '[') {\n         bracket_count++;\n      } else if (string[i]\
    \ == ']') {\n         bracket_count--;\n      }\n      if (bracket_count < 0)\
    \ return false;\n   }\n   return bracket_count == 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp53otfywj: /tmp/tmp53otfywj.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp20hpdm7d: /tmp/tmp20hpdm7d.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(auto& c : string) {\n\t\tif(c == '[')\n\t\t\
    \tst.push(c);\n\t\telse if(c == ']') {\n\t\t\tif(st.empty())\n\t\t\t\treturn false;\n\
    \t\t\telse if(st.top() == '[')\n\t\t\t\tst.pop();\n\t\t\telse\n\t\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl29fuorx: /tmp/tmpl29fuorx.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint valid = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tvalid++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tvalid--;\n\
    \t\t}\n\t\tif (valid < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn valid !=\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxnyl713g: /tmp/tmpxnyl713g.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // create a vector of chars\n    std::vector<char> brackets;\n    //\
    \ loop through the string\n    for (char c : string) {\n        // if c is an\
    \ opening bracket\n        if (c == '[') {\n            // push it onto the vector\n\
    \            brackets.push_back(c);\n        } else {\n            // otherwise,\
    \ pop the most recent opening bracket\n            brackets.pop_back();\n    \
    \    }\n    }\n    // if the vector is empty, then there was a valid nesting\n\
    \    return brackets.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'double free or corruption (out)

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmplrqe4fk7: /tmp/tmplrqe4fk7.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(auto &c : string) {\n\t\tif(c == '[') {\n\t\
    \t\tst.push(c);\n\t\t}\n\t\telse if(!st.empty()){\n\t\t\tst.pop();\n\t\t}\n\t\t\
    else{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn st.empty();\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpx4lmntor: /tmp/tmpx4lmntor.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> brackets;\n  for (char bracket : string) {\n    if (bracket\
    \ == '[') {\n      brackets.push(bracket);\n    } else if (bracket == ']') {\n\
    \      if (brackets.empty()) {\n        return false;\n      }\n      brackets.pop();\n\
    \    }\n  }\n  return brackets.empty();\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4tyn3h2i: /tmp/tmp4tyn3h2i.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stk;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\
    \tif (string[i] == '[')\n\t\t\tstk.push(string[i]);\n\t\telse if (string[i] ==\
    \ ']') {\n\t\t\tif (stk.empty())\n\t\t\t\treturn false;\n\t\t\tstk.pop();\n\t\t\
    }\n\t}\n\treturn stk.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpelxkc4m0: /tmp/tmpelxkc4m0.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(int i = 0; i < string.length(); i++) {\n    if(string[i]\
    \ == '[') count++;\n    else if(string[i] == ']') count--;\n    if(count < 0)\
    \ return false;\n  }\n  return count > 0 ? false : true;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpsi5j6pui: /tmp/tmpsi5j6pui.cpp:25: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    std::stack<char> s;\n    for(int i = 0;\
    \ i < n; i++) {\n        if(string[i] == '[') {\n            s.push(string[i]);\n\
    \        }\n        else if(string[i] == ']') {\n            if(s.empty()) {\n\
    \                return false;\n            }\n            else {\n          \
    \      s.pop();\n            }\n        }\n    }\n    if(s.empty())\n        return\
    \ true;\n    else \n        return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpd0n_n9c9: /tmp/tmpd0n_n9c9.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint i=0;\n\tstd::stack<char> s;\n\twhile(i < string.length())\n\t{\n\t\t\
    if(string[i] == '[')\n\t\t{\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if(!s.empty()\
    \ && string[i] == ']')\n\t\t{\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.empty() &&\
    \ string[i] == ']')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\tif(s.empty())\n\
    \t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmprzck56z9: /tmp/tmprzck56z9.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tif(string.size() == 0) return false;\n\tif(string.at(0)\
    \ == ']') return false;\n\tfor(int i = 0; i < string.size(); i++){\n\t\tif(string.at(i)\
    \ == '['){\n\t\t\tst.push(string.at(i));\n\t\t}\n\t\telse if(string.at(i) == ']'){\n\
    \t\t\tif(st.empty())\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\tst.pop();\n\t\
    \t}\n\t}\n\tif(st.empty())\n\t\treturn true;\n\telse \n\t\treturn false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpl0y975da: /tmp/tmpl0y975da.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count <= 0 && i < string.length()-1){\n\
    \            return false;\n        }\n    }\n    return count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp39q1lke6: /tmp/tmp39q1lke6.cpp:32: int main(): Assertion `candidate(("[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint c = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tc++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tc--;\n\
    \t\t}\n\t\tif (c == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp40k79g0d: /tmp/tmp40k79g0d.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int flag = 0;\n    for(int i = 0; i < string.length(); i++) {\n     \
    \   if(string[i] == '[') {\n            flag = 1;\n        }\n        if(string[i]\
    \ == ']') {\n            if(flag == 1) {\n                return true;\n     \
    \       }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpwnl19_7a: /tmp/tmpwnl19_7a.cpp:29: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int a = 0;\n  for(int i = 0; i < string.length(); i++){\n    if(string[i]\
    \ == '['){\n      a++;\n    }\n    else if(string[i] == ']'){\n      a--;\n  \
    \  }\n    if(a == 0){\n      return true;\n    }\n  }\n  return false;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4d94qf1: /tmp/tmpa4d94qf1.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint openBracket = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\
    \tif (string[i] == '[') {\n\t\t\topenBracket++;\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\topenBracket--;\n\t\t}\n\t\tif (openBracket < 0) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpa1tnx7py: /tmp/tmpa1tnx7py.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count_closing = 0;\n\tint count_opening = 0;\n\tbool result = false;\n\
    \tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\
    \t\tcount_opening++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount_closing++;\n\
    \t\t}\n\t}\n\tif (count_closing > count_opening) {\n\t\treturn result;\n\t}\n\t\
    else {\n\t\treturn true;\n\t}\n\t\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpolf2rcfm: /tmp/tmpolf2rcfm.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(char c : string) {\n        if(c == '[') {\n\
    \            count++;\n        } else if(c == ']') {\n            count--;\n \
    \       }\n        if(count < 0) return false;\n    }\n    return count == 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp259cboi9: /tmp/tmp259cboi9.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag=false;\n    std::stack<char> s;\n    // loop through the elements\
    \ of the string and push if it is '[' otherwise pop.\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            s.push(string[i]);\n        }else{\n\
    \            if(s.empty()==false){\n                s.pop();\n               \
    \ flag=true;\n            }\n        }\n    }\n    if(s.empty() && flag){\n  \
    \      return true;\n    }else{\n        return false;\n    }\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpr7hc72ib: /tmp/tmpr7hc72ib.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int k=0;\n  for(int i=0;i<string.length();i++){\n    if(string[i]=='['){\n\
    \      k++;\n    }\n    else{\n      k--;\n    }\n    if(k<0){\n      return false;\n\
    \    }\n  }\n  if(k==0){\n    return true;\n  }\n  else{\n    return false;\n\
    \  }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0wsf30lw: /tmp/tmp0wsf30lw.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<char> arr;\n    for(auto c: string){\n        if(c == '[')\
    \ arr.push_back(c);\n        else if(c == ']'){\n            if(arr.size() > 0\
    \ && arr.back() == '[')\n                arr.pop_back();\n            else\n \
    \               return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9rsmc5rd: /tmp/tmp9rsmc5rd.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i,sum=0;\n    if(string.length()==0)\n        return 0;\n    if(string.length()%2!=0)\n\
    \        return 0;\n    for(i=0;i<string.length();i++)\n    {\n        if(string[i]=='[')\n\
    \            sum++;\n        else if(string[i]==']')\n            sum--;\n   \
    \     if(sum<0)\n            return 0;\n    }\n    if(sum==0)\n        return\
    \ 1;\n    else \n        return 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5owy8t16: /tmp/tmp5owy8t16.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif (string.size() % 2 != 0) return false;\n\tstd::stack<char> stk;\n\t\
    for (char c : string) {\n\t\tif (c == '[') {\n\t\t\tstk.push(c);\n\t\t}\n\t\t\
    else {\n\t\t\tif (stk.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\
    \t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp8m_4k_c5: /tmp/tmp8m_4k_c5.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(auto ch : string) {\n        if(ch == '[')\n\
    \            count++;\n        else\n            count--;\n        if(count <\
    \ 0)\n            return false;\n    }\n    return count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpb09hun8_: /tmp/tmpb09hun8_.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  bool is_nested = false;\n  int count_open = 0;\n  int count_close = 0;\n\
    \  for (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n\
    \      count_open++;\n    }\n    if (string[i] == ']') {\n      count_close++;\n\
    \    }\n    if (count_open < count_close) {\n      return false;\n    }\n  }\n\
    \  if (count_open == count_close) {\n    is_nested = true;\n  }\n  return is_nested;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpjsmmu6ag: /tmp/tmpjsmmu6ag.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121179
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // if(string.size()==0)\n    //     return false;\n    // int i=0;\n\
    \    // stack<char> s;\n    // for(i=0;i<string.size();i++){\n    //     if(string[i]=='[')\n\
    \    //         s.push(string[i]);\n    //     else{\n    //         if(s.empty())\n\
    \    //             return false;\n    //         s.pop();\n    //     }\n   \
    \ // }\n    // if(!s.empty())\n    //     return false;\n    // return true;\n\
    \    int brackets = 0;\n    for (int i = 0; i < string.size(); i++) {\n      \
    \  if (string[i] == '[')\n            brackets++;\n        else {\n          \
    \  if (brackets == 0)\n                return false;\n            brackets--;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdqvr1xcj: /tmp/tmpdqvr1xcj.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tassert(string.size() > 0);\n\tstd::string valid = \"[]\";\n\tstd::string\
    \ newString = \"\";\n\tfor (int i = 0; i < string.size(); i++) {\n\t\tif (string[i]\
    \ == valid[0] || string[i] == valid[1]) {\n\t\t\tnewString += string[i];\n\t\t\
    }\n\t}\n\tstd::stack<char> st;\n\tfor (char c : newString) {\n\t\tif (c == '[')\
    \ {\n\t\t\tst.push(c);\n\t\t}\n\t\telse {\n\t\t\tif (st.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\treturn (st.empty());\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa78tdeq6: /tmp/tmpa78tdeq6.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    int i = 0;\n    bool flag = false;\n    while(i\
    \ < string.length()){\n        if(string[i] == '[')\n            stk.push(string[i]);\n\
    \        else if(string[i] == ']'){\n            if(stk.empty())\n           \
    \     return false;\n            else{\n                if(stk.top() == '['){\n\
    \                    flag = true;\n                    stk.pop();\n          \
    \      }\n                else\n                    return false;\n          \
    \  }\n        }\n        i++;\n    }\n    if(stk.empty() && flag)\n        return\
    \ true;\n    else\n        return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpw_u86zz0: /tmp/tmpw_u86zz0.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> s;\n  for(int i=0;i<string.length();i++){\n    if(string[i]=='['){\n\
    \      s.push(string[i]);\n    }\n    else if(!s.empty()){\n      s.pop();\n \
    \   }\n    else if(s.empty()){\n      return false;\n    }\n  }\n  return true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp7uywgr4p: /tmp/tmp7uywgr4p.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // int count = 0;\n    // for(int i = 0; i < string.length(); i++){\n\
    \    //     if(string[i] == '['){\n    //         count++;\n    //     }\n   \
    \ //     else if(string[i] == ']'){\n    //         count--;\n    //     }\n \
    \   //     if(count < 0){\n    //         return false;\n    //     }\n    //\
    \ }\n    // return count == 0;\n    std::stack<char> s;\n    for(int i = 0; i\
    \ < string.length(); i++){\n        if(string[i] == '['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i] == ']'){\n            if(s.empty()){\n \
    \               return false;\n            }\n            s.pop();\n        }\n\
    \    }\n    return s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpga6qwss2: /tmp/tmpga6qwss2.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int sz = string.size();\n  int i = 0;\n  int count = 0;\n  while(i < sz)\
    \ {\n    if(string[i] == '[')\n      count++;\n    else\n      count--;\n    if(count\
    \ < 0)\n      return false;\n    i++;\n  }\n  return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpjdz_9ueg: /tmp/tmpjdz_9ueg.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpljha98yj: /tmp/tmpljha98yj.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tassert(string.length()>0);\n\tstd::stack<char> stack;\n\tfor(int i=0;i<string.length();i++){\n\
    \t\tif(string[i]=='[')\n\t\t\tstack.push(string[i]);\n\t\telse if(string[i]==']'){\n\
    \t\t\tif(stack.empty())\n\t\t\t\treturn false;\n\t\t\tstack.pop();\n\t\t}\n\t\
    }\n\treturn stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdmr6f4zt: /tmp/tmpdmr6f4zt.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint open = 0;\n\tint closed = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\topen++;\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tclosed++;\n\t\t}\n\t}\n\treturn closed > open ? false : true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp6z86_gxb: /tmp/tmp6z86_gxb.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char>st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if(st.top()=='['){\n\t\t\t\tst.pop();\n\
    \t\t\t}\n\t\t}\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn\
    \ false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpi0hanz1w: /tmp/tmpi0hanz1w.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy54hikxd: /tmp/tmpy54hikxd.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.size()>0){\n\
    \t\t\t\tst.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.size()==0){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl25r8h1g: /tmp/tmpl25r8h1g.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n = string.length();\n\tint i, index, count;\n\tcount = 0;\n\tfor (i\
    \ = 0; i < n; i++) {\n\t\tif (string[i] == '[') {\n\t\t\tcount++;\n\t\t}\n\t\t\
    else if (string[i] == ']') {\n\t\t\tcount--;\n\t\t}\n\t\tif (count == 0) {\n\t\
    \t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxt75yf8h: /tmp/tmpxt75yf8h.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string == \"[]\")\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpge5fc7yt: /tmp/tmpge5fc7yt.cpp:21: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string.size() == 0) {\n\t\treturn false;\n\t}\n\tint left = 0;\n\tint\
    \ right = 0;\n\tfor(int i = 0; i < string.size(); i++) {\n\t\tif(string[i] ==\
    \ '[') {\n\t\t\tleft++;\n\t\t}\n\t\tif(string[i] == ']') {\n\t\t\tright++;\n\t\
    \t}\n\t}\n\tif(left == right) {\n\t\treturn false;\n\t}\n\tif(left == 1 || right\
    \ == 1) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4ztqsdzy: /tmp/tmp4ztqsdzy.cpp:36: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> brackets;\n    for(const auto element : string) {\n\
    \        if(element == '[') {\n            brackets.push(element);\n        }\
    \ else if(!brackets.empty()) {\n            brackets.pop();\n        } else {\n\
    \            return false;\n        }\n    }\n    return !brackets.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmprilj5nyi: /tmp/tmprilj5nyi.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(int i = 0; i < string.length(); i++) {\n    if(string[i]\
    \ == '[') {\n      count++;\n    }\n    else if(string[i] == ']') {\n      count--;\n\
    \    }\n    if(count < 0) {\n      return false;\n    }\n  }\n  return count ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpep8fbd2_: /tmp/tmpep8fbd2_.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char>s;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\ts.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(s.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\tif(s.empty()){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmprr7a2kt8: /tmp/tmprr7a2kt8.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpc2s4svmf: /tmp/tmpc2s4svmf.cpp:17: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string.size() == 0) {\n\t\treturn false;\n\t}\n\tstd::stack<char> s;\n\
    \tfor(int i = 0; i < string.size(); i++) {\n\t\tif(string[i] == '[') {\n\t\t\t\
    s.push(string[i]);\n\t\t}\n\t\telse if(!s.empty() && string[i] == ']') {\n\t\t\
    \ts.pop();\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn s.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9c91l4n4: /tmp/tmp9c91l4n4.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> brackets;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string[i] == '[') {\n\t\t\tbrackets.push(string[i]);\n\t\t}\n\t\t\
    else if (string[i] == ']') {\n\t\t\tif (brackets.empty()) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\tbrackets.pop();\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpoi2tqwz1: /tmp/tmpoi2tqwz1.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> sequence;\n\tfor (auto character : string) {\n\t\tif (character\
    \ == '[') {\n\t\t\tsequence.push(character);\n\t\t}\n\t\telse if (character ==\
    \ ']') {\n\t\t\tif (sequence.empty()) return false;\n\t\t\telse sequence.pop();\n\
    \t\t}\n\t}\n\treturn !sequence.empty();\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpc2d9ojrg: /tmp/tmpc2d9ojrg.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t\tstd::stack<char> st;\n\t\tfor(char ch : string) {\n\t\t\tif(ch == '[')\
    \ {\n\t\t\t\tst.push(ch);\n\t\t\t}\n\t\t\telse if(ch == ']') {\n\t\t\t\tif(st.empty())\
    \ {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tst.pop();\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppgoitthh: /tmp/tmppgoitthh.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int l=0, r=0;\n  for(char c: string){\n    if(c=='[')\n      l++;\n   \
    \ else\n      r++;\n    if(r>l)\n      return false;\n  }\n  return l==r;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpaxj4sjdk: /tmp/tmpaxj4sjdk.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(auto elem : string) {\n\t\tif(elem == '[')\
    \ {\n\t\t\tst.push(elem);\n\t\t} else {\n\t\t\tif(st.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpntxfmpsg: /tmp/tmpntxfmpsg.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::string *s = new std::string;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts->push_back('[');\n\t\t}\n\t\telse\
    \ if (string[i] == ']') {\n\t\t\tif (s->empty())\n\t\t\t\treturn false;\n\t\t\t\
    else if (s->back() == '[')\n\t\t\t\ts->pop_back();\n\t\t\telse\n\t\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpk7o4i6x5: /tmp/tmpk7o4i6x5.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<char> my_stack;\n    for(int i = 0; i < string.size(); i++){\n\
    \        if(string[i] == '['){\n            my_stack.push_back(string[i]);\n \
    \       }\n        else if(string[i] == ']'){\n            if(my_stack.size()\
    \ != 0){\n                my_stack.pop_back();\n            }\n            else{\n\
    \                return false;\n            }\n        }\n    }\n    if(my_stack.size()\
    \ != 0){\n        return false;\n    }\n    return true;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp3w92yp38: /tmp/tmp3w92yp38.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int bracket_count = 0;\n    for (int i = 0; i < string.length(); i++)\
    \ {\n        if (string[i] == '[') {\n            bracket_count++;\n        }\
    \ else if (string[i] == ']') {\n            bracket_count--;\n        }\n    \
    \    if (bracket_count < 0) {\n            return false;\n        }\n    }\n \
    \   return bracket_count > 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpwz_m3ir9: /tmp/tmpwz_m3ir9.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count++;\n        }\n        else if(string[i]\
    \ == ']'){\n            count--;\n        }\n        if(count < 0){\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp0dh4iuda: /tmp/tmp0dh4iuda.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count >\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpp63b0pul: /tmp/tmpp63b0pul.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()){\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\
    }\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpljha98yj: /tmp/tmpljha98yj.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tbool is_valid=false;\n\tint count=0;\n\tfor(int i=0;i<string.length();i++){\n\
    \t\tif(string[i]=='['){\n\t\t\tcount++;\n\t\t}\n\t\telse{\n\t\t\tcount--;\n\t\t\
    }\n\t\tif(count==0){\n\t\t\tis_valid=true;\n\t\t}\n\t}\n\treturn is_valid;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp7t0iuv2z: /tmp/tmp7t0iuv2z.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int len = string.length();\n  for(int i = 0; i < len; i++) {\n    if(string[i]\
    \ == '[' && string[i+1] == ']') {\n      return true;\n    }\n  }\n  return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpqi8ihmrb: /tmp/tmpqi8ihmrb.cpp:24: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[')\n\t\t\tcount++;\n\t\telse if (string[i] == ']')\n\t\t\tcount--;\n\t\t\
    if (count < 0)\n\t\t\treturn false;\n\t}\n\treturn count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmps7o2sebs: /tmp/tmps7o2sebs.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\telse if (!s.empty()\
    \ && string[i] == ']') {\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpvt9q0jzc: /tmp/tmpvt9q0jzc.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (char c : string) {\n\t\tif (c == '[') {\n\t\t\t\
    count++;\n\t\t}\n\t\telse if (c == ']') {\n\t\t\tcount--;\n\t\t}\n\t\tif (count\
    \ < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpneytqjzg: /tmp/tmpneytqjzg.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tchar temp;\n\tstd::stack<char> s;\n\tfor (auto ch : string) {\n\t\tif (ch\
    \ == '[')\n\t\t\ts.push(ch);\n\t\telse {\n\t\t\tif (s.empty())\n\t\t\t\treturn\
    \ false;\n\t\t\ttemp = s.top();\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn (s.empty());\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp4aqd3y6j: /tmp/tmp4aqd3y6j.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for(char c : string) {\n        if(c ==\
    \ '[') {\n            stack.push(c);\n        } else {\n            if(stack.empty())\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return !stack.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr47t1ccu: /tmp/tmpr47t1ccu.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\
    \t\t\tst.push(string[i]);\n\t\t}\n\t\telse if(!st.empty() && string[i]==']'){\n\
    \t\t\tst.pop();\n\t\t}\n\t\telse if(st.empty() && string[i]==']'){\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\tif(st.empty()){\n\t\treturn true;\n\t}\n\treturn false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwm6mw491: /tmp/tmpwm6mw491.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> S;\n    for(char ch : string) {\n        if(ch == '[')\
    \ S.push(ch);\n        else if(!S.empty()) S.pop();\n        else return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmplmbev2m9: /tmp/tmplmbev2m9.cpp:25: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(char ch : string) {\n    if(ch == '[') {\n      count++;\n\
    \    }\n    else if(ch == ']') {\n      count--;\n    }\n    if(count == -1) {\n\
    \      return false;\n    }\n  }\n  return count == 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpkgkoa760: /tmp/tmpkgkoa760.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121182
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstack<char> s;\n\tchar x;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string[i] == '[' || string[i] == '{' || string[i] == '(') {\n\t\t\
    \ts.push(string[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (s.empty()) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tswitch (string[i]) {\n\t\tcase ']':\n\t\t\tx = s.top();\n\
    \t\t\ts.pop();\n\t\t\tif (x == '{' || x == '(') {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tx = s.top();\n\t\t\ts.pop();\n\t\t\tif\
    \ (x == '[' || x == '(') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t\
    case ')':\n\t\t\tx = s.top();\n\t\t\ts.pop();\n\t\t\tif (x == '{' || x == '[')\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp39be1sx3.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp39be1sx3.cpp:13:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |  stack<char> s;\n     \
    \ |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp39be1sx3.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp39be1sx3.cpp:13:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |  stack<char> s;\n      |        ^~~~\n/tmp/tmp39be1sx3.cpp:17:4:\
    \ error: \u2018s\u2019 was not declared in this scope\n   17 |    s.push(string[i]);\n\
    \      |    ^\n/tmp/tmp39be1sx3.cpp:20:7: error: \u2018s\u2019 was not declared\
    \ in this scope\n   20 |   if (s.empty()) {\n      |       ^\n/tmp/tmp39be1sx3.cpp:25:8:\
    \ error: \u2018s\u2019 was not declared in this scope\n   25 |    x = s.top();\n\
    \      |        ^\n/tmp/tmp39be1sx3.cpp:47:9: error: \u2018s\u2019 was not declared\
    \ in this scope\n   47 |  return s.empty();\n      |         ^\n"
  stdout: ''
  timestamp: 1660121182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> bracket;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string[i] == '[')\n\t\t\tbracket.push(string[i]);\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (bracket.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\tbracket.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (bracket.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpxxyfa_il: /tmp/tmpxxyfa_il.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stck;\n    for(char c : string){\n        if(c == '[')\
    \ stck.push(c);\n        else if(c == ']'){\n            if(stck.empty()) return\
    \ false;\n            else stck.pop();\n        }\n    }\n    return stck.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmphv9vd1jw: /tmp/tmphv9vd1jw.cpp:27: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> stack;\n  std::size_t count = 0;\n  for (std::size_t i\
    \ = 0; i < string.size(); i++) {\n    if (string[i] == '[') {\n      stack.push(string[i]);\n\
    \    } else if (string[i] == ']') {\n      if (stack.empty()) {\n        return\
    \ false;\n      } else {\n        stack.pop();\n        count++;\n      }\n  \
    \  }\n  }\n  return !stack.empty() && count > 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdlm5kugr: /tmp/tmpdlm5kugr.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  \tint flag=0;\n\tfor(int i=0;i<string.length();i++)\n\t{\n\t\tif(string[i]=='[')\n\
    \t\t{\n\t\t\tflag++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag--;\n\t\t}\n\t\tif(flag<=0)\n\
    \t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp25cf2aap: /tmp/tmp25cf2aap.cpp:34: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int depth = 0;\n    for (int i = 0; i < string.length(); i++) {\n   \
    \     if (string[i] == '[') {\n            depth++;\n        } else if (string[i]\
    \ == ']') {\n            depth--;\n        }\n        if (depth < 0) {\n     \
    \       return false;\n        }\n    }\n    return depth != 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp3do3cr3e: /tmp/tmp3do3cr3e.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  stack<char> st;\n  int n = string.length();\n  for(int i=0;i<n;i++){\n\
    \    if(string[i]=='['){\n      st.push(string[i]);\n    }\n    else if(string[i]==']'){\n\
    \      if(st.empty()){\n        return false;\n      }\n      else if(st.top()=='['){\n\
    \        st.pop();\n      }\n    }\n  }\n  if(st.empty()){\n    return true;\n\
    \  }\n  else{\n    return false;\n  }\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpph_9ixdm.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpph_9ixdm.cpp:13:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |   stack<char> st;\n   \
    \   |   ^~~~~\n      |   std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpph_9ixdm.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpph_9ixdm.cpp:13:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |   stack<char> st;\n      |         ^~~~\n/tmp/tmpph_9ixdm.cpp:17:7:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   17 |       st.push(string[i]);\n      |       ^~\n      |       std\n/tmp/tmpph_9ixdm.cpp:20:10:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   20 |       if(st.empty()){\n      |          ^~\n      |          std\n\
    /tmp/tmpph_9ixdm.cpp:28:6: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018std\u2019?\n   28 |   if(st.empty()){\n      |      ^~\n\
    \      |      std\n/tmp/tmpph_9ixdm.cpp:34:1: warning: control reaches end of\
    \ non-void function [-Wreturn-type]\n   34 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660121183
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tbool flag = false;\n\tstack<char> st;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\tst.push(string[i]);\n\t\t}\n\t\t\
    else if (string[i] == ']') {\n\t\t\tif (st.empty()) {\n\t\t\t\tflag = false;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.pop();\n\t\t\t\tflag = true;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp5vbnq2u2.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp5vbnq2u2.cpp:14:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   14 |  stack<char> st;\n    \
    \  |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp5vbnq2u2.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp5vbnq2u2.cpp:14:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   14 |  stack<char> st;\n      |        ^~~~\n/tmp/tmp5vbnq2u2.cpp:17:4:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   17 |    st.push(string[i]);\n      |    ^~\n      |    std\n/tmp/tmp5vbnq2u2.cpp:20:8:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   20 |    if (st.empty()) {\n      |        ^~\n      |        std\n"
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (size_t i = 0; i < string.size(); i++)\n\t{\n\t\t\
    if (string[i] == '[')\n\t\t\tcount++;\n\t\telse\n\t\t\tcount--;\n\t\tif (count\
    \ < 0)\n\t\t\treturn false;\n\t}\n\treturn count == 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsy3j3wb5: /tmp/tmpsy3j3wb5.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> brackets;\n  for (char bracket : string) {\n    if (bracket\
    \ == '[') {\n      brackets.push(bracket);\n    } else if (bracket == ']') {\n\
    \      if (brackets.empty()) {\n        return false;\n      }\n      brackets.pop();\n\
    \    }\n  }\n  return brackets.empty();\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp4tyn3h2i: /tmp/tmp4tyn3h2i.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// create a stack\n\tstd::stack<char> s;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\t// Add bracket if it is an opening bracket\n\t\tif (string[i] ==\
    \ '[') {\n\t\t\ts.push(string[i]);\n\t\t}\n\t\t// If closing bracket is seen,\
    \ pop from stack if stack is non-empty\n\t\telse if (string[i] == ']') {\n\t\t\
    \tif (s.empty())\n\t\t\t\treturn false;\n\t\t\ts.pop();\n\t\t}\n\t}\n\t// if stack\
    \ is empty, then return true\n\treturn s.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3lkq6mab: /tmp/tmp3lkq6mab.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int cnt = 0;\n    for(auto i : string){\n        if(i == '[') cnt++;\n\
    \        else if(i == ']') cnt--;\n        if(cnt < 0) return false;\n    }\n\
    \    return cnt == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpfv2bj2g7: /tmp/tmpfv2bj2g7.cpp:25: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint check=0;\n\tfor(int i=0;i<string.length();i++)\n\t{\n\t\t//count the\
    \ occurance of [ and ]\n\t\tif(string[i]=='[')\n\t\t\tcheck++;\n\t\telse if(string[i]==']')\n\
    \t\t\tcheck--;\n\t\t//if ] occur more then [ then we cant have valid subsequence\n\
    \t\tif(check<0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpagtc5rx7: /tmp/tmpagtc5rx7.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '[')\n            count++;\n        else if(string[i] == ']')\n\
    \            count--;\n        if(count == -1)\n            return false;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdeondg7m: /tmp/tmpdeondg7m.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stack;\n\tfor (int i = 0; i < string.length(); i++) {\n\
    \t\tif (string[i] == '[') {\n\t\t\tstack.push(string[i]);\n\t\t}\n\t\telse if\
    \ (string[i] == ']') {\n\t\t\tif (stack.empty()) {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t\tstack.pop();\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpz85_gkl3: /tmp/tmpz85_gkl3.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    std::stack<char> s;\n    for(int i = 0;\
    \ i < n; i++) {\n        if(string[i] == '[') {\n            s.push(string[i]);\n\
    \        }\n        else if(string[i] == ']') {\n            if(s.empty()) {\n\
    \                return false;\n            }\n            else {\n          \
    \      s.pop();\n            }\n        }\n    }\n    if(s.empty()) {\n      \
    \  return true;\n    }\n    else {\n        return false;\n    }\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpr9rdv7p9: /tmp/tmpr9rdv7p9.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  if(string.size()==0)return false;\n  int count=0;\n  for(int i=0;i<string.size();i++){\n\
    \    if(string[i]=='['){\n      count++;\n    }\n    else{\n      count--;\n \
    \   }\n    if(count<0)return false;\n  }\n  return true;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmplhp8_0iq: /tmp/tmplhp8_0iq.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint arr[string.length()] = {0};\n\tfor(int i = 0; i < string.length();\
    \ i++) {\n\t\tif(string[i] == '[') {\n\t\t\tarr[i] = 1;\n\t\t}\n\t\telse if(string[i]\
    \ == ']') {\n\t\t\tif(i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if(i\
    \ == string.length() - 1) {\n\t\t\t\tif(arr[i - 1] == 1) {\n\t\t\t\t\treturn true;\n\
    \t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tif(arr[i - 1] == 1) {\n\t\t\t\t\tarr[i] = 1;\n\t\t\t\t}\n\t\t\t\
    \telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i\
    \ = 0; i < string.length(); i++) {\n\t\tif(arr[i] == 1) {\n\t\t\treturn true;\n\
    \t\t}\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpcgqxyv0p: /tmp/tmpcgqxyv0p.cpp:50: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn count >\
    \ 0 ? false : true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpp63b0pul: /tmp/tmpp63b0pul.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int left = 0;\n    int right = 0;\n    for(int i = 0; i < string.length();\
    \ i++){\n        if(string[i] == '[')\n            left++;\n        else if(string[i]\
    \ == ']')\n            right++;\n    }\n    if(left > right)\n        return true;\n\
    \    else\n        return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpph3ao93d: /tmp/tmpph3ao93d.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count=0;\n  for(auto x:string)\n  {\n    if(x=='[')\n    {\n      count++;\n\
    \    }\n    else\n    {\n      count--;\n    }\n    if(count<0)\n    {\n     \
    \ return false;\n    }\n  }\n  return count==0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpts78hw9j: /tmp/tmpts78hw9j.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121184
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(auto i : string){\n    if(i == '['){\n      count++;\n\
    \    }\n    else{\n      count--;\n    }\n    if(count < 0){\n      return false;\n\
    \    }\n  }\n  return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6bp5yd7r: /tmp/tmp6bp5yd7r.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tcount\
    \ += (string[i] == '[') ? 1 : -1;\n\t\tif (count < 0) return false;\n\t}\n\treturn\
    \ count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpyn2psazx: /tmp/tmpyn2psazx.cpp:24: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6kidhfj8: /tmp/tmp6kidhfj8.cpp:17: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string.empty())\n\t\treturn false;\n\tstd::stack<char> char_stack;\n\
    \tfor(auto c : string) {\n\t\tif(c == '[')\n\t\t\tchar_stack.push(c);\n\t\telse\
    \ {\n\t\t\tif(char_stack.empty())\n\t\t\t\treturn false;\n\t\t\tchar_stack.pop();\n\
    \t\t}\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnv4qvfar: /tmp/tmpnv4qvfar.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> brackets;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string[i] == '[') {\n\t\t\tbrackets.push(string[i]);\n\t\t}\n\t\t\
    else if (string[i] == ']') {\n\t\t\tif (brackets.empty()) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\tbrackets.pop();\n\t\t}\n\t}\n\treturn brackets.empty();\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpth4fpckl: /tmp/tmpth4fpckl.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> s;\n\tfor (char c : string) {\n\t\tif (c == '[') {\n\t\
    \t\ts.push(c);\n\t\t}\n\t\telse if (c == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\
    \treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn !s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3_1k26j2: /tmp/tmp3_1k26j2.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tbool flag = false;\n\tstd::vector<char> v(string.size());\n\tint k = 0;\n\
    \tfor (int i = 0; i < string.size(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\
    \tv[k] = '[';\n\t\t\tk++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (k\
    \ == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v[k - 1]\
    \ == '[') {\n\t\t\t\tflag = true;\n\t\t\t\tv[k - 1] = ' ';\n\t\t\t\tk--;\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpdipsejmi: /tmp/tmpdipsejmi.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    int n = string.length();\n    for(int i =\
    \ 0; i < n; i++) {\n        if(string[i] == '[') {\n            stk.push(string[i]);\n\
    \        } else {\n            if(stk.empty()) {\n                return false;\n\
    \            } else {\n                stk.pop();\n            }\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp7v4z2423: /tmp/tmp7v4z2423.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint brackets = 0;\n\tfor (auto character : string) {\n\t\tif (character\
    \ == '[') {\n\t\t\tbrackets++;\n\t\t}\n\t\telse if (character == ']') {\n\t\t\t\
    brackets--;\n\t\t}\n\t\tif (brackets < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\
    \treturn brackets > 0;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpsnf9f5db: /tmp/tmpsnf9f5db.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stack;\n\tfor (char c : string) {\n\t\tif (c == '[')\n\
    \t\t\tstack.push(c);\n\t\telse if (c == ']') {\n\t\t\tif (stack.empty())\n\t\t\
    \t\treturn false;\n\t\t\tstack.pop();\n\t\t}\n\t}\n\treturn stack.empty();\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwsudo_u4: /tmp/tmpwsudo_u4.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for(int i = 0; i < string.length();\
    \ i++){\n        if(string[i] == '['){\n            open++;\n        }\n     \
    \   else if(string[i] == ']'){\n            close++;\n        }\n        if(close\
    \ > open){\n            return false;\n        }\n    }\n    if(open == close){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpnnkuumnp: /tmp/tmpnnkuumnp.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> myStack;\n\tfor (char c : string) {\n\t\tif (c == '[')\
    \ {\n\t\t\tmyStack.push(c);\n\t\t}\n\t\telse if (c == ']') {\n\t\t\tif (myStack.empty())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmyStack.pop();\n\t\t}\n\t}\n\treturn\
    \ !myStack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp57ekxqx2: /tmp/tmp57ekxqx2.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tcount--;\n\
    \t\t}\n\t\tif (count < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmplrqe4fk7: /tmp/tmplrqe4fk7.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121180
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Solved using Stack data structure\n    std::stack<char> brackets;\n\
    \    for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[')\n\
    \            brackets.push(string[i]);\n        else if(string[i] == ']') {\n\
    \            if(brackets.empty())\n                return false;\n           \
    \ else if(brackets.top() == '[')\n                brackets.pop();\n          \
    \  else\n                return false;\n        }\n    }\n    return brackets.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpr8kyvcfi: /tmp/tmpr8kyvcfi.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    \tif (string[i] == '[')\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tcount--;\n\t\t\t\
    if (count < 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpc6p8xam0: /tmp/tmpc6p8xam0.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n  \
    \          for(int j=i+1;j<string.length();j++){\n                if(string[j]==']'){\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpbhgoh2b3: /tmp/tmpbhgoh2b3.cpp:27: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char>s;\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n\
    \            s.push(string[i]);\n        }\n        else if(string[i]==']'){\n\
    \            if(s.size()>0){\n                s.pop();\n            }\n      \
    \      else{\n                return false;\n            }\n        }\n    }\n\
    \    if(s.size()>0){\n        return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwgo66j2w.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpwgo66j2w.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char>s;\n   \
    \   |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpwgo66j2w.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpwgo66j2w.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char>s;\n      |           ^~~~\n\
    /tmp/tmpwgo66j2w.cpp:16:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   16 |             s.push(string[i]);\n      |             ^\n/tmp/tmpwgo66j2w.cpp:19:16:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |             if(s.size()>0){\n\
    \      |                ^\n/tmp/tmpwgo66j2w.cpp:27:8: error: \u2018s\u2019 was\
    \ not declared in this scope\n   27 |     if(s.size()>0){\n      |        ^\n"
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    int i = 0;\n    while(i < string.length()){\n\
    \        if(string[i] == '['){\n            stk.push(string[i]);\n        }else\
    \ if(string[i] == ']'){\n            if(stk.empty()){\n                return\
    \ false;\n            }else{\n                stk.pop();\n            }\n    \
    \    }\n        i++;\n    }\n    if(stk.empty()){\n        return true;\n    }else{\n\
    \        return false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5clksdhe: /tmp/tmp5clksdhe.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint counter = 0;\n\tfor (char& ch : string) {\n\t\tif (ch == '[') {\n\t\
    \t\tcounter++;\n\t\t}\n\t\telse if (ch == ']') {\n\t\t\tcounter--;\n\t\t}\n\t\t\
    if (counter == -1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp8y4hyxnv: /tmp/tmp8y4hyxnv.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t//output var\n\tbool result = false;\n\t// store open brackets in stack\n\
    \tstd::stack<char> open_brackets;\n\t//loop through characters\n\tfor (int i =\
    \ 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\topen_brackets.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (open_brackets.empty()) {\n\t\
    \t\t\t//return false if there is a close bracket before an open bracket\n\t\t\t\
    \treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//remove the open bracket from\
    \ the stack\n\t\t\t\topen_brackets.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// if all the\
    \ brackets are equal, return true\n\tif (open_brackets.empty()) {\n\t\tresult\
    \ = true;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph1bms8ws: /tmp/tmph1bms8ws.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> st;\n    for(char c : string) {\n        if(c == '[')\
    \ {\n            st.push(c);\n        } else {\n            if(st.empty()) return\
    \ false;\n            else st.pop();\n        }\n    }\n    return st.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp0fgvooeo: /tmp/tmp0fgvooeo.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t//if(string.size()==0) return false;\n\t//if(string.size()==1) return false;\n\
    \tint n=string.size();\n\tint maxLen = 0;\n\tint count=0;\n\tstd::stack<char>\
    \ s;\n\tfor(int i=0;i<n;i++){\n\t\tif(string[i]=='['){\n\t\t\ts.push(string[i]);\n\
    \t\t\tcount++;\n\t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(!s.empty()){\n\t\
    \t\t\ts.pop();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t}\n\tif(s.empty()){\n\t\treturn true;\n\t}\n\treturn false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp04wfadft: /tmp/tmp04wfadft.cpp:43: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> bracket_stack;\n  for (char bracket : string) {\n    if\
    \ (bracket == '[') {\n      bracket_stack.push(bracket);\n    } else if (bracket\
    \ == ']') {\n      if (bracket_stack.empty()) {\n        return false;\n     \
    \ } else {\n        bracket_stack.pop();\n      }\n    }\n  }\n  return bracket_stack.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpcrv2ea_s: /tmp/tmpcrv2ea_s.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> s;\n    for(char ch : string) {\n        if(ch == '[')\n\
    \            s.push(ch);\n        else {\n            if(s.empty())\n        \
    \        return false;\n            else\n                s.pop();\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp50ykr2v6: /tmp/tmp50ykr2v6.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph4ub7d_0: /tmp/tmph4ub7d_0.cpp:17: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for(int i = 0; i < string.length(); i++){\n     \
    \   if(string[i] == '['){\n            count += 1;\n        }\n        else if(string[i]\
    \ == ']'){\n            count -= 1;\n        }\n        if(count < 0){\n     \
    \       return false;\n        }\n    }\n    return true;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpfj2kv09q: /tmp/tmpfj2kv09q.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(auto x : string){\n    if(x == '[')\n      count++;\n\
    \    else\n      count--;\n    if(count < 0)\n      return false;\n  }\n  return\
    \ count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpf3_x0vem: /tmp/tmpf3_x0vem.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121185
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> S;\n    for(int i=0;i<string.length();i++){\n      \
    \  if(string[i]=='[')\n            S.push(string[i]);\n        else{\n       \
    \     if(S.empty())\n                return false;\n            else\n       \
    \         S.pop();\n        }\n    }\n    if(S.empty())\n        return true;\n\
    \    else\n        return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpqh9wx3yr: /tmp/tmpqh9wx3yr.cpp:33: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t//Create two variables to keep track of the opening and closing brackets\n\
    \tint open_count = 0;\n\tint close_count = 0;\n\t//Loop through the string\n\t\
    for (int i = 0; i < string.length(); i++) {\n\t\t//If the bracket is an opening\
    \ bracket, increment the opening bracket counter\n\t\tif (string[i] == '[') {\n\
    \t\t\topen_count++;\n\t\t}\n\t\t//If the bracket is a closing bracket, increment\
    \ the closing bracket counter\n\t\tif (string[i] == ']') {\n\t\t\tclose_count++;\n\
    \t\t}\n\t\t//If the closing bracket counter is greater than the opening bracket\
    \ counter, break out of the loop\n\t\tif (close_count > open_count) {\n\t\t\t\
    break;\n\t\t}\n\t}\n\t//If the opening bracket counter is equal to the closing\
    \ bracket counter and it is not zero, return true\n\tif (open_count == close_count\
    \ && open_count != 0) {\n\t\treturn true;\n\t}\n\t//Otherwise, return false\n\t\
    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmprw7_dtw7: /tmp/tmprw7_dtw7.cpp:42: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint stack = 0;\n\tfor (auto s : string) {\n\t\tif (s == '[') stack++;\n\
    \t\telse if (s == ']') stack--;\n\t\tif (stack == 0) return true;\n\t}\n\treturn\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmprmml48fh: /tmp/tmprmml48fh.cpp:24: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stack;\n\tfor (int i = 0; i < string.length(); i++) {\n\
    \t\tchar c = string[i];\n\t\tif (c == '[') {\n\t\t\tstack.push(c);\n\t\t}\n\t\t\
    else if (c == ']') {\n\t\t\tif (stack.empty()) {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\tif (stack.top() == '[') {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpcvoeyxju: /tmp/tmpcvoeyxju.cpp:34: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint bracket_open_count = 0;\n\tint bracket_close_count = 0;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\tbracket_open_count++;\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tbracket_close_count++;\n\t\t}\n\
    \t}\n\tif (bracket_open_count != bracket_close_count) {\n\t\treturn false;\n\t\
    }\n\tstd::stack<char> stk;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string[i] == '[') {\n\t\t\tstk.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (stk.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stk.empty()) {\n\t\treturn\
    \ true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpvp3be289: /tmp/tmpvp3be289.cpp:51: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::stack<char> s;\n  for(auto c : string) {\n    if(c == '[') {\n   \
    \   s.push(c);\n    } else {\n      if(s.empty()) {\n        return false;\n \
    \     }\n      s.pop();\n    }\n  }\n  return s.empty();\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp4vw_kftr: /tmp/tmp4vw_kftr.cpp:30: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::vector<char> str;\n\tfor (size_t i = 0; i < string.size(); i++)\n\t\
    {\n\t\tif (string[i] == '[') {\n\t\t\tstr.push_back(string[i]);\n\t\t}\n\t\telse\
    \ if (string[i] == ']') {\n\t\t\tif (str.size() <= 0) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\tstr.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\tif (str.size()\
    \ == 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpkdnahyfw: /tmp/tmpkdnahyfw.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[' &&\
    \ string[i + 1] == ']')\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpktks40po: /tmp/tmpktks40po.cpp:22: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> bracketStack;\n\tif (string.length() == 0) {\n\t\treturn\
    \ false;\n\t}\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tbracketStack.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (bracketStack.empty()) {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\telse {\n\t\t\t\tbracketStack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (bracketStack.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp8c_0vosv: /tmp/tmp8c_0vosv.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> stk;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\
    \tif (string[i] == '[') {\n\t\t\tstk.push(string[i]);\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tif (stk.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (stk.empty()) {\n\t\treturn\
    \ true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpy8hoyrzr: /tmp/tmpy8hoyrzr.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char>stk;\n    bool flag = false;\n    for(auto s:string){\n\
    \        if(s == '[')\n            stk.push(s);\n        else{\n            if(stk.empty())\n\
    \                return false;\n            stk.pop();\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9wmnfixq: /tmp/tmp9wmnfixq.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for(const auto& element : string) {\n  \
    \      if(element == '[') {\n            stack.push(element);\n        }\n   \
    \     else if(element == ']') {\n            if(stack.empty()) {\n           \
    \     return false;\n            }\n            else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    return !stack.empty();\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpv834vqz4: /tmp/tmpv834vqz4.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i = 0;\n    for(auto& c : string) {\n        if(i == 0) {\n     \
    \       i++;\n        }\n        else if(i > 0) {\n            if(c == ']') {\n\
    \                if(string[i-1] == '[') {\n                    i--;\n        \
    \        }\n                else {\n                    return false;\n      \
    \          }\n            }\n            else {\n                i++;\n      \
    \      }\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9x10nlbb: /tmp/tmp9x10nlbb.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint cnt = 0;\n\tfor (int i = 0; i < string.size(); i++) {\n\t\tif (string[i]\
    \ == '[')\n\t\t\tcnt++;\n\t\telse if (string[i] == ']')\n\t\t\tcnt--;\n\t\tif\
    \ (cnt < 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6a5i5yzh: /tmp/tmp6a5i5yzh.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    //int count=0;\n    std::stack<char> stack;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='[')\n            stack.push(string[i]);\n        else\
    \ if(string[i]==']'){\n            if(stack.empty())\n                return false;\n\
    \            else{\n                stack.pop();\n            }\n        }\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpwloaesb1: /tmp/tmpwloaesb1.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> s;\n    for(int i=0;i<string.length();i++){\n      \
    \  if(string[i]=='[')\n            s.push(string[i]);\n        else{\n       \
    \     if(s.empty())\n                return false;\n            else{\n      \
    \          if(s.top()=='[')\n                    s.pop();\n                else\n\
    \                    return false;\n            }\n        }\n    }\n    if(s.empty())\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpbps7w7y8: /tmp/tmpbps7w7y8.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstd::stack<char> st;\n\tfor(int i=0;i<string.length();i++){\n\t\tif(string[i]=='[')\n\
    \t\t\tst.push(string[i]);\n\t\telse if(!st.empty() && string[i]==']')\n\t\t\t\
    st.pop();\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpfaa3wbrb: /tmp/tmpfaa3wbrb.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string.size()==0)\n\t\treturn false;\n\tstd::stack<char> s;\n\tfor(int\
    \ i=0;i<string.size();i++){\n\t\tif(string[i]=='[')\n\t\t\ts.push(string[i]);\n\
    \t\telse{\n\t\t\tif(s.empty())\n\t\t\t\treturn false;\n\t\t\ts.pop();\n\t\t}\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp909kkuwc: /tmp/tmp909kkuwc.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    assert(!string.empty());\n    int open = 0;\n    int close = 0;\n   \
    \ for(const auto& ch : string) {\n        if(ch == '[') {\n            ++open;\n\
    \        }\n        else if(ch == ']') {\n            ++close;\n        }\n  \
    \      if(close > open) {\n            return false;\n        }\n    }\n    return\
    \ open > close;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpiptzk_pl: /tmp/tmpiptzk_pl.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  // check that string is valid\n  assert(string.size() != 0);\n  int total\
    \ = 0;\n  for (int i = 0; i < string.size(); i++) {\n    if (string[i] == '[')\
    \ {\n      total++;\n    } else if (string[i] == ']') {\n      total--;\n    }\n\
    \    if (total < 0) {\n      return false;\n    }\n  }\n  return total > 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp4nidb0rh: /tmp/tmp4nidb0rh.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint size = string.size();\n\tint count = 0;\n\tfor (int i = 0; i < size;\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string[i]\
    \ == ']') {\n\t\t\tcount--;\n\t\t}\n\t\tif (count == 0) {\n\t\t\treturn true;\n\
    \t\t}\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3tnp8yxy: /tmp/tmp3tnp8yxy.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n = string.length();\n\tif(n%2!=0)\n\t\treturn false;\n\tint count\
    \ = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(string[i]=='[')\n\t\t\tcount++;\n\t\t\
    else if(string[i]==']')\n\t\t\tcount--;\n\t\tif(count<0)\n\t\t\treturn false;\n\
    \t}\n\treturn count==0;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpo9fnnkwp: /tmp/tmpo9fnnkwp.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count=0;\n\tfor(int i=0;i<string.length();i++)\n\t{\n\t\tif(string[i]=='[')\n\
    \t\t\tcount++;\n\t\telse\n\t\t\tcount--;\n\t\tif(count<0)\n\t\t\treturn false;\n\
    \t}\n\treturn true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppnvytgqz: /tmp/tmppnvytgqz.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint i = 0;\n\tint open = 0;\n\tint close = 0;\n\twhile (string[i] != '\\\
    0')\n\t{\n\t\tif (string[i] == '[')\n\t\t{\n\t\t\topen++;\n\t\t}\n\t\telse if\
    \ (string[i] == ']')\n\t\t{\n\t\t\tclose++;\n\t\t}\n\t\ti++;\n\t}\n\treturn open\
    \ > close;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmph94t05pp: /tmp/tmph94t05pp.cpp:32: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string.length()==0){\n\t\treturn false;\n\t}\n\tstack<char> s;\n\tfor(int\
    \ i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse{\n\t\t\tif(s.empty()){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    else{\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(s.empty()){\n\t\treturn true;\n\
    \t}\n\telse{\n\t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpn2tbr8_s.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpn2tbr8_s.cpp:16:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   16 |  stack<char> s;\n     \
    \ |  ^~~~~\n      |  std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpn2tbr8_s.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpn2tbr8_s.cpp:16:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |  stack<char> s;\n      |        ^~~~\n/tmp/tmpn2tbr8_s.cpp:19:4:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |    s.push(string[i]);\n\
    \      |    ^\n/tmp/tmpn2tbr8_s.cpp:22:7: error: \u2018s\u2019 was not declared\
    \ in this scope\n   22 |    if(s.empty()){\n      |       ^\n/tmp/tmpn2tbr8_s.cpp:30:5:\
    \ error: \u2018s\u2019 was not declared in this scope\n   30 |  if(s.empty()){\n\
    \      |     ^\n/tmp/tmpn2tbr8_s.cpp:36:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   36 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660121186
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint len = string.length();\n\tstd::stack<char> stack;\n\tfor (int i = 0;\
    \ i < len; i++) {\n\t\tif (string[i] == '[') {\n\t\t\tstack.push(string[i]);\n\
    \t\t}\n\t\telse if (!stack.empty() && string[i] == ']') {\n\t\t\tstack.pop();\n\
    \t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp49wvuzah: /tmp/tmp49wvuzah.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ == '[')\n\t\t\tcount++;\n\t\telse if (string[i] == ']')\n\t\t\tcount--;\n\t\t\
    if (count < 0)\n\t\t\treturn false;\n\t}\n\treturn count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmps7o2sebs: /tmp/tmps7o2sebs.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121183
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for(int i = 0; i < string.length(); i++) {\n    if(string[i]\
    \ == '[') count++;\n    else count--;\n    if(count < 0) return false;\n  }\n\
    \  return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpz_5n8v63: /tmp/tmpz_5n8v63.cpp:25: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// create stack to push opening brackets\n\tstd::stack<char> stk;\n\t//\
    \ traverse the string from left to right\n\tfor(char ch : string) {\n\t\t// if\
    \ the character is an opening bracket\n\t\tif(ch == '[') {\n\t\t\t// push it in\
    \ the stack\n\t\t\tstk.push(ch);\n\t\t}\n\t\t// if the character is a closing\
    \ bracket\n\t\telse if(ch == ']') {\n\t\t\t// pop the top element from the stack\n\
    \t\t\tstk.pop();\n\t\t}\n\t}\n\t// if the stack is empty, then we must have balanced\
    \ brackets\n\t// so return true, else false\n\treturn stk.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tif(string.length()<1) return false;\n\tstd::stack<char> st;\n\tfor(int\
    \ i=0;i<string.length();i++){\n\t\tif(string[i]=='['){\n\t\t\tst.push(string[i]);\n\
    \t\t}\n\t\telse if(string[i]==']'){\n\t\t\tif(st.empty()) return false;\n\t\t\t\
    else st.pop();\n\t\t}\n\t}\n\tif(st.empty()) return true;\n\telse return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpnrl1uucw: /tmp/tmpnrl1uucw.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// Returns false if there is only one or zero brackets\n\tif (string.length()\
    \ < 2) {\n\t\treturn false;\n\t}\n\t// Bracket counter. Starts at 0\n\tint bracketCounter\
    \ = 0;\n\t// Iterate through the string\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\t// If the char is a bracket, add 1 to the counter\n\t\tif (string[i]\
    \ == '[') {\n\t\t\tbracketCounter++;\n\t\t}\n\t\t// If the char is a bracket,\
    \ subtract 1 from the counter\n\t\telse if (string[i] == ']') {\n\t\t\tbracketCounter--;\n\
    \t\t}\n\t\t// If the bracketCounter is 0 after a bracket has been removed, return\
    \ false\n\t\tif (bracketCounter == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t//\
    \ If the bracketCounter is not 0, return true\n\tif (bracketCounter != 0) {\n\t\
    \treturn true;\n\t}\n\t// If the loop was completed and returns false, return\
    \ false\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpan9vyun4: /tmp/tmpan9vyun4.cpp:43: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    for(auto c : string) {\n        if(c == '[')\n\
    \            stk.push(c);\n        else {\n            if(stk.empty()) return\
    \ false;\n            stk.pop();\n        }\n    }\n    return stk.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpn9rktc19: /tmp/tmpn9rktc19.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121187
