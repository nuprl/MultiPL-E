name: HumanEval_59_largest_prime_factor
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Insert your code here.\n    std::vector<long> L;\n    long k;\n\
    \    long t = n;\n    for (long i = 2; i < t; i++){\n        if (t % i == 0){\n\
    \            L.push_back(i);\n            t = t / i;\n            i = 1;\n   \
    \     }\n    }\n    if (L.size() == 0){\n        k = t;\n    } else {\n      \
    \  k = L[L.size() - 1];\n    }\n    return k;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpthm5cspi: /tmp/tmpthm5cspi.cpp:29: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_factor = 1;\n    long d = 2;\n    while (n > 1) {\n \
    \       while (n % d == 0) {\n            largest_factor = d;\n            n /=\
    \ d;\n        }\n        d += 1;\n    }\n    return largest_factor;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO\n    return 0;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpcnspex31: /tmp/tmpcnspex31.cpp:14: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  for (long i = 2; i < n; i++) {\n    if (n % i == 0) {\n      return\
    \ largest_prime_factor(n / i);\n    }\n  }\n  return n;\n}\nint main() {\n   \
    \ auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long c=2;\n  while(c<=n){\n    if(n%c==0){\n      n/=c;\n    }else{\n\
    \      c++;\n    }\n  }\n  return c;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n// your code goes here\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpmhppr0ie: /tmp/tmpmhppr0ie.cpp:13: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    int lpf;\n    for (int i = 2; i <= n; i++) {\n        while (n % i\
    \ == 0) {\n            lpf = i;\n            n /= i;\n        }\n    }\n    return\
    \ lpf;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: your code here\n    long result = 0;\n    for (long i = 2;\
    \ i <= n; i++) {\n        // Checks if i is a prime number.\n        bool is_prime\
    \ = true;\n        for (long j = 2; j <= i / 2; j++) {\n            if (i % j\
    \ == 0) {\n                is_prime = false;\n                break;\n       \
    \     }\n        }\n        if (is_prime) {\n            while (n % i == 0) {\n\
    \                result = i;\n                n /= i;\n            }\n       \
    \ }\n    }\n    return result;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largestPrime = -1;\n    while (n % 2 == 0) {\n        largestPrime\
    \ = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n\
    \        while (n % i == 0) {\n            largestPrime = i;\n            n =\
    \ n / i;\n        }\n    }\n    if (n > 2)\n        largestPrime = n;\n    return\
    \ largestPrime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long max_prime = -1;\n  while (n % 2 == 0) {\n    max_prime = 2;\n \
    \   n /= 2;\n  }\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i\
    \ == 0) {\n      max_prime = i;\n      n /= i;\n    }\n  }\n  if (n > 2)\n   \
    \ max_prime = n;\n  return max_prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n>1);\n  for (long i = 2; i*i <= n; i++) {\n    if (n % i ==\
    \ 0) {\n      n /= i;\n      i--;\n    }\n  }\n  return n;\n}\nint main() {\n\
    \    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long max_factor = 0;\n  for (long i = 2; i <= n; i++) {\n    if (n %\
    \ i == 0) {\n      n /= i;\n      max_factor = i;\n    }\n  }\n  return max_factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp2q44k9rj: /tmp/tmp2q44k9rj.cpp:21: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    // Handle 2 separately, since 2 is the only even\
    \ prime.\n    if (n % 2 == 0) return largest_prime_factor(n / 2);\n    // n is\
    \ odd at this point.\n    long largest_factor = 1;\n    long d = 3;\n    while\
    \ (d * d <= n) {\n        if (n % d == 0) {\n            n /= d;\n           \
    \ largest_factor = d;\n        } else {\n            d += 2;\n        }\n    }\n\
    \    if (n > 1) {\n        // n is prime, since it is larger than any previous\
    \ factors.\n        return n;\n    } else {\n        return largest_factor;\n\
    \    }\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    for (long i = 2; i < n; i++) {\n        if (n\
    \ % i == 0)\n            return largest_prime_factor(n / i);\n    }\n    return\
    \ n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long f = 2;\n  while (n % f != 0) {\n    f += 1;\n  }\n  if (n / f ==\
    \ 1) {\n    return f;\n  }\n  return largest_prime_factor(n / f);\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime = 0;\n    for (long i = 2; i <= n; i++) {\n   \
    \     if (n % i == 0) {\n            largest_prime = i;\n            while (n\
    \ % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    return\
    \ largest_prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong current_largest_prime_factor = 2;\n\tlong remaining_n = n;\n\t\
    while (remaining_n % current_largest_prime_factor == 0) {\n\t\tremaining_n /=\
    \ current_largest_prime_factor;\n\t}\n\tlong next_prime_number = current_largest_prime_factor\
    \ + 1;\n\twhile (remaining_n > 1) {\n\t\tif (remaining_n % next_prime_number ==\
    \ 0) {\n\t\t\tcurrent_largest_prime_factor = next_prime_number;\n\t\t\tremaining_n\
    \ /= next_prime_number;\n\t\t}\n\t\telse {\n\t\t\tnext_prime_number += 2;\n\t\t\
    }\n\t}\n\treturn current_largest_prime_factor;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest = 1;\n    long i = 2;\n    while (i * i <= n) {\n   \
    \     if (n % i == 0) {\n            if (largest < i)\n                largest\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    if (largest < n)\n        largest = n;\n    return largest;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // For n >= 2, n is composed of 2 or odd numbers.\n  if (n % 2 == 0)\
    \ {\n    n = n / 2;\n    while (n % 2 == 0) {\n      n = n / 2;\n    }\n  }\n\n\
    \  long factor = 3;\n  while (n != 1) {\n    if (n % factor == 0) {\n      n =\
    \ n / factor;\n      while (n % factor == 0) {\n        n = n / factor;\n    \
    \  }\n    }\n    factor += 2;\n  }\n  return factor - 2;\n}\nint main() {\n  \
    \  auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: Complete this function.\n    long lpf = 0;\n    for(long\
    \ i = 2; i <= n; i++){\n        if(n % i == 0){\n            lpf = i;\n      \
    \      n /= i;\n            i = 1;\n        }\n    }\n    return lpf;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime = -1;\n    while (n % 2 == 0) {\n        largest_prime\
    \ = 2;\n        n /= 2;\n    }\n    // Now n is odd\n    long f = 3;\n    while\
    \ (f * f <= n) {\n        if (n % f == 0) {\n            largest_prime = f;\n\
    \            n /= f;\n        } else {\n            f += 2;\n        }\n    }\n\
    \    if (n > largest_prime)\n        largest_prime = n;\n    return largest_prime;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n > 1);\n  long t = n;\n  long i = 2;\n  while (i * i <= t) {\n\
    \    if (t % i == 0) {\n      t /= i;\n    } else {\n      i++;\n    }\n  }\n\
    \  return t;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n  \
    \  assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63))\
    \ == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong i = 2;\n\twhile (i < n) {\n\t\tif (n % i == 0) {\n\t\t\tn /= i;\n\
    \t\t} else {\n\t\t\ti += 1;\n\t\t}\n\t}\n\treturn n;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // To be implemented.\n    long largest = 0;\n    for (long i = 2;\
    \ i <= n; i++) {\n        while (n % i == 0) {\n            largest = i;\n   \
    \         n /= i;\n        }\n    }\n    return largest;\n}\nint main() {\n  \
    \  auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // your code here\n  long high = n / 2;\n  for (long i = 2; i <= high;\
    \ i++) {\n    if (n % i == 0) {\n      while (n % i == 0) {\n        n /= i;\n\
    \      }\n      high = n / 2;\n    }\n  }\n  return n;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp2rn3fwiw: /tmp/tmp2rn3fwiw.cpp:24: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Write your code here.\n    // Hint: The solution is related to\
    \ the Fundamental Theorem of Arithmetic.\n    // https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\n\
    \    //\n    // The largest prime factor will be equal to n / the smallest factor\
    \ of n.\n    //\n    // Note that a prime number is a number that is only divisible\
    \ by 1 and itself.\n    // You might find a useful method for determining whether\
    \ a number is prime.\n    // If a number n is not prime, then it can be written\
    \ as a product of prime\n    // numbers (which may or may not be distinct).\n\
    \    //\n    // For example, if n = 16, you can write it as 16 = 2 * 2 * 2 * 2,\
    \ or\n    // 16 = 2 * 2 * 4, or 16 = 2 * 8, or 16 = 4 * 4.\n    //\n    // If\
    \ you iterate over the divisors of 16, you will find that 2 is the smallest\n\
    \    // divisor that is not 1.\n    //\n    // If n is prime, then the largest\
    \ prime factor of n is n.\n    //\n    // Pro tip: make a helper function that\
    \ will determine whether a number is prime.\n    // This can simplify your code.\n\
    \    if (isPrime(n)) return n;\n    return n / smallestFactor(n);\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpd8dil3m2.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpd8dil3m2.cpp:30:9: error: \u2018isPrime\u2019 was not declared\
    \ in this scope\n   30 |     if (isPrime(n)) return n;\n      |         ^~~~~~~\n\
    /tmp/tmpd8dil3m2.cpp:31:16: error: \u2018smallestFactor\u2019 was not declared\
    \ in this scope\n   31 |     return n / smallestFactor(n);\n      |          \
    \      ^~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    return -1;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp929ai1bv: /tmp/tmp929ai1bv.cpp:13: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n > 1);\n  for (long i = 2; i <= n; i++) {\n    if (n % i ==\
    \ 0) {\n      n /= i;\n      i -= 1;\n    }\n  }\n  return n;\n}\nint main() {\n\
    \    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "tmp4s8aw8qc: /tmp/tmp4s8aw8qc.cpp:20: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // YOUR CODE HERE\n    assert(n > 1);\n    int i;\n    for (i = 2;\
    \ i <= n; i++) {\n        if (n % i == 0) {\n            n /= i;\n           \
    \ i--;\n        }\n    }\n    return i;\n}\nint main() {\n    auto candidate =\
    \ largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\nlong i = n/2;\nwhile(i!=0){\n if(n%i==0){\n   long j=i/2;\n   while(j!=0){\n\
    \     if(i%j==0)\n        return largest_prime_factor(n/i);\n     j--;\n   }\n\
    \   return i;\n }\n  i--;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1i9w3khs.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmp1i9w3khs.cpp:22:9: warning: empty parentheses were disambiguated\
    \ as a function declaration [-Wvexing-parse]\n   22 | int main() {\n      |  \
    \       ^~\n/tmp/tmp1i9w3khs.cpp:22:9: note: remove parentheses to default-initialize\
    \ a variable\n   22 | int main() {\n      |         ^~\n      |         --\n/tmp/tmp1i9w3khs.cpp:22:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmp1i9w3khs.cpp:22:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   22 | int main() {\n      |            ^\n/tmp/tmp1i9w3khs.cpp:29:2: error:\
    \ expected \u2018}\u2019 at end of input\n   29 | }\n      |  ^\n/tmp/tmp1i9w3khs.cpp:8:35:\
    \ note: to match this \u2018{\u2019\n    8 | long largest_prime_factor(long n)\
    \ {\n      |                                   ^\n/tmp/tmp1i9w3khs.cpp:29:2: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n   29 | }\n      |\
    \  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long factor = n;\n  long largest = -1;\n  int j = 2;\n  while (factor\
    \ != 1){\n      if (factor % j == 0){\n          factor = factor / j;\n      \
    \    largest = j;\n      }\n      else{\n          j = j + 1;\n      }\n  }\n\
    \  return largest;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i;\n    for (i = 2; i * i <= n; i++) {\n        while (n % i\
    \ == 0) {\n            n /= i;\n        }\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "tmp5bttxup7: /tmp/tmp5bttxup7.cpp:20: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    long d = 3;\n  \
    \  while (d * d <= n) {\n        if (n % d == 0) {\n            n /= d;\n    \
    \    } else {\n            d += 2;\n        }\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor = 0;\n    for (long i = 2; i < n / 2; i++)\
    \ {\n        if (n % i == 0) {\n            long factor = n / i;\n           \
    \ if (is_prime(factor)) {\n                largest_prime_factor = factor;\n  \
    \              break;\n            }\n        }\n    }\n    return largest_prime_factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi3dy2o86.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpi3dy2o86.cpp:13:17: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   13 |             if (is_prime(factor)) {\n      |\
    \                 ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: implement me\n    return -1;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp0y1mb34q: /tmp/tmp0y1mb34q.cpp:14: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long copy = n;\n  long big = 0;\n  int i = 2;\n  if (n < 2) {\n    return\
    \ -1;\n  }\n  for (i = 2; i < copy; i++) {\n    if (copy % i == 0) {\n      big\
    \ = i;\n      copy = copy / i;\n      i = 2;\n    }\n  }\n  return copy;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: Implement.\n    if(n == 1){\n        return 1;\n    }\n \
    \   for(long i = 2; i<=sqrt(n); i++){\n        if(n%i == 0){\n            return\
    \ largest_prime_factor(n/i);\n        }\n    }\n    return n;\n}\nint main() {\n\
    \    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: IMPLEMENT ME\n    int largestFactor = 1;\n    for (int i\
    \ = 1; i <= n; i++) {\n        if (n % i == 0) {\n            if (i > largestFactor)\
    \ {\n                bool flag = true;\n                for (int j = 2; j < i;\
    \ j++) {\n                    if (i % j == 0) {\n                        flag\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n                if (flag) {\n                    largestFactor = i;\n\
    \                }\n            }\n        }\n    }\n    return largestFactor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\t// long primes[n];\n\t// int ind = 0;\n\t// for(long i = 2; i <= n;\
    \ i++){\n\t// \tif(isPrime(i)){\n\t// \t\tprimes[ind] = i;\n\t// \t\tind++;\n\t\
    // \t}\n\t// }\n\t// int div = 1;\n\t// for(int i = ind-1; i >= 0; i--){\n\t//\
    \ \tif(n % primes[i] == 0){\n\t// \t\tdiv = primes[i];\n\t// \t\tbreak;\n\t//\
    \ \t}\n\t// }\n\t// return div;\n\tlong div = 2;\n\twhile(n > 1){\n\t\tif(n %\
    \ div == 0){\n\t\t\tn /= div;\n\t\t}else{\n\t\t\tdiv++;\n\t\t}\n\t}\n\treturn\
    \ div;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // test only odd numbers\n    for (long i = 3; i < n; i += 2) {\n\
    \        // we are checking if i is a factor of n\n        if (n % i == 0) {\n\
    \            // check if i is prime\n            long j;\n            for (j =\
    \ 3; j < i; j += 2) {\n                if (i % j == 0) {\n                   \
    \ break;\n                }\n            }\n            // i is prime\n      \
    \      if (j >= i) {\n                return i;\n            }\n        }\n  \
    \  }\n    // n is prime so return n\n    return n;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpfwgxcg10: /tmp/tmpfwgxcg10.cpp:31: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tassert(n > 1);\n\tlong factor = 0;\n\tlong p = 2;\n\twhile (n != 1)\
    \ {\n\t\twhile (n % p == 0) {\n\t\t\tn /= p;\n\t\t\tfactor = p;\n\t\t}\n\t\tp\
    \ += 1;\n\t}\n\treturn factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long d = 2;\n    while (n > 1) {\n        while (n % d == 0) {\n \
    \           n /= d;\n        }\n        d += 1;\n    }\n    return d - 1;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tfor (long i = 2; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\t\
    long p = n / i;\n\t\t\tif (p == 1) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (p\
    \ % i != 0) {\n\t\t\t\treturn largest_prime_factor(p);\n\t\t\t}\n\t\t}\n\t}\n\t\
    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpwcou0dtu: /tmp/tmpwcou0dtu.cpp:25: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n// TODO: implement this function\n  long largest = 2;\n  while (n % 2\
    \ == 0) {\n    n /= 2;\n  }\n  for (long d = 3; d * d <= n; d += 2) {\n    while\
    \ (n % d == 0) {\n      largest = d;\n      n /= d;\n    }\n  }\n  if (n > 2)\
    \ {\n    largest = n;\n  }\n  return largest;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long largestPrime = -1;\n  while (n % 2 == 0) {\n    largestPrime =\
    \ 2;\n    n >>= 1;\n  }\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while\
    \ (n % i == 0) {\n      largestPrime = i;\n      n = n / i;\n    }\n  }\n  if\
    \ (n > 2)\n    largestPrime = n;\n  return largestPrime;\n}\nint main() {\n  \
    \  auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Start with the smallest prime number, 2.\n\n    // We stop when\
    \ we find the largest prime factor (because we only\n    // generate primes in\
    \ increasing order).\n    // This is not the most efficient way to do this...\n\
    \    long largest_factor = 2;\n    long remaining = n;\n    // Check if remaining\
    \ is divisible by 2. If so, update largest_factor.\n    while (remaining % 2 ==\
    \ 0) {\n        largest_factor = 2;\n        remaining = remaining / 2;\n    }\n\
    \    // Loop over the remaining odd numbers up to sqrt(n).\n    for (long i =\
    \ 3; i * i <= remaining; i += 2) {\n        // Check if remaining is divisible\
    \ by i. If so, update largest_factor.\n        while (remaining % i == 0) {\n\
    \            largest_factor = i;\n            remaining = remaining / i;\n   \
    \     }\n    }\n    // If remaining is greater than 2, then it is the largest\
    \ prime factor.\n    if (remaining > 2) {\n        largest_factor = remaining;\n\
    \    }\n    return largest_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor=2;\n    while(n>largest_prime_factor){\n\
    \        if(n%largest_prime_factor==0){\n            n=n/largest_prime_factor;\n\
    \            largest_prime_factor=2;\n        }\n        else\n            largest_prime_factor++;\n\
    \    }\n    return largest_prime_factor;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n    \
    \        n /= i;\n        } else {\n            i++;\n        }\n    }\n    return\
    \ i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Your code here\n    long maxPrime = -1;\n    while (n % 2 == 0)\
    \ {\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <=\
    \ sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n\
    \            n = n / i;\n        }\n    }\n    if (n > 2)\n        maxPrime =\
    \ n;\n    return maxPrime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  //TODO: Implement me!\n  long i;\n  for(i=2;i<=n;i++){\n    if(n%i==0){\n\
    \      break;\n    }\n  }\n  long d = n/i;\n  return d;\n}\nint main() {\n   \
    \ auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "tmpdnjzgbn4: /tmp/tmpdnjzgbn4.cpp:22: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong prime=0;\n\tlong largest_prime=0;\n\tstd::vector<long> prime_factors;\n\
    \twhile(n%2==0){\n\t\tprime_factors.push_back(2);\n\t\tn=n/2;\n\t}\n\tfor(long\
    \ i=3;i<=sqrt(n);i=i+2){\n\t\twhile(n%i==0){\n\t\t\tprime_factors.push_back(i);\n\
    \t\t\tn=n/i;\n\t\t}\n\t}\n\tif(n>2){\n\t\tprime_factors.push_back(n);\n\t}\n\t\
    std::cout<<n<<std::endl;\n\tlargest_prime=prime_factors[prime_factors.size()-1];\n\
    \t// std::cout<<largest_prime<<std::endl;\n\treturn largest_prime;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: "5\n1\n7\n11\n29\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    // Find 2^a * d = n\n    long a = 0;\n    long\
    \ d = n;\n    while (d % 2 == 0) {\n        d /= 2;\n        a += 1;\n    }\n\
    \    // Now d is odd and by the fundamental theorem of arithmetic, it's a product\n\
    \    // of primes, which must be greater than two.\n    assert(d > 1);\n    //\
    \ If a > 0, the largest prime factor must be a power of two.\n    if (a > 0) {\n\
    \        return (1L << a);\n    }\n    // Try all the primes below 1000.\n   \
    \ for (long p = 3; p < 1000; p += 2) {\n        if (d % p == 0) {\n          \
    \  d /= p;\n            break;\n        }\n    }\n    // At this point, either\
    \ p was never a factor, or we have d = p * q, where\n    // p is the largest prime\
    \ factor and q is less than 1000. In the latter\n    // case, because q < 1000,\
    \ it must be a product of primes.\n    if (d < 1000) {\n        return d;\n  \
    \  }\n    // In the former case, the largest prime factor is p, the largest prime\n\
    \    // less than 1000.\n    return 999;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpjde7fy5o: /tmp/tmpjde7fy5o.cpp:44: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long result = 0;\n  while(n%2==0){\n    result = 2;\n    n=n/2;\n  }\n\
    \  for(long i=3;i<=sqrt(n);i+=2){\n    while(n%i==0){\n      result = i;\n   \
    \   n=n/i;\n    }\n  }\n  if(n>2){\n    result = n;\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long f = 2;\n  while (n != f) {\n    if (n % f == 0) {\n      n /= f;\n\
    \    } else {\n      f++;\n    }\n  }\n  return f;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long p = 1;\n    while (n%2 == 0) {\n        p = 2;\n        n /=\
    \ 2;\n    }\n    long d = 3;\n    while (d <= n) {\n        if (n%d == 0) {\n\
    \            p = d;\n            n /= d;\n        } else {\n            d += 2;\n\
    \        }\n    }\n    return p;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    int i = 2;\n    while (n > 1) {\n        while\
    \ (n % i == 0)\n            n /= i;\n        i++;\n    }\n    return i - 1;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    // Your code here\n    long long largestFactor\
    \ = 1;\n    long long divisor = 3;\n    while (n % 2 == 0) {\n        largestFactor\
    \ = 2;\n        n /= 2;\n    }\n    while (n != 1) {\n        while (n % divisor\
    \ == 0) {\n            largestFactor = divisor;\n            n /= divisor;\n \
    \       }\n        divisor += 2;\n    }\n    return largestFactor;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest = 0;\n    for (long i = 2; i < n; i++) {\n        if\
    \ (n % i == 0) {\n            largest = i;\n            while (n % i == 0) {\n\
    \                n /= i;\n            }\n        }\n    }\n    if (n > 1) {\n\
    \        largest = n;\n    }\n    return largest;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    int i;\n    for (i = 2; i <= n; i++) {\n        if (n % i == 0) {\n\
    \            n /= i;\n            i--;\n        }\n    }\n    return i;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Check for base cases\n    if (n == 1 || n == 2) {\n        return\
    \ n;\n    }\n    // Check if n is even\n    if (n % 2 == 0) {\n        return\
    \ largest_prime_factor(n / 2);\n    }\n    // All other cases are odd\n    for\
    \ (long i = 3; i <= sqrt(n); i+=2) {\n        if (n % i == 0) {\n            return\
    \ largest_prime_factor(n / i);\n        }\n    }\n    // Case where n is prime\n\
    \    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    int ret = -1;\n    for (int i = 2; i <= n / i; i++) {\n        while\
    \ (n % i == 0) {\n            ret = i;\n            n /= i;\n        }\n    }\n\
    \    if (n > 1)\n        ret = n;\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    long largest = 0;\n    while (n % 2 == 0) {\n\
    \        largest = 2;\n        n /= 2;\n    }\n    long i = 3;\n    while (i <=\
    \ n) {\n        if (n % i == 0) {\n            largest = i;\n            n /=\
    \ i;\n        } else {\n            i += 2;\n        }\n    }\n    return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long factor = 2;\n  while (n > 1) {\n    if (n % factor == 0) {\n  \
    \    n /= factor;\n    } else {\n      factor++;\n    }\n  }\n  return factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong x = 2;\n\twhile (n > 1) {\n\t\tif (n % x == 0) {\n\t\t\tn /= x;\n\
    \t\t} else {\n\t\t\tx++;\n\t\t}\n\t}\n\treturn x;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_factor = -1;\n    while (n % 2 == 0) {\n        largest_factor\
    \ = 2;\n        n /= 2;\n    }\n    for (int factor = 3; factor <= sqrt(n); factor\
    \ += 2) {\n        while (n % factor == 0) {\n            largest_factor = factor;\n\
    \            n /= factor;\n        }\n    }\n    if (n > 2) {\n        largest_factor\
    \ = n;\n    }\n    return largest_factor;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Fill in this function.\n    \n    long i=2;\n    while(i*i<=n){\n\
    \        if(n%i==0){\n            n=n/i;\n        }\n        else{\n         \
    \   i++;\n        }\n    }\n    return n;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // (5 points)\n    long i=2;\n    while(i<=n){\n        if(n%i==0){\n\
    \            n=n/i;\n        }\n        else{\n            i++;\n        }\n \
    \   }\n    return i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: write your implementation here\n    // see https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    assert(n>1);\n    // don't need to check 2 and 3\n    long factor = 2;\n\
    \    long largest_factor = 2;\n    long n_orig = n;\n    std::map<long, long>\
    \ prime_factor;\n    std::vector<long> prime_list;\n    // 2-3-5 wheel\n    //\
    \ wheel the factor 2,3,5, get the position\n    int wheel[] = {2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10};\n\
    \    int wheel_pos = 0;\n    while (true) {\n        // find the next prime factor\n\
    \        if (n % factor == 0) {\n            //std::cout << \"factor is \" <<\
    \ factor << std::endl;\n            if (prime_factor.find(factor) == prime_factor.end())\
    \ {\n                prime_factor[factor] = 1;\n                prime_list.push_back(factor);\n\
    \            } else {\n                prime_factor[factor]++;\n            }\n\
    \            n = n / factor;\n            //while (n % factor == 0) {\n      \
    \      //    n = n / factor;\n            //}\n            largest_factor = factor;\n\
    \        }\n        // if n is a prime factor, return\n        if (n == 1) {\n\
    \            //std::cout << \"largest factor is \" << largest_factor << std::endl;\n\
    \            //std::cout << \"prime factor is \" << std::endl;\n            //for\
    \ (auto& i : prime_factor) {\n            //    std::cout << i.first << \"^\"\
    \ << i.second << std::endl;\n            //}\n            //std::cout << \"prime\
    \ list is \" << std\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvtidomr6.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpvtidomr6.cpp:47:9: warning: empty parentheses were disambiguated\
    \ as a function declaration [-Wvexing-parse]\n   47 | int main() {\n      |  \
    \       ^~\n/tmp/tmpvtidomr6.cpp:47:9: note: remove parentheses to default-initialize\
    \ a variable\n   47 | int main() {\n      |         ^~\n      |         --\n/tmp/tmpvtidomr6.cpp:47:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmpvtidomr6.cpp:47:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   47 | int main() {\n      |            ^\n/tmp/tmpvtidomr6.cpp:54:2: error:\
    \ expected \u2018}\u2019 at end of input\n   54 | }\n      |  ^\n/tmp/tmpvtidomr6.cpp:22:18:\
    \ note: to match this \u2018{\u2019\n   22 |     while (true) {\n      |     \
    \             ^\n/tmp/tmpvtidomr6.cpp:54:2: error: expected \u2018}\u2019 at end\
    \ of input\n   54 | }\n      |  ^\n/tmp/tmpvtidomr6.cpp:8:35: note: to match this\
    \ \u2018{\u2019\n    8 | long largest_prime_factor(long n) {\n      |        \
    \                           ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long factor = 2;\n    while (n > 1) {\n        while (n % factor ==\
    \ 0) {\n            n /= factor;\n        }\n        factor++;\n    }\n    return\
    \ factor - 1;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n \
    \   assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n   \
    \ assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n   \
    \ assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong lpf = 0;\n\tfor (long i = 2; i <= n; i++) {\n\t\tif (n % i == 0)\
    \ {\n\t\t\tlpf = i;\n\t\t\tn /= i;\n\t\t\ti = 1;\n\t\t}\n\t}\n\treturn lpf;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor = 2;\n    long max = n;\n    long quotient\
    \ = 0;\n    long remainder = 0;\n    bool is_prime = true;\n    // while (n %\
    \ 2 == 0) {\n    //     n = n / 2;\n    // }\n    // if (n == 1) {\n    //   \
    \  return 2;\n    // }\n    for (long i = 3; i <= n; i += 2) {\n        is_prime\
    \ = true;\n        for (long j = 2; j < i; j++) {\n            if (i % j == 0)\
    \ {\n                is_prime = false;\n                break;\n            }\n\
    \        }\n        if (is_prime) {\n            std::cout << i << std::endl;\n\
    \            if (n % i == 0) {\n                quotient = n / i;\n          \
    \      remainder = n % i;\n                if (remainder == 0) {\n           \
    \         if (i > largest_prime_factor) {\n                        largest_prime_factor\
    \ = i;\n                    }\n                    n = quotient;\n           \
    \     }\n            }\n        }\n    }\n    return largest_prime_factor;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: "3\n5\n3\n5\n7\n3\n5\n7\n3\n5\n7\n11\n3\n5\n7\n11\n13\n17\n19\n23\n29\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    //YOUR CODE GOES HERE\n    long i;\n    for(i=2;i<n;i++)\n    {\n\
    \        if(n%i==0)\n        {\n            n=n/i;\n            i--;\n       \
    \ }\n    }\n    return i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long factor = n / 2;\n  while(factor > 1) {\n    if(n % factor == 0)\
    \ {\n      if(is_prime(factor))\n        return factor;\n    }\n    factor -=\
    \ 1;\n  }\n  assert(false);\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx_8sbuv3.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpx_8sbuv3.cpp:12:10: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   12 |       if(is_prime(factor))\n      |        \
    \  ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n % 2 == 0) {\n        return largest_prime_factor(n / 2);\n \
    \   }\n    for (long i = 3; i <= n; i += 2) {\n        if (n % i == 0) {\n   \
    \         return largest_prime_factor(n / i);\n        }\n    }\n    return n;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp7gten2eh: /tmp/tmp7gten2eh.cpp:21: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Try dividing n by 2, then 3, then 5, etc. until you find a factor.\n\
    \    long factor = 2;\n    while (n > 1) {\n        if (n % factor == 0) {\n \
    \           // n is divisible by factor. Divide it out as often as possible.\n\
    \            while (n % factor == 0) {\n                n /= factor;\n       \
    \     }\n            // If n is 1, we're done.\n            if (n == 1) {\n  \
    \              return factor;\n            }\n            // If n is not 1, we\
    \ need to try to divide it by something else.\n            // We will try to divide\
    \ it by primes.\n            // The next prime after factor is factor + 1, but\
    \ that's not a\n            // prime, so we'll try factor + 2, and then factor\
    \ + 4, etc.\n            // Keep adding 2 to factor until you get a prime.\n \
    \           factor += 2;\n            while (!is_prime(factor)) {\n          \
    \      factor += 2;\n            }\n        } else {\n            // n is not\
    \ divisible by factor. Try the next odd number.\n            factor += 2;\n  \
    \      }\n    }\n    return 0;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxjezs5p9.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpxjezs5p9.cpp:27:21: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   27 |             while (!is_prime(factor)) {\n  \
    \    |                     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest = 0;\n    // Is 2 the largest factor of n?\n    if (n\
    \ % 2 == 0)\n        largest = 2;\n    // Check for other factors.\n    for (long\
    \ i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            largest\
    \ = i;\n            while (n % i == 0)\n                n /= i;\n        }\n \
    \   }\n    // n is prime if n > 2, so it is the largest factor.\n    if (n > 2)\n\
    \        largest = n;\n    return largest;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpa6lfosq7: /tmp/tmpa6lfosq7.cpp:31: int main(): Assertion `candidate((330))\
    \ == (11)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong x = n;\n\tfor (long i = 2; i <= (n/2); i++) {\n\t\twhile (x % i\
    \ == 0) {\n\t\t\tx = x / i;\n\t\t}\n\t}\n\treturn x;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmprii7ysgv: /tmp/tmprii7ysgv.cpp:19: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor = 1;\n    long d = 2;\n    while (n > 1)\
    \ {\n        while (n % d == 0) {\n            largest_prime_factor = d;\n   \
    \         n /= d;\n        }\n        d = d + 1;\n        if (d*d > n) {\n   \
    \         if (n > 1) {\n                largest_prime_factor = n;\n          \
    \  }\n            break;\n        }\n    }\n    return largest_prime_factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\t// test all numbers from 2 up to n.\n\tfor (long factor = 2; factor\
    \ <= n; factor++) {\n\t\t// test if this factor is a prime number\n\t\tbool isPrime\
    \ = true;\n\t\tfor (long test = 2; test < factor; test++) {\n\t\t\tif (factor\
    \ % test == 0) {\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \t// if it is a prime factor, return it.\n\t\tif (isPrime && n % factor == 0)\
    \ {\n\t\t\treturn factor;\n\t\t}\n\t}\n\t// n should always have a prime factor\
    \ (it is composite), so this should not\n\t// be reached.\n\treturn -1;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpdqg4jke9: /tmp/tmpdqg4jke9.cpp:30: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Assume n > 1 and is not a prime.\n    assert(n > 1);\n    // Start\
    \ with n and keep halving the number until we get a prime number.\n    while (n\
    \ > 1) {\n        int factor = 2;\n        while (n % factor != 0) {\n       \
    \     factor += 1;\n        }\n        n /= factor;\n    }\n    return n;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp_46f2trv: /tmp/tmp_46f2trv.cpp:23: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long factor = 2;\n    long max_factor = 1;\n    long largest_prime_factor\
    \ = 1;\n    while (factor <= n) {\n        if (n % factor == 0) {\n          \
    \  if (is_prime(factor)) {\n                largest_prime_factor = factor;\n \
    \           }\n            max_factor = factor;\n            n /= factor;\n  \
    \      } else {\n            factor += 1;\n        }\n    }\n    return largest_prime_factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw5o6m4sq.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpw5o6m4sq.cpp:14:17: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   14 |             if (is_prime(factor)) {\n      |\
    \                 ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n      \
    \      if (is_prime(n / i)) {\n                return n / i;\n            }\n\
    \        }\n    }\n    assert(false);\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpja53y1wl.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpja53y1wl.cpp:11:17: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   11 |             if (is_prime(n / i)) {\n      |\
    \                 ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n == 1) {\n        return 1;\n    }\n    long largest_prime_factor\
    \ = 1;\n    for (long i = 2; i <= n; i++) {\n        if (n % i == 0) {\n     \
    \       n /= i;\n            largest_prime_factor = i;\n        }\n    }\n   \
    \ return largest_prime_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpjys2wp7f: /tmp/tmpjys2wp7f.cpp:24: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    for (long i = 2; i < n; i++) {\n        if (n\
    \ % i == 0) {\n            return largest_prime_factor(n / i);\n        }\n  \
    \  }\n    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long i;\n  long nn = n;\n  long max = -1;\n  for (i = 2; i <= nn; i++)\
    \ {\n    if (n % i == 0) {\n      n = n / i;\n      if (i > max)\n        max\
    \ = i;\n      i = 2;\n    }\n  }\n  return max;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\t//prime factor of n\n\t//always start by dividing by 2 to cancel out\
    \ 2s\n\t//71929 = 3 * 3 * 3 * 7 * 11 * 13\n\tint count = 0;\n\t//while n is divisible\
    \ by 2, divide by 2\n\twhile(n % 2 == 0){\n\t\tn = n / 2;\n\t\t//while n is divisible\
    \ by 2, divide by 2\n\t\twhile(n % 2 == 0){\n\t\t\tn = n / 2;\n\t\t}\n\t}\n\t\
    //now n is odd, and all factors of 2 have been removed\n\t//now check if n is\
    \ divisible by 3\n\tfor(int i = 3; i <= sqrt(n); i+=2){\n\t\twhile(n % i == 0){\n\
    \t\t\t//while n is divisible by i, divide by i\n\t\t\tn = n / i;\n\t\t}\n\t}\n\
    \t//if n is less than 2, return 2\n\tif(n < 2){\n\t\treturn 2;\n\t}\n\t//otherwise,\
    \ return n\n\treturn n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp1x5elet4: /tmp/tmp1x5elet4.cpp:39: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n > 1);\n  long largest = 0;\n  // Start with 2, because 1 is\
    \ not a prime number.\n  for (long i = 2; i <= n; i++) {\n    if (n % i == 0)\
    \ {\n      largest = i;\n      n /= i;\n      i = 1;\n    }\n  }\n  return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  for (long i = 2; i <= n; i++) {\n    if (n % i == 0) {\n      n /= i;\n\
    \      i--;\n    }\n  }\n  return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpacnwrl0j: /tmp/tmpacnwrl0j.cpp:19: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // TODO: Replace with your code.\n\tlong i;\n\tfor(i=2;i<n;i++)\n\t\
    {\n\t\tif(n%i==0)\n\t\t{\n\t\t\tn=n/i;\n\t\t\ti--;\n\t\t}\n\t}\n  return i;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: Implement this function.\n    if(n%2==0) n/=2;\n    for(long\
    \ i=3;i<=sqrt(n);i+=2){\n        if(n%i==0){\n            n/=i;\n            i=3;\n\
    \        }\n    }\n    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpq9vkyv6c: /tmp/tmpq9vkyv6c.cpp:22: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest = 2;\n\twhile (n > largest) {\n\t\tif (n % largest == 0)\
    \ {\n\t\t\tn /= largest;\n\t\t} else {\n\t\t\tlargest += 1;\n\t\t}\n\t}\n\treturn\
    \ largest;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i;\n    for (i = 2; i < n; i++) {\n        if (n % i == 0) {\n\
    \            return largest_prime_factor(n / i);\n        }\n    }\n    return\
    \ n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: Write code here.\n    long res=0;\n    if(n<=2)\n       \
    \ return res;\n    while(n%2==0)\n    {\n        res=2;\n        n/=2;\n    }\n\
    \    for(int i=3;i<=sqrt(n);i+=2)\n    {\n        while(n%i==0)\n        {\n \
    \           res=i;\n            n/=i;\n        }\n    }\n    if(n>2)\n       \
    \ res=n;\n    return res;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n % 2 == 0) {\n        return largest_prime_factor(n / 2);\n \
    \   }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n\
    \            return largest_prime_factor(n / i);\n        }\n    }\n    return\
    \ n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest_factor = -1;\n\tfor (long i = 2; i * i <= n; i++) {\n\t\
    \tif (n % i == 0) {\n\t\t\tlargest_factor = i;\n\t\t\twhile (n % i == 0) {\n\t\
    \t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t}\n\tif (n > 1) {\n\t\tlargest_factor = n;\n\t\
    }\n\treturn largest_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    std::vector<long> factors;\n    long d = 2;\n    while (n > 1) {\n\
    \        while (n % d == 0) {\n            factors.push_back(d);\n           \
    \ n /= d;\n        }\n        d += 1;\n    }\n    return factors.back();\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long largest_factor = 2;\n  while (n % 2 == 0) {\n    n /= 2;\n  }\n\
    \  for (long i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      largest_factor\
    \ = i;\n      n /= i;\n    }\n  }\n  if (n > 2) {\n    largest_factor = n;\n \
    \ }\n  return largest_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    return 0;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpqs73xdlu: /tmp/tmpqs73xdlu.cpp:13: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n      \
    \      return largest_prime_factor(n / i);\n        }\n    }\n    return n;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tstd::vector<long> prime_factors;\n\twhile(n % 2 == 0) {\n\t\tprime_factors.push_back(2);\n\
    \t\tn /= 2;\n\t}\n\tfor(long i = 3; i <= n; i += 2) {\n\t\twhile(n % i == 0) {\n\
    \t\t\tprime_factors.push_back(i);\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn prime_factors.back();\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n   assert(n > 1);\n   // Your Code\n   long prime_factor = -1;\n   for(long\
    \ i = 2; i <= n; ++i) {\n       if(n % i == 0) {\n           while(n % i == 0)\
    \ {\n               n /= i;\n           }\n           prime_factor = i;\n    \
    \   }\n   }\n   return prime_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\nlong factor=2;\nlong prime=1;\nwhile(n>1){\nif(n%factor==0){\nn=n/factor;\n\
    if(factor>prime){\nprime=factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp54xydoiz.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmp54xydoiz.cpp:17:9: warning: empty parentheses were disambiguated\
    \ as a function declaration [-Wvexing-parse]\n   17 | int main() {\n      |  \
    \       ^~\n/tmp/tmp54xydoiz.cpp:17:9: note: remove parentheses to default-initialize\
    \ a variable\n   17 | int main() {\n      |         ^~\n      |         --\n/tmp/tmp54xydoiz.cpp:17:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmp54xydoiz.cpp:17:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   17 | int main() {\n      |            ^\n/tmp/tmp54xydoiz.cpp:24:2: error:\
    \ expected \u2018}\u2019 at end of input\n   24 | }\n      |  ^\n/tmp/tmp54xydoiz.cpp:12:16:\
    \ note: to match this \u2018{\u2019\n   12 | if(n%factor==0){\n      |       \
    \         ^\n/tmp/tmp54xydoiz.cpp:24:2: error: expected \u2018}\u2019 at end of\
    \ input\n   24 | }\n      |  ^\n/tmp/tmp54xydoiz.cpp:11:11: note: to match this\
    \ \u2018{\u2019\n   11 | while(n>1){\n      |           ^\n/tmp/tmp54xydoiz.cpp:24:2:\
    \ error: expected \u2018}\u2019 at end of input\n   24 | }\n      |  ^\n/tmp/tmp54xydoiz.cpp:8:35:\
    \ note: to match this \u2018{\u2019\n    8 | long largest_prime_factor(long n)\
    \ {\n      |                                   ^\n/tmp/tmp54xydoiz.cpp:24:2: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   24 |\
    \ }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\t// Not a prime.\n\tassert(n > 1);\n\tlong largest = 1;\n\tlong f = 2;\n\
    \twhile (n > 1) {\n\t\tif (n % f == 0) {\n\t\t\tlargest = f;\n\t\t\tn /= f;\n\t\
    \t} else {\n\t\t\tf++;\n\t\t}\n\t}\n\treturn largest;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest = 1;\n\tfor (long i = 2; i <= n; i++) {\n\t\twhile (n %\
    \ i == 0) {\n\t\t\tn /= i;\n\t\t\tlargest = i;\n\t\t}\n\t}\n\treturn largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long max_prime = -1;\n  // check for every number up to sqrt(n) if it's\
    \ a prime factor\n  // if it is, check if it's larger than the last prime factor\n\
    \  // if it is, save it in max_prime\n  // return max_prime\n  for (long i = 2;\
    \ i <= (long)sqrt(n); i++) {\n    if (n % i == 0) {\n      bool prime = true;\n\
    \      for (long j = 2; j <= (long)sqrt(i); j++) {\n        if (i % j == 0) {\n\
    \          prime = false;\n          break;\n        }\n      }\n      if (prime\
    \ && i > max_prime) {\n        max_prime = i;\n      }\n    }\n  }\n  return max_prime;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmplpep0mdt: /tmp/tmplpep0mdt.cpp:32: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Write your code here.\n    int i;\n    for(i=2;i<=n;i++)\n    {\n\
    \        if(n%i==0)\n        {\n            n=n/i;\n            i--;\n       \
    \ }\n    }\n    return i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor = 2;\n    long i = 2;\n    while (i <= n)\
    \ {\n        if (n % i == 0) {\n            n /= i;\n            largest_prime_factor\
    \ = i;\n        } else {\n            i += 1;\n        }\n    }\n    return largest_prime_factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\t// Obvious exception:\n\tif (n < 2) return 0;\n\t// Eliminate all evens:\n\
    \twhile (n % 2 == 0) n /= 2;\n\t// Eliminate all factors of 3:\n\twhile (n % 3\
    \ == 0) n /= 3;\n\t// A factor of n must be less than sqrt(n), so we can stop\
    \ checking\n\t// at that point.\n\tlong max_prime_factor = (long) sqrt(n);\n\t\
    // Try to eliminate all factors of 5, then 7, etc.\n\tlong candidate = 5;\n\t\
    while (candidate <= max_prime_factor) {\n\t\twhile (n % candidate == 0) n /= candidate;\n\
    \t\tcandidate += 2;\n\t\twhile (n % candidate == 0) n /= candidate;\n\t\tcandidate\
    \ += 4;\n\t}\n\treturn n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpom3g0acf: /tmp/tmpom3g0acf.cpp:31: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest_prime = 1;\n\tlong i = 2;\n\tlong root = sqrt(n);\n\twhile\
    \ (i <= root) {\n\t\tif (n % i == 0) {\n\t\t\tlargest_prime = i;\n\t\t\tn /= i;\n\
    \t\t\troot = sqrt(n);\n\t\t}\n\t\ti += 1;\n\t}\n\treturn (n == 1) ? largest_prime\
    \ : n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpwoak25di: /tmp/tmpwoak25di.cpp:25: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long d = n;\n    for (long p = 2; p * p <= n; p++) {\n        if (n\
    \ % p == 0) {\n            d = p;\n            while (n % p == 0) {\n        \
    \        n /= p;\n            }\n        }\n    }\n    if (n > 1) {\n        d\
    \ = n;\n    }\n    return d;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  if (n == 2) return 2;\n  long largest = 0;\n  while (n % 2 == 0) {\n\
    \    largest = 2;\n    n /= 2;\n  }\n  // Now n is odd.\n  for (long i = 3; i\
    \ <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      largest = i;\n      n\
    \ /= i;\n    }\n  }\n  if (n > 2) largest = n;\n  return largest;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n   if (n == 1) {\n       return 1;\n   }\n   long largest = 1;\n   for\
    \ (long i = 2; i <= n; i++) {\n       if (n % i == 0) {\n           largest =\
    \ i;\n           n /= i;\n           i--;\n       }\n   }\n   return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long p = 2;\n    long largest = 1;\n    while (n > 1) {\n        while\
    \ (n % p == 0) {\n            largest = p;\n            n /= p;\n        }\n \
    \       p++;\n    }\n    return largest;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n      \
    \      n /= i;\n            i--;\n        }\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // assert(n > 1);\n  long factor = n;\n  while (factor > 1) {\n    int\
    \ i = 2;\n    while (i <= factor) {\n      if (factor % i == 0) {\n        factor\
    \ /= i;\n        break;\n      }\n      i++;\n    }\n  }\n  return factor;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpj2kepjv5: /tmp/tmpj2kepjv5.cpp:25: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long prime = 2;\n    while (n % prime != 0) {\n        prime++;\n\
    \    }\n    if (n == prime) {\n        return n;\n    }\n    return largest_prime_factor(n\
    \ / prime);\n}\nint main() {\n    auto candidate = largest_prime_factor;\n   \
    \ assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63))\
    \ == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n      \
    \      // If i is a factor of n, then n / i will be a factor of n.\n         \
    \   long f1 = i;\n            long f2 = n / i;\n            // Check if f1 and\
    \ f2 are prime.\n            // If they are not prime, then they will have a prime\
    \ factor\n            // less than f1 or f2.\n            // Notice that f1 <\
    \ f2.\n            // So we only need to check if f1 has a prime factor less than\
    \ f1.\n            if (largest_prime_factor(f1) == f1) {\n                return\
    \ f1;\n            }\n            else {\n                return largest_prime_factor(f2);\n\
    \            }\n        }\n    }\n    // If we cannot find a factor, then n must\
    \ be a prime.\n    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp87z6dooj: /tmp/tmp87z6dooj.cpp:32: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long end = floor(sqrt(n));\n    long current = 2;\n    while (current\
    \ < end) {\n        if (n % current == 0) {\n            if (is_prime(n / current))\
    \ {\n                return n / current;\n            }\n            return largest_prime_factor(n\
    \ / current);\n        }\n        current++;\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpzvl06uzy.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpzvl06uzy.cpp:13:17: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   13 |             if (is_prime(n / current)) {\n \
    \     |                 ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime = 1;\n    for (long i = 2; i <= n; i++) {\n   \
    \     if (n % i == 0) {\n            largest_prime = i;\n            while (n\
    \ % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    return\
    \ largest_prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // TODO: implement this function\n    int count = 0;\n    int i =\
    \ 2;\n    int output;\n    while (n!=1){\n        if (n%i==0){\n            output\
    \ = i;\n            n = n/i;\n            i = 2;\n        }else{\n           \
    \ i = i+1;\n        }\n    }\n    return output;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n % 2 == 0) {\n        n = n / 2;\n    }\n    long largest = 1;\n\
    \    for (long divisor = 3; divisor <= n; divisor += 2) {\n        if (n % divisor\
    \ == 0) {\n            largest = divisor;\n            n = n / divisor;\n    \
    \    }\n    }\n    return largest;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmppbrmhz4d: /tmp/tmppbrmhz4d.cpp:24: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n <= 1) {\n        return 0;\n    }\n\n    for (long i = 2; i\
    \ <= n; i++) {\n        if (n % i == 0) {\n            return std::max(i, largest_prime_factor(n\
    \ / i));\n        }\n    }\n\n    return 0;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long largest = 0;\n  while (n % 2 == 0) {\n    largest = 2;\n    n /=\
    \ 2;\n  }\n  for (long i = 3; i * i <= n; i += 2) {\n    while (n % i == 0) {\n\
    \      largest = i;\n      n /= i;\n    }\n  }\n  if (n > 2) {\n    largest =\
    \ n;\n  }\n  return largest;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long t = 2;\n    while (n > 1){\n        if (n % t == 0){\n      \
    \      n /= t;\n        } else {\n            t += 1;\n        }\n    }\n    return\
    \ t;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n   // assert(n > 1);\n   // assert(!is_prime(n));\n    for (long i = 2;\
    \ i < n; i++) {\n        if (n % i == 0) {\n            if (is_prime(i)) {\n \
    \               return i;\n            }\n        }\n    }\n    return n;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi17bfxhl.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmpi17bfxhl.cpp:13:17: error: \u2018is_prime\u2019 was not\
    \ declared in this scope\n   13 |             if (is_prime(i)) {\n      |    \
    \             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // This is a brute force solution. We could save time by working downwards\n\
    \  // from sqrt(n).\n  long largest_factor = 1;\n  long factor = 2;\n  while (n\
    \ > 1) {\n    while (n % factor == 0) {\n      largest_factor = factor;\n    \
    \  n /= factor;\n    }\n    factor += 1;\n  }\n  return largest_factor;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tstd::vector<long> small_primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 };\n\tfor (auto i : small_primes)\
    \ {\n\t\tif (n % i == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn n;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "tmp7exlkw29: /tmp/tmp7exlkw29.cpp:19: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i;\n    for (i = 2; i * i <= n; i++) {\n        while (n % i\
    \ == 0) {\n            n /= i;\n        }\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "tmpsvtzu7o5: /tmp/tmpsvtzu7o5.cpp:20: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n > 1);\n  long factor = 2;\n  while (n > 1) {\n    while (n\
    \ % factor == 0) {\n      n /= factor;\n    }\n    factor++;\n  }\n  return factor\
    \ - 1;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n > 1);\n  long factor = 2;\n  long last_factor = 1;\n  if (n\
    \ % 2 == 0) {\n    last_factor = 2;\n    n /= 2;\n    while (n % 2 == 0) {\n \
    \     n /= 2;\n    }\n  }\n  factor = 3;\n  double max_factor = sqrt(n);\n  while\
    \ (n > 1 && factor <= max_factor) {\n    if (n % factor == 0) {\n      n /= factor;\n\
    \      last_factor = factor;\n      while (n % factor == 0) {\n        n /= factor;\n\
    \      }\n      max_factor = sqrt(n);\n    }\n    factor += 2;\n  }\n  if (n ==\
    \ 1) {\n    return last_factor;\n  } else {\n    return n;\n  }\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong i;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\t\
    long factor = n / i;\n\t\t\tbool is_prime = true;\n\t\t\tlong j;\n\t\t\tfor (j\
    \ = 2; j <= factor; j++) {\n\t\t\t\tif (factor % j == 0) {\n\t\t\t\t\tis_prime\
    \ = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_prime) {\n\t\t\t\
    \treturn factor;\n\t\t\t}\n\t\t}\n\t}\n\treturn n;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpjx77eto3: /tmp/tmpjx77eto3.cpp:30: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // start with the lowest divisor, 2\n    long divisor = 2;\n    //\
    \ continue dividing by 2 as long as possible\n    while (n % divisor == 0) {\n\
    \        n /= divisor;\n    }\n    // If the number is now 1, it was previously\
    \ a power of 2 and thus 2 is the\n    // largest prime factor.\n    if (n == 1)\
    \ return divisor;\n    // Otherwise, the largest prime factor is >= 3 and < n.\n\
    \    divisor = 3;\n    // Continue dividing by consecutive odd numbers.\n    while\
    \ (n > 1) {\n        while (n % divisor == 0) {\n            n /= divisor;\n \
    \       }\n        divisor += 2;\n    }\n    // We're done.\n    return divisor\
    \ - 2;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i;\n    for (i = 2; i < sqrt(n) + 1; i++) {\n        if (n %\
    \ i == 0) {\n            return std::max(largest_prime_factor(n / i), largest_prime_factor(i));\n\
    \        }\n    }\n    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n// put your code here\n    assert(n>1);\n    long div = 2;\n    long largest\
    \ = 1;\n    while(n>1){\n        while(n%div == 0){\n            largest = div;\n\
    \            n = n/div;\n        }\n        div++;\n    }\n    return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\t// Start with 1.\n\tlong max_prime = 1;\n\t// Iterate from 2 until half\
    \ of n.\n\tfor (long i = 2; i < n / 2; i++) {\n\t\t// If i is a factor of n.\n\
    \t\tif (n % i == 0) {\n\t\t\t// Check if i is a prime.\n\t\t\tbool prime = true;\n\
    \t\t\tfor (long j = 2; j < i; j++) {\n\t\t\t\tif (i % j == 0) {\n\t\t\t\t\tprime\
    \ = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If prime, check if\
    \ i is the largest prime factor.\n\t\t\tif (prime && i > max_prime) {\n\t\t\t\t\
    max_prime = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_prime;\n}\nint main() {\n  \
    \  auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i = 2;\n    while (n % i != 0) {\n        i++;\n    }\n    if\
    \ (n == i) {\n        return n;\n    }\n    return largest_prime_factor(n / i);\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong i=2;\n\tlong largest=0;\n\twhile(i<=n){\n\t\tif(n%i==0){\n\t\t\t\
    n/=i;\n\t\t\tlargest=i;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    int i;\n    for (i = 2; i < n; i++) {\n        if (n % i == 0) {\n\
    \            n /= i;\n            i--;\n        }\n    }\n    return i;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Note: n is not a prime\n    for (long i = n / 2; i > 1; i--) {\n\
    \        if (n % i == 0) {\n            return largest_prime_factor(i);\n    \
    \    }\n    }\n    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest_prime = 1;\n\twhile (n % 2 == 0) {\n\t\tlargest_prime =\
    \ 2;\n\t\tn = n / 2;\n\t}\n\tlong factor = 3;\n\tlong max_factor = sqrt(n);\n\t\
    while (n > 1 && factor <= max_factor) {\n\t\tif (n % factor == 0) {\n\t\t\tlargest_prime\
    \ = factor;\n\t\t\tn = n / factor;\n\t\t\twhile (n % factor == 0) {\n\t\t\t\t\
    n = n / factor;\n\t\t\t}\n\t\t\tmax_factor = sqrt(n);\n\t\t}\n\t\tfactor = factor\
    \ + 2;\n\t}\n\tif (n == 1) {\n\t\treturn largest_prime;\n\t} else {\n\t\treturn\
    \ n;\n\t}\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    int lpf = 1;\n    for (int i = 2; i * i <= n;\
    \ i += 1) {\n        if (n % i == 0) {\n            lpf = i;\n            n /=\
    \ i;\n            // Early exit for a small (2^11) sample set.\n            if\
    \ (n == 1) {\n                return lpf;\n            }\n        }\n    }\n \
    \   return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n \
    \   assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n   \
    \ assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n   \
    \ assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpk5ughqq5: /tmp/tmpk5ughqq5.cpp:26: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n <= 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n \
    \       return largest_prime_factor(n / 2);\n    }\n    for (long i = 3; i <=\
    \ n / 2; i += 2) {\n        if (n % i == 0) {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    return n;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // TODO: implement me.\n  if(n%2==0)\n  {\n      while(n%2==0)\n   \
    \   {\n          n=n/2;\n      }\n  }\n  for(int i=3;i<=sqrt(n);i=i+2)\n  {\n\
    \      if(n%i==0)\n      {\n          while(n%i==0)\n          {\n           \
    \   n=n/i;\n          }\n      }\n  }\n  if(n>2)\n  {\n      return n;\n  }\n\
    \  return 0;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n  \
    \  assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63))\
    \ == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpjdvr0scg: /tmp/tmpjdvr0scg.cpp:36: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i=2;\n    while(n!=1){\n        if(n%i==0){\n            n/=i;\n\
    \        }\n        else{\n            i++;\n        }\n    }\n    return i;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tassert(n > 1);\n\t// Assume n is odd, so start at 3 and step by 2.\n\
    \tfor (long f = 3; f * f <= n; f += 2) {\n\t\tif (n % f == 0) {\n\t\t\tn /= f;\n\
    \t\t\twhile (n % f == 0) {\n\t\t\t\tn /= f;\n\t\t\t}\n\t\t}\n\t}\n\treturn n;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp3p6i2rcr: /tmp/tmp3p6i2rcr.cpp:24: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Iterate through potential factors and eliminate them as potential\
    \ factors.\n    long factor = 2;\n    while (n != 1) {\n        while (n % factor\
    \ == 0) {\n            n /= factor;\n        }\n        factor += 1;\n    }\n\
    \    return factor - 1;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long factor = 2;\n  while (n > 1) {\n    while (n % factor == 0) {\n\
    \      n /= factor;\n    }\n    factor += 1;\n  }\n  return factor - 1;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long count = 0;\n    for (long i = 2; i * i <= n; i++) {\n       \
    \ if (n % i == 0) {\n            count = i;\n            while (n % i == 0) {\n\
    \                n /= i;\n            }\n        }\n    }\n    if (n > 1)\n  \
    \      count = n;\n    return count;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    int res = 2;\n    while (n > res) {\n        if (n % res == 0) {\n\
    \            n /= res;\n        } else {\n            res++;\n        }\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // Check if n is a prime number.\n  if (n == 2 || n == 3) {\n    return\
    \ n;\n  }\n  //\n  long max_factor = 1;\n  // Start from 2, then check if current\
    \ number is a factor of n.\n  for (long factor = 2; factor * factor <= n; factor++)\
    \ {\n    if (n % factor == 0) {\n      // Check if factor is prime.\n      for\
    \ (long i = 2; i * i <= factor; i++) {\n        if (factor % i == 0) {\n     \
    \     break;\n        }\n        max_factor = factor;\n      }\n    }\n  }\n \
    \ return max_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpledp034e: /tmp/tmpledp034e.cpp:31: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // I'm pretty sure this is how it works.\n    long f = 2;\n    while\
    \ (f < n) {\n        if (n % f == 0) {\n            // f goes into n evenly.\n\
    \            n /= f;\n        } else {\n            // f does not go into n evenly,\
    \ increase f by 1.\n            f++;\n        }\n    }\n    return f;\n}\nint\
    \ main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long largest_factor;\n  // Note: return 2 if n == 2 or 3.\n  if (n %\
    \ 2 == 0) {\n    largest_factor = 2;\n    while (n % 2 == 0) {\n      n /= 2;\n\
    \    }\n  } else if (n % 3 == 0) {\n    largest_factor = 3;\n    while (n % 3\
    \ == 0) {\n      n /= 3;\n    }\n  } else {\n    largest_factor = 1;\n  }\n  //\
    \ Check odd numbers up to the square root of n\n  long factor = 5;\n  while (factor\
    \ <= std::sqrt(n)) {\n    if (n % factor == 0) {\n      n /= factor;\n      largest_factor\
    \ = factor;\n    } else if (n % (factor + 2) == 0) {\n      n /= factor + 2;\n\
    \      largest_factor = factor + 2;\n    }\n    factor += 6;\n  }\n  // If n is\
    \ a prime number, n will be the largest prime factor.\n  if (n != 1) {\n    largest_factor\
    \ = n;\n  }\n  return largest_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpgycn9w8d: /tmp/tmpgycn9w8d.cpp:47: int main(): Assertion `candidate((330))\
    \ == (11)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    long largest_prime_factor = 0;\n    for (long\
    \ i = 2; i <= n; i++) {\n        if (n % i == 0) {\n            largest_prime_factor\
    \ = i;\n            n /= i;\n            i = 2;\n        }\n    }\n    return\
    \ largest_prime_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long factors = 2;\n  long num = n;\n  // get all the factors of the\
    \ number\n  while (factors < num) {\n    if (num % factors == 0) {\n      num\
    \ = num / factors;\n    } else {\n      factors++;\n    }\n  }\n  return num;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest = -1;\n    while (n % 2 == 0) {\n        largest = 2;\n\
    \        n /= 2;\n    }\n    long p = 3;\n    while (n != 1) {\n        while\
    \ (n % p == 0) {\n            largest = p;\n            n /= p;\n        }\n \
    \       p += 2;\n    }\n    return largest;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong lpf = 1;\n\tif (n % 2 == 0) {\n\t\tlpf = 2;\n\t\twhile (n % 2 ==\
    \ 0) {\n\t\t\tn /= 2;\n\t\t}\n\t}\n\tfor (long i = 3; i <= sqrt(n); i += 2) {\n\
    \t\tif (n % i == 0) {\n\t\t\tlpf = i;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /=\
    \ i;\n\t\t\t}\n\t\t}\n\t}\n\treturn lpf;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpa06yhcte: /tmp/tmpa06yhcte.cpp:28: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong i;\n\tlong num = n;\n\tlong result = -1;\n\t// Find the largest\
    \ prime factor of n.\n\t// Reduce the number by the prime factor\n\t// Repeat\
    \ until the number is 1 or prime\n\tfor (i = 2; i <= n; i++) {\n\t\tif (n % i\
    \ == 0) {\n\t\t\tn = n / i;\n\t\t\tresult = i;\n\t\t\ti--;\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n>1);\n    long m=2;\n    while(m<n){\n        if(n%m==0){\n\
    \            n/=m;\n        }\n        else{\n            m++;\n        }\n  \
    \  }\n    return m;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest_prime = 0;\n\tlong factor = 2;\n\twhile (n > 1) {\n\t\t\
    while (n % factor == 0) {\n\t\t\tlargest_prime = factor;\n\t\t\tn /= factor;\n\
    \t\t}\n\t\tfactor += 1;\n\t}\n\treturn largest_prime;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tif (n % 2 == 0) {\n\t\tn /= 2;\n\t\twhile (n % 2 == 0) {\n\t\t\tn /=\
    \ 2;\n\t\t}\n\t}\n\tif (n % 3 == 0) {\n\t\tn /= 3;\n\t\twhile (n % 3 == 0) {\n\
    \t\t\tn /= 3;\n\t\t}\n\t}\n\tlong i = 5;\n\twhile (n >= i * i) {\n\t\tif (n %\
    \ i == 0) {\n\t\t\tn /= i;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\
    }\n\t\t}\n\t\ti += 2;\n\t\tif (n % i == 0) {\n\t\t\tn /= i;\n\t\t\twhile (n %\
    \ i == 0) {\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\t\ti += 4;\n\t}\n\treturn n;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpbu22umpe: /tmp/tmpbu22umpe.cpp:43: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest = -1;\n    long factor = 2;\n    while (n > 1) {\n  \
    \      if (n % factor == 0) {\n            largest = factor;\n            n /=\
    \ factor;\n            while (n % factor == 0) {\n                n /= factor;\n\
    \            }\n        }\n        factor += 1;\n    }\n    return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n < 2) return 0;\n    long div = 2;\n    while (n % div != 0)\
    \ div++;\n    if (n == div) return n;\n    long pf = largest_prime_factor(n /\
    \ div);\n    return (pf > div) ? pf : div;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n    \
    \        n /= i;\n        } else {\n            i += 1;\n        }\n    }\n  \
    \  return i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n  \
    \  assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63))\
    \ == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime = -1;\n    while (n % 2 == 0) {\n        largest_prime\
    \ = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n\
    \        while (n % i == 0) {\n            largest_prime = i;\n            n =\
    \ n / i;\n        }\n    }\n    if (n > 2)\n        largest_prime = n;\n    return\
    \ largest_prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n == 2) return 2;\n    else if (n % 2 == 0) return largest_prime_factor(n\
    \ / 2);\n    else {\n        for (long i = 3; i < n; i += 2) {\n            if\
    \ (n % i == 0) return largest_prime_factor(n / i);\n        }\n        return\
    \ n;\n    }\n}\nint main() {\n    auto candidate = largest_prime_factor;\n   \
    \ assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63))\
    \ == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor = 0;\n    int i = 1;\n    while (i <= n)\
    \ {\n        if (n % i == 0) {\n            int counter = 0;\n            for\
    \ (int j = 1; j <= i; j++) {\n                if (i % j == 0) {\n            \
    \        counter++;\n                }\n            }\n            if (counter\
    \ == 2) {\n                largest_prime_factor = i;\n            }\n        }\n\
    \        i++;\n    }\n    return largest_prime_factor;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Your code here.\n    long k=2;\n    while(n>1){\n        if(n%k==0){\n\
    \            n=n/k;\n        }\n        else{\n            k++;\n        }\n \
    \   }\n    return k;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n      \
    \      return largest_prime_factor(n / i);\n        }\n    }\n    return n;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tassert(n > 1);\n\tfor (long i = 2; i <= std::sqrt(n); i++) {\n\t\tif\
    \ (n % i == 0) {\n\t\t\treturn std::max(largest_prime_factor(n / i), largest_prime_factor(i));\n\
    \t\t}\n\t}\n\treturn n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long ans = -1;\n    long p = 2;\n    while (p*p <= n) {\n        if\
    \ (n % p == 0) {\n            ans = p;\n            while (n % p == 0) n /= p;\n\
    \        }\n        p++;\n    }\n    if (n > 1) ans = n;\n    return ans;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long i = 2;\n  while (n > 1) {\n    while (n % i == 0) {\n      n /=\
    \ i;\n    }\n    i++;\n  }\n  return i-1;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong divisor = 2;\n\tlong result = 1;\n\tlong remainder = n;\n\twhile\
    \ (remainder > 1) {\n\t\t// If our current divisor is a factor of the current\
    \ remainder, divide out all instances of that factor,\n\t\t// and update the result\
    \ and remainder.\n\t\tif (remainder % divisor == 0) {\n\t\t\tremainder /= divisor;\n\
    \t\t\tresult = divisor;\n\t\t}\n\t\t// Otherwise move on to the next divisor.\n\
    \t\telse {\n\t\t\tdivisor++;\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n\
    \    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime = -1;\n    while (n % 2 == 0) {\n        largest_prime\
    \ = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n\
    \        while (n % i == 0) {\n            largest_prime = i;\n            n =\
    \ n / i;\n        }\n    }\n    if (n > 2)\n        largest_prime = n;\n    return\
    \ largest_prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_prime_factor = 2;\n    while (n % 2 == 0) {\n       \
    \ n = n / 2;\n    }\n    for (long i = 3; i <= n; i = i + 2) {\n        if (n\
    \ % i == 0) {\n            n = n / i;\n            largest_prime_factor = i;\n\
    \        }\n    }\n    return largest_prime_factor;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp78uui4os: /tmp/tmp78uui4os.cpp:24: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // // implement this function\n    // long prime = 1;\n    // for\
    \ (long i = 2; i <= sqrt(n); i++) {\n    //     if (n % i == 0) {\n    //    \
    \     prime = i;\n    //         break;\n    //     }\n    // }\n    // return\
    \ prime;\n    long prime = 1;\n    for (long i = 2; i <= sqrt(n); i++) {\n   \
    \     if (n % i == 0) {\n            while (n % i == 0) {\n                n /=\
    \ i;\n            }\n            prime = i;\n        }\n    }\n    if (n > 1)\
    \ prime = n;\n    return prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    return n;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpm34uszfc: /tmp/tmpm34uszfc.cpp:13: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  int largest = -1;\n  for (int i = 2; i <= n; i++) {\n    while (n %\
    \ i == 0) {\n      largest = i;\n      n /= i;\n    }\n  }\n  return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    ////////////////start//////////////////\n    std::vector<long> factors;\n\
    \    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {\n            factors.push_back(i);\n\
    \        }\n    }\n    std::sort(factors.begin(), factors.end());\n    for (auto\
    \ it = factors.rbegin(); it != factors.rend(); it++) {\n        bool flag = true;\n\
    \        for (long i = 2; i < *it; i++) {\n            if (*it % i == 0) {\n \
    \               flag = false;\n                break;\n            }\n       \
    \ }\n        if (flag) return *it;\n    }\n    ///////////////end////////////////////\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    // Insert your code here.\n    int i;\n    for(i=2;i<n;i++)\n    {\n\
    \        if(n%i==0)\n        {\n            break;\n        }\n    }\n    return\
    \ i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp68qwpdh2: /tmp/tmp68qwpdh2.cpp:22: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n// TODO: Implement Me\n// Initialize lpf as 1\nlong lpf = 1;\n// Write\
    \ a loop that divides n by 2, 3, 4, ...\n// Stop when n becomes 1.\n// If n is\
    \ not divisible by the current factor,\n// skip the iteration.\n// Update lpf\
    \ with the current factor.\nwhile (n != 1) {\nlong factor = 1;\nwhile (n % factor\
    \ == 0) {\nn /= factor;\nlpf = factor;\n}\nint main() {\n    auto candidate =\
    \ largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1y97y_ln.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmp1y97y_ln.cpp:23:9: warning: empty parentheses were disambiguated\
    \ as a function declaration [-Wvexing-parse]\n   23 | int main() {\n      |  \
    \       ^~\n/tmp/tmp1y97y_ln.cpp:23:9: note: remove parentheses to default-initialize\
    \ a variable\n   23 | int main() {\n      |         ^~\n      |         --\n/tmp/tmp1y97y_ln.cpp:23:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmp1y97y_ln.cpp:23:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   23 | int main() {\n      |            ^\n/tmp/tmp1y97y_ln.cpp:30:2: error:\
    \ expected \u2018}\u2019 at end of input\n   30 | }\n      |  ^\n/tmp/tmp1y97y_ln.cpp:17:16:\
    \ note: to match this \u2018{\u2019\n   17 | while (n != 1) {\n      |       \
    \         ^\n/tmp/tmp1y97y_ln.cpp:30:2: error: expected \u2018}\u2019 at end of\
    \ input\n   30 | }\n      |  ^\n/tmp/tmp1y97y_ln.cpp:8:35: note: to match this\
    \ \u2018{\u2019\n    8 | long largest_prime_factor(long n) {\n      |        \
    \                           ^\n/tmp/tmp1y97y_ln.cpp:30:2: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   30 | }\n      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  // We begin with 2, and increment it until we find the largest prime\
    \ factor.\n  // This is not an optimal solution, which is left as an exercise.\n\
    \  long p = 2;\n  while (p < n) {\n    if (n % p == 0) {\n      n /= p;\n    }\
    \ else {\n      p++;\n    }\n  }\n  return p;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    int i = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n     \
    \       n /= i;\n        } else {\n            i++;\n        }\n    }\n    return\
    \ i;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long ans = 0;\n  for (long i = 2; i < n; i++) {\n    if (n % i == 0)\
    \ {\n      ans = i;\n      n /= i;\n      i--;\n    }\n  }\n  if (n > 1) {\n \
    \   ans = n;\n  }\n  return ans;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      n\
    \ /= i;\n    } else {\n      i += 1;\n    }\n  }\n  return n;\n}\nint main() {\n\
    \    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long x = 2;\n    while (x <= n) {\n        if (n % x == 0)\n     \
    \       n /= x;\n        else\n            x += 1;\n    }\n    return x;\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n// This assertion checks that the input is valid.\n// If it fails, the\
    \ program will exit with failure.\nassert(n > 1);\n// ...\nreturn 0;\n}\nint main()\
    \ {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) ==\
    \ (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
    \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: "tmphfqox3di: /tmp/tmphfqox3di.cpp:17: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong largest = 2;\n\tfor (long i = 2; i < n; i++) {\n\t\tif (n % i ==\
    \ 0) {\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t\tlargest = i;\n\t\t}\n\
    \t}\n\treturn largest;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpruikmnq5: /tmp/tmpruikmnq5.cpp:21: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n// write the function here\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmpeluiyuvt: /tmp/tmpeluiyuvt.cpp:13: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_factor = 2;\n    while (n % 2 == 0) {\n        n = n\
    \ / 2;\n    }\n    // No need to worry about evens.\n    for (long i = 3; i <=\
    \ sqrt(n); i = i + 2) {\n        // Check if i is a factor.\n        while (n\
    \ % i == 0) {\n            largest_factor = i;\n            n = n / i;\n     \
    \   }\n    }\n    // Is the number itself a prime?\n    if (n > 2) {\n       \
    \ largest_factor = n;\n    }\n    return largest_factor;\n}\nint main() {\n  \
    \  auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    //if (n % 2 == 0)\n    //    return 2;\n    long\
    \ factor = 0;\n    while (n % 2 == 0) {\n        n /= 2;\n        factor = 2;\n\
    \    }\n    for (long i = 3; i < n + 1; i += 2) {\n        if (n % i == 0) {\n\
    \            n /= i;\n            factor = i;\n        }\n    }\n    return factor;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp69jvt1ln: /tmp/tmp69jvt1ln.cpp:28: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    std::vector<long> factor;\n    long i;\n    for (i = 2; i < n; i++)\
    \ {\n        if (n % i == 0) {\n            factor.push_back(i);\n           \
    \ n /= i;\n            i = 2;\n        }\n    }\n    return factor.back();\n}\n\
    int main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmpapsghkzc: /tmp/tmpapsghkzc.cpp:22: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong i = 2;\n\twhile (i * i <= n) {\n\t\tif (n % i == 0) {\n\t\t\tn\
    \ /= i;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn n;\n}\nint main() {\n\
    \    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n\
    \    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n  \
    \  assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n\tlong d = 2;\n\twhile (n > 1) {\n\t\twhile (n % d == 0) {\n\t\t\tn /=\
    \ d;\n\t\t}\n\t\td += 1;\n\t}\n\treturn d - 1;\n}\nint main() {\n    auto candidate\
    \ = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27))\
    \ == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) ==\
    \ (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest = -1;\n    for (long i = 2; i <= n / i; i++) {\n    \
    \    while (n % i == 0) {\n            largest = i;\n            n /= i;\n   \
    \     }\n    }\n    if (n > 1) {\n        largest = n;\n    }\n    return largest;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    assert(n > 1);\n    int max_prime = -1;\n    while (n % 2 == 0) {\n\
    \        max_prime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n);\
    \ i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n      \
    \      n = n / i;\n        }\n    }\n    if (n > 2)\n        max_prime = n;\n\
    \    return max_prime;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  assert(n > 1);\n  for (long i = 2; i < n; i++) {\n    if (n % i == 0)\
    \ {\n      long j = n / i;\n      if (j == 1) {\n        return i;\n      } else\
    \ {\n        return largest_prime_factor(j);\n      }\n    }\n  }\n  return -1;\n\
    }\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
    \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) ==\
    \ (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195))\
    \ == (29));\n}\n"
  stdout: ''
  stderr: "tmp57zz3ywl: /tmp/tmp57zz3ywl.cpp:24: int main(): Assertion `candidate((15))\
    \ == (5)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long largest_factor = 1;\n    while (n % 2 == 0) {\n        largest_factor\
    \ = 2;\n        n /= 2;\n    }\n    for (long i = 3; i <= std::sqrt(n); i += 2)\
    \ {\n        while (n % i == 0) {\n            largest_factor = i;\n         \
    \   n /= i;\n        }\n    }\n    if (n > 2) {\n        largest_factor = n;\n\
    \    }\n    return largest_factor;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    if (n <= 1) {\n        return -1;\n    }\n    if (n == 2) {\n    \
    \    return 2;\n    }\n    int ans = -1;\n    while (n % 2 == 0) {\n        n\
    \ /= 2;\n    }\n    int sqrt_n = (int)sqrt(n);\n    for (int i = 3; i <= sqrt_n;\
    \ i += 2) {\n        if (n % i == 0) {\n            ans = std::max(ans, i);\n\
    \            while (n % i == 0) {\n                n /= i;\n            }\n  \
    \      }\n    }\n    if (n != 1) {\n        ans = std::max(ans, n);\n    }\n \
    \   return ans;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "/tmp/tmponb3z6ui.cpp: In function \u2018long int largest_prime_factor(long\
    \ int)\u2019:\n/tmp/tmponb3z6ui.cpp:29:23: error: no matching function for call\
    \ to \u2018max(int&, long int&)\u2019\n   29 |         ans = std::max(ans, n);\n\
    \      |               ~~~~~~~~^~~~~~~~\nIn file included from /usr/include/c++/11/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/11/cmath:1935,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:41,\n                 from\
    \ /tmp/tmponb3z6ui.cpp:2:\n/usr/include/c++/11/bits/stl_algobase.h:254:5: note:\
    \ candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const _Tp&,\
    \ const _Tp&)\u2019\n  254 |     max(const _Tp& __a, const _Tp& __b)\n      |\
    \     ^~~\n/usr/include/c++/11/bits/stl_algobase.h:254:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmponb3z6ui.cpp:29:23: note:   deduced\
    \ conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019 and \u2018\
    long int\u2019)\n   29 |         ans = std::max(ans, n);\n      |            \
    \   ~~~~~~~~^~~~~~~~\nIn file included from /usr/include/c++/11/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/11/cmath:1935,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:41,\n                 from\
    \ /tmp/tmponb3z6ui.cpp:2:\n/usr/include/c++/11/bits/stl_algobase.h:300:5: note:\
    \ candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&, _Compare)\u2019\n  300 |     max(const _Tp& __a, const _Tp&\
    \ __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/11/bits/stl_algobase.h:300:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmponb3z6ui.cpp:29:23:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018long int\u2019)\n   29 |         ans = std::max(ans, n);\n\
    \      |               ~~~~~~~~^~~~~~~~\nIn file included from /usr/include/c++/11/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:65,\n\
    \                 from /tmp/tmponb3z6ui.cpp:2:\n/usr/include/c++/11/bits/stl_algo.h:3461:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr _Tp std::max(st"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n    long i;\n    while (n % 2 == 0) {\n        n = n / 2;\n    }\n   \
    \ for (i = 3; i <= sqrt(n); i = i + 2) {\n        while (n % i == 0) {\n     \
    \       n = n / i;\n        }\n    }\n    if (n > 2) {\n        return n;\n  \
    \  }\n    return 2;\n}\nint main() {\n    auto candidate = largest_prime_factor;\n\
    \    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n  \
    \  assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n  \
    \  assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: "tmp8yqb5njx: /tmp/tmp8yqb5njx.cpp:26: int main(): Assertion `candidate((27))\
    \ == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
    // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long\
    \ n) {\n  long i = 2;\n  while (i < n) {\n    if (n % i == 0) {\n      n /= i;\n\
    \    } else {\n      i += 1;\n    }\n  }\n  return n;\n}\nint main() {\n    auto\
    \ candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n   \
    \ assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330))\
    \ == (11));\n    assert(candidate((13195)) == (29));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
