language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\t// Write your code here\n\tint v1 = (int) value[0] - 48;\n\tint\
    \ v2 = (int) value[2] - 48;\n\tint sum = v1 * 10 + v2;\n\t//cout << sum << endl;\n\
    \tif (sum <= 15)\n\t\treturn 10;\n\telse\n\t\treturn 15;\n}\nint main() {\n  \
    \  auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnpomsju7: /tmp/tmpnpomsju7.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\t// TODO: convert string value to integer, using std::atoi\n\tint\
    \ num_int = std::atoi(value.c_str());\n\t// TODO: compare num_int to the next\
    \ highest integer\n\t//       and the next lowest integer to see which one\n\t\
    //       is closer to num_int\n\tif (num_int < std::atoi(value.c_str() + 1)) {\n\
    \t\treturn num_int;\n\t}\n\treturn num_int + 1;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpuo_9gpw2: /tmp/tmpuo_9gpw2.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  char temp[100];\n  float number = atof(value.c_str());\n  float\
    \ n = number - (int)number;\n  if(n >= 0.5) return (int)number + 1;\n  else return\
    \ (int)number;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpo2xzovh3: /tmp/tmpo2xzovh3.cpp:27: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\treturn std::stol(value);\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwao8wznb: /tmp/tmpwao8wznb.cpp:22: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = stod(value);\n    double d2 = round(d);\n    // cout\
    \ << d2 << endl;\n    return d2;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  //your code here\n  return round(stod(value));\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141430
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long result;\n    // TODO: Write code to implement this function\n\
    \    float fl = stof(value);\n    float delta = fl - floor(fl);\n    if (delta\
    \ < 0.5) {\n        result = floor(fl);\n    } else {\n        result = ceil(fl);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_lo_macg: /tmp/tmp_lo_macg.cpp:32: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    if(value[0] == '-')\n        return ceil(std::stod(value)) < floor(std::stod(value))\
    \ ? ceil(std::stod(value)) : floor(std::stod(value));\n    else\n        return\
    \ floor(std::stod(value)) < ceil(std::stod(value)) ? ceil(std::stod(value)) :\
    \ floor(std::stod(value));\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyiet6r31: /tmp/tmpyiet6r31.cpp:27: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::string str;\n  int i = 0;\n  int flag = 0;\n  int decimal_count\
    \ = 0;\n  for(char c : value) {\n    if(c == '.') {\n      flag = 1;\n      decimal_count++;\n\
    \    }\n    if(decimal_count > 1) {\n      return -1;\n    }\n    if(flag && c\
    \ == '.') {\n      break;\n    }\n    if(flag) {\n      str += c;\n    }\n   \
    \ i++;\n  }\n  if(str.size() == 0) {\n    return atoi(value.c_str());\n  }\n \
    \ if(str.size() > 2) {\n    return -1;\n  }\n  i--;\n  long decimal_part = atoi(str.c_str());\n\
    \  long integer_part = atoi(value.substr(0, i).c_str());\n  if(decimal_part >=\
    \ 50) {\n    return integer_part + 1;\n  }\n  else {\n    return integer_part;\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1h9fsrpz: /tmp/tmp1h9fsrpz.cpp:56: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double n=std::stod(value);\n  //return (n>0)?((long)n+(long)n+1)/2:(double)n>((double)n+1-n/2)?(long)n+1:(long)n;\n\
    \  return n>0?(long)std::ceil(n):(long)std::floor(n);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpzbjjk6b5: /tmp/tmpzbjjk6b5.cpp:26: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141430
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double parsed = std::stod(value);\n    long rounded = std::round(parsed);\n\
    \    if (parsed != rounded) {\n        return rounded;\n    }\n    else {\n  \
    \      if (parsed >= 0) {\n            return parsed + 1;\n        }\n       \
    \ else {\n            return parsed - 1;\n        }\n    }\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnl6z7vw2: /tmp/tmpnl6z7vw2.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  return 0;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3ombc_nv: /tmp/tmp3ombc_nv.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double a = std::stod(value);\n    int c = std::round(a);\n   \
    \ return c;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141430
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long result = 0;\n    double number = stod(value);\n    if (number\
    \ >= 0) {\n        result = (long) number;\n        if (number-result >= 0.5)\
    \ {\n            result++;\n        }\n    } else {\n        result = (long) number;\n\
    \        if (result-number >= 0.5) {\n            result--;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tint integerValue = std::stoi(value);\n\tint decimalValue = value.find('.');\n\
    \tif (decimalValue == -1) {\n\t\treturn integerValue;\n\t}\n\tint nextDigit =\
    \ value[decimalValue + 1] - '0';\n\tif (nextDigit < 5) {\n\t\treturn integerValue;\n\
    \t}\n\treturn integerValue + 1;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_85lhmb2: /tmp/tmp_85lhmb2.cpp:32: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\t// TODO: Implement me\n\tint num = std::stoi(value);\n\tdouble num1\
    \ = std::stod(value);\n\tif(num1 >= num)\n\t\treturn num;\n\telse\n\t\treturn\
    \ num - 1;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpx60lalp9: /tmp/tmpx60lalp9.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // return std::stol(value);\n    return lround(std::stod(value));\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tlong num = std::stol(value);\n\tlong num2 = num + 1;\n\tlong num3\
    \ = num - 1;\n\tif (std::to_string(num).size() == std::to_string(num2).size())\
    \ {\n\t\treturn num;\n\t}\n\treturn num2;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph9fdsefx: /tmp/tmph9fdsefx.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\t// remove the decimal and convert to integer\n\tlong intvalue =\
    \ std::stol(value.substr(0, value.find('.')));\n\tdouble decimalvalue = std::stod(value.substr(value.find('.')));\n\
    \t// if the decimal is not zero then return the closest integer\n\tif (decimalvalue\
    \ > 0.5) {\n\t\treturn ++intvalue;\n\t} else if (decimalvalue < -0.5) {\n\t\t\
    return --intvalue;\n\t} else {\n\t\treturn intvalue;\n\t}\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 2)\n"
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int i = value.find('.');\n  if (i == std::string::npos) {\n    //\
    \ no fractional part, so return the value.\n    return std::stol(value);\n  }\n\
    \  // check if there is a fractional part.\n  value.erase(i, 1);\n  if (i == value.size()\
    \ - 1) {\n    // there was a fractional part, but it was zero.\n    return std::stol(value);\n\
    \  }\n  // if there is a fractional part, we need to determine if we are\n  //\
    \ rounding up or down.\n  // first, determine if we are rounding away from zero.\n\
    \  int value_int = std::stol(value);\n  if (value_int < 0) {\n    // the value\
    \ is negative, so we round towards zero.\n    return value_int;\n  }\n  // now,\
    \ determine which direction to round.\n  int fractional_part = std::stol(value.substr(i\
    \ + 1));\n  if (fractional_part < 5) {\n    // if the fractional part is less\
    \ than five, round down.\n    return value_int;\n  }\n  if (fractional_part >\
    \ 5) {\n    // if the fractional part is greater than five, round up.\n    return\
    \ value_int + 1;\n  }\n  // if the fractional part is equal to five, need to round\
    \ to the\n  // closest even number.\n  if (value_int % 2 == 0) {\n    // if the\
    \ fractional part is five and the integer part is even,\n    // round down.\n\
    \    return value_int;\n  }\n  // if the fractional part is five and the integer\
    \ part is odd,\n  // round up.\n  return value_int + 1;\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqwvdc0c7: /tmp/tmpqwvdc0c7.cpp:60: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tfloat floatValue = std::stof(value);\n\tint out;\n\tif (floatValue\
    \ < 0) {\n\t\tout = floatValue - 0.5;\n\t} else {\n\t\tout = floatValue + 0.5;\n\
    \t}\n\treturn out;\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  assert(value.size() > 0);\n  double d = std::stod(value);\n  double\
    \ diff = d - (long)d;\n  return diff < 0.5 ? (long)d : (long)d + 1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpefxsag3u: /tmp/tmpefxsag3u.cpp:26: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    //return std::stol(value);\n    long int rv = std::stol(value);\n\
    \    double fv = std::stod(value);\n    if (fv - rv >= 0.5) {\n        return\
    \ rv + 1;\n    }\n    return rv;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpawuttx0i: /tmp/tmpawuttx0i.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  float number = atof(value.c_str());\n  float rounded = 0;\n  if\
    \ (number > 0)\n    rounded = floor(number + 0.5);\n  else\n    rounded = ceil(number\
    \ - 0.5);\n  return (long)rounded;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141430
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::size_t found = value.find(\".\");\n  if (found != std::string::npos)\
    \ {\n    if (int(value[found + 1]) > 5) {\n      value[found - 1]++;\n    }\n\
    \    value.resize(found);\n  }\n  return std::stol(value);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptx8i78ch: /tmp/tmptx8i78ch.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  return std::round(std::stold(value));\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long x=stol(value);\n  return x%1>=0.5?x+1:x;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpabzt40fd: /tmp/tmpabzt40fd.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // Write your code here...\n  double temp = std::stod(value);\n\
    \  int i = temp;\n  if(temp-i >= 0.5)\n    i++;\n  return i;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5palwvf2: /tmp/tmp5palwvf2.cpp:28: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  return num > 0 ? std::ceil(num)\
    \ : std::floor(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcfixqef1: /tmp/tmpcfixqef1.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double v = std::stod(value);\n  if (v > 0)\n    return ceil(v);\n\
    \  else\n    return floor(v);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbkjtd2y2: /tmp/tmpbkjtd2y2.cpp:28: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // Good luck!\n  std::stringstream ss(value);\n  double temp;\n\
    \  ss >> temp;\n  return ceil(temp);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpe3tdtbsu: /tmp/tmpe3tdtbsu.cpp:27: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long result = std::round(std::stod(value));\n    return result;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble x = std::stod(value);\n\treturn lround(x);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::string decimal;\n  std::string integer;\n  if (value.find('.')\
    \ != std::string::npos) {\n    integer = value.substr(0, value.find('.'));\n \
    \   decimal = value.substr(value.find('.') + 1);\n  } else {\n    integer = value;\n\
    \  }\n  long int_value = std::stol(integer);\n  if (decimal.empty()) {\n    return\
    \ int_value;\n  }\n  if (decimal[0] >= '5') {\n    return int_value + 1;\n  }\n\
    \  return int_value;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfjk3dxy0: /tmp/tmpfjk3dxy0.cpp:38: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::cout << \"Input value is \" << value << std::endl;\n  int i\
    \ = 0;\n  bool is_neg = false;\n  double num = 0;\n  if (value[0] == '-') {\n\
    \    i = 1;\n    is_neg = true;\n  }\n  while (i < value.length()) {\n    if (value[i]\
    \ == '.') {\n      break;\n    }\n    num = num * 10 + (value[i] - '0');\n   \
    \ i++;\n  }\n  if (i == value.length()) {\n    if (is_neg) {\n      return -num;\n\
    \    }\n    return num;\n  }\n  i++;\n  double dec = 0.1;\n  while (i < value.length())\
    \ {\n    num = num + (value[i] - '0') * dec;\n    dec = dec / 10;\n    i++;\n\
    \  }\n  if (is_neg) {\n    num = -num;\n  }\n  int res = num;\n  if (num - res\
    \ >= 0.5) {\n    res++;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpuxkg0lr2: /tmp/tmpuxkg0lr2.cpp:58: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: 'Input value is 10

    Input value is 14.5

    Input value is -15.5

    '
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::istringstream ss(value);\n    double i;\n    ss >> i;\n \
    \   //why do we need to do this?\n    i+=0.5;\n    std::cout << \"Value \" <<\
    \ i << std::endl;\n    return (int)i;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpsopb98w_: /tmp/tmpsopb98w_.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: 'Value 10.5

    Value 15

    Value -15

    '
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double val = stod(value);\n    int r_val = int(val);\n    double\
    \ diff = val - r_val;\n    if (diff >= 0.5)\n        return r_val + 1;\n    else\n\
    \        return r_val;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpv86kb04e: /tmp/tmpv86kb04e.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double double_value = std::stod(value);\n  long long_value = std::stol(value);\n\
    \  return (double_value - long_value) >= 0.5 ? (long_value + 1) : long_value;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp9ztb5i9h: /tmp/tmp9ztb5i9h.cpp:25: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    return (long) (std::stod(value) + 0.5);\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp51j_pl0o: /tmp/tmp51j_pl0o.cpp:23: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // your code here\n    if(value[0]=='-')\n    {\n        long\
    \ val=stoi(value);\n        if(val%2==0)\n        {\n            return val;\n\
    \        }\n        else\n        {\n            return val-1;\n        }\n  \
    \  }\n    else\n    {\n        long val=stoi(value);\n        if(val%2==0)\n \
    \       {\n            return val;\n        }\n        else\n        {\n     \
    \       return val+1;\n        }\n    }\n\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4rjk_p5o: /tmp/tmp4rjk_p5o.cpp:47: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tlong i = std::stol(value);\n\tdouble v = std::stod(value);\n\tdouble\
    \ z = i + 0.5;\n\tif (v >= z) {\n\t\treturn i + 1;\n\t}\n\treturn i;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpm3hqgjpn: /tmp/tmpm3hqgjpn.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = atof(value.c_str());\n  long int l = d;\n  if ((int)d\
    \ == l) {\n    return l;\n  }\n  return (int)d + (d > 0 ? 1 : -1);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpv9hnrzj8: /tmp/tmpv9hnrzj8.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  bool isNegative = false;\n  if (value[0] == '-') {\n    isNegative\
    \ = true;\n    value.erase(0, 1);\n  }\n  size_t found = value.find(\".\");\n\
    \  if (found == std::string::npos) {\n    return atoi(value.c_str());\n  }\n \
    \ long int integer = atoi(value.substr(0, found).c_str());\n  long int decimal\
    \ = atoi(value.substr(found + 1, value.length() - 1).c_str());\n  if (decimal\
    \ >= 50) {\n    integer += 1;\n  }\n  if (isNegative) {\n    integer *= -1;\n\
    \  }\n  return integer;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjs522kz0: /tmp/tmpjs522kz0.cpp:39: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    int last = value.find_last_of(\".\");\n    int first = value.find_first_of(\"\
    .\");\n    std::string integerPart;\n    std::string decimalPart;\n    if(last\
    \ == -1){\n        return std::stoi(value);\n    }\n    if(last == first){\n \
    \       integerPart = value.substr(0,last);\n        decimalPart = value.substr(last+1);\n\
    \    }\n    else{\n        integerPart = value.substr(0,first);\n        decimalPart\
    \ = value.substr(first+1);\n    }\n    int deci = std::stoi(decimalPart);\n  \
    \  // std::cout<<\"integer Part \"<<integerPart<<\"\\n\";\n    // std::cout<<\"\
    decimal Part \"<<decimalPart<<\"\\n\";\n    if(deci>=5){\n        if(integerPart[0]\
    \ == '-'){\n            integerPart = std::to_string(std::stoi(integerPart)-1);\n\
    \        }\n        else{\n            integerPart = std::to_string(std::stoi(integerPart)+1);\n\
    \        }\n    }\n    return std::stoi(integerPart);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  float number = atof(value.c_str());\n  std::cout << std::setprecision(5)\
    \ << std::fixed << number << \"\\n\";\n  long int result = 0;\n  if (number ==\
    \ (int)number) {\n    result = (int)number;\n  } else {\n    int temp = (int)number;\n\
    \    if (number - temp > 0.5) {\n      result = temp + 1;\n    } else {\n    \
    \  result = temp;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcuk1db1_: /tmp/tmpcuk1db1_.cpp:35: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141431
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    return (std::round(std::stof(value)));\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141431
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long p = std::stol(value);\n  long q = p;\n  return p == q ? p :\
    \ q < p ? q + 1 : q;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_aee9uci: /tmp/tmp_aee9uci.cpp:24: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double val = std::stod(value);\n    if (val > 0) {\n        if\
    \ (val - int(val) > 0.5) {\n            return int(val) + 1;\n        } else {\n\
    \            return int(val);\n        }\n    } else {\n        if (val - int(val)\
    \ < -0.5) {\n            return int(val) - 1;\n        } else {\n            return\
    \ int(val);\n        }\n    }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_5govx2c: /tmp/tmp_5govx2c.cpp:35: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  long int len = value.length();\n  std::string\
    \ str = \"\";\n  for(long int i = 0; i < len; i++)\n  {\n    if(value[i] == '.')\n\
    \    {\n      if(value[i+1] >= '5')\n      {\n        std::string a = str;\n \
    \       long int b = atoi(a.c_str());\n        return b+1;\n      }\n      else\n\
    \      {\n        std::string a = str;\n        long int b = atoi(a.c_str());\n\
    \        return b;\n      }\n    }\n    else\n    {\n      str += value[i];\n\
    \    }\n  }\n  std::string a = str;\n  long int b = atoi(a.c_str());\n  return\
    \ b;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmprvf5adml: /tmp/tmprvf5adml.cpp:50: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    long i = d;\n    return (std::abs(d\
    \ - i) < std::abs(d - (i + 1))) ? i : i + 1;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwueoloi7: /tmp/tmpwueoloi7.cpp:25: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tif(value.length()==1){\n\t\tif(value[0]>=48&&value[0]<=57){\n\t\t\
    \treturn value[0]-48;\n\t\t}\n\t}\n\tstd::string a;\n\tint i=0;\n\tif(value[0]=='-'){\n\
    \t\ti=1;\n\t}\n\twhile(value[i]!='.'){\n\t\ta+=value[i];\n\t\ti++;\n\t}\n\tfloat\
    \ b=std::stof(a);\n\tfloat c=std::stof(value);\n\tfloat d=c-b;\n\tif(d>=0.5){\n\
    \t\tif(value[0]=='-'){\n\t\t\treturn b-1;\n\t\t}\n\t\treturn b+1;\n\t}\n\treturn\
    \ b;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcvf98dkk: /tmp/tmpcvf98dkk.cpp:46: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double dvalue = std::stod(value);\n    long ivalue = std::stol(value);\n\
    \    double delta = dvalue - ivalue;\n    if (fabs(delta) >= 0.5) {\n        if\
    \ (delta > 0) ivalue++;\n        else ivalue--;\n    }\n    return ivalue;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = stod(value);\n  double fraction = num - int(num);\n\
    \  if (fraction >= 0.5) {\n    return int(num) + 1;\n  } else {\n    return int(num);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpdeebg441: /tmp/tmpdeebg441.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream ss(value);\n    double d;\n    ss >> d;\n  \
    \  return std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code goes here\n  double x = std::stod(value);\n  long res\
    \ = 0;\n  if (x > 0)\n  {\n    res = std::ceil(x);\n  }\n  else\n  {\n    res\
    \ = std::floor(x);\n  }\n  return res;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmmt75n95: /tmp/tmpmmt75n95.cpp:35: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double val = std::stod(value);\n    if ((int)(val) == val)\n \
    \       return (int)(val);\n    return (val > 0) ? (int)(val+0.5) : (int)(val-0.5);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tlong num = std::stol(value);\n\tlong ans = 0;\n\tif (fmod(num, 1)\
    \ == 0.5) {\n\t\tif (num < 0) {\n\t\t\tans = floor(num) - 1;\n\t\t}\n\t\telse\
    \ {\n\t\t\tans = ceil(num) + 1;\n\t\t}\n\t}\n\telse {\n\t\tans = round(num);\n\
    \t}\n\treturn ans;\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmn0rjyxu: /tmp/tmpmn0rjyxu.cpp:35: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tstd::stringstream ss(value);\n\tdouble d;\n\tss >> d;\n\treturn\
    \ d > 0 ? std::floor(d) : std::ceil(d);\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3fvg8xap: /tmp/tmp3fvg8xap.cpp:25: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  if (value.length() == 1)\n    return std::stol(value);\n  std::string\
    \ number = \"\";\n  std::string indicator = \"\";\n  std::stringstream ss(value);\n\
    \  if (value[0] == '-') {\n    ss >> indicator;\n    ss >> number;\n  } else\n\
    \    ss >> number;\n  int len = number.length();\n  std::string low = number;\n\
    \  std::string high = number;\n  for (int i = len - 1; i >= 0; i--) {\n    if\
    \ (number[i] != '9') {\n      low[i] = number[i] + 1;\n      high[i] = number[i]\
    \ - 1;\n      for (int j = i + 1; j < len; j++) {\n        low[j] = '0';\n   \
    \     high[j] = '9';\n      }\n      break;\n    }\n  }\n  long low_num = std::stol(low);\n\
    \  long high_num = std::stol(high);\n  long num = std::stol(number);\n  long diff1\
    \ = abs(num - low_num);\n  long diff2 = abs(num - high_num);\n  if (diff1 == diff2)\
    \ {\n    if (indicator == \"-\")\n      return high_num;\n    else\n      return\
    \ low_num;\n  } else if (diff1 < diff2)\n    return low_num;\n  else\n    return\
    \ high_num;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5dd1ijuf: /tmp/tmp5dd1ijuf.cpp:58: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n// Write your code here\ndouble str_value = std::stod(value);\nif\
    \ (std::floor(str_value) == std::ceil(str_value)) {\nreturn str_value;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmdo808gr.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmdo808gr.cpp:22:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   22 | int main() {\n      |            ^\n/tmp/tmpmdo808gr.cpp:29:1:\
    \ error: expected \u2018}\u2019 at end of input\n   29 | }\n      | ^\n/tmp/tmpmdo808gr.cpp:16:41:\
    \ note: to match this \u2018{\u2019\n   16 | long closest_integer(std::string\
    \ value) {\n      |                                         ^\n/tmp/tmpmdo808gr.cpp:29:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   29 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    if(value.find(\".\") == -1)\n        return std::stol(value);\n\
    \    if(value.substr(value.find(\".\") + 1) > \"5\")\n        return std::stol(value.substr(0,\
    \ value.find(\".\"))) + 1;\n    return std::stol(value.substr(0, value.find(\"\
    .\")));\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpc25_1zve: /tmp/tmpc25_1zve.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int val = std::stoi(value);\n  int r = val/10;\n  double g = val\
    \ - r*10;\n  if(g>5){\n    r+=1;\n  }\n  return r;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpghadywua: /tmp/tmpghadywua.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int counter = 0;\n  int digit = 0;\n  std::string ret = \"\";\n\
    \  std::string ret2 = \"\";\n  if (value[0] == '-') {\n    counter = 1;\n  }\n\
    \  while (value[counter] != '.') {\n    ret += value[counter];\n    counter++;\n\
    \  }\n  // return ret;\n  if (ret.length() == 1) {\n    digit = stoi(ret);\n \
    \   if (digit < 9) {\n      digit++;\n    }\n    return digit;\n  }\n  for (int\
    \ i = 0; i < ret.length(); i++) {\n    if (ret[i] == '0') {\n      ret2 += ret[i];\n\
    \    }\n    else if (ret[i] != '0') {\n      ret2 += ret[i];\n      break;\n \
    \   }\n  }\n  if (ret2.length() == 1) {\n    digit = stoi(ret2);\n    if (digit\
    \ < 9) {\n      digit++;\n    }\n    return digit;\n  }\n  if (value[0] == '-')\
    \ {\n    digit = stoi(ret2);\n    if (digit > -9) {\n      digit--;\n    }\n \
    \   return digit;\n  }\n  digit = stoi(ret2);\n  if (digit < 9) {\n    digit++;\n\
    \  }\n  return digit;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjtj4g2_c: /tmp/tmpjtj4g2_c.cpp:67: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream stringtodouble(value);\n    double test;\n \
    \   stringtodouble >> test;\n    return std::round(test);\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::istringstream iss(value);\n  long x;\n  iss >> x;\n  if (value[value.size()\
    \ - 1] == '.') {\n    return x;\n  }\n  long y = std::round(std::stod(value));\n\
    \  return y;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long v = atol(value.c_str());\n  double f = atof(value.c_str());\n\
    \  return f - v > 0.5 ? v + 1 : v;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpx0yrt1uy: /tmp/tmpx0yrt1uy.cpp:24: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int len = value.length();\n  std::string a = value.substr(0,len-2);\n\
    \  std::string b = value.substr(len-2,len);\n  int first = std::stoi(a);\n  int\
    \ second = std::stoi(b);\n  if(second < 50){\n    return first;\n  }else{\n  \
    \  return first+1;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660141433
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  float n = std::stof(value);\n  return (std::round(n));\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble x = std::stod(value);\n\tdouble y = std::round(x);\n\treturn\
    \ (long)y;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n        double v = std::stod(value);\n        return std::round(v);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int len = value.length();\n  int i = 0;\n  int l = 0;\n  while(i\
    \ < len) {\n    if(value[i] == '.') {\n      l = len - i - 1;\n      break;\n\
    \    }\n    i++;\n  }\n  long v = std::stol(value.substr(0, i));\n  long p = std::stol(value.substr(i\
    \ + 1, l));\n  long x = pow(10, l - 1);\n  if(p >= x / 2) {\n    v++;\n  }\n \
    \ return v;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 3) > this->size() (which is 2)\n"
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long long result = 0;\n  double number = std::stod(value);\n  int\
    \ rounded_number = (int) std::floor(number);\n  int rounded_plus_one = (int) std::ceil(number);\n\
    \  if (std::abs(number - rounded_number) == std::abs(number - rounded_plus_one))\
    \ {\n    if (number > 0) {\n      result = rounded_plus_one;\n    } else {\n \
    \     result = rounded_number;\n    }\n  } else if (std::abs(number - rounded_number)\
    \ < std::abs(number - rounded_plus_one)) {\n    result = rounded_number;\n  }\
    \ else {\n    result = rounded_plus_one;\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tlong int num = std::stol(value);\n\treturn num+1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptwtlik0e: /tmp/tmptwtlik0e.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\t//std::cout << \"input value: \" << value << std::endl;\n\tstd::stringstream\
    \ stream(value);\n\tdouble val;\n\tstream >> val;\n\t//std::cout << \"val: \"\
    \ << val << std::endl;\n\treturn val >= 0 ? std::ceil(val) : std::floor(val);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmppjcdezgp: /tmp/tmppjcdezgp.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble n = stod(value);\n\tint n1 = n, n2 = n1 + 1;\n\tif(n-n1 ==\
    \ n2-n) return n1;\n\tif(n-n1 > n2-n) return n2;\n\treturn n1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpadzx66uz: /tmp/tmpadzx66uz.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  if (val>0)\n    return std::ceil(val);\n\
    \  else\n    return std::floor(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpf_z8vrq3: /tmp/tmpf_z8vrq3.cpp:28: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double number = std::stod(value);\n    return std::round(number);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = stod(value);\n  return ceil(num);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpeodprxea: /tmp/tmpeodprxea.cpp:24: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  //your code here\n  return 0;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpla50_gu9: /tmp/tmpla50_gu9.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::string tmp;\n  long res;\n  if (value.find('.') != std::string::npos)\
    \ {\n    for (int i = 0; i < value.size(); i++) {\n      if (value[i] == '.')\
    \ {\n        tmp = value.substr(0, i);\n        break;\n      }\n    }\n    if\
    \ (std::stod(value) - std::stoi(tmp) >= 0.5) {\n      res = std::stoi(tmp) + 1;\n\
    \    } else {\n      res = std::stoi(tmp);\n    }\n  } else {\n    res = std::stoi(value);\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgqb4iguh: /tmp/tmpgqb4iguh.cpp:40: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141433
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double x = std::stod(value);\n  return round(x);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    return std::floor(d + 0.5);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0zptl7by: /tmp/tmp0zptl7by.cpp:24: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int whole_number = std::stoi(value);\n  float decimal = std::stof(value)\
    \ - whole_number;\n  if (decimal >= 0.5)\n    whole_number += 1;\n  else if (decimal\
    \ <= -0.5)\n    whole_number -= 1;\n  return whole_number;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141433
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  double value_d = std::stod(value);\n  if(value_d\
    \ - static_cast<int>(value_d) >= 0.5)\n    return static_cast<int>(value_d) +\
    \ 1;\n  else\n    return static_cast<int>(value_d);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbvhhxt28: /tmp/tmpbvhhxt28.cpp:28: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble n = atof(value.c_str());\n\tlong x = round(n);\n\treturn\
    \ x;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  long result = (long)num;\n  return\
    \ (num - result) >= 0.5 ? result + 1 : result;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpou1uczz1: /tmp/tmpou1uczz1.cpp:25: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tint decimalPoint = value.find(\".\");\n\tif (decimalPoint != std::string::npos)\
    \ {\n\t\tdouble number = std::stod(value);\n\t\tif (number < 0) {\n\t\t\treturn\
    \ (int) number;\n\t\t}\n\t\telse {\n\t\t\treturn (int) number + 1;\n\t\t}\n\t\
    }\n\telse {\n\t\treturn std::stoi(value);\n\t}\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvg80udbz: /tmp/tmpvg80udbz.cpp:35: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream ss(value);\n    double val_d;\n    ss >> val_d;\n\
    \    return val_d>0 ? std::floor(val_d) : std::ceil(val_d);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpdw4ez_64: /tmp/tmpdw4ez_64.cpp:25: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    bool neg = false;\n    if (value[0] == '-') {\n        neg = true;\n\
    \        value.erase(0, 1);\n    }\n    auto pos = value.find('.');\n    if (pos\
    \ == std::string::npos) {\n        return std::stol(value);\n    }\n    if (value[pos\
    \ + 1] >= '5') {\n        value.erase(pos, value.size() - pos);\n        long\
    \ val = std::stol(value);\n        return neg ? --val : ++val;\n    }\n    value.erase(pos,\
    \ value.size() - pos);\n    return std::stol(value);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqpo6m4n5: /tmp/tmpqpo6m4n5.cpp:38: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = stod(value);\n  return round(val);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141434
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long x = std::round(std::stod(value));\n    return x;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    float f_value = std::stof(value);\n    if (f_value < 0) {\n  \
    \      return (int)f_value - 1;\n    }\n    return (int)f_value;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp54q0_i2l: /tmp/tmp54q0_i2l.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141434
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = std::stod(value);\n    return num < 0 ? ceil(num)\
    \ : floor(num);\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjy_tkuzt: /tmp/tmpjy_tkuzt.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double number = std::stod(value);\n  return (number-static_cast<long>(number)>=0.5)?\n\
    \  static_cast<long>(number)+1:static_cast<long>(number);\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphnss_jgj: /tmp/tmphnss_jgj.cpp:25: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double x=std::stod(value);\n    if(x>0)\n    {\n        return\
    \ std::round(x);\n    }\n    else if(x<0)\n    {\n        return std::round(x);\n\
    \    }\n    else{\n        return 0;\n    }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141435
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tstd::vector<std::string> strs;\n\tboost::split(strs, value, boost::is_any_of(\"\
    .\"));\n\tif (strs.size() == 1) {\n\t\treturn std::stol(value);\n\t}\n\tlong left\
    \ = std::stol(strs[0]);\n\tdouble right = std::stod(\"0.\" + strs[1]);\n\tif (right\
    \ > 0.5) {\n\t\tleft++;\n\t}\n\treturn left;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi26nodro.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpi26nodro.cpp:18:2: error: \u2018boost\u2019 has not been declared\n\
    \   18 |  boost::split(strs, value, boost::is_any_of(\".\"));\n      |  ^~~~~\n\
    /tmp/tmpi26nodro.cpp:18:28: error: \u2018boost\u2019 has not been declared\n \
    \  18 |  boost::split(strs, value, boost::is_any_of(\".\"));\n      |        \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660141435
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  return std::stol(value);\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpd8nzdm62: /tmp/tmpd8nzdm62.cpp:22: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble num = std::stod(value);\n\treturn std::round(num);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::string::size_type pos = value.find('.');\n  if (pos == std::string::npos)\
    \ {\n    return std::atol(value.c_str());\n  } else {\n    std::string decimal_number\
    \ = value.substr(pos + 1);\n    long integer_part = std::atol(value.substr(0,\
    \ pos).c_str());\n    long decimal_part = std::atol(decimal_number.c_str());\n\
    \    if (decimal_part * 10 >= 5) {\n      if (integer_part < 0) {\n        return\
    \ integer_part - 1;\n      } else {\n        return integer_part + 1;\n      }\n\
    \    } else {\n      return integer_part;\n    }\n  }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnu1a5yas: /tmp/tmpnu1a5yas.cpp:40: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble number = std::stod(value);\n\tstd::cout << number << std::endl;\n\
    \tif (number >= 0)\n\t\treturn std::ceil(number);\n\telse\n\t\treturn std::floor(number);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpq61hkglg: /tmp/tmpq61hkglg.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: '10

    14.5

    -15.5

    15.3

    '
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long result;\n  double temp;\n  std::stringstream ss(value);\n \
    \ ss >> temp;\n  if(temp > 0){\n    if(temp >= std::floor(temp) + 0.5){\n    \
    \  result = std::ceil(temp);\n    }else{\n      result = std::floor(temp);\n \
    \   }\n  }else{\n    if(temp >= std::floor(temp) + 0.5){\n      result = std::floor(temp);\n\
    \    }else{\n      result = std::ceil(temp);\n    }\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code here\n  int integer = std::stoi(value);\n  int decimal\
    \ = std::stoi(value.substr(value.find(\".\")));\n  std::cout << integer << std::endl;\n\
    \  std::cout << decimal << std::endl;\n  if (decimal < 5) {\n    return integer;\n\
    \  } else {\n    return integer+1;\n  }\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 2)\n"
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tlong i = std::stol(value);\n\tlong q, r;\n\tq = i / 1;\n\tr = i\
    \ % 1;\n\tif (r > 0.5) {\n\t\tq = q + 1;\n\t}\n\treturn q;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfe7i7h0x: /tmp/tmpfe7i7h0x.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  float number;\n  std::stringstream ss(value);\n  ss >> number;\n\
    \  long result = number;\n  float difference = number - result;\n  std::cout <<\
    \ difference << std::endl;\n  if (difference >= 0.5) {\n    result += 1;\n  }\n\
    \  else if (difference <= -0.5) {\n    result -= 1;\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: '0

    0.5

    -0.5

    0.3

    0

    '
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double doubleValue = std::stod(value);\n  long roundValue = std::lround(doubleValue);\n\
    \  std::cout << \"Value is: \" << doubleValue << \" and rounded value is: \" <<\
    \ roundValue << \"\\n\";\n  return roundValue;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: 'Value is: 10 and rounded value is: 10

    Value is: 14.5 and rounded value is: 15

    Value is: -15.5 and rounded value is: -16

    Value is: 15.3 and rounded value is: 15

    Value is: 0 and rounded value is: 0

    '
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream ss;\n    ss << value;\n    double val;\n   \
    \ ss >> val;\n    if (val < 0) {\n        return (long)val - 1;\n    }\n    return\
    \ (long)val;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgu0y2c6f: /tmp/tmpgu0y2c6f.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double valueDouble = std::stod(value);\n  return valueDouble > 0\
    \ ? std::ceil(valueDouble) : std::floor(valueDouble);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpsi8uqdpb: /tmp/tmpsi8uqdpb.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int integerValue = std::stoi(value);\n  float floatValue = std::stof(value);\n\
    \  if(floatValue > integerValue)\n    return integerValue + 1;\n  else\n    return\
    \ integerValue;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2rua84hu: /tmp/tmp2rua84hu.cpp:28: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code goes here\n  int n = value.size();\n  double sz = n;\n\
    \  double num=0;\n  for(int i=0;i<n;i++){\n    if(value[i]=='.'){\n      sz=i;\n\
    \      continue;\n    }\n    int curr = value[i]-'0';\n    num = num*10 + curr;\n\
    \  }\n  int power = n-sz-1;\n  num = num*pow(10,power);\n  //std::cout<<num<<std::endl;\n\
    \  if(value[0]!='-'){\n    int a = ceil(num);\n    int b = floor(num);\n    if(a-num<num-b){\n\
    \      return a;\n    }\n    else{\n      return b;\n    }\n  }\n  else{\n   \
    \ int a = floor(num);\n    int b = ceil(num);\n    if(a-num<num-b){\n      return\
    \ a;\n    }\n    else{\n      return b;\n    }\n  }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpr633yecw: /tmp/tmpr633yecw.cpp:55: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream s(value);\n  double x;\n  s >> x;\n  return round(x);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // your code goes here.\n  double dub = std::stod(value);\n  long\
    \ result = std::round(dub);\n  return result;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int res = 0;\n  std::string::size_type sz;\n\n  double num = std::stod(value,\
    \ &sz);\n  double temp = num - (int)num;\n  if (temp >= 0.5)\n    res = (int)num\
    \ + 1;\n  else\n    res = (int)num;\n  return res;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfr_2jg8j: /tmp/tmpfr_2jg8j.cpp:32: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble v = atof(value.c_str());\n\treturn round(v);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long i = strtol(value.c_str(), NULL, 10);\n\
    \    double j = strtod(value.c_str(), NULL);\n    if (j-i >= 0.5) {\n        return\
    \ i+1;\n    }\n    else {\n        return i;\n    }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcw_854nz: /tmp/tmpcw_854nz.cpp:31: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::cout << \"the value:\" << value << std::endl;\n  std::stringstream\
    \ is(value);\n  double x;\n  is >> x;\n  std::cout << \"the value:\" << x << std::endl;\n\
    \  std::cout << \"the value:\" << std::ceil(x) << std::endl;\n  return std::ceil(x);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpb2_1s7mw: /tmp/tmpb2_1s7mw.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: 'the value:10

    the value:10

    the value:10

    the value:14.5

    the value:14.5

    the value:15

    the value:-15.5

    the value:-15.5

    the value:-15

    '
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long number = std::stol(value);\n    long ret = number;\n    if\
    \ (((long)(ret + 1) - number) < (number - ret)) {\n        ret = ret + 1;\n  \
    \  }\n    return ret;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpf4yihv23: /tmp/tmpf4yihv23.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tdouble val = std::stod(value);\n\treturn std::lround(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tint length = value.length();\n\tlong result = 0;\n\tfor (int i =\
    \ 0; i < length; i++) {\n\t\tif (value[i] == '.') {\n\t\t\tif (value[i + 1] >\
    \ '4') {\n\t\t\t\tresult += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tresult *= 10;\n\
    \t\tresult += value[i] - '0';\n\t}\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmprrbnn65c: /tmp/tmprrbnn65c.cpp:35: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::string intPart,decPart;\n    std::stringstream ss(value);\n\
    \    std::getline(ss,intPart,'.');\n    std::getline(ss,decPart,'.');\n    long\
    \ int res = std::stol(intPart);\n    if(decPart.size()!=0){\n        if(decPart.size()>1){\n\
    \            if(decPart[0]>'4'){\n                if(intPart[0]=='-')\n      \
    \              res--;\n                else\n                    res++;\n    \
    \        }\n        }\n        else if(decPart[0]>'5'){\n            if(intPart[0]=='-')\n\
    \                res--;\n            else\n                res++;\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpefrvaczs: /tmp/tmpefrvaczs.cpp:43: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long ret = 0;\n  double num = std::stod(value);\n  if (num >= 0)\
    \ {\n    ret = std::floor(num + 0.5);\n  } else {\n    ret = std::ceil(num - 0.5);\n\
    \  }\n  return ret;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::istringstream ss(value);\n    long number;\n    ss >> number;\n\
    \    if (number > 0) {\n        if (number - (int)number < 0.5) {\n          \
    \  return (int)number;\n        } else {\n            return (int)number + 1;\n\
    \        }\n    } else {\n        if (number - (int)number > -0.5) {\n       \
    \     return (int)number;\n        } else {\n            return (int)number -\
    \ 1;\n        }\n    }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpk7t2edrg: /tmp/tmpk7t2edrg.cpp:37: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  //your code here\n  long num = stod(value);\n  std::cout << num\
    \ << std::endl;\n  long base = floor(num);\n  long ceiling = ceil(num);\n  if\
    \ (abs(num - base) < abs(num - ceiling)) {\n    return base;\n  }\n  return ceiling;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6fr74iqb: /tmp/tmp6fr74iqb.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: '10

    14

    '
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = stod(value);\n  // printf(\"%f %d %d %f\\n\", d, (int)d,\
    \ (int)d + 1, d - (int)d);\n  if (d - (int)d >= 0.5) {\n    return (int)d + 1;\n\
    \  } else {\n    return (int)d;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpb06pbmqt: /tmp/tmpb06pbmqt.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long a = strtol(value.c_str(), NULL, 10);\n  double b = std::stod(value);\n\
    \  if (b > a) {\n    return a + 1;\n  }\n  return a;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpphl60xxf: /tmp/tmpphl60xxf.cpp:28: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // TODO: Write your code here\n    long number = std::stol(value);\n\
    \    long a = number;\n    long b = number + 1;\n    long c = number - 1;\n  \
    \  float n = std::atof(value.c_str());\n    float absA = std::abs(n - a);\n  \
    \  float absB = std::abs(n - b);\n    float absC = std::abs(n - c);\n    if (absA\
    \ == absB && absB == absC)\n        return absA < absB ? a : absB < absC ? b :\
    \ c;\n    if (absA == absB)\n        return absA < absB ? a : b;\n    if (absB\
    \ == absC)\n        return absB < absC ? b : c;\n    if (absA == absC)\n     \
    \   return absA < absC ? a : c;\n    return absA < absB ? absA < absC ? a : c\
    \ : absB < absC ? b : c;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmprscl7tay: /tmp/tmprscl7tay.cpp:38: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long a = std::stol(value);\n    long int a_ = std::stol(value);\n\
    \    if (a_ < a) {\n        return a_;\n    }\n    else {\n        return a+1;\n\
    \    }\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1kw988w5: /tmp/tmp1kw988w5.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    float num = std::stof(value);\n    float whole, fractpart, intpart;\n\
    \    fractpart = modf(num, &intpart);\n    if (fractpart > 0.5) {\n        whole\
    \ = intpart + 1;\n    } else {\n        whole = intpart;\n    }\n    return whole;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjvw4vyxs.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjvw4vyxs.cpp:19:27: error: cannot convert \u2018float*\u2019 to \u2018\
    double*\u2019\n   19 |     fractpart = modf(num, &intpart);\n      |         \
    \                  ^~~~~~~~\n      |                           |\n      |    \
    \                       float*\nIn file included from /usr/include/c++/9/cmath:45,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpjvw4vyxs.cpp:2:\n/usr/include/x86_64-linux-gnu/bits/mathcalls.h:110:1:\
    \ note:   initializing argument 2 of \u2018double modf(double, double*)\u2019\n\
    \  110 | __MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr)) __nonnull ((2));\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = atof(value.c_str());\n    double decimal = num -\
    \ int(num);\n    if (decimal < 0.5) {\n        return int(num);\n    } else {\n\
    \        return int(num)+1;\n    }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkxocis8d: /tmp/tmpkxocis8d.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::cout << \"round of \" << value << \" is \" << round(std::stod(value))\
    \ << \"\\n\";\n  return (long) round(std::stod(value));\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: 'round of 10 is 10

    round of 14.5 is 15

    round of -15.5 is -16

    round of 15.3 is 15

    round of 0 is 0

    '
  timestamp: 1660141436
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tint integer = stoi(value);\n\tdouble d = stod(value);\n\tif (integer\
    \ == d)\n\t\treturn integer;\n\tdouble abs_num = abs(d);\n\tint nearest_integer\
    \ = static_cast<int>(abs_num + 0.5);\n\tif (d < 0)\n\t\treturn -nearest_integer;\n\
    \treturn nearest_integer;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1snjxenu: /tmp/tmp1snjxenu.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::string decimal;\n    std::stringstream stream;\n    bool\
    \ negative = false;\n    if (value[0] == '-') {\n        negative = true;\n  \
    \      value.erase(0, 1);\n    }\n    auto dot_it = std::find(value.begin(), value.end(),\
    \ '.');\n    if (dot_it != value.end()) {\n        decimal = std::string(std::next(dot_it),\
    \ value.end());\n        value.erase(dot_it, value.end());\n    }\n    stream\
    \ << value;\n    long whole;\n    stream >> whole;\n    if (decimal.empty()) {\n\
    \        return whole;\n    }\n    long hundredths = std::stol(decimal);\n   \
    \ return hundredths > 50 ? (negative ? whole - 1 : whole + 1) : whole;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2eiykyr1: /tmp/tmp2eiykyr1.cpp:41: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int a = std::stoi(value);\n  std::cout << \"value \" << a << std::endl;\n\
    \  std::cout << \"value \" << a + 0.5 << std::endl;\n  std::cout << \"value \"\
    \ << (int)(a + 0.5) << std::endl;\n  return (int)(a + 0.5);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphf49lwhc: /tmp/tmphf49lwhc.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: 'value 10

    value 10.5

    value 10

    value 14

    value 14.5

    value 14

    '
  timestamp: 1660141437
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    float num = std::stof(value);\n    float diff = num - floor(num);\n\
    \    if (diff == 0.5) {\n        if (num > 0) {\n            return ceil(num);\n\
    \        } else {\n            return floor(num);\n        }\n    } else if (diff\
    \ > 0.5) {\n        return ceil(num);\n    } else {\n        return floor(num);\n\
    \    }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // N is the size of the string.\n  int N = value.size();\n  // first\
    \ we handle negative numbers.\n  int sign = 1;\n  if (value[0] == '-') {\n   \
    \ sign = -1;\n    value = value.substr(1, N - 1);\n    N--;\n  }\n  if (N == 1)\
    \ {\n    return sign * (value[0] - '0');\n  }\n  // N >= 2, we first examine the\
    \ decimal point.\n  int decimal_point = value.find(\".\");\n  int integer_part\
    \ = 0;\n  double decimal_part = 0.0;\n  if (decimal_point != std::string::npos)\
    \ {\n    integer_part = std::stoi(value.substr(0, decimal_point));\n    std::string\
    \ dp_string = value.substr(decimal_point + 1, N - decimal_point - 1);\n    decimal_part\
    \ = std::stod(dp_string);\n  } else {\n    integer_part = std::stoi(value);\n\
    \  }\n  if (decimal_part == 0.0) {\n    return sign * integer_part;\n  }\n  //\
    \ decimal_part >= 0.1, we compare decimal_part with 0.5.\n  if (decimal_part <\
    \ 0.5) {\n    return sign * integer_part;\n  } else {\n    return sign * (integer_part\
    \ + 1);\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_ecu2ze4: /tmp/tmp_ecu2ze4.cpp:55: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnet6k6nj: /tmp/tmpnet6k6nj.cpp:21: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    // This is only here to get the program\
    \ to compile.\n    // You should remove this, and write your own code\n    //\
    \ that solves the problem.\n    // This is only here to get the program to compile.\n\
    \    // You should remove this, and write your own code\n    // that solves the\
    \ problem.\n    // This is only here to get the program to compile.\n    // You\
    \ should remove this, and write your own code\n    // that solves the problem.\n\
    \    // This is only here to get the program to compile.\n    // You should remove\
    \ this, and write your own code\n    // that solves the problem.\n    // This\
    \ is only here to get the program to compile.\n    // You should remove this,\
    \ and write your own code\n    // that solves the problem.\n    // This is only\
    \ here to get the program to compile.\n    // You should remove this, and write\
    \ your own code\n    // that solves the problem.\n    // This is only here to\
    \ get the program to compile.\n    // You should remove this, and write your own\
    \ code\n    // that solves the problem.\n    // This is only here to get the program\
    \ to compile.\n    // You should remove this, and write your own code\n    //\
    \ that solves the problem.\n    // This is only here to get the program to compile.\n\
    \    // You should remove this, and write your own code\n    // that solves the\
    \ problem.\n    // This is only here to get the program to compile.\n    // You\
    \ should remove this, and write your own code\n    // that solves the problem.\n\
    \    return 42;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1s2kk2ls: /tmp/tmp1s2kk2ls.cpp:52: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // TODO: implement me!\n  std::cout << value << std::endl;\n  //\
    \ -1.5, -1,  -> -2\n  // -1.4, -1,  -> -1\n  // 1.4,  1,   -> 1\n  // 1.5,  1,\
    \   -> 2\n  // 1.6,  1,   -> 2\n  double num = std::stod(value);\n  int floor_val\
    \ = std::floor(num);\n  int ceil_val = std::ceil(num);\n  double diff_floor =\
    \ num - floor_val;\n  double diff_ceil = ceil_val - num;\n  if (diff_floor > diff_ceil)\
    \ {\n    return ceil_val;\n  } else {\n    return floor_val;\n  }\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp29k83b73: /tmp/tmp29k83b73.cpp:38: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: '10

    14.5

    '
  timestamp: 1660141437
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  //your code here\n  std::stringstream ss(value);\n  double num =\
    \ 0;\n  ss >> num;\n  return (long) num;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2ddd1zod: /tmp/tmp2ddd1zod.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141438
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  return round(stod(value));\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141438
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double d = std::stod(value);\n    int x = d;\n    if(fabs(d-x)\
    \ > 0.5) return x+1;\n    return x;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6613d7wy: /tmp/tmp6613d7wy.cpp:25: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141438
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream ss;\n  ss << value;\n  double input;\n  ss >>\
    \ input;\n  return static_cast<long>(std::ceil(input));\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpc1qk4x41: /tmp/tmpc1qk4x41.cpp:27: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int val = atoi(value.c_str());\n  double dval = atof(value.c_str());\n\
    \  double diff = dval - val;\n  if (diff < 0.5)\n    return val;\n  else\n   \
    \ return val + 1;\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2c79hzxn: /tmp/tmp2c79hzxn.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141438
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val = std::stod(value);\n  std::cout << val << std::endl;\n\
    \  if ((long) val == val) {\n    return (long) val;\n  } else {\n    if (std::abs(val\
    \ - (long) val) > 0.5) {\n      return std::round(val);\n    } else {\n      return\
    \ std::floor(val);\n    }\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0gwvmqll: /tmp/tmp0gwvmqll.cpp:32: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: '10

    14.5

    '
  timestamp: 1660141439
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write code here.\n    double d1 = stod(value);\n    double\
    \ d2 = ceil(d1);\n    double d3 = floor(d1);\n    if(d1 - d3 == d2 - d1)\n   \
    \ {\n        if(d1 > 0)\n            return d2;\n        else\n            return\
    \ d3;\n    }\n    else if(d1 - d3 > d2 - d1)\n        return d2;\n    else\n \
    \       return d3;\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141438
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tstd::istringstream stream{value};\n\tdouble val;\n\tstream >> val;\n\
    \tif (val < 0) {\n\t\treturn std::ceil(val);\n\t}\n\treturn std::floor(val);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4rf0l6p2: /tmp/tmp4rf0l6p2.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::string::size_type sz;\n  long num = std::stol(value, &sz);\n\
    \  long fraction = std::stol(value.substr(sz));\n  return num + (fraction < 5\
    \ ? 0 : 1);\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stol\n"
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long number = std::stol(value);\n  if (std::ceil(number) - number\
    \ < .5) {\n    return std::ceil(number);\n  } else {\n    return std::floor(number);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgebfigla: /tmp/tmpgebfigla.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double digit = std::stod(value);\n  if(digit < 0){\n    return (std::floor(digit));\n\
    \  }\n  return std::ceil(digit);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjexaa7_k: /tmp/tmpjexaa7_k.cpp:28: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::istringstream iss{value};\n  double val;\n  iss >> val;\n \
    \ return lround(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141439
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double floater = std::stod(value);\n  int r = static_cast<int>(std::round(floater));\n\
    \  return r;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double dval = stod(value);\n    long sign = dval > 0 ? 1 : -1;\n\
    \    return sign * round(abs(dval));\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6vtonvpm: /tmp/tmp6vtonvpm.cpp:24: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  float val = std::stof(value);\n  if (val > 0) {\n    return std::ceil(val);\n\
    \  } else {\n    return std::floor(val);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpxvj8svsw: /tmp/tmpxvj8svsw.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    int i = 0;\n    int sign = 1;\n    if (value[0] == '-') {\n  \
    \      sign = -1;\n        i++;\n    }\n    for (; i < value.size(); i++) {\n\
    \        if (value[i] == '.') {\n            break;\n        }\n    }\n    if\
    \ (i == value.size()) {\n        return stol(value);\n    }\n    long integer\
    \ = stol(value.substr(0, i));\n    double decimal = stod(value.substr(i, value.size()));\n\
    \    if (decimal < 0.5) {\n        return integer;\n    }\n    else if (decimal\
    \ > 0.5) {\n        return sign * (integer + 1);\n    }\n    else {\n        if\
    \ (integer % 2 == 0) {\n            return integer;\n        }\n        else {\n\
    \            return sign * (integer + 1);\n        }\n    }\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8llg3lbt: /tmp/tmp8llg3lbt.cpp:51: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    size_t finddot = value.find(\".\");\n    if (finddot == std::string::npos)\
    \ {\n        return std::stol(value);\n    }\n    size_t len = value.length();\n\
    \    std::string aftrDot = value.substr(finddot + 1, len - finddot);\n    if (aftrDot[0]\
    \ > '5') {\n        std::string beforeDot = value.substr(0, finddot);\n      \
    \  return std::stol(beforeDot) + 1;\n    }\n    else {\n        std::string beforeDot\
    \ = value.substr(0, finddot);\n        return std::stol(beforeDot);\n    }\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpoljdfn3c: /tmp/tmpoljdfn3c.cpp:35: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int n = atoi(value.c_str());\n  return n;\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp7_n6zqk8: /tmp/tmp7_n6zqk8.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double val=stod(value);\n  long s=val<0?-1:1;\n  return round(val)*s;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1f8oemjg: /tmp/tmp1f8oemjg.cpp:25: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  float f = std::stof(value);\n  int i = std::stoi(value);\n  float\
    \ diff_i = std::abs(i - f);\n  float diff_j = std::abs(i + 1 - f);\n  if (diff_i\
    \ < diff_j)\n    return i;\n  else\n    return i + 1;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwj5ax3g2: /tmp/tmpwj5ax3g2.cpp:30: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double num = std::stod(value);\n    // return round(num);\n  \
    \  double a = num, b = num;\n    while (true) {\n        if (fmod(a, 1) == 0)\n\
    \            return (long)a;\n        if (fmod(b, 1) == 0)\n            return\
    \ (long)b;\n        a -= 1;\n        b += 1;\n    }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141444
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = std::stod(value);\n  if (num < 0) {\n    num *= -1;\n\
    \    return num = std::ceil(num) * -1;\n  }\n  return num = std::ceil(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpour_ihzc: /tmp/tmpour_ihzc.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\treturn std::nearbyint(std::stod(value));\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphykq788z: /tmp/tmphykq788z.cpp:22: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d=std::stod(value);\n  double frac=d-std::floor(d);\n  double\
    \ frac1=std::ceil(d)-d;\n  long ret=0;\n  if(frac<=frac1)\n    ret=std::floor(d);\n\
    \  else\n    ret=std::ceil(d);\n  return ret;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0i3e4040: /tmp/tmp0i3e4040.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d=std::stod(value);\n  return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tfloat f = stof(value);\n\tint intf = (int)f;\n\tint diff_neg = abs(intf\
    \ - f);\n\tint diff_pos = (int)f + 1 - f;\n\tif (diff_neg <= diff_pos)\n\t\treturn\
    \ intf;\n\telse\n\t\treturn intf + 1;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp50iunmaa: /tmp/tmp50iunmaa.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  return round(std::stof(value));\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  if (value.find(\".\") == std::string::npos) {\n    return std::stol(value);\n\
    \  }\n  std::string integer;\n  std::string fraction;\n  std::stringstream value_stream(value);\n\
    \  getline(value_stream, integer, '.');\n  getline(value_stream, fraction, '.');\n\
    \  long integer_part = std::stol(integer);\n  long frac_part = std::stol(fraction);\n\
    \  if (integer_part == 0) {\n    if (frac_part >= 5) {\n      return 1;\n    }\
    \ else {\n      return 0;\n    }\n  }\n  if (frac_part >= 5) {\n    return integer_part\
    \ + 1;\n  } else {\n    return integer_part;\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpafu2xcdo: /tmp/tmpafu2xcdo.cpp:44: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream ss(value);\n    double d;\n    ss >> d;\n  \
    \  long int_part = d;\n    long closest = d - int_part > 0.5 ? int_part + 1 :\
    \ int_part;\n    return closest;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplt2irys8: /tmp/tmplt2irys8.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long result = 0;\n    double value_double = std::stod(value);\n\
    \    double integer = std::floor(value_double);\n    if (value_double - integer\
    \ >= 0.5)\n        result = integer + 1;\n    else\n        result = integer;\n\
    \    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgjflzffm: /tmp/tmpgjflzffm.cpp:30: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double v = std::stod(value);\n  if (v - std::floor(v) < 0.5) {\n\
    \    return std::floor(v);\n  } else {\n    return std::ceil(v);\n  }\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptr0r9blj: /tmp/tmptr0r9blj.cpp:28: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream ss(value);\n    double d;\n    ss >> d;\n  \
    \  // Round d to the nearest whole number\n    d += (d > 0) ? 0.5 : -0.5;\n  \
    \  // Convert it back to a string\n    ss.str(\"\");\n    ss << d;\n    long closest;\n\
    \    ss >> closest;\n    return closest;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpd9qnoo5n: /tmp/tmpd9qnoo5n.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tint dot = value.find('.');\n\tif (dot == -1) {\n\t\treturn std::stol(value);\n\
    \t}\n\tlong ret = std::stol(value.substr(0, dot));\n\tstd::string dec = value.substr(dot\
    \ + 1);\n\tint val = std::stoi(dec);\n\tif (val >= 5) {\n\t\treturn ret + 1;\n\
    \t}\n\treturn ret;\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpdwo594m5: /tmp/tmpdwo594m5.cpp:33: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double d = std::stod(value);\n  return std::lround(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141438
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  long integer, decimal;\n  std::stringstream input(value);\n  input\
    \ >> integer;\n  decimal = integer;\n  if (value.find('.') != std::string::npos)\
    \ {\n    input.ignore();\n    input >> decimal;\n  }\n  if (decimal <= 4) {\n\
    \    return integer;\n  } else {\n    return integer + 1;\n  }\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpi9ajoxj1: /tmp/tmpi9ajoxj1.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // Your code here\n  std::stringstream ss(value);\n  double d;\n\
    \  ss >> d;\n  long int l = d;\n  if((d-l) >= 0.5) {\n    l += 1;\n  }\n  return\
    \ l;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqszyml1u: /tmp/tmpqszyml1u.cpp:31: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  if (value.empty()) {\n    return 0;\n  }\n  int pos = value.find('.');\n\
    \  if (pos == -1) {\n    return std::stol(value);\n  } else {\n    return std::stol(value.substr(0,\
    \ pos));\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpuujrntzj: /tmp/tmpuujrntzj.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141439
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::istringstream iss(value);\n  double d;\n  iss >> d;\n  long\
    \ n = std::lround(d);\n  if (n == 0 && d < 0) {\n    return n;\n  }\n  if (n >\
    \ 0 && d - n < 0.5) {\n    return n;\n  }\n  return n + 1;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbkyat9vd: /tmp/tmpbkyat9vd.cpp:33: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int i = 0;\n  long x;\n  // value = \"15.3\";\n  x = std::atol(value.c_str());\n\
    \  double decimal = std::abs(x - static_cast<int>(x));\n  double decimal_ = 1\
    \ - decimal;\n  if (decimal > decimal_)\n    return static_cast<int>(x) + 1;\n\
    \  else if (decimal < decimal_)\n    return static_cast<int>(x);\n  else if (decimal\
    \ == decimal_) {\n    if (x > 0)\n      return static_cast<int>(x) + 1;\n    else\n\
    \      return static_cast<int>(x) - 1;\n  }\n  return 0;\n}\nint main() {\n  \
    \  auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp16mom_lk: /tmp/tmp16mom_lk.cpp:38: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    int v = atoi(value.c_str());\n    long res = v;\n    if(value.find('.')\
    \ != std::string::npos) {\n        value.erase(0, value.find('.')+1);\n      \
    \  int frac = atoi(value.c_str());\n        if(frac > 5)\n            res++;\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8po6t2zu: /tmp/tmp8po6t2zu.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    double decimal = std::stod(value);\n    std::cout << decimal <<\
    \ std::endl;\n    std::cout << std::round(decimal) << std::endl;\n    return std::round(decimal);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: '10

    10

    14.5

    15

    -15.5

    -16

    15.3

    15

    0

    0

    '
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // your code here\n    int decimal_point = value.find(\".\");\n\
    \    std::string integer_part = value.substr(0, decimal_point);\n    int integer_part_value\
    \ = std::stoi(integer_part);\n    std::string decimal_part = value.substr(decimal_point\
    \ + 1,\n        value.length() - decimal_point - 1);\n    double decimal_part_value\
    \ = std::stod(decimal_part);\n    if (decimal_part_value >= 50) {\n        return\
    \ integer_part_value + 1;\n    } else {\n        return integer_part_value;\n\
    \    }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2v3dqf6i: /tmp/tmp2v3dqf6i.cpp:33: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\t//atoi,atof,atol,atoll,strtol,strtoll,sscanf\n\treturn atof(value.c_str());\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkqfh1yto: /tmp/tmpkqfh1yto.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    int l = value.length();\n    for(int i = 0; i < l; i++) {\n  \
    \      if(value[i] == '.') {\n            if(i == l - 1) {\n                value.pop_back();\n\
    \                return std::stol(value);\n            }\n            if(value[i\
    \ + 1] >= '5') {\n                value.pop_back();\n                if(value[0]\
    \ == '-') {\n                    value.pop_back();\n                    return\
    \ std::stol(value) - 1;\n                }\n                else {\n         \
    \           value.pop_back();\n                    return std::stol(value) + 1;\n\
    \                }\n            }\n            else {\n                value.pop_back();\n\
    \                return std::stol(value);\n            }\n        }\n    }\n \
    \   return std::stol(value);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double num = stod(value);\n  double decimal = num - floor(num);\n\
    \  if (decimal >= 0.5) {\n    return ceil(num);\n  } else {\n    return floor(num);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3w7v647n: /tmp/tmp3w7v647n.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    std::stringstream stream(value);\n    double d;\n    stream >>\
    \ d;\n    // std::cout << d << std::endl;\n    return std::round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    return std::round(std::stof(value));\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    if(value.at(0) == '-'){\n        value.erase(0,1);\n        int\
    \ x = atoi(value.c_str());\n        if(x < (x + 1)){\n            std::stringstream\
    \ ss;\n            ss << (x+1);\n            value = ss.str();\n            value.insert(0,\
    \ \"-\");\n            return std::stol(value);\n        }else{\n            return\
    \ x;\n        }\n    }else{\n        int x = atoi(value.c_str());\n        if(x\
    \ > (x + 1)){\n            std::stringstream ss;\n            ss << (x+1);\n \
    \           return std::stol(ss.str());\n        }else{\n            return x;\n\
    \        }\n    }\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpo9n7cliy: /tmp/tmpo9n7cliy.cpp:43: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  int first, last;\n  if (value.size() == 0)\n    return -1;\n  if\
    \ (value.size() == 1)\n    return value[0] - '0';\n  if (value[0] == '-') {\n\
    \    first = 1;\n    last = value.size() - 1;\n  } else {\n    first = 0;\n  \
    \  last = value.size();\n  }\n  std::string temp(value.begin() + first, value.begin()\
    \ + last);\n  int num = std::stoi(temp);\n  std::string num_str = std::to_string(num);\n\
    \  int diff = num_str.size() - temp.size();\n  int first_digit = temp[0] - '0';\n\
    \  if (value[last] - '0' >= 5) {\n    if (first_digit == 9) {\n      first_digit\
    \ = 0;\n      diff++;\n    } else {\n      first_digit++;\n    }\n  }\n  for (int\
    \ i = 0; i < diff; i++) {\n    first_digit *= 10;\n  }\n  if (value[0] == '-')\n\
    \    return -first_digit;\n  return first_digit;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplh44vzqe: /tmp/tmplh44vzqe.cpp:51: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double fl_value = std::stod(value);\n  double digit = fl_value -\
    \ floor(fl_value);\n  double diff = ceil(fl_value) - fl_value;\n  if (digit >\
    \ diff) {\n    return ceil(fl_value);\n  } else {\n    return floor(fl_value);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpql3ydzlk: /tmp/tmpql3ydzlk.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141440
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double converted_value = std::stod(value);\n  double rounded_value\
    \ = std::round(converted_value);\n  long int closer_int = static_cast<long int>(rounded_value);\n\
    \  return closer_int;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141440
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    int val = std::stoi(value);\n    int decimal = std::stoi(value.substr(value.find('.')+1));\n\
    \    if(decimal >= 5) {\n        return val + 1;\n    }\n    return val;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpl2oz8soq: /tmp/tmpl2oz8soq.cpp:26: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\treturn value.find(\".\") == std::string::npos ? std::stol(value)\
    \ :\n\t\tstd::stol(value.substr(0, value.find(\".\"))) + (value.back() > '4');\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcpyi4lh2: /tmp/tmpcpyi4lh2.cpp:24: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tauto integer = (int)std::atof(value.c_str());\n\tauto decimal =\
    \ std::atof(value.c_str()) - integer;\n\tif (decimal >= 0.5) {\n\t\treturn integer\
    \ + 1;\n\t}\n\treturn integer;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpy5qtoh5o: /tmp/tmpy5qtoh5o.cpp:28: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream convert(value);\n  double number;\n  convert >>\
    \ number;\n  return (long) (number > 0) ? floor(number + 0.5) : ceil(number -\
    \ 0.5);\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double number = std::stod(value);\n  if (number > 0)\n    return\
    \ std::ceil(number);\n  else\n    return std::floor(number);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplztb7_hf: /tmp/tmplztb7_hf.cpp:28: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  // Your code here\n  double temp=std::stod(value);\n  if(temp>0){\n\
    \    if(temp-int(temp)>=0.5)\n      return temp+1;\n    else\n      return temp;\n\
    \  }\n  else{\n    if(temp-int(temp)<0.5)\n      return temp-1;\n    else\n  \
    \    return temp;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpb4muelsw: /tmp/tmpb4muelsw.cpp:38: int main(): Assertion `candidate(("0"))
    == (0)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  return std::lround(std::stod(value));\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // create local variable\n    double number;\n    // convert the\
    \ string to a double\n    number = std::stod(value);\n    // cast the double to\
    \ a long and return it\n    return static_cast<long>(number);\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp82zjvi6w: /tmp/tmp82zjvi6w.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  double number = stod(value);\n  long upper = ceil(number);\n  long\
    \ lower = floor(number);\n  if(abs(number - upper) > abs(number - lower)){\n \
    \   return lower;\n  }\n  return upper;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgdxo8hxb: /tmp/tmpgdxo8hxb.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n  std::stringstream ss(value);\n  double num = 0;\n  ss >> num;\n\
    \  std::cout << num << std::endl;\n  return (int)std::round(num);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: '10

    14.5

    -15.5

    15.3

    0

    '
  timestamp: 1660141441
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n\tint i;\n\tchar val[value.length()+1];\n\tstrcpy(val, value.c_str());\n\
    \tfloat f = atof(val);\n\tif(f>0){\n\t\ti = ceil(f);\n\t}\n\telse{\n\t\ti = floor(f);\n\
    \t}\n\treturn i;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvi5ku3qq: /tmp/tmpvi5ku3qq.cpp:34: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141441
