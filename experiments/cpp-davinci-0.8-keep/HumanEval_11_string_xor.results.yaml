name: HumanEval_11_string_xor
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string output\
    \ = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        int x = (a[i] -\
    \ '0') ^ (b[i] - '0');\n        output += std::to_string(x);\n    }\n    return\
    \ output;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string output\
    \ = \"\";\n    int size = a.size();\n    for(int i = 0; i < size; i++) {\n   \
    \     if (a[i] == b[i])\n            output += \"0\";\n        else\n        \
    \    output += \"1\";\n    }\n    return output;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  if (a.size() != b.size())\
    \ return \"\";\n  std::string res = \"\";\n  for (int i = 0; i < a.size(); i++)\
    \ {\n    if (a[i] == b[i]) res += \"0\";\n    else res += \"1\";\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string s;\n    for (int i = 0; i < a.size(); i++) {\n \
    \       s += std::to_string((a[i] - '0') ^ (b[i] - '0'));\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int l = 0;\n    int\
    \ r = 0;\n    int c = 0;\n    std::string result;\n    while (l < a.length() ||\
    \ r < b.length()) {\n        int sum = c;\n        if (l < a.length()) sum +=\
    \ a[l] - '0';\n        if (r < b.length()) sum += b[r] - '0';\n        result\
    \ += '0' + (sum & 1);\n        c = sum >> 1;\n        l++;\n        r++;\n   \
    \ }\n    if (c != 0) result += '0' + c;\n    return result;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpqbwbe5to: /tmp/tmpqbwbe5to.cpp:26: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string res = \"\
    \";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\tres\
    \ += \"0\";\n\t\t}\n\t\telse {\n\t\t\tres += \"1\";\n\t\t}\n\t}\n\treturn res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    \n    std::string\
    \ result=\"\";\n    int length_a = a.length();\n    int length_b = b.length();\n\
    \    int length;\n    char temp;\n    assert(length_a == length_b);\n\n    for(int\
    \ i=0; i<length_a; i++)\n    {\n        int temp_a = a[i] - '0';\n        int\
    \ temp_b = b[i] - '0';\n        if(temp_a==1 && temp_b==1)\n        {\n      \
    \      temp = '0';\n        }\n        else if(temp_a==0 && temp_b==0)\n     \
    \   {\n            temp = '0';\n        }\n        else\n        {\n         \
    \   temp = '1';\n        }\n        result.push_back(temp);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string answer;\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] ==\
    \ b[i]) {\n      answer += '0';\n    } else {\n      answer += '1';\n    }\n \
    \ }\n  return answer;\n}\nint main() {\n    auto candidate = string_xor;\n   \
    \ assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string result;\n  result.reserve(a.size());\n  for (std::size_t i = 0;\
    \ i < a.size(); ++i) {\n    result.push_back(a[i] == b[i] ? '0' : '1');\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string res;\n\t\
    for (int i = 0; i < (int)a.size(); i++) {\n\t\tres += a[i] == b[i] ? '0' : '1';\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string output;\n\
    \tfor (int i = 0; i < a.length(); i++) {\n\t\tif (a[i] == b[i])\n\t\t\toutput.push_back('0');\n\
    \t\telse\n\t\t\toutput.push_back('1');\n\t}\n\treturn output;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t// TODO: Your code here\n\
    \tassert(a.length() == b.length());\n\t//Implementation of XOR\n\tstring result\
    \ = \"\";\n\tfor (int i = 0; i < a.length(); i++) {\n\t\t//Concatenating the strings\n\
    \t\tresult += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy90cq03l.cpp: In function \u2018std::string string_xor(std::string,\
    \ std::string)\u2019:\n/tmp/tmpy90cq03l.cpp:11:2: error: \u2018string\u2019 was\
    \ not declared in this scope; did you mean \u2018std::string\u2019?\n   11 | \
    \ string result = \"\";\n      |  ^~~~~~\n      |  std::string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy90cq03l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpy90cq03l.cpp:14:3:\
    \ error: \u2018result\u2019 was not declared in this scope\n   14 |   result +=\
    \ ((a[i] - '0') ^ (b[i] - '0')) + '0';\n      |   ^~~~~~\n/tmp/tmpy90cq03l.cpp:16:9:\
    \ error: \u2018result\u2019 was not declared in this scope\n   16 |  return result;\n\
    \      |         ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string answer;\n\
    \tfor (unsigned int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\
    \tanswer += '0';\n\t\t}\n\t\telse {\n\t\t\tanswer += '1';\n\t\t}\n\t}\n\treturn\
    \ answer;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result;\n\
    \    assert(a.size() == b.size());\n    for (unsigned int i = 0; i < a.size();\
    \ i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else\
    \ {\n            result += '1';\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n     \
    \ result += '0';\n    else\n      result += '1';\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result;\n\
    \    std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(result),\
    \ [](char a, char b) {\n        return a ^ b;\n    });\n    return result;\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmp1had63ho: /tmp/tmp1had63ho.cpp:16: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int len_a = a.length();\n\
    \    int len_b = b.length();\n    assert(len_a == len_b);\n    std::string res\
    \ = \"\";\n    for (int i = 0; i < len_a; i++) {\n        if (a[i] == b[i]) {\n\
    \            res.push_back('0');\n        } else {\n            res.push_back('1');\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string ret;\n\
    \    for (int i = 0; i < a.size(); i++) {\n        ret += (a[i] == b[i]) ? '0'\
    \ : '1';\n    }\n    return ret;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string res;\n    for (int i = 0; i < a.size(); i++) {\n\
    \        if (a[i] == b[i])\n            res += '0';\n        else\n          \
    \  res += '1';\n    }\n    return res;\n}\nint main() {\n    auto candidate =\
    \ string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int a_size = a.size();\n\
    \    int b_size = b.size();\n    //calculate the length of string\n    int size\
    \ = std::max(a_size, b_size);\n    std::string result;\n    // string xor operation\n\
    \    for (int i = 0; i < size; i++) {\n        int first = 0;\n        int second\
    \ = 0;\n        // to avoid error if a < b so we use modulo operator\n       \
    \ if (i < a_size) {\n            first = a[i] == '1';\n        }\n        if (i\
    \ < b_size) {\n            second = b[i] == '1';\n        }\n        // if condition\
    \ for the c++ xor\n        if (first ^ second) {\n            result += '1';\n\
    \        } else {\n            result += '0';\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int x = stoi(a, nullptr,\
    \ 2);\n    int y = stoi(b, nullptr, 2);\n    int z = x ^ y;\n    std::string s\
    \ = std::bitset<8>(z).to_string();\n    return s;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmp49d68o93: /tmp/tmp49d68o93.cpp:16: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string out;\n \
    \ for (int i = 0; i < a.size(); i++) {\n    int a1 = a[i] - '0';\n    int b1 =\
    \ b[i] - '0';\n    out += (a1^b1) + '0';\n  }\n  return out;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result=\"\
    \";\n  assert(a.size()==b.size());\n  int n=a.size();\n  for(int i=0;i<n;i++){\n\
    \    if(a[i]==b[i]){\n      result+='0';\n    }\n    else{\n      result+='1';\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string result;\n\tint len = a.size();\n\tfor (int i = 0; i < len; i++)\
    \ {\n\t\tresult += (a[i] == b[i]) ? '0' : '1';\n\t}\n\treturn result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int i = 0;\n    std::string\
    \ result = \"\";\n    int a_len = a.length();\n    int b_len = b.length();\n \
    \   assert(a_len==b_len);\n    while(i<a_len){\n        if((a[i]=='0'&&b[i]=='0')||(a[i]=='1'&&b[i]=='1')){\n\
    \            result.append(\"0\");\n        }\n        else if((a[i]=='0'&&b[i]=='1')||(a[i]=='1'&&b[i]=='0')){\n\
    \            result.append(\"1\");\n        }\n        i++;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string out;\n\
    \    assert(a.size() == b.size());\n    for (int i = 0; i < a.size(); i++) {\n\
    \        out.push_back((a[i] == b[i]) ? '0' : '1');\n    }\n    return out;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string res;\n\t\
    std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(res), [](char\
    \ a, char b) {\n\t\treturn (a == b) ? '0' : '1';\n\t});\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string res;\n \
    \ res.resize(a.size());\n  for (int i = 0; i < a.size(); i++) {\n    res[i] =\
    \ ((a[i] == '0') ^ (b[i] == '0')) + '0';\n  }\n  return res;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    int length = a.length();\n    assert(length == b.length());\n \
    \   for (int i = 0; i < length; i++) {\n        if (a[i] == b[i]) {\n        \
    \    result.append(\"0\");\n        } else {\n            result.append(\"1\"\
    );\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n   \
    \   result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    assert(a.length() == b.length());\n    for (int i = 0; i < a.length();\
    \ i++) {\n        res += (a[i] == b[i]) ? '0' : '1';\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    int i = 0;\n    while(a[i] && b[i]) {\n        res += std::to_string((a[i]\
    \ - '0') ^ (b[i] - '0'));\n        i++;\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    assert(a.size() == b.size());\n    for (int i = 0; i < a.size();\
    \ i++) {\n        result += (a[i] != b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // check whether the\
    \ strings are of equal length\n    assert(a.length() == b.length());\n    std::string\
    \ result = \"\";\n    // perform XOR operation on every bit\n    for (size_t i\
    \ = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result\
    \ += '0';\n        } else {\n            result += '1';\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    if(a.size() != b.size())\n\
    \        return \"\";\n    int len = a.size();\n    std::string s;\n    for(int\
    \ i = 0; i < len; i++) {\n        int tmp = a[i] - '0' ^ b[i] - '0';\n       \
    \ s += (tmp + '0');\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // your code here.\n\
    \t\n\treturn a;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: "tmpwxgqk4ad: /tmp/tmpwxgqk4ad.cpp:14: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string result = \"\";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tresult\
    \ += (a[i] == b[i]) ? '0' : '1';\n\t}\n\treturn result;\n}\nint main() {\n   \
    \ auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";  // initialize result\n    // traverse all bits, if bits are \n    //\
    \ same, then XOR is 0, else 1\n    for (int i = 0; i < a.size(); i++) {\n    \
    \    // cout << boolalpha << (a[i] == b[i]) << endl;\n        // bool s = a[i]\
    \ == b[i];\n        // cout << boolalpha << (s ? '0' : '1') << endl;\n       \
    \ // cout << a[i] << b[i] << endl;\n        result += (a[i] == b[i]) ? '0' : '1';\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(int i=0;i<a.size();i++){\n        if(a[i]==b[i]){\n            res.push_back('0');\n\
    \        }\n        else{\n            res.push_back('1');\n        }\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n     \
    \ result += '0';\n    else\n      result += '1';\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string result;\n\tfor (size_t i = 0; i < a.size(); i++) {\n\t\tif (a[i]\
    \ == b[i]) {\n\t\t\tresult += '0';\n\t\t} else {\n\t\t\tresult += '1';\n\t\t}\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = string_xor;\n   \
    \ assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result;\n\
    \    int len = a.length();\n    for(int i = 0; i < len; i++) {\n        result\
    \ += ((a[i]-'0') ^ (b[i]-'0'))+'0';\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string res;\n\t\
    for (std::size_t i = 0; i < a.size(); ++i) {\n\t\tres += (a[i] != b[i]) ? '1'\
    \ : '0';\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tint l1 = a.length();\n\
    \tint l2 = b.length();\n\tif (l1 > l2) {\n\t\twhile (l1 != l2) {\n\t\t\tb = '0'\
    \ + b;\n\t\t\tl2++;\n\t\t}\n\t}\n\telse if (l2 > l1) {\n\t\twhile (l2 != l1) {\n\
    \t\t\ta = '0' + a;\n\t\t\tl1++;\n\t\t}\n\t}\n\tstd::string res = \"\";\n\tfor\
    \ (int i = 0; i < l1; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tres += '0';\n\t\telse\n\
    \t\t\tres += '1';\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int size = std::max(a.size(),\
    \ b.size());\n    std::string result(size, '0');\n    for (int i = 0; i < size;\
    \ i++) {\n        char ai = i < a.size() ? a[i] : '0';\n        char bi = i <\
    \ b.size() ? b[i] : '0';\n        result[i] = ai ^ bi ? '1' : '0';\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string answer =\
    \ \"\";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tanswer += (a[i] == b[i])\
    \ ? '0' : '1';\n\t}\n\treturn answer;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(int i=0;i<a.size();i++){\n        if(a[i]!=b[i]) res+='1';\n        else\
    \ res+='0';\n    }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        result += ((a[i] -\
    \ '0') ^ (b[i] - '0')) + '0';\n    }\n    return result;\n}\nint main() {\n  \
    \  auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string res = \"\
    \";\n\tint c = 0;\n\tstd::string::iterator i;\n\tfor (i = a.begin(); i != a.end();\
    \ i++) {\n\t\tc = (((*i == '1') ^ (b[i - a.begin()] == '1')) ^ c);\n\t\tif (c\
    \ == 0)\n\t\t\tres += '0';\n\t\telse\n\t\t\tres += '1';\n\t\tc = ((*i == '1')\
    \ & (b[i - a.begin()] == '1')) | ((*i == '1') & c) | (c & (b[i - a.begin()] ==\
    \ '1'));\n\t}\n\tif (c == 1)\n\t\tres += '1';\n\tstd::reverse(res.begin(), res.end());\n\
    \treturn res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: "tmpiwnz366b: /tmp/tmpiwnz366b.cpp:26: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n\
    \            res += \"0\";\n        } else {\n            res += \"1\";\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(int i=0;i<a.size();i++){\n        if(a[i]==b[i]) res.push_back('0');\n\
    \        else res.push_back('1');\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    int len = std::max(a.length(), b.length());\n    int carry = 0;\n\
    \    for (int i = 0; i < len; i++) {\n        int sum = carry;\n        sum +=\
    \ (i < a.length()) ? a[i] - '0' : 0;\n        sum += (i < b.length()) ? b[i] -\
    \ '0' : 0;\n        if (sum > 1) {\n            carry = 1;\n            sum -=\
    \ 2;\n        } else {\n            carry = 0;\n        }\n        res += sum\
    \ + '0';\n    }\n    if (carry) {\n        res += '1';\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpr78xx_fe: /tmp/tmpr78xx_fe.cpp:30: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int c = 0;\n    std::string\
    \ s;\n    for (int i = 0; i < a.size(); i++) {\n        int n = a[i] ^ b[i];\n\
    \        int last = n;\n        n = n ^ c;\n        c = (last & c) | (last & n)\
    \ | (c & n);\n        s += ('0' + n);\n    }\n    return s;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmp035wulw8: /tmp/tmp035wulw8.cpp:21: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    if(a.size() != b.size())\
    \ {\n        std::cout << \"Length of strings must be equal\" << std::endl;\n\
    \        return \"\";\n    }\n    int n = a.size();\n    std::string res = \"\"\
    ;\n    for(int i = 0; i < n; i++) {\n        if(a[i] == b[i]) {\n            res\
    \ += '0';\n        } else {\n            res += '1';\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++) {\n        res += (a[i] == b[i])\
    \ ? '0' : '1';\n    }\n    return res;\n}\nint main() {\n    auto candidate =\
    \ string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    int n = a.size();\n    for (int i = 0; i < n; i++) {\n        result\
    \ += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tint len1 = a.length();\n\
    \tint len2 = b.length();\n\tif (len1 > len2) {\n\t\tstd::string temp;\n\t\tfor\
    \ (int i = 0; i < len1 - len2; i++) {\n\t\t\ttemp += '0';\n\t\t}\n\t\tb = temp\
    \ + b;\n\t}\n\telse if (len2 > len1) {\n\t\tstd::string temp;\n\t\tfor (int i\
    \ = 0; i < len2 - len1; i++) {\n\t\t\ttemp += '0';\n\t\t}\n\t\ta = temp + a;\n\
    \t}\n\tstd::string answer;\n\tfor (int i = 0; i < a.length(); i++) {\n\t\tif (a[i]\
    \ == b[i]) {\n\t\t\tanswer += '0';\n\t\t}\n\t\telse if (a[i] != b[i]) {\n\t\t\t\
    answer += '1';\n\t\t}\n\t}\n\treturn answer;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string ans = \"\
    \";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\tans\
    \ += '0';\n\t\t} else {\n\t\t\tans += '1';\n\t\t}\n\t}\n\treturn ans;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  for (int i = 0; i < a.size(); i++) {\n    result += (a[i] != b[i]) ? '1' :\
    \ '0';\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int aLen = a.length();\n\
    \    int bLen = b.length();\n    assert(aLen == bLen);\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < aLen; i++) {\n        char c1 = a[i];\n     \
    \   char c2 = b[i];\n        if (c1 == c2) {\n            res += '0';\n      \
    \  } else {\n            res += '1';\n        }\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string ans;\n  for (size_t i = 0; i < a.size(); i++) {\n    if (a[i] ==\
    \ b[i]) {\n      ans += '0';\n    } else {\n      ans += '1';\n    }\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    // i is the index of the first 1 in the b string\n    // If\
    \ a string b only contain 0s return empty string\n    int i = 0;\n    while (b[i]\
    \ == '0') {\n        ++i;\n    }\n    std::stringstream res;\n    int j = 0;\n\
    \    while (j < a.size()) {\n        if (a[j] == b[j]) {\n            res << '0';\n\
    \        } else {\n            res << '1';\n        }\n        j++;\n    }\n \
    \   return res.str();\n}\nint main() {\n    auto candidate = string_xor;\n   \
    \ assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  int length = a.length();\n  assert(length == b.length());\n  for (int i = 0;\
    \ i < length; i++) {\n    if ((a[i] == '0' && b[i] == '0') || (a[i] == '1' &&\
    \ b[i] == '1')) {\n      result.push_back('0');\n    } else {\n      result.push_back('1');\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // Assert that the\
    \ two strings are of the same length.\n    assert(a.length() == b.length());\n\
    \    std::string result;\n    for (int i = 0; i < a.length(); i++) {\n       \
    \ // If one of the bits is 1 and the other is 0, add a 1 to the result.\n    \
    \    if ((a[i] == '1' && b[i] == '0') || (a[i] == '0' && b[i] == '1')) {\n   \
    \         result += '1';\n        }\n        // Otherwise, add a 0 to the result.\n\
    \        else {\n            result += '0';\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string s = \"\
    \";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i]) s.push_back('0');\n\
    \        else s.push_back('1');\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) ==\
    \ (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    if(a.size() != b.size())\
    \ return \"Strings must be of same length.\";\n    std::string result = \"\";\n\
    \    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i]) {\n       \
    \     result += \"0\";\n        } else {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n   \
    \   result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\treturn \"\";\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmp1bswbw1l: /tmp/tmp1bswbw1l.cpp:12: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n     \
    \ result += '0';\n    else\n      result += '1';\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string res;\n  int n = a.size();\n  for (int i = 0; i < n; i++) {\n  \
    \  if (a[i] == b[i])\n      res += '0';\n    else\n      res += '1';\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string ans=\"\
    \";\n    assert(a.length() == b.length());\n    for(int i=0;i<a.length();i++)\
    \ {\n        if(a[i] == b[i]) {\n            ans += '0';\n        } else {\n \
    \           ans += '1';\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  // your code here\n\
    \  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    //\
    \ XOR logic: if a and b are equal, a xor b will be 0\n    if (a[i] == b[i]) {\n\
    \      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  // TODO: your code here!\n\
    \  int a_len = a.length();\n  int b_len = b.length();\n  std::string ans = \"\"\
    ;\n  int carry = 0;\n  // Gives answer as a string\n  for(int i = a_len - 1, j\
    \ = b_len - 1; i >= 0 || j >= 0; i--, j--) {\n    int a_bit = 0;\n    int b_bit\
    \ = 0;\n    if(i >= 0)\n      a_bit = a[i] - '0';\n    if(j >= 0)\n      b_bit\
    \ = b[j] - '0';\n    int sum = a_bit ^ b_bit ^ carry;\n    ans = std::to_string(sum)\
    \ + ans;\n    carry = (a_bit & b_bit) | (a_bit & carry) | (b_bit & carry);\n \
    \ }\n  if(carry)\n    ans = std::to_string(carry) + ans;\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmplweh8rcj: /tmp/tmplweh8rcj.cpp:31: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int aSize = a.size();\n\
    \    int bSize = b.size();\n    int minSize = (aSize < bSize) ? aSize : bSize;\n\
    \    std::string result = \"\";\n    for (int i = 0; i < minSize; i++) {\n   \
    \     result += (a[i] ^ b[i]) + '0';\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    assert(a.length() == b.length());\n    for (int i = 0; i < a.length();\
    \ i++) {\n        res += (a[i] == b[i]) ? '0' : '1';\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    std::string temp = \"\";\n    int i=0;\n    while(i < a.length()\
    \ && i < b.length()){\n        if(a[i] == b[i]){\n            temp += \"0\";\n\
    \        }\n        else{\n            temp += \"1\";\n        }\n        i++;\n\
    \    }\n    if(i != a.length()){\n        temp += a.substr(i, a.length()-i);\n\
    \    }\n    else if(i != b.length()){\n        temp += b.substr(i, b.length()-i);\n\
    \    }\n    i = 0;\n    while(i < temp.length()){\n        if(temp[i] == '0'){\n\
    \            if(result.length() > 0 || temp[i+1] == '1'){\n                result\
    \ += temp[i];\n            }\n        }\n        else{\n            result +=\
    \ temp[i];\n        }\n        i++;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpmovsnzhe: /tmp/tmpmovsnzhe.cpp:43: int main(): Assertion `candidate((\"\
    1\"), (\"1\")) == (\"0\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  for (int i = 0; i < a.size(); i++) {\n    result += (a[i] == b[i]) ? '0' :\
    \ '1';\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result = \"\";\n    for (int i = 0; i < a.size();\
    \ i++) {\n        int x = (a[i] == '0') ? 0 : 1;\n        int y = (b[i] == '0')\
    \ ? 0 : 1;\n        if (x != y) {\n            result += '1';\n        } else\
    \ {\n            result += '0';\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string ans = \"\
    \";\n  int length = std::max(a.length(), b.length());\n  int aLen = a.length();\n\
    \  int bLen = b.length();\n  char minBinary = '0';\n  while (aLen > 0 || bLen\
    \ > 0) {\n    char aChar = aLen > 0 ? a[aLen - 1] : minBinary;\n    char bChar\
    \ = bLen > 0 ? b[bLen - 1] : minBinary;\n    if (aChar == bChar) {\n      ans\
    \ = '0' + ans;\n    } else {\n      ans = '1' + ans;\n    }\n    aLen--;\n   \
    \ bLen--;\n  }\n  return ans;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n\
    \            res += \"0\";\n        } else {\n            res += \"1\";\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string xor_string;\n\
    \    if(a.length() > b.length()) {\n        std::string zeros(a.length() - b.length(),\
    \ '0');\n        b = zeros + b;\n    } else if(a.length() < b.length()) {\n  \
    \      std::string zeros(b.length() - a.length(), '0');\n        a = zeros + a;\n\
    \    }\n    assert(a.length() == b.length());\n    for(int i = 0; i < a.length();\
    \ i++) {\n        if(a[i] == b[i]) {\n            xor_string += '0';\n       \
    \ } else {\n            xor_string += '1';\n        }\n    }\n    return xor_string;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  if (a.length() != b.length())\n\
    \    return \"\";\n  std::string result;\n  for (std::size_t i = 0; i < a.length();\
    \ i++) {\n    if (a[i] == b[i])\n      result += '0';\n    else\n      result\
    \ += '1';\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string result =\
    \ \"\";\n\tint l1 = a.length();\n\tint l2 = b.length();\n\tif (l1 != l2) {\n\t\
    \tif (l1 > l2) {\n\t\t\tint x = l1 - l2;\n\t\t\twhile (x--) {\n\t\t\t\tb = '0'\
    \ + b;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint x = l2 - l1;\n\t\t\twhile (x--)\
    \ {\n\t\t\t\ta = '0' + a;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.length();\
    \ i++) {\n\t\tif (a[i] == b[i])\n\t\t\tresult = result + '0';\n\t\telse\n\t\t\t\
    result = result + '1';\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string xor_str;\n\
    \tfor (int i = 0; i < std::min(a.length(), b.length()); i++) {\n\t\tif (a[i] ==\
    \ b[i])\n\t\t\txor_str += '0';\n\t\telse\n\t\t\txor_str += '1';\n\t}\n\treturn\
    \ xor_str;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(size_t i = 0; i < a.size(); i++) {\n        if(a[i] == b[i]) {\n    \
    \        res += '0';\n        } else {\n            res += '1';\n        }\n \
    \   }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n  \
    \  assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    int m = a.size();\n    int n = b.size();\n    int i = m-1;\n    int j = n-1;\n\
    \    while(i>=0 || j>=0) {\n        if(i<0) {\n            res = b[j] + res;\n\
    \            j--;\n        }\n        else if(j<0) {\n            res = a[i] +\
    \ res;\n            i--;\n        }\n        else {\n            if(a[i]==b[j])\
    \ {\n                res = '0' + res;\n            }\n            else res = '1'\
    \ + res;\n            i--;\n            j--;\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i])\n\
    \            result += '0';\n        else\n            result += '1';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string ret(a.size(), '0');\n  for (int i = 0; i < a.size(); ++i) {\n \
    \   ret[i] = (a[i] - '0') ^ (b[i] - '0') + '0';\n  }\n  return ret;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string xored;\n\
    \tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\txored +=\
    \ '0';\n\t\t}\n\t\telse {\n\t\t\txored += '1';\n\t\t}\n\t}\n\treturn xored;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // your code here!\n\
    \tstd::string str=\"\";\n\tfor(int i=0;i<a.length();i++)\n\t{\n\t\tif(a[i]==b[i])\n\
    \t\t\tstr=str+\"0\";\n\t\telse\n\t\t\tstr=str+\"1\";\n\t}\n    return str;\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int len1 = a.length();\n\
    \    int len2 = b.length();\n    int diff = std::abs(len1 - len2);\n    std::string\
    \ temp = \"\";\n    if(len1 > len2) {\n        while(diff) {\n            temp\
    \ += \"0\";\n            diff--;\n        }\n        b = temp + b;\n    }\n  \
    \  else if(len2 > len1) {\n        while(diff) {\n            temp += \"0\";\n\
    \            diff--;\n        }\n        a = temp + a;\n    }\n    std::string\
    \ result = \"\";\n    for(int i = 0; i < a.length(); i++) {\n        if(a[i] ==\
    \ b[i])\n            result += \"0\";\n        else\n            result += \"\
    1\";\n    }\n    return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string ans = \"\
    \";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      ans\
    \ += '0';\n    } else {\n      ans += '1';\n    }\n  }\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int m = a.size();\n\
    \    int n = b.size();\n    if(m != n) {\n        std::cerr << \"error: string_xor\
    \ : invalid arguments sizes\" << std::endl;\n        std::exit(1);\n    }\n  \
    \  for(int i = 0; i < m; i++) {\n        assert(a[i] == '0' || a[i] == '1');\n\
    \        assert(b[i] == '0' || b[i] == '1');\n    }\n    std::string c = \"\"\
    ;\n    for(int i = 0; i < m; i++) {\n        if(a[i] == b[i]) {\n            c\
    \ += '0';\n        } else {\n            c += '1';\n        }\n    }\n    return\
    \ c;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string xor1=\
    \ \"\";\n    for(int i=0; i<a.length(); i++){\n        if(a[i] == b[i]){\n   \
    \         xor1 += \"0\";\n        }\n        else{\n            xor1 += \"1\"\
    ;\n        }\n    }\n    return xor1;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(int i=0;i<a.size();i++){\n        if(a[i]==b[i])\n            res.push_back('0');\n\
    \        else\n            res.push_back('1');\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(int i=0;i<a.size();i++){\n        if(a[i]==b[i]){\n            res.push_back('0');\n\
    \        }else{\n            res.push_back('1');\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  // your code here...\n\
    \  std::string x = \"\";\n  for(int i = 0; i < a.length(); i++){\n    if((a[i]\
    \ == '1' && b[i] == '0') || (a[i] == '0' && b[i] == '1')){\n      x += '1';\n\
    \    }\n    else{\n      x += '0';\n    }\n  }\n  return x;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string ans;\n \
    \ int l = a.length();\n  for(int i = 0; i < l; i++) {\n    int x = (a[i] == '0'\
    \ ? 0 : 1) ^ (b[i] == '0' ? 0 : 1);\n    ans.push_back(x + '0');\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string s = \"\
    \";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i]) s += '0';\n\
    \        else s += '1';\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  for (size_t i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result\
    \ += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string ret;\n\tfor (size_t i = 0; i < a.size(); i++) {\n\t\tif (a[i] ==\
    \ b[i])\n\t\t\tret += '0';\n\t\telse\n\t\t\tret += '1';\n\t}\n\treturn ret;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i])\n\
    \            result += '0';\n        else\n            result += '1';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string r;\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\
    \ {\n      r += '0';\n    } else {\n      r += '1';\n    }\n  }\n  return r;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n   if(a.size() == b.size())\
    \ {\n      std::string result = \"\";\n      for(int i = 0; i < a.size(); i++)\
    \ {\n         if(a[i] == b[i]) {\n            result += '0';\n         } else\
    \ {\n            result += '1';\n         }\n      }\n      return result;\n \
    \  }\n   else {\n      assert(0);\n   }\n}\nint main() {\n    auto candidate =\
    \ string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tint i;\n\tstd::string\
    \ result = \"\";\n\tfor (i = 0; i < (int) a.size(); i++) {\n\t\tif (a[i] == b[i])\n\
    \t\t\tresult += '0';\n\t\telse\n\t\t\tresult += '1';\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string ret;\n\
    \    int len = a.length();\n    for(int i = 0; i < len; i++) {\n        ret.push_back((a[i]\
    \ - '0') ^ (b[i] - '0') + '0');\n    }\n    return ret;\n}\nint main() {\n   \
    \ auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n\
    \            res += \"0\";\n        } else {\n            res += \"1\";\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t//assert(a.length()\
    \ == b.length());\n\tif (a.length() != b.length())\n\t\treturn \"\";\n\tint n\
    \ = a.length();\n\tstd::string res = \"\";\n\tfor (int i = 0; i < n; i++) {\n\t\
    \tif (a[i] == b[i])\n\t\t\tres += '0';\n\t\telse\n\t\t\tres += '1';\n\t}\n\treturn\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result = \"\";\n    for (int i = 0; i < a.size();\
    \ i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else\
    \ {\n            result += '1';\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::stringstream ss;\n  for (int i = 0; i < a.size(); i++) {\n    int x =\
    \ a[i] - '0';\n    int y = b[i] - '0';\n    ss << (x ^ y);\n  }\n  return ss.str();\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";  // initialize result\n    // traverse all bits, if bits are \n    //\
    \ same, then XOR is 0, else 1\n    for (int i = 0; i < a.size(); i++) {\n    \
    \    // convert both bits to int \n        bool x = a[i] - '0';\n        bool\
    \ y = b[i] - '0';\n        // Take XOR of current bits and add them to result\n\
    \        result += (x ^ y) + '0';\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    string res;\n    int\
    \ len = min(a.length(), b.length());\n    for(int i = 0; i < len; i++) {\n   \
    \     res += (a[i] == b[i]) ? '0' : '1';\n    }\n    // Fill the rest with 0s\n\
    \    for(int i = len; i < a.length(); i++) {\n        res += '0';\n    }\n   \
    \ for(int i = len; i < b.length(); i++) {\n        res += '0';\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd4_r2yd0.cpp: In function \u2018std::string string_xor(std::string,\
    \ std::string)\u2019:\n/tmp/tmpd4_r2yd0.cpp:8:5: error: \u2018string\u2019 was\
    \ not declared in this scope; did you mean \u2018std::string\u2019?\n    8 | \
    \    string res;\n      |     ^~~~~~\n      |     std::string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpd4_r2yd0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpd4_r2yd0.cpp:9:15:\
    \ error: \u2018min\u2019 was not declared in this scope; did you mean \u2018std::min\u2019\
    ?\n    9 |     int len = min(a.length(), b.length());\n      |               ^~~\n\
    \      |               std::min\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd4_r2yd0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmpd4_r2yd0.cpp:11:9: error: \u2018\
    res\u2019 was not declared in this scope\n   11 |         res += (a[i] == b[i])\
    \ ? '0' : '1';\n      |         ^~~\n/tmp/tmpd4_r2yd0.cpp:15:9: error: \u2018\
    res\u2019 was not declared in this scope\n   15 |         res += '0';\n      |\
    \         ^~~\n/tmp/tmpd4_r2yd0.cpp:18"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t// Your code here.\n\
    \tassert(a.length() == b.length());\n\tstd::string result;\n\tfor (int i = 0;\
    \ i < a.length(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\tresult += '0';\n\t\t\
    }\n\t\telse {\n\t\t\tresult += '1';\n\t\t}\n\t}\n\treturn result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i]) result\
    \ += '0';\n        else result += '1';\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i])\n\
    \            result += '0';\n        else\n            result += '1';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result;\n    for (std::size_t i = 0; i < a.size();\
    \ ++i) {\n        int num = a[i] ^ b[i];\n        result += num + '0';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string res;\n    for (int i = 0; i < a.size(); i++) {\n\
    \        if (a[i] == b[i]) {\n            res += '0';\n        } else {\n    \
    \        res += '1';\n        }\n    }\n    return res;\n}\nint main() {\n   \
    \ auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // your code here\n\
    \    if(a.size()>b.size())\n    b=string(a.size()-b.size(),'0')+b;\n    else if(a.size()<b.size())\n\
    \    a=string(b.size()-a.size(),'0')+a;\n    string res;\n    for(int i=0;i<a.size();i++)\n\
    \    {\n        if(a[i]==b[i])\n        res.push_back('0');\n        else\n  \
    \      res.push_back('1');\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) ==\
    \ (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5klvqxh6.cpp: In function \u2018std::string string_xor(std::string,\
    \ std::string)\u2019:\n/tmp/tmp5klvqxh6.cpp:10:7: error: \u2018string\u2019 was\
    \ not declared in this scope; did you mean \u2018std::string\u2019?\n   10 | \
    \    b=string(a.size()-b.size(),'0')+b;\n      |       ^~~~~~\n      |       std::string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5klvqxh6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp5klvqxh6.cpp:12:7:\
    \ error: \u2018string\u2019 was not declared in this scope; did you mean \u2018\
    std::string\u2019?\n   12 |     a=string(b.size()-a.size(),'0')+a;\n      |  \
    \     ^~~~~~\n      |       std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5klvqxh6.cpp:2:\n/shared/centos7/gcc/9.2"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string res;\n \
    \ int n = a.size();\n  int m = b.size();\n  int i = n - 1;\n  int j = m - 1;\n\
    \  while (i >= 0 && j >= 0) {\n    if (a[i] == b[j]) {\n      res.push_back('0');\n\
    \    } else {\n      res.push_back('1');\n    }\n    i--;\n    j--;\n  }\n  while\
    \ (i >= 0) {\n    res.push_back(a[i]);\n    i--;\n  }\n  while (j >= 0) {\n  \
    \  res.push_back(b[j]);\n    j--;\n  }\n  std::reverse(res.begin(), res.end());\n\
    \  return res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string result;\n\
    \tfor (int i = 0; i < (int)a.size(); i++) {\n\t\tchar c = a[i] ^ b[i];\n\t\tresult\
    \ += c;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: "tmpk4w_cky5: /tmp/tmpk4w_cky5.cpp:17: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string result;\n  std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(result),\n\
    \                 [](char a, char b) { return a ^ b; });\n  return result;\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpbepnr8be: /tmp/tmpbepnr8be.cpp:16: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string xor_res;\n\
    \    for(int i=0;i<(int)a.size();i++){\n        if(a[i]!=b[i]) xor_res += '1';\n\
    \        else xor_res += '0';\n    }\n    return xor_res;\n}\nint main() {\n \
    \   auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i])\n\
    \            result += '0';\n        else\n            result += '1';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    int n = a.size();\n    std::string c(n, '0');\n    for (int\
    \ i = 0; i < n; i++) {\n        if (a[i] == b[i]) {\n            c[i] = '0';\n\
    \        } else {\n            c[i] = '1';\n        }\n    }\n    return c;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string result =\
    \ \"\";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i])\n\t\t\t\
    result += '0';\n\t\telse\n\t\t\tresult += '1';\n\t}\n\treturn result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::stringstream\
    \ ss;\n    for (int i = 0; i < a.size(); i++) {\n        int x = (a[i] - '0')\
    \ ^ (b[i] - '0');\n        ss << x;\n    }\n    return ss.str();\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string res;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tint r = (a[i]\
    \ - '0') ^ (b[i] - '0');\n\t\tres += std::to_string(r);\n\t}\n\treturn res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  int n = a.size();\n  assert(n == b.size());\n  for (int i = 0; i < n; i++)\
    \ {\n    if (a[i] == b[i]) {\n      result += '0';\n    } else {\n      result\
    \ += '1';\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // TODO: Your code\
    \ here\n    std::string result;\n    int len = std::max(a.length(), b.length());\n\
    \    int carry = 0;\n    a = std::string(len - a.length(), '0') + a;\n    b =\
    \ std::string(len - b.length(), '0') + b;\n    for (int i = len - 1; i >= 0; i--)\
    \ {\n        int digit = carry ^ (a[i] - '0') ^ (b[i] - '0');\n        result\
    \ = std::to_string(digit) + result;\n        carry = (a[i] - '0') & (b[i] - '0');\n\
    \    }\n    if (carry) {\n        result = '1' + result;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpheamlhka: /tmp/tmpheamlhka.cpp:26: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string xor_str=\"\
    \";\n  if(a.length()>b.length())\n  {\n    for(int i=0;i<b.length();i++)\n   \
    \ {\n      if(a[i]==b[i])\n      {\n        xor_str+=\"0\";\n      }\n      else\n\
    \      {\n        xor_str+=\"1\";\n      }\n    }\n    xor_str+=a.substr(b.length());\n\
    \  }\n  else\n  {\n    for(int i=0;i<a.length();i++)\n    {\n      if(a[i]==b[i])\n\
    \      {\n        xor_str+=\"0\";\n      }\n      else\n      {\n        xor_str+=\"\
    1\";\n      }\n    }\n    xor_str+=b.substr(a.length());\n  }\n  return xor_str;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string output = \"\";\n    for (int i = 0; i < a.size();\
    \ i++) {\n        if (a[i] == b[i]) {\n            output += \"0\";\n        }\
    \ else {\n            output += \"1\";\n        }\n    }\n    return output;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  for (size_t i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n      result\
    \ += '0';\n    else\n      result += '1';\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string s;\n \
    \   int n = a.size();\n    int m = b.size();\n    assert(n == m);\n    for (int\
    \ i = 0; i < n; i++) {\n        char ch = (a[i] == b[i]) ? '0' : '1';\n      \
    \  s += ch;\n    }\n    return s;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int i;\n    std::string\
    \ res;\n    for(i=0;i<a.length();i++)\n    {\n        if(a[i]==b[i])\n       \
    \     res+='0';\n        else\n            res+='1';\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result;\n\
    \    for (int i = 0; i < a.size(); i++) {\n        result += a[i] == b[i] ? '0'\
    \ : '1';\n    }\n    return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    int len = std::max(a.length(), b.length());\n    for (int i = 0;\
    \ i < len; i++) {\n        int m = (a[i] == '1');\n        int n = (b[i] == '1');\n\
    \        res += (m ^ n) + '0';\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) ==\
    \ (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++)\n        res += (a[i] == b[i])\
    \ ? '0' : '1';\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string res;\n\t\
    for (size_t i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\tres +=\
    \ '0';\n\t\t}\n\t\telse {\n\t\t\tres += '1';\n\t\t}\n\t}\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::stringstream ss;\n\
    \  for (size_t i = 0; i < a.size(); ++i) {\n    if (a[i] == b[i]) {\n      ss\
    \ << '0';\n    } else {\n      ss << '1';\n    }\n  }\n  return ss.str();\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    if(a.size() > b.size())\n\
    \    {\n        int delta = a.size() - b.size();\n        for(int i = 0; i < delta;\
    \ i++)\n        {\n            b = \"0\" + b;\n        }\n    }\n    else if(a.size()\
    \ < b.size())\n    {\n        int delta = b.size() - a.size();\n        for(int\
    \ i = 0; i < delta; i++)\n        {\n            a = \"0\" + a;\n        }\n \
    \   }\n    std::string sol = \"\";\n    for(int i = 0; i < a.size(); i++)\n  \
    \  {\n        if(a[i] == b[i])\n        {\n            sol += \"0\";\n       \
    \ }\n        else\n        {\n            sol += \"1\";\n        }\n    }\n  \
    \  return sol;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string xorstring;\n    for(int i = 0; i < a.size(); i++)\
    \ {\n        if(a[i] == b[i]) {\n            xorstring.push_back('0');\n     \
    \   } else {\n            xorstring.push_back('1');\n        }\n    }\n    return\
    \ xorstring;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++)\n    {\n        if(a[i] == b[i])\n\
    \            result += '0';\n        else\n            result += '1';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string res = \"\";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tres +=\
    \ '0' + (a[i] - '0') ^ (b[i] - '0');\n\t}\n\treturn res;\n}\nint main() {\n  \
    \  auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::stringstream result;\n\
    \tfor (int i = 0; i < a.size(); i++) {\n\t\tresult << (a[i] != b[i]);\n\t}\n\t\
    return result.str();\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    // your code here\n\
    \    std::string output=\"\";\n    assert(a.length()==b.length());\n    for(int\
    \ i=0;i<a.length();i++){\n        if(a[i]==b[i]){\n            output=output+\"\
    0\";\n        }\n        else{\n            output=output+\"1\";\n        }\n\
    \    }\n    return output;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string answer;\n  for (unsigned int i = 0; i < a.size(); i++) {\n    answer\
    \ += (a[i] == b[i]) ? '0' : '1';\n  }\n  return answer;\n}\nint main() {\n   \
    \ auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string res;\n    for (int i = 0; i < a.size(); i++) {\n\
    \        res += ((a[i] == '0') ^ (b[i] == '0')) ? '1' : '0';\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string c;\n    c.resize(a.size());\n    for (size_t i =\
    \ 0; i < a.size(); i++) {\n        if (a[i] == b[i])\n            c[i] = '0';\n\
    \        else\n            c[i] = '1';\n    }\n    return c;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t// assert(a.length()\
    \ == b.length());\n\tstd::string output;\n\t// for (int i = 0; i < a.length();\
    \ i++) {\n\t// \tif (a[i] == b[i]) {\n\t// \t\toutput += '0';\n\t// \t} else {\n\
    \t// \t\toutput += '1';\n\t// \t}\n\t// }\n\tint x = std::stoi(a, nullptr, 2);\n\
    \tint y = std::stoi(b, nullptr, 2);\n\tint z = x ^ y;\n\toutput = std::bitset<32>(z).to_string();\n\
    \toutput = output.substr(output.find('1'));\n\treturn output;\n}\nint main() {\n\
    \    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpxkyegxsd: /tmp/tmpxkyegxsd.cpp:26: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int len_a = a.length();\n\
    \    int len_b = b.length();\n    int result_length = 0;\n    if (len_a > len_b)\
    \ {\n        result_length = len_a;\n    } else {\n        result_length = len_b;\n\
    \    }\n    std::string result = \"\";\n    for (int i = 0; i < result_length;\
    \ i++) {\n        char num1, num2;\n        if (i < len_a) {\n            num1\
    \ = a[i];\n        } else {\n            num1 = '0';\n        }\n        if (i\
    \ < len_b) {\n            num2 = b[i];\n        } else {\n            num2 = '0';\n\
    \        }\n        if (num1 == num2) {\n            result += '0';\n        }\
    \ else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result;\n    for (size_t i = 0; i < a.size(); i++)\
    \ {\n        result += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    if(a.size() != b.size())\n\
    \        return \"\";\n    std::string result = \"\";\n    for(int i = 0; i <\
    \ a.size(); i++) {\n        if(a[i] == b[i])\n            result += '0';\n   \
    \     else\n            result += '1';\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  int i = 0;\n  int s\
    \ = a.size();\n  std::string res = \"\";\n  for (i = 0; i < s; i++) {\n    if\
    \ (a[i] == b[i]) {\n      res += \"0\";\n    } else {\n      res += \"1\";\n \
    \   }\n  }\n  return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int lena = a.length();\n\
    \    int lenb = b.length();\n    int len = lena>lenb?lena:lenb;\n    std::string\
    \ c = \"\";\n    for(int i=0;i<len;i++){\n        int indexa = len-1-i;\n    \
    \    int indexb = len-1-i;\n        int chara = (indexa>=0&&indexa<lena)?a[indexa]-'0':0;\n\
    \        int charb = (indexb>=0&&indexb<lenb)?b[indexb]-'0':0;\n        c = (chara^charb)+c;\n\
    \    }\n    return c;\n}\nint main() {\n    auto candidate = string_xor;\n   \
    \ assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8puz5u9x.cpp: In function \u2018std::string string_xor(std::string,\
    \ std::string)\u2019:\n/tmp/tmp8puz5u9x.cpp:17:26: error: no match for \u2018\
    operator+\u2019 (operand types are \u2018int\u2019 and \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019})\n   17 |         c = (chara^charb)+c;\n\
    \      |             ~~~~~~~~~~~~~^~\n      |                   |       |\n  \
    \    |                   int     std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8puz5u9x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp8puz5u9x.cpp:17:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   17\
    \ |         c = (chara^charb)+c;\n      |                           ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result;\n\
    \    int i;\n    for(i=0;i<a.length();i++)\n    {\n        result += (a[i] ==\
    \ b[i]) ? '0' : '1';\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    int s = a.size();\n    int t = b.size();\n    int  i = 0;\n   \
    \ // Append zeros to make length's of both string same\n    if(s < t) {\n    \
    \    for(i = 0 ; i < t - s ; i++) {\n            a = '0' + a;\n        }\n   \
    \ }\n    else if(s > t) {\n        for(i = 0 ; i < s - t ; i++) {\n          \
    \  b = '0' + b;\n        }\n    }\n    for(i = 0 ; i < a.size() ; i++) {\n   \
    \     result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    result += (a[i] == b[i])\
    \ ? '0' : '1';\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  // Your code here\n\
    \  std::string result=\"\";\n  for(int i=0;i<a.length();i++)\n  {\n    if(a[i]==b[i])\n\
    \      result.push_back('0');\n    else\n      result.push_back('1');\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string s=\"\"\
    ;\n    for(int i=0;i<a.size();i++)\n        s+=(a[i]==b[i])?0:1;\n    return s;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmp807jaer3: /tmp/tmp807jaer3.cpp:15: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string ans = \"\";\n    for (int i = 0; i < a.size(); i++)\
    \ {\n        if (a[i] == b[i])\n            ans += '0';\n        else\n      \
    \      ans += '1';\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::string c = \"\";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tc += (a[i]\
    \ == b[i]) ? '0' : '1';\n\t}\n\treturn c;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string c;\n  c.resize(a.size());\n\
    \  for (int i = 0; i < a.size(); i++) {\n    c[i] = (a[i] == b[i]) ? '0' : '1';\n\
    \  }\n  return c;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int len = a.length();\n\
    \    std::string out=\"\";\n    for(int i=0;i<len;i++){\n        if(a[i]==b[i])\
    \ out.push_back('0');\n        else out.push_back('1');\n    }\n    return out;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == b[i]) {\n\
    \            result += '0';\n        } else {\n            result += '1';\n  \
    \      }\n    }\n    return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    return \"\";\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmpxths90vz: /tmp/tmpxths90vz.cpp:12: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result = a;\n    for (int i = 0; i < a.size(); i++)\
    \ {\n        if (a[i] == b[i]) {\n            result[i] = '0';\n        } else\
    \ {\n            result[i] = '1';\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t//Your code here\n\t\
    return std::bitset<8>(a).to_ulong() ^ std::bitset<8>(b).to_ulong();\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnx8hhi0i.cpp: In function \u2018std::string string_xor(std::string,\
    \ std::string)\u2019:\n/tmp/tmpnx8hhi0i.cpp:9:38: error: could not convert \u2018\
    (std::bitset<8>(a, 0).std::bitset<8>::to_ulong() ^ std::bitset<8>(b, 0).std::bitset<8>::to_ulong())\u2019\
    \ from \u2018long unsigned int\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n    9 |  return std::bitset<8>(a).to_ulong() ^ std::bitset<8>(b).to_ulong();\n\
    \      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                      |\n      |                     \
    \                 long unsigned int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    assert(a.length() == b.length());\n    for (int i = 0; i < a.length();\
    \ i++) {\n        if (a[i] == b[i]) {\n            res.push_back('0');\n     \
    \   } else {\n            res.push_back('1');\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string s = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    // Add the\
    \ bits\n    s += '0' + (a[i]-'0') ^ (b[i]-'0');\n  }\n  return s;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tchar tmp;\n\tstd::string\
    \ res;\n\tfor (int i = 0; i < a.length(); i++) {\n\t\tif (a[i] == b[i]) tmp =\
    \ '0';\n\t\telse tmp = '1';\n\t\tres += tmp;\n\t}\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    \n    std::string\
    \ result = \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] ==\
    \ b[i]) {\n            result += '0';\n        }\n        else {\n           \
    \ result += '1';\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) ==\
    \ (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  assert(a.size() == b.size());\n\
    \  std::string x = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i]\
    \ == b[i])\n      x += \"0\";\n    else\n      x += \"1\";\n  }\n  return x;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result;\n\
    \    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i])\n       \
    \     result += '0';\n        else\n            result += '1';\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";  // initialize result\n    // Traverse all characters\n    for (int\
    \ i = 0; i < a.size(); i++) {\n        // If characters are same, append 0 to\
    \ result\n        if (a[i] == b[i])\n            result.push_back('0');\n    \
    \    // Else append 1 to result\n        else\n            result.push_back('1');\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int lena = a.length();\n\
    \    int lenb = b.length();\n    int len = std::max(lena, lenb);\n    std::string\
    \ res(len, '0');\n    int i;\n    for (i = 0; i < lena && i < lenb; i++) {\n \
    \       res[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    while (i < lena) {\n\
    \        res[i] = a[i];\n        i++;\n    }\n    while (i < lenb) {\n       \
    \ res[i] = b[i];\n        i++;\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) ==\
    \ (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result;\n\
    \  for (int i = 0; i < a.size(); i++) {\n    result += ((a[i] - '0') ^ (b[i] -\
    \ '0')) + '0';\n  }\n  return result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tint n = a.size();\n\t\
    int m = b.size();\n\tassert(n==m);\n\tstd::string result = \"\";\n\tfor(int i=0;\
    \ i<n; i++) {\n\t\tif(a[i]==b[i])\n\t\t\tresult += '0';\n\t\telse\n\t\t\tresult\
    \ += '1';\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tint N = a.size();\n\t\
    int M = b.size();\n\tif (N != M) {\n\t\tthrow std::runtime_error(\"Size mismatch\"\
    );\n\t}\n\tstd::stringstream result;\n\tfor (int i = 0; i < N; i++) {\n\t\tif\
    \ (a[i] == b[i]) {\n\t\t\tresult << \"0\";\n\t\t} else {\n\t\t\tresult << \"1\"\
    ;\n\t\t}\n\t}\n\treturn result.str();\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t// Here, input is a\
    \ string\n\t// XOR result is also string\n\t// so, we have to convert charachter\
    \ from string to integer\n\t// then XOR them and convert the integer to string.\n\
    \tstd::string res;\n\t// Check if size of strings is same\n\tif (a.size() != b.size())\
    \ {\n\t\tassert(0);\n\t}\n\telse {\n\t\t// Conversion from character to integer\n\
    \t\tfor (int i = 0; i < a.size(); i++) {\n\t\t\tres.push_back(((a[i] - '0') ^\
    \ (b[i] - '0')) + '0');\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto\
    \ candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) ==\
    \ (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n\
    \            res += \"0\";\n        } else {\n            res += \"1\";\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n   \
    \   result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string s = \"\"\
    ;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i]) {\n\t\t\ts.push_back('0');\n\
    \t\t} else {\n\t\t\ts.push_back('1');\n\t\t}\n\t}\n\treturn s;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res=\"\
    \";\n    int i;\n    for(i=0;i<a.length();i++)\n    {\n        if(a[i]==b[i])\n\
    \            res+='0';\n        else\n            res+='1';\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string result =\
    \ \"\";\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i])\n\t\t\t\
    result += '0';\n\t\telse\n\t\t\tresult += '1';\n\t}\n\treturn result;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++)\
    \ {\n        result += a[i] ^ b[i];\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: "tmp914j89nd: /tmp/tmp914j89nd.cpp:17: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tassert(a.size() == b.size());\n\
    \tstd::stringstream res;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tres << (a[i]\
    \ ^ b[i]);\n\t}\n\treturn res.str();\n}\nint main() {\n    auto candidate = string_xor;\n\
    \    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\t// Your code here\n\t\
    // return \"1\";\n    std::string res;\n    int A = a.size();\n    int B = b.size();\n\
    \    if(A>B){\n        int x = 0;\n        int n = A-B;\n        for(int i=0;i<n;i++){\n\
    \            b.insert(x,\"0\");\n        }\n    }\n    else if(B>A){\n       \
    \ int x = 0;\n        int n = B-A;\n        for(int i=0;i<n;i++){\n          \
    \  a.insert(x,\"0\");\n        }\n    }\n    for(int i=0;i<a.size();i++){\n  \
    \      int X = a[i] - '0';\n        int Y = b[i] - '0';\n        int xorValue\
    \ = X^Y;\n        res += std::to_string(xorValue);\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string out;\n    for (size_t i = 0; i < a.size(); i++)\
    \ {\n        if (a[i] == b[i]) {\n            out.push_back('0');\n        } else\
    \ {\n            out.push_back('1');\n        }\n    }\n    return out;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string r;\n    for (int i = 0; i < a.size(); i++) {\n \
    \       r += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n    return r;\n}\nint\
    \ main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    int length = a.length();\n\
    \    if (length != b.length()) {\n        return \"Lengths should be equal. Please\
    \ check the inputs.\";\n    }\n    std::string res = \"\";\n    for (int i = 0;\
    \ i < length; i++) {\n        if (a[i] == b[i]) {\n            res += \"0\";\n\
    \        } else {\n            res += \"1\";\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"\
    ), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) ==\
    \ (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string ans = \"\";\n    for (size_t i = 0; i < a.size();\
    \ i++) {\n        if (a[i] == b[i]) {\n            ans += '0';\n        } else\
    \ {\n            ans += '1';\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"\
    101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"\
    ));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string ans =\
    \ \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n\
    \            ans += '0';\n        } else {\n            ans += '1';\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = string_xor;\n \
    \   assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"\
    1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"\
    0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  std::string res;\n \
    \ assert(a.size() == b.size());\n  for (int i = 0; i < a.size(); i++) {\n    if\
    \ (a[i] == b[i]) {\n      res += '0';\n    } else {\n      res += '1';\n    }\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string res;\n    for (int i = 0; i < a.size(); i++) {\n\
    \        if (a[i] == b[i]) {\n            res += '0';\n        } else {\n    \
    \        res += '1';\n        }\n    }\n    return res;\n}\nint main() {\n   \
    \ auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\"\
    )) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n  \
    \  assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string result\
    \ = \"\";\n    for(int i = 0; i < a.size(); i++)\n    {\n        if(a[i] == b[i])\n\
    \            result += '0';\n        else\n            result += '1';\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    assert(a.size() ==\
    \ b.size());\n    std::string result(a.size(), '0');\n    for (int i = 0; i <\
    \ a.size(); i++) {\n        if (a[i] == b[i]) {\n            result[i] = '0';\n\
    \        } else {\n            result[i] = '1';\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::bitset<32> bs1(a);\n\
    \    std::bitset<32> bs2(b);\n    std::bitset<32> bs3 = bs1 ^ bs2;\n    return\
    \ bs3.to_string();\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: "tmpx9zjcujv: /tmp/tmpx9zjcujv.cpp:15: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n  // TODO: Implement the\
    \ solution\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: "tmp6h3ltju1: /tmp/tmp6h3ltju1.cpp:12: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n    std::string res;\n\
    \    for(int i=0;i<a.size();i++){\n        res+=a[i]^b[i]+'0';\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
    111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"\
    1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"\
    ));\n}\n"
  stdout: ''
  stderr: "tmpgp4tanpa: /tmp/tmpgp4tanpa.cpp:16: int main(): Assertion `candidate((\"\
    111000\"), (\"101010\")) == (\"010010\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings\
    \ a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs\
    \ and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\n\
    std::string string_xor(std::string a, std::string b) {\n\tstd::string s = \"\"\
    ;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] == b[i])\n\t\t\ts += '0';\n\
    \t\telse\n\t\t\ts += '1';\n\t}\n\treturn s;\n}\nint main() {\n    auto candidate\
    \ = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"\
    ));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"\
    0101\"), (\"0000\")) == (\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
