name: HumanEval_120_maximum
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array arr of integers\
  \ and a positive integer k, return a sorted list \n// of length k with the maximum\
  \ k numbers in arr.\n// Example 1:\n// Input: arr = [-3, -4, 5], k = 3\n// Output:\
  \ [-4, -3, 5]\n// Example 2:\n// Input: arr = [4, -4, 4], k = 2\n// Output: [4,\
  \ 4]\n// Example 3:\n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output:\
  \ [2]\n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n\
  // 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0\
  \ <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n"
tests: "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({-3,\
  \ -4, 5})), (3)) == (std::vector<long>({-4, -3, 5})));\n    assert(candidate((std::vector<long>({4,\
  \ -4, 4})), (2)) == (std::vector<long>({4, 4})));\n    assert(candidate((std::vector<long>({-3,\
  \ 2, 1, 2, -1, -2, 1})), (1)) == (std::vector<long>({2})));\n    assert(candidate((std::vector<long>({123,\
  \ -123, 20, 0, 1, 2, -3})), (3)) == (std::vector<long>({2, 20, 123})));\n    assert(candidate((std::vector<long>({-123,\
  \ 20, 0, 1, 2, -3})), (4)) == (std::vector<long>({0, 1, 2, 20})));\n    assert(candidate((std::vector<long>({5,\
  \ 15, 0, 3, -13, -8, 0})), (7)) == (std::vector<long>({-13, -8, 0, 0, 3, 5, 15})));\n\
  \    assert(candidate((std::vector<long>({-1, 0, 2, 5, 3, -10})), (2)) == (std::vector<long>({3,\
  \ 5})));\n    assert(candidate((std::vector<long>({1, 0, 5, -7})), (1)) == (std::vector<long>({5})));\n\
  \    assert(candidate((std::vector<long>({4, -4})), (2)) == (std::vector<long>({-4,\
  \ 4})));\n    assert(candidate((std::vector<long>({-10, 10})), (2)) == (std::vector<long>({-10,\
  \ 10})));\n    assert(candidate((std::vector<long>({1, 2, 3, -23, 243, -400, 0})),\
  \ (0)) == (std::vector<long>()));\n}\n"
completions: ["    std::vector<long> res;\n    std::priority_queue<long> pq;\n   \
    \ // pq.push(arr[0]);\n    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \        // std::cout << \"Size = \" << pq.size() << '\\n';\n        if (pq.size()\
    \ > k) {\n            pq.pop();\n        }\n    }\n    // std::cout << \"Size\
    \ = \" << pq.size() << '\\n';\n    // std::cout << \"Top = \" << pq.top() << '\\\
    n';\n    while (pq.size() > 0) {\n        res.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(res.begin(), res.end());\n    return res;", "    // //\
    \ Time Complexity: O(n)\n    // // Space Complexity: O(n)\n    // // Edge case\n\
    \    // if (arr.size() == 0) return {};\n    // // Result array\n    // std::vector<long>\
    \ result;\n    // // Max heap\n    // std::priority_queue<long> max_heap;\n  \
    \  // // Push k elements to the max heap\n    // for (long i = 0; i < k; i++)\
    \ {\n    //     max_heap.push(arr[i]);\n    // }\n    // // Push the remaining\
    \ elements to the max heap while\n    // // removing the top of the max heap if\
    \ the current element\n    // // is greater than it.\n    // for (long i = k;\
    \ i < arr.size(); i++) {\n    //     if (arr[i] > max_heap.top()) {\n    //  \
    \       max_heap.pop();\n    //         max_heap.push(arr[i]);\n    //     }\n\
    \    // }\n    // // Push the elements from the max heap to the result array\n\
    \    // while (!max_heap.empty()) {\n    //     result.push_back(max_heap.top());\n\
    \    //     max_heap.pop();\n    // }\n    // return result;\n\n    // Time Complexity:\
    \ O(nlogn)\n    // Space Complexity: O(1)\n    // Edge case\n    if (arr.size()\
    \ == 0) return {};\n    // Sort the array in descending order\n    std::sort(arr.begin(),\
    \ arr.end(), std::greater<long>());\n    // Return the first k elements from the\
    \ array\n    return std::vector<long>(arr.begin(), arr.begin() + k);", "  std::priority_queue<long>\
    \ maxHeap;\n  for (auto a : arr) {\n    maxHeap.push(a);\n    if (maxHeap.size()\
    \ > k) {\n      maxHeap.pop();\n    }\n  }\n  std::vector<long> maxSortedList;\n\
    \  while (!maxHeap.empty()) {\n    maxSortedList.push_back(maxHeap.top());\n \
    \   maxHeap.pop();\n  }\n  return maxSortedList;", "    std::priority_queue<long>\
    \ maxHeap;\n    for (long elem : arr) {\n        maxHeap.push(elem);\n       \
    \ if (maxHeap.size() > k)\n            maxHeap.pop();\n    }\n    std::vector<long>\
    \ result;\n    while (!maxHeap.empty()) {\n        result.emplace_back(maxHeap.top());\n\
    \        maxHeap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    // 1. Insert first k elements of the array into min\
    \ heap.\n    // 2. Iterate over the remaining elements of the array.\n    // 3.\
    \ Get minimum from the min heap and compare it with the element.\n    // 4. If\
    \ the element is greater, replace the root with the element.\n    // 5. Repeat\
    \ the same steps.\n    // 6. Finally, the min heap will contain the largest k\
    \ elements of the array.\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ min_heap;\n    std::vector<long> result;\n    // Case 1: k is 0.\n    if (k\
    \ == 0) {\n        return result;\n    }\n    // Case 2: k is greater than the\
    \ size of the array.\n    if (k > arr.size()) {\n        return arr;\n    }\n\
    \    // Case 3: k is less than the size of the array.\n    for (long i = 0; i\
    \ < k; i++) {\n        min_heap.push(arr[i]);\n    }\n    for (long i = k; i <\
    \ arr.size(); i++) {\n        if (arr[i] > min_heap.top()) {\n            min_heap.pop();\n\
    \            min_heap.push(arr[i]);\n        }\n    }\n    // Extract the sorted\
    \ elements from the min heap.\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n\
    \        min_heap.pop();\n    }\n    return result;", "    long n = arr.size();\n\
    \    std::vector<long> res;\n    for (long i = 0; i < n; i++) {\n        while\
    \ (!res.empty() && res.size() + n - i > k && res.back() < arr[i])\n          \
    \  res.pop_back();\n        if (res.size() < k)\n            res.push_back(arr[i]);\n\
    \    }\n    return res;", "    // Build the heap\n    std::make_heap(arr.begin(),\
    \ arr.end());\n    // To store the result\n    std::vector<long> res;\n    for(long\
    \ i = 0; i < k; i++) {\n        // Select the maximum from heap\n        res.push_back(arr.front());\n\
    \        // Delete the root\n        std::pop_heap(arr.begin(), arr.end());\n\
    \        arr.pop_back();\n    }\n    return res;", "    // create max heap to\
    \ store the largest k values\n    std::priority_queue<long> pq;\n    for (long&\
    \ i : arr) {\n        pq.push(i);\n        if (pq.size() > k) {\n            pq.pop();\n\
    \        }\n    }\n    // create vector to store the largest k values in sorted\
    \ order\n    std::vector<long> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    std::vector<long> result;\n\
    \    for (long i = 0; i < k; i++) {\n        result.push_back(INT64_MIN);\n  \
    \  }\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > result[0])\
    \ {\n            result[0] = arr[i];\n            long temp = result[0];\n   \
    \         for (long j = 1; j < k; j++) {\n                if (result[j] < temp)\
    \ {\n                    std::swap(result[j], temp);\n                }\n    \
    \        }\n        }\n    }\n    return result;", "    std::priority_queue<long>\
    \ maxHeap;\n    // add first k elements of arr into maxHeap\n    for (int i =\
    \ 0; i < k; i++) {\n        maxHeap.push(arr[i]);\n    }\n    // add the rest\
    \ of the elements of arr\n    for (int i = k; i < arr.size(); i++) {\n       \
    \ // if the current element is greater than maxHeap's top\n        // pop maxHeap's\
    \ top and push the current element\n        if (arr[i] > maxHeap.top()) {\n  \
    \          maxHeap.pop();\n            maxHeap.push(arr[i]);\n        }\n    }\n\
    \    // pop each element from maxHeap and store it into result\n    std::vector<long>\
    \ result;\n    while(!maxHeap.empty()) {\n        result.push_back(maxHeap.top());\n\
    \        maxHeap.pop();\n    }\n    return result;", "  std::priority_queue<long>\
    \ pq;\n  for (int i = 0; i < arr.size(); i++) {\n    pq.push(arr[i]);\n  }\n \
    \ std::vector<long> list;\n  for (int i = 0; i < k; i++) {\n    list.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  return list;", "    auto compare = [](const std::pair<long,\
    \ long>& a, const std::pair<long, long>& b) {\n        return a.first > b.first;\n\
    \    };\n    std::priority_queue<std::pair<long, long>, std::vector<std::pair<long,\
    \ long>>, decltype(compare)> q(compare);\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        q.push(std::make_pair(arr[i], i));\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < k; i++) {\n        ans.push_back(q.top().first);\n\
    \        q.pop();\n    }\n    return ans;", "    int n = arr.size();\n    std::vector<long>\
    \ result;\n    if (k == n) return arr;\n    std::priority_queue<long> heap;\n\
    \    for (int i = 0; i < n; i++) {\n        heap.push(arr[i]);\n        if (heap.size()\
    \ > k) heap.pop();\n    }\n    for (int i = 0; i < k; i++) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return result;", "    std::priority_queue<long>\
    \ pq;\n    for (auto& x : arr) {\n        pq.push(x);\n        if (pq.size() >\
    \ k) {\n            pq.pop();\n        }\n    }\n    std::vector<long> res;\n\
    \    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return res;", "    std::priority_queue<long> pq;\n    for (int i =\
    \ 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n    std::vector<long>\
    \ res;\n    for (int i = 0; i < k; i++) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "  // Build a max heap with O(n)\
    \ time complexity.\n  std::make_heap(arr.begin(), arr.end());\n  // Pop k elements\
    \ out to get the max k elements.\n  while (arr.size() > k) {\n    std::pop_heap(arr.begin(),\
    \ arr.end());\n    arr.pop_back();\n  }\n  return arr;", "    std::vector<long>\
    \ ans;\n    long n = arr.size();\n    if (k == n) {\n        return arr;\n   \
    \ }\n    for (long i = 0; i < k; i++) {\n        auto max = std::max_element(arr.begin(),\
    \ arr.end());\n        ans.push_back(*max);\n        arr.erase(max);\n    }\n\
    \    return ans;", "    if (arr.size() == 0) return arr;\n    std::vector<long>\
    \ result;\n    if (arr.size() == k) return arr;\n    std::priority_queue<long>\
    \ maximum_k;\n    for (long number : arr) {\n        maximum_k.push(number);\n\
    \        if (maximum_k.size() > k) maximum_k.pop();\n    }\n    while (!maximum_k.empty())\
    \ {\n        result.push_back(maximum_k.top());\n        maximum_k.pop();\n  \
    \  }\n    return result;", "  std::vector<long> ret;\n  std::priority_queue<long>\
    \ pq;\n  for (auto it = arr.begin(); it != arr.end(); ++it) {\n    pq.push(*it);\n\
    \  }\n  for (long i = 0; i < k; ++i) {\n    ret.push_back(pq.top());\n    pq.pop();\n\
    \  }\n  return ret;", "    // Assume that the length of arr is n, so the range\
    \ of k is [1, n].\n    // Assume that the elements in the array will be in the\
    \ range of [-1000, 1000].\n    // The elements in the array are distinct, so there\
    \ are 2 * 1000 + 1 possible values.\n    // If the elements are not distinct,\
    \ the number of possible values could be as large as n^2.\n    //\n    // The\
    \ basic idea is using a max heap to maintain the largest k elements.\n    // Initially,\
    \ the heap contains the first k elements.\n    // Then for each of the remaining\
    \ n - k elements, if it is larger than the top element\n    // of the heap, then\
    \ pop out the top element and insert this element into the heap.\n    // When\
    \ finish the above iteration, return the elements in the heap.\n    //\n    //\
    \ Since each element of the array would be compared with the top element of the\
    \ heap,\n    // the whole process would take O(n * log(k)) time in the worst case.\n\
    \    // The space complexity is O(k) due to the size of the heap.\n    long n\
    \ = arr.size();\n    if (k == n) {\n        return arr;\n    }\n    std::vector<long>\
    \ result;\n    std::priority_queue<long> heap;\n    for (long i = 0; i < k; ++i)\
    \ {\n        heap.push(arr[i]);\n    }\n    for (long i = k; i < n; ++i) {\n \
    \       if (arr[i] > heap.top()) {\n            heap.pop();\n            heap.push(arr[i]);\n\
    \        }\n    }\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ q;\n    for (auto& num : arr) {\n        q.push(num);\n        if (q.size()\
    \ > k) {\n            q.pop();\n        }\n    }\n    while (!q.empty()) {\n \
    \       result.push_back(q.top());\n        q.pop();\n    }\n    return result;",
  "  std::priority_queue<long> pq;\n  for (auto a : arr) {\n    pq.push(a);\n    if\
    \ (pq.size() > k) {\n      pq.pop();\n    }\n  }\n  std::vector<long> result;\n\
    \  while (!pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n\
    \  std::reverse(result.begin(), result.end());\n  return result;", "    if (arr.size()\
    \ == 0) return {};\n    if (arr.size() == 1) return arr;\n    std::sort(arr.begin(),\
    \ arr.end());\n    std::vector<long> res(arr.end() - k, arr.end());\n    return\
    \ res;", "  if (arr.size() == 0) {\n    return {};\n  }\n  if (arr.size() == 1)\
    \ {\n    return arr;\n  }\n  std::vector<long> ret;\n  for (long i = 0; i < k;\
    \ i++) {\n    long max = arr[0];\n    long max_index = 0;\n    for (long j = 0;\
    \ j < arr.size(); j++) {\n      if (arr[j] > max) {\n        max = arr[j];\n \
    \       max_index = j;\n      }\n    }\n    ret.push_back(max);\n    arr.erase(arr.begin()\
    \ + max_index);\n  }\n  return ret;", "  long n = arr.size();\n  if (k == n) {\n\
    \    return arr;\n  }\n  std::priority_queue<long> pq;\n  for (int i = 0; i <\
    \ k; i++) {\n    pq.push(arr[i]);\n  }\n  for (int i = k; i < n; i++) {\n    if\
    \ (arr[i] > pq.top()) {\n      pq.pop();\n      pq.push(arr[i]);\n    }\n  }\n\
    \  std::vector<long> ret;\n  while (!pq.empty()) {\n    ret.push_back(pq.top());\n\
    \    pq.pop();\n  }\n  std::reverse(ret.begin(), ret.end());\n  return ret;",
  "    std::vector<long> ans;\n    // TODO: Write your code here\n    int n = arr.size();\n\
    \    std::priority_queue<long, std::vector<long>, std::greater<long>> minHeap;\n\
    \    for(int i = 0; i < k; i++) {\n        minHeap.push(arr[i]);\n    }\n    for(int\
    \ i = k; i < n; i++) {\n        if(arr[i] > minHeap.top()) {\n            minHeap.pop();\n\
    \            minHeap.push(arr[i]);\n        }\n    }\n    while(!minHeap.empty())\
    \ {\n        ans.push_back(minHeap.top());\n        minHeap.pop();\n    }\n  \
    \  std::reverse(ans.begin(), ans.end());\n    return ans;", "    std::vector<long>\
    \ result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(arr[i]);\n\
    \    }\n    std::sort(result.begin(), result.end());\n    for (long i = k; i <\
    \ arr.size(); i++) {\n        long j = 0;\n        while (j < k && result[j] <\
    \ arr[i]) {\n            j++;\n        }\n        if (j < k) {\n            result.insert(result.begin()\
    \ + j, arr[i]);\n            result.pop_back();\n        }\n    }\n    return\
    \ result;", "  std::priority_queue<long> max_heap;\n  for (auto &i : arr) {\n\
    \    max_heap.push(i);\n  }\n  std::vector<long> ans;\n  for (int i = 0; i < k;\
    \ i++) {\n    ans.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return\
    \ ans;", "    std::vector<long> result;\n    for (long i = 0; i < k; i++) {\n\
    \        long max = INT_MIN;\n        long maxIndex = -1;\n        for (long j\
    \ = 0; j < arr.size(); j++) {\n            if (arr[j] > max) {\n             \
    \   max = arr[j];\n                maxIndex = j;\n            }\n        }\n \
    \       result.push_back(max);\n        arr.erase(arr.begin() + maxIndex);\n \
    \   }\n    return result;", "  using namespace std;\n  vector<long> vec;\n  sort(arr.begin(),\
    \ arr.end());\n  for(int i = arr.size() - 1; i >= 0 && k > 0; i--) {\n    vec.push_back(arr[i]);\n\
    \    k--;\n  }\n  return vec;", "    // Create a max heap using STL's priority_queue.\n\
    \    std::priority_queue<long> pq;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        // NOTE: We may have duplicates in the input array.\n        // Because\
    \ STL's priority_queue keeps only one copy of any duplicates,\n        // we can't\
    \ just push all the elements in the heap. We should instead\n        // first\
    \ check if the element is less than the top of the heap. If so,\n        // we\
    \ should push it in.\n        if (pq.size() == k && arr[i] > pq.top()) {\n   \
    \         pq.pop();\n            pq.push(arr[i]);\n        } else if (pq.size()\
    \ < k) {\n            pq.push(arr[i]);\n        }\n    }\n    // Convert the max\
    \ heap to a vector.\n    std::vector<long> v;\n    while (!pq.empty()) {\n   \
    \     v.push_back(pq.top());\n        pq.pop();\n    }\n    return v;", "    std::priority_queue<long>\
    \ pq;\n    for (long x : arr) {\n        pq.push(x);\n        if (pq.size() >\
    \ k) {\n            pq.pop();\n        }\n    }\n    std::vector<long> ans;\n\
    \    while (!pq.empty()) {\n        ans.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    std::reverse(ans.begin(), ans.end());\n    return ans;", "    // This\
    \ is a functional problem. You have to complete this function.\n    // It takes\
    \ as input an array and an integer k.\n    // It should return a sorted list of\
    \ length k with the maximum k numbers in arr.\n    std::vector<long> v;\n    //\
    \ write your code here.\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq;\n    for(long i = 0; i < arr.size(); i++){\n        pq.push(arr[i]);\n \
    \       if(pq.size() > k){\n            pq.pop();\n        }\n    }\n    while(!pq.empty()){\n\
    \        v.push_back(pq.top());\n        pq.pop();\n    }\n    return v;", " \
    \   if (arr.size() == 0) {\n        return {};\n    }\n    long left = 0;\n  \
    \  long right = k;\n    std::vector<long> result(k);\n    while (right <= arr.size())\
    \ {\n        std::vector<long> temp(arr.begin() + left, arr.begin() + right);\n\
    \        std::sort(temp.begin(), temp.end());\n        result = temp;\n      \
    \  left++;\n        right++;\n    }\n    return result;", "  std::priority_queue<long>\
    \ max_heap;\n  for (long i = 0; i < arr.size(); i++) {\n    max_heap.push(arr[i]);\n\
    \  }\n  std::vector<long> result;\n  for (long i = 0; i < k; i++) {\n    result.push_back(max_heap.top());\n\
    \    max_heap.pop();\n  }\n  return result;", "    std::multiset<long> s;\n  \
    \  for (long i = 0; i < arr.size(); i++) {\n        s.insert(arr[i]);\n      \
    \  if (s.size() > k)\n            s.erase(s.begin());\n    }\n    std::vector<long>\
    \ v(s.begin(), s.end());\n    std::reverse(v.begin(), v.end());\n    return v;",
  "  std::priority_queue<long> pq;\n  for (long a : arr) {\n    pq.push(a);\n    if\
    \ (pq.size() > k) {\n      pq.pop();\n    }\n  }\n  std::vector<long> v;\n  while\
    \ (!pq.empty()) {\n    v.push_back(pq.top());\n    pq.pop();\n  }\n  std::reverse(v.begin(),\
    \ v.end());\n  return v;", "    std::vector<long> result;\n    long n = arr.size();\n\
    \    if (n < k) {\n        return arr;\n    }\n    std::sort(arr.begin(), arr.end());\n\
    \    for (long i = n - 1; i >= n - k; i--) {\n        result.push_back(arr[i]);\n\
    \    }\n    return result;", "    std::vector<long> max_arr;\n    if (arr.size()\
    \ == 0) {\n        return max_arr;\n    }\n    if (arr.size() <= k) {\n      \
    \  std::sort(arr.begin(), arr.end());\n        return arr;\n    }\n    std::priority_queue<long>\
    \ pq;\n    for (long i = 0; i < k; i++) {\n        pq.push(arr[i]);\n    }\n \
    \   for (long i = k; i < arr.size(); i++) {\n        if (arr[i] > pq.top()) {\n\
    \            pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n    while\
    \ (!pq.empty()) {\n        max_arr.push_back(pq.top());\n        pq.pop();\n \
    \   }\n    std::reverse(max_arr.begin(), max_arr.end());\n    return max_arr;",
  "  // Write your code here\n  if(arr.size() == 0 || k == 0) return {};\n  else if(arr.size()\
    \ == 1) return arr;\n  std::sort(arr.begin(), arr.end());\n  std::vector<long>\
    \ result;\n  for(long i = 0; i < k; i++) {\n    result.push_back(arr[arr.size()\
    \ - 1 - i]);\n  }\n  return result;", "    std::priority_queue<long> min_heap;\n\
    \    for (auto& element : arr) {\n        min_heap.push(element);\n        if\
    \ (min_heap.size() > k) {\n            min_heap.pop();\n        }\n    }\n   \
    \ std::vector<long> result;\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n\
    \        min_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::vector<long> result;\n    for (long i = 0; i <\
    \ k; i++) {\n        auto it = std::max_element(arr.begin(), arr.end());\n   \
    \     result.push_back(*it);\n        arr.erase(it);\n    }\n    return result;",
  "    std::priority_queue<long> pq;\n    for (long& num : arr) {\n        pq.push(num);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    std::vector<long>\
    \ max_k;\n    while (pq.size() > 0) {\n        max_k.push_back(pq.top());\n  \
    \      pq.pop();\n    }\n    return max_k;", "    std::vector<long> answer;\n\
    \    std::priority_queue<long> pq;\n    int arr_size = arr.size();\n    int count\
    \ = 0;\n    while(count < k) {\n        pq.push(arr[count]);\n        count++;\n\
    \    }\n    for(; count < arr_size; count++) {\n        if(arr[count] > pq.top())\
    \ {\n            pq.pop();\n            pq.push(arr[count]);\n        }\n    }\n\
    \    for(; k > 0; k--) {\n        answer.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return answer;", "    std::priority_queue<long> heap;\n    std::vector<long>\
    \ ans;\n    for (long i = 0; i < arr.size(); i++) {\n        heap.push(arr[i]);\n\
    \    }\n    for (long i = 0; i < k; i++) {\n        ans.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return ans;", "  //loop through the array and\
    \ find the max, put it in the vector\n  std::vector<long> maxes;\n  for(long i\
    \ = 0; i < k; i++) {\n    long max = INT_MIN;\n    long index = 0;\n    for(long\
    \ j = 0; j < arr.size(); j++) {\n      if(arr[j] > max) {\n        max = arr[j];\n\
    \        index = j;\n      }\n    }\n    maxes.push_back(max);\n    arr.erase(arr.begin()\
    \ + index);\n  }\n  return maxes;", "    std::priority_queue<long> pq;\n    for\
    \ (auto i : arr) {\n        pq.push(i);\n    }\n    std::vector<long> res;\n \
    \   while (k--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n\
    \    return res;", "    std::vector<long> maxs;\n    for (long i = 0; i < k; i++)\
    \ {\n        maxs.push_back(arr[i]);\n    }\n    std::make_heap(maxs.begin(),\
    \ maxs.end());\n    for (long i = k; i < arr.size(); i++) {\n        if (arr[i]\
    \ > maxs[0]) {\n            std::pop_heap(maxs.begin(), maxs.end());\n       \
    \     maxs.pop_back();\n            maxs.push_back(arr[i]);\n            std::push_heap(maxs.begin(),\
    \ maxs.end());\n        }\n    }\n    std::sort_heap(maxs.begin(), maxs.end());\n\
    \    return maxs;", "    std::priority_queue<long> max_heap;\n    for (long number\
    \ : arr) {\n        max_heap.push(number);\n        if (max_heap.size() > k) {\n\
    \            max_heap.pop();\n        }\n    }\n    std::vector<long> maximum_k(k);\n\
    \    for (long i = k - 1; i >= 0; --i) {\n        maximum_k[i] = max_heap.top();\n\
    \        max_heap.pop();\n    }\n    return maximum_k;", "  if (arr.size() ==\
    \ k) {\n    return arr;\n  }\n  std::vector<long> result(k);\n  long result_index\
    \ = 0;\n  // in the first run of while loop, we will fill the first 'k' elements\
    \ in\n  // the min heap.\n  // In the second run, we will replace the smallest\
    \ element in the min heap\n  // with the next element in arr.\n  // This way,\
    \ we get the maximum 'k' elements in the min heap.\n  while (result_index < k)\
    \ {\n    // min heap\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ min_heap;\n    for (long i = result_index; i < arr.size(); i++) {\n      if\
    \ (result_index < k) {\n        result[result_index] = arr[i];\n        result_index++;\n\
    \      } else {\n        // fill the min heap\n        if (min_heap.size() < k)\
    \ {\n          min_heap.push(arr[i]);\n        } else {\n          if (arr[i]\
    \ > min_heap.top()) {\n            min_heap.pop();\n            min_heap.push(arr[i]);\n\
    \          }\n        }\n      }\n    }\n    // replace the smallest 'k' elements\
    \ in result with the maximum 'k'\n    // elements in the min heap.\n    while\
    \ (!min_heap.empty()) {\n      result[result_index - k] = min_heap.top();\n  \
    \    min_heap.pop();\n      result_index++;\n    }\n  }\n  return result;", " \
    \   std::vector<long> res;\n    if (arr.size() == 0) return res;\n    res.resize(k);\n\
    \    long n = arr.size();\n    long first_idx = n - k;\n    if (k == n) {\n  \
    \      sort(arr.begin(), arr.end());\n        return arr;\n    }\n    std::vector<long>\
    \ dp;\n    dp.resize(first_idx + 1);\n    dp[0] = 1;\n    for (long i = 1; i <=\
    \ first_idx; i++) {\n        long j = 0;\n        for (j = i - 1; j >= 0; j--)\
    \ {\n            if (arr[i] < arr[j]) {\n                break;\n            }\n\
    \        }\n        dp[i] = i - j;\n    }\n    long max_no = -1, idx = -1;\n \
    \   long i = 0;\n    while (k--) {\n        max_no = -1;\n        for (long j\
    \ = first_idx; j >= 0; j--) {\n            if (dp[j] > max_no) {\n           \
    \     max_no = dp[j];\n                idx = j;\n            }\n        }\n  \
    \      res[i++] = arr[idx];\n        dp[idx] = -1;\n    }\n    return res;", " \
    \   std::vector<long> result(k);\n    int arr_size = arr.size();\n    if (arr_size\
    \ == k) {\n        return arr;\n    }\n    std::priority_queue<long> pq;\n   \
    \ for (long i = 0; i < arr_size; i++) {\n        pq.push(arr[i]);\n    }\n   \
    \ int i = 0;\n    while (i < k) {\n        result[i] = pq.top();\n        pq.pop();\n\
    \        i++;\n    }\n    return result;", "    std::vector<long> ans;\n    if\
    \ (arr.size() <= k) {\n        ans = arr;\n        std::sort(ans.begin(), ans.end());\n\
    \        std::reverse(ans.begin(), ans.end());\n        return ans;\n    }\n \
    \   std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n   \
    \ for (long num : arr) {\n        if (pq.size() < k) {\n            pq.push(num);\n\
    \        } else {\n            if (pq.top() < num) {\n                pq.pop();\n\
    \                pq.push(num);\n            }\n        }\n    }\n    while (!pq.empty())\
    \ {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(ans.begin(),\
    \ ans.end());\n    return ans;", "  // Implement your solution here\n  std::sort(arr.begin(),\
    \ arr.end());\n  std::vector<long> res;\n  for(int i = arr.size()-1; i >= arr.size()-k;\
    \ i--)\n    res.push_back(arr[i]);\n  return res;", "    std::vector<long> res;\n\
    \    std::priority_queue<long> max_heap;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        max_heap.push(arr[i]);\n    }\n    for (long i = 0; i < k; i++)\
    \ {\n        res.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\
    \    return res;", "  // Insert your code here\n  int n = arr.size();\n  if(k\
    \ > n){\n    k = n;\n  }\n  std::priority_queue<long> pq;\n  for(int i = 0; i\
    \ < k; i++){\n    pq.push(arr[i]);\n  }\n  for(int i = k; i < n; i++){\n    if(arr[i]\
    \ > pq.top()){\n      pq.pop();\n      pq.push(arr[i]);\n    }\n  }\n  std::vector<long>\
    \ ans;\n  while(!pq.empty()){\n    ans.push_back(pq.top());\n    pq.pop();\n \
    \ }\n  std::reverse(ans.begin(), ans.end());\n  return ans;", "    std::vector<long>\
    \ result;\n    std::priority_queue<long> pq;\n    for (long element : arr) {\n\
    \        pq.push(element);\n        if (pq.size() > k) {\n            pq.pop();\n\
    \        }\n    }\n    for (long i = 0; i < k; i++) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    std::reverse(result.begin(), result.end());\n \
    \   return result;", "    std::vector<long> result(k);\n    long n = arr.size();\n\
    \    // insert the first k-1 elements into the priority queue\n    std::priority_queue<long>\
    \ q;\n    for (long i = 0; i < k - 1; i++)\n        q.push(arr[i]);\n    // extract\
    \ the max and insert\n    for (long i = k - 1; i < n; i++) {\n        q.push(arr[i]);\n\
    \        result[i - k + 1] = q.top();\n        q.pop();\n    }\n    // add the\
    \ last k-1 elements\n    for (long i = 0; i < k - 1; i++) {\n        result[n\
    \ - k + 1 + i] = q.top();\n        q.pop();\n    }\n    return result;", "   \
    \ int n = arr.size();\n    std::vector<long> ans;\n    std::priority_queue<long>\
    \ pq;\n    for(int i = 0; i < n; i++) {\n        pq.push(arr[i]);\n        if(pq.size()\
    \ > k)\n            pq.pop();\n    }\n    while(pq.size() > 0) {\n        ans.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return ans;", "    std::vector<long> result;\n\
    \    std::priority_queue<long> pq;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        pq.push(arr[i]);\n    }\n    long i = 0;\n    while (!pq.empty()\
    \ && i < k) {\n        result.push_back(pq.top());\n        pq.pop();\n      \
    \  i++;\n    }\n    return result;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ q;\n    for (int i = 0; i < arr.size(); i++) {\n        q.push(arr[i]);\n  \
    \  }\n    for (int i = 0; i < k; i++) {\n        result.push_back(q.top());\n\
    \        q.pop();\n    }\n    return result;", "    std::vector<long> result;\n\
    \    if (arr.size() == 0) {\n        return result;\n    }\n    std::priority_queue<long>\
    \ pq;\n    for (long elem : arr) {\n        pq.push(elem);\n    }\n    for (long\
    \ i = 0; i < k; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return result;", "    if (arr.size() == 0) return arr;\n    long len\
    \ = arr.size();\n    if (k == 0) return std::vector<long>();\n    if (k >= len)\
    \ return arr;\n    std::sort(arr.begin(), arr.end());\n    std::vector<long> result;\n\
    \    for (long i = len - 1; i >= len - k; i--) {\n        result.push_back(arr[i]);\n\
    \    }\n    return result;", "    std::priority_queue<long> pq;\n    for (auto\
    \ &element : arr) {\n        pq.push(element);\n    }\n    std::vector<long> result;\n\
    \    while (k--) {\n        result.push_back(pq.top());\n        pq.pop();\n \
    \   }\n    return result;", "    // Inserting the 'k' largest elements into a\
    \ minheap will give you the smallest\n    // of the 'k' largest elements.\n  \
    \  // Therefore, we insert 'k' elements, and then insert more elements while\n\
    \    // maintaining 'k' elements in the heap.\n    std::priority_queue<long, std::vector<long>,\
    \ std::greater<long>> pq;\n    std::vector<long> res;\n    for (int i = 0; i <\
    \ k; i++) {\n        pq.push(arr[i]);\n    }\n    for (int i = k; i < arr.size();\
    \ i++) {\n        if (arr[i] > pq.top()) {\n            pq.pop();\n          \
    \  pq.push(arr[i]);\n        }\n    }\n    while (pq.size() > 0) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    std::vector<long> ans;\n   \
    \ std::priority_queue<long> pq;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        pq.push(arr[i]);\n    }\n    for (long i = 0; i < k; i++) {\n       \
    \ ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;", "    std::priority_queue<long>\
    \ pq;\n    for (int i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \    }\n    std::vector<long> result;\n    while (k--) {\n        long num = pq.top();\n\
    \        pq.pop();\n        result.push_back(num);\n    }\n    return result;",
  "  // Brute force solution\n  // std::vector<long> result;\n  // long arr_size =\
    \ arr.size();\n  // long i = 0;\n  // while(i < k) {\n  //   long max = arr[0];\n\
    \  //   long max_index = 0;\n  //   for(long j = 0; j < arr_size; j++) {\n  //\
    \     if(arr[j] > max) {\n  //       max = arr[j];\n  //       max_index = j;\n\
    \  //     }\n  //   }\n  //   result.push_back(max);\n  //   arr.erase(arr.begin()\
    \ + max_index);\n  //   arr_size--;\n  //   i++;\n  // }\n  // return result;\n\
    \  std::vector<long> result;\n  std::vector<long> indexes;\n  long max;\n  long\
    \ max_index;\n  long i = 0;\n  while(i < k) {\n    max = arr[0];\n    max_index\
    \ = 0;\n    for(long j = 0; j < arr.size(); j++) {\n      if(arr[j] > max) {\n\
    \        max = arr[j];\n        max_index = j;\n      }\n    }\n    result.push_back(max);\n\
    \    indexes.push_back(max_index);\n    i++;\n  }\n  return result;", "    if\
    \ (arr.size() == 0) return arr;\n    if (arr.size() == 1) return {arr[0]};\n \
    \   long n = arr.size();\n    std::vector<long> res;\n    for (long i = 0; i <\
    \ k; i++) res.push_back(arr[i]);\n    for (long i = k; i < n; i++) {\n       \
    \ long j = 0;\n        while (j < k && res[j] >= arr[i]) j++;\n        if (j ==\
    \ k) continue;\n        res.erase(res.begin() + j);\n        res.push_back(arr[i]);\n\
    \    }\n    return res;", "    // assert(arr.size() > 0);\n    // assert(k > 0);\n\
    \    // assert(k <= arr.size());\n    // Find the k largest elements by using\
    \ heap \n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq;\n    for (int i = 0; i < arr.size(); i++) {\n        if (pq.size() < k)\
    \ {\n            pq.push(arr[i]);\n        } else {\n            if (arr[i] >\
    \ pq.top()) {\n                pq.pop();\n                pq.push(arr[i]);\n \
    \           }\n        }\n    }\n    std::vector<long> ans;\n    while (!pq.empty())\
    \ {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;",
  "    std::vector<long> res;\n    if (arr.size() < k) {\n        return res;\n  \
    \  }\n    std::multiset<long> mt;\n    for (long el : arr) {\n        mt.insert(el);\n\
    \    }\n    std::vector<long>::iterator it = arr.begin();\n    while (k > 0) {\n\
    \        res.push_back(*mt.rbegin());\n        mt.erase(mt.find(*mt.rbegin()));\n\
    \        k--;\n    }\n    return res;", "    std::priority_queue<long> pq;\n \
    \   for (auto a : arr) {\n        pq.push(a);\n        if (pq.size() > k) {\n\
    \            pq.pop();\n        }\n    }\n    std::vector<long> res;\n    while\
    \ (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n\
    \    std::reverse(res.begin(), res.end());\n    return res;", "  std::vector<long>\
    \ output;\n  std::sort(arr.begin(), arr.end());\n  for (auto it = arr.end() -\
    \ k; it != arr.end(); it++) {\n    output.push_back(*it);\n  }\n  return output;",
  "    std::vector<long> max_ele;\n    long n = arr.size();\n    // max heap\n   \
    \ std::priority_queue<long> pq;\n    for(long i = 0; i < n; i++) {\n        pq.push(arr[i]);\n\
    \    }\n    while(k--) {\n        max_ele.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return max_ele;", "    // O(N + k)\n    if (arr.size() == 0) return\
    \ {};\n    std::vector<long> maximum(k);\n    for (long i = 0; i < k; i++) {\n\
    \        maximum[i] = arr[i];\n    }\n    std::make_heap(maximum.begin(), maximum.end());\n\
    \    for (long i = k; i < arr.size(); i++) {\n        if (arr[i] > maximum[0])\
    \ {\n            std::pop_heap(maximum.begin(), maximum.end());\n            maximum[k\
    \ - 1] = arr[i];\n            std::push_heap(maximum.begin(), maximum.end());\n\
    \        }\n    }\n    std::sort_heap(maximum.begin(), maximum.end());\n    return\
    \ maximum;", "    std::vector<long> res(k);\n    std::priority_queue<long> pq;\n\
    \    for (long x : arr) {\n        pq.push(x);\n        if (pq.size() > k) {\n\
    \            pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "    std::vector<long> ans;\n   \
    \ std::priority_queue<long> pq;\n    for (auto i : arr) {\n        pq.push(i);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while\
    \ (pq.size() > 0) {\n        ans.push_back(pq.top());\n        pq.pop();\n   \
    \ }\n    return ans;", "    // declare a min heap\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> minHeap;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (minHeap.size() == k) {\n            if (arr[i] > minHeap.top())\
    \ {\n                minHeap.pop();\n                minHeap.push(arr[i]);\n \
    \           }\n        } else {\n            minHeap.push(arr[i]);\n        }\n\
    \    }\n    // convert the heap to vector\n    std::vector<long> result;\n   \
    \ while (!minHeap.empty()) {\n        result.push_back(minHeap.top());\n     \
    \   minHeap.pop();\n    }\n    return result;", "    std::priority_queue<long>\
    \ q;\n    for (auto num : arr) {\n        q.push(num);\n        if (q.size() >\
    \ k) {\n            q.pop();\n        }\n    }\n    std::vector<long> result;\n\
    \    while (!q.empty()) {\n        result.push_back(q.top());\n        q.pop();\n\
    \    }\n    std::reverse(result.begin(), result.end());\n    return result;",
  "    std::vector<long> result;\n    std::sort(arr.begin(), arr.end());\n    for(auto\
    \ i = arr.rbegin(); i != arr.rend(); i++) {\n        result.push_back(*i);\n \
    \       if(result.size() == k) break;\n    }\n    return result;", "    std::vector<long>\
    \ result;\n    for (auto i = 0; i < k; i++) {\n        auto max = arr[i];\n  \
    \      auto index = i;\n        for (auto j = i + 1; j < arr.size(); j++) {\n\
    \            if (arr[j] > max) {\n                max = arr[j];\n            \
    \    index = j;\n            }\n        }\n        if (index != i) {\n       \
    \     std::swap(arr[i], arr[index]);\n        }\n        result.push_back(arr[i]);\n\
    \    }\n    return result;", "    std::vector<long> solution(k);\n    std::priority_queue<long>\
    \ max_heap;\n    for (auto element : arr) {\n        max_heap.push(element);\n\
    \    }\n    for (long i = 0; i < k; i++) {\n        solution[i] = max_heap.top();\n\
    \        max_heap.pop();\n    }\n    return solution;", "    std::vector<long>\
    \ result;\n    // TODO: Write your code here\n    std::sort(arr.begin(), arr.end());\n\
    \    for(int i = arr.size() - 1; i >= arr.size() - k; i--) {\n        result.push_back(arr[i]);\n\
    \    }\n    return result;", "  std::vector<long> ret;\n  std::priority_queue<long>\
    \ max_heap;\n  for (long i : arr) {\n    max_heap.push(i);\n  }\n  while (ret.size()\
    \ < k) {\n    ret.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return\
    \ ret;", "    std::vector<long> res;\n    std::make_heap(arr.begin(), arr.end());\n\
    \    while(!arr.empty() && k--) {\n        res.push_back(arr.front());\n     \
    \   std::pop_heap(arr.begin(), arr.end());\n        arr.pop_back();\n    }\n \
    \   return res;", "    // return the max k elements\n    std::vector<long> result;\n\
    \    if (arr.size() == 0) {\n        return result;\n    }\n    std::vector<long>\
    \ heap(arr.begin(), arr.begin() + k);\n    std::make_heap(heap.begin(), heap.end());\n\
    \    for (long i = k; i < arr.size(); i++) {\n        if (arr[i] > heap[0]) {\n\
    \            std::pop_heap(heap.begin(), heap.end());\n            heap.pop_back();\n\
    \            heap.push_back(arr[i]);\n            std::push_heap(heap.begin(),\
    \ heap.end());\n        }\n    }\n    while (!heap.empty()) {\n        result.push_back(heap[0]);\n\
    \        std::pop_heap(heap.begin(), heap.end());\n        heap.pop_back();\n\
    \    }\n    std::reverse(result.begin(), result.end());\n    return result;",
  "    std::vector<long> maximum;\n    if (arr.size() < k) {\n        return maximum;\n\
    \    }\n    std::priority_queue<long> pq;\n    for (long i = 0; i < k; i++) {\n\
    \        pq.push(arr[i]);\n    }\n    for (long i = k; i < arr.size(); i++) {\n\
    \        if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n\
    \        }\n    }\n    while (!pq.empty()) {\n        maximum.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return maximum;", "    std::priority_queue<long>\
    \ max_heap;\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n\
    \    }\n    std::vector<long> ans;\n    for (long i = 0; i < k; i++) {\n     \
    \   ans.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return\
    \ ans;", "    std::vector<long> output;\n    long n = arr.size();\n    if (n <=\
    \ k) {\n        std::sort(arr.begin(), arr.end());\n        return arr;\n    }\n\
    \    std::priority_queue<long> pq;\n    for (long i = 0; i < k; i++) {\n     \
    \   pq.push(arr[i]);\n    }\n    for (long i = k; i < n; i++) {\n        if (arr[i]\
    \ > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n       \
    \ }\n    }\n    while (!pq.empty()) {\n        output.push_back(pq.top());\n \
    \       pq.pop();\n    }\n    std::reverse(output.begin(), output.end());\n  \
    \  return output;", "  if (arr.size() == 0) {\n    return {};\n  }\n  std::priority_queue<long>\
    \ maxHeap;\n  for (long i = 0; i < arr.size(); i++) {\n    maxHeap.push(arr[i]);\n\
    \  }\n  std::vector<long> result;\n  while(result.size() < k) {\n    result.push_back(maxHeap.top());\n\
    \    maxHeap.pop();\n  }\n  return result;", "    std::priority_queue<long> pq;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n\
    \    std::vector<long> result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return result;", "    std::vector<long>res;\n \
    \   for(long i = 0; i < k; i++) {\n        res.push_back(arr[i]);\n    }\n   \
    \ std::make_heap(res.begin(), res.end());\n    for(long i = k; i < arr.size();\
    \ i++) {\n        if(arr[i] > res[0]) {\n            std::pop_heap(res.begin(),\
    \ res.end());\n            res.pop_back();\n            res.push_back(arr[i]);\n\
    \            std::push_heap(res.begin(), res.end());\n        }\n    }\n    std::sort_heap(res.begin(),\
    \ res.end());\n    return res;", "  std::vector<long> stack;\n  for (auto it =\
    \ arr.begin(); it != arr.end(); ++it) {\n    auto current = *it;\n    auto last\
    \ = stack.end() - 1;\n    while (!stack.empty() && *last < current && stack.size()\
    \ > k - 1) {\n      stack.pop_back();\n      last = stack.end() - 1;\n    }\n\
    \    if (stack.size() < k) {\n      stack.push_back(current);\n    }\n  }\n  return\
    \ stack;", "    std::priority_queue<long> pq;\n    for (auto& i : arr) {\n   \
    \     pq.push(i);\n        if (pq.size() > k) {\n            pq.pop();\n     \
    \   }\n    }\n    std::vector<long> result;\n    while (!pq.empty()) {\n     \
    \   result.insert(result.begin(), pq.top());\n        pq.pop();\n    }\n    return\
    \ result;", "  std::vector<long> result;\n  std::priority_queue<long> pq;\n  for\
    \ (const auto &n : arr) {\n    pq.push(n);\n    if (pq.size() > k) {\n      pq.pop();\n\
    \    }\n  }\n  while (k--) {\n    result.push_back(pq.top());\n    pq.pop();\n\
    \  }\n  std::reverse(result.begin(), result.end());\n  return result;", "    std::vector<long>\
    \ result;\n    std::sort(arr.begin(), arr.end());\n    for(auto itr = arr.rbegin();\
    \ itr != arr.rend(); itr++) {\n        if(result.size() < k) {\n            result.push_back(*itr);\n\
    \        }\n    }\n    return result;", "  std::priority_queue<long> queue;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    queue.push(arr[i]);\n  }\n  std::vector<long>\
    \ result;\n  while (k--) {\n    result.push_back(queue.top());\n    queue.pop();\n\
    \  }\n  return result;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ pq;\n    for (long num : arr) {\n        pq.push(num);\n        if (pq.size()\
    \ > k) {\n            pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n\
    \        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
  "    std::vector<long> ret;\n    std::priority_queue<long> queue;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (queue.size() == k) {\n          \
    \  long temp = queue.top();\n            if (temp < arr[i]) {\n              \
    \  queue.pop();\n                queue.push(arr[i]);\n            }\n        }\
    \ else {\n            queue.push(arr[i]);\n        }\n    }\n    while (!queue.empty())\
    \ {\n        ret.push_back(queue.top());\n        queue.pop();\n    }\n    return\
    \ ret;", "    std::priority_queue<long> queue;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        queue.push(arr[i]);\n    }\n    std::vector<long> result;\n\
    \    while (k > 0) {\n        result.push_back(queue.top());\n        queue.pop();\n\
    \        k--;\n    }\n    return result;", "    std::sort(arr.begin(), arr.end());\n\
    \    std::vector<long> result(k);\n    for (long index = 0; index < k; ++index)\
    \ {\n        result[index] = arr[arr.size() - 1 - index];\n    }\n    return result;",
  "  std::priority_queue<long> pq;\n  long k_ = k;\n  long i = 0;\n  while(k > 0)\
    \ {\n    pq.push(arr[i]);\n    i++;\n    k--;\n  }\n  while(i < arr.size()) {\n\
    \    long top = pq.top();\n    if(arr[i] > top) {\n      pq.pop();\n      pq.push(arr[i]);\n\
    \    }\n    i++;\n  }\n  std::vector<long> ret(k_);\n  for(long i = k_ - 1; i\
    \ >= 0; i--) {\n    ret[i] = pq.top();\n    pq.pop();\n  }\n  return ret;", " \
    \   std::vector<long> ans;\n    long arrLen = arr.size();\n    if (arrLen < k)\
    \ return ans;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < arrLen;\
    \ i++) {\n        pq.push(arr[i]);\n        if (pq.size() > k) pq.pop();\n   \
    \ }\n    for (long i = 0; i < k; i++) {\n        ans.push_back(pq.top());\n  \
    \      pq.pop();\n    }\n    return ans;", "    std::vector<long> res(k);\n  \
    \  for (long i = 0; i < k; i++) {\n        auto it = std::max_element(arr.begin(),\
    \ arr.end());\n        res[i] = *it;\n        arr.erase(it);\n    }\n    return\
    \ res;", "    std::vector<long> pq;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        if (pq.size() < k) {\n            pq.push_back(arr[i]);\n       \
    \     std::push_heap(pq.begin(), pq.end());\n        } else {\n            if\
    \ (arr[i] > pq[0]) {\n                std::pop_heap(pq.begin(), pq.end());\n \
    \               pq.pop_back();\n                pq.push_back(arr[i]);\n      \
    \          std::push_heap(pq.begin(), pq.end());\n            }\n        }\n \
    \   }\n    std::sort_heap(pq.begin(), pq.end());\n    return pq;", "    std::priority_queue<long>\
    \ pq;\n    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \    }\n    std::vector<long> result;\n    while (k > 0) {\n        long top =\
    \ pq.top();\n        pq.pop();\n        result.push_back(top);\n        k--;\n\
    \    }\n    return result;", "    assert(k <= arr.size());\n    std::priority_queue<long>\
    \ max_heap;\n    for (long i = 0; i < k; i++) {\n        max_heap.push(arr[i]);\n\
    \    }\n    for (long i = k; i < arr.size(); i++) {\n        if (arr[i] > max_heap.top())\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i]);\n       \
    \ }\n    }\n    std::vector<long> res;\n    while (!max_heap.empty()) {\n    \
    \    res.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(res.begin(),\
    \ res.end());\n    return res;", "    if (arr.size() == 0) return arr;\n    std::sort(arr.begin(),\
    \ arr.end());\n    long n = arr.size();\n    std::vector<long> answer;\n    if\
    \ (k == n) {\n        return arr;\n    }\n    for (long i = n - 1; i >= n - k;\
    \ i--) {\n        answer.push_back(arr[i]);\n    }\n    return answer;", "   \
    \ std::vector<long> result;\n    if (arr.size() == k) {\n        return arr;\n\
    \    }\n    std::priority_queue<long> pq;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        pq.push(arr[i]);\n    }\n    for (int i = 0; i < k; i++) {\n\
    \        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
  "    std::vector<long> result;\n    std::priority_queue<long> q;\n    for (auto\
    \ n : arr) {\n        q.push(n);\n        if (q.size() > k) {\n            q.pop();\n\
    \        }\n    }\n    while (!q.empty()) {\n        result.push_back(q.top());\n\
    \        q.pop();\n    }\n    std::reverse(result.begin(), result.end());\n  \
    \  return result;", "    // Implement your solution by completing the below function\n\
    \    std::priority_queue<long> pq;\n    for(int i = 0; i < arr.size(); i++) {\n\
    \        pq.push(arr[i]);\n    }\n    std::vector<long> res;\n    while(k--) {\n\
    \        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
  "    long minIdx = -1;\n    std::vector<long> result;\n    for (long j = 0; j <\
    \ k; j++) {\n        long max = LONG_MIN;\n        for (long i = 0; i < arr.size();\
    \ i++) {\n            if (arr[i] > max && i > minIdx) {\n                max =\
    \ arr[i];\n                minIdx = i;\n            }\n        }\n        result.push_back(max);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    if (arr.size()\
    \ == 0) {\n        return result;\n    }\n    std::priority_queue<long> queue;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        queue.push(arr[i]);\n   \
    \ }\n    for (int i = 0; i < k; i++) {\n        result.push_back(queue.top());\n\
    \        queue.pop();\n    }\n    return result;", "    std::priority_queue<long>\
    \ pq;\n    std::vector<long> result;\n    for (auto value : arr) {\n        pq.push(value);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while\
    \ (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n  \
    \  }\n    return result;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ max_heap;\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n\
    \    }\n    for (long i = 0; i < k; i++) {\n        result.push_back(max_heap.top());\n\
    \        max_heap.pop();\n    }\n    return result;", "    std::vector<long> result;\n\
    \    std::sort(arr.begin(), arr.end());\n    for(long i = arr.size() - 1; i >=\
    \ arr.size() - k; i--) {\n        result.push_back(arr[i]);\n    }\n    return\
    \ result;", "  std::vector<long> result;\n  // TODO\n  return result;", "    std::priority_queue<long>\
    \ pq;\n    std::vector<long> ans;\n    for (long num : arr) {\n        pq.push(num);\n\
    \        if (pq.size() > k)\n            pq.pop();\n    }\n    while (!pq.empty())\
    \ {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;",
  "    std::priority_queue<long> pq;\n    for (auto i : arr) {\n        pq.push(i);\n\
    \    }\n    std::vector<long> result;\n    for (int i = 0; i < k; i++) {\n   \
    \     result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
  "    std::vector<long> result;\n    if (arr.size() < k) {\n        return result;\n\
    \    }\n    result.resize(k);\n    std::make_heap(result.begin(), result.end());\n\
    \    for (auto i = 0; i < arr.size(); ++i) {\n        if (arr[i] > result[0])\
    \ {\n            std::pop_heap(result.begin(), result.end());\n            result[k\
    \ - 1] = arr[i];\n            std::push_heap(result.begin(), result.end());\n\
    \        }\n    }\n    std::sort_heap(result.begin(), result.end());\n    return\
    \ result;", "    long len = arr.size();\n    if (k == len) {\n        return arr;\n\
    \    }\n    std::priority_queue<long> pq;\n    for (long i = 0; i < k; i++) {\n\
    \        pq.push(arr[i]);\n    }\n    for (long i = k; i < len; i++) {\n     \
    \   if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n\
    \        }\n    }\n    std::vector<long> v;\n    while (!pq.empty()) {\n     \
    \   v.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(v.begin(),\
    \ v.end());\n    return v;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ q;\n    for (int i = 0; i < arr.size(); i++) {\n        q.push(arr[i]);\n  \
    \  }\n    for (int i = 0; i < k; i++) {\n        result.push_back(q.top());\n\
    \        q.pop();\n    }\n    return result;", "    std::vector<long> result;\n\
    \    int largest = -1;\n    int largestIndex = -1;\n    while(result.size() <\
    \ k) {\n        largest = -1;\n        largestIndex = -1;\n        for(int i =\
    \ 0; i < arr.size(); i++) {\n            if(arr[i] > largest) {\n            \
    \    largest = arr[i];\n                largestIndex = i;\n            }\n   \
    \     }\n        if(largestIndex == -1) {\n            return result;\n      \
    \  }\n        result.push_back(largest);\n        arr.erase(arr.begin() + largestIndex);\n\
    \    }\n    return result;", "    std::vector<long> output = {};\n    for (long\
    \ i = 0; i < k; i++) {\n        output.push_back(arr[i]);\n    }\n    std::sort(output.begin(),\
    \ output.end());\n    for (long i = k; i < arr.size(); i++) {\n        if (arr[i]\
    \ > output[0]) {\n            output[0] = arr[i];\n            std::sort(output.begin(),\
    \ output.end());\n        }\n    }\n    return output;", "    // handles base\
    \ case\n    if (k == 0) return {};\n    if (k == 1) return {*std::max_element(arr.begin(),\
    \ arr.end())};\n    if (k == arr.size()) return arr;\n    // creates a max heap\
    \ of size k and inserts the first k elements of the array\n    std::priority_queue<long>\
    \ max_heap;\n    for (long i = 0; i < k; i++) {\n        max_heap.push(arr[i]);\n\
    \    }\n    // replaces the max element of the heap if the next element is greater\n\
    \    for (long i = k; i < arr.size(); i++) {\n        if (arr[i] > max_heap.top())\
    \ {\n            max_heap.pop();\n            max_heap.push(arr[i]);\n       \
    \ }\n    }\n    // copies heap elements to an array\n    std::vector<long> result(k);\n\
    \    for (long i = k - 1; i >= 0; i--) {\n        result[i] = max_heap.top();\n\
    \        max_heap.pop();\n    }\n    return result;", "    std::vector<long> result(k);\n\
    \    std::priority_queue<long> max_heap;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        max_heap.push(arr[i]);\n    }\n    for (long i = 0; i < k; i++)\
    \ {\n        result[i] = max_heap.top();\n        max_heap.pop();\n    }\n   \
    \ return result;", "  std::vector<long> maxList;\n  std::priority_queue<long>\
    \ pq;\n  for (long i = 0; i < arr.size(); i++) {\n    pq.push(arr[i]);\n  }\n\
    \  while (!pq.empty() && k > 0) {\n    maxList.push_back(pq.top());\n    pq.pop();\n\
    \    k--;\n  }\n  return maxList;", "    std::vector<long> res;\n    // TODO:\
    \ Write your code here\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ minHeap;\n    for(long n : arr) {\n        minHeap.push(n);\n        if(minHeap.size()\
    \ > k) {\n            minHeap.pop();\n        }\n    }\n    while(!minHeap.empty())\
    \ {\n        res.push_back(minHeap.top());\n        minHeap.pop();\n    }\n  \
    \  return res;", "    std::priority_queue<long> heap;\n    for (long i = 0; i\
    \ < arr.size(); i++) {\n        heap.push(arr[i]);\n    }\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return result;", "    std::multiset<long> set;\n\
    \    std::vector<long> results;\n    for (auto const & i : arr) {\n        set.insert(i);\n\
    \        if (set.size() > k) {\n            set.erase(set.begin());\n        }\n\
    \    }\n    for (auto const & i : set) {\n        results.push_back(i);\n    }\n\
    \    return results;", "    std::vector<long> ans;\n    for(long i = 0; i < k;\
    \ i++) {\n        ans.push_back(arr[i]);\n    }\n    std::sort(ans.begin(), ans.end());\n\
    \    for(long i = k; i < arr.size(); i++) {\n        if(arr[i] > ans[0]) {\n \
    \           ans[0] = arr[i];\n            std::sort(ans.begin(), ans.end());\n\
    \        }\n    }\n    return ans;", "    std::vector<long> result;\n    if (arr.size()\
    \ < k) return result;\n    std::priority_queue<long> max_heap;\n    for (long\
    \ i = 0; i < k; i++) max_heap.push(arr[i]);\n    long index = k;\n    while (index\
    \ < arr.size()) {\n        if (arr[index] > max_heap.top()) {\n            max_heap.pop();\n\
    \            max_heap.push(arr[index]);\n        }\n        index++;\n    }\n\
    \    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n\
    \        max_heap.pop();\n    }\n    return result;", "    std::vector<long> q;\n\
    \    long n = arr.size();\n    for (long i = 0; i < n; i++) {\n        // if q\
    \ is empty or q.size() is smaller than k\n        // than just add the element\
    \ from arr\n        if (q.empty() || q.size() < k) {\n            q.push_back(arr[i]);\n\
    \        } else {\n            // if element from arr is greater than the element\
    \ at front of q\n            // than remove all elements from q that are smaller\
    \ than element at arr\n            // and add it to the q\n            if (arr[i]\
    \ > q.front()) {\n                while(!q.empty() && q.back() < arr[i]) {\n \
    \                   q.pop_back();\n                }\n                q.push_back(arr[i]);\n\
    \            }\n        }\n    }\n    return q;", "    // Create a max heap\n\
    \    std::priority_queue<long> max_heap;\n    for (auto ele : arr) {\n       \
    \ max_heap.push(ele);\n    }\n    std::vector<long> res;\n    for (long i = 0;\
    \ i < k; i++) {\n        res.push_back(max_heap.top());\n        max_heap.pop();\n\
    \    }\n    return res;", "    std::vector<long> v(arr.begin(), arr.begin() +\
    \ k);\n    std::make_heap(v.begin(), v.end());\n    for (int i = k; i < arr.size();\
    \ i++) {\n        if (arr[i] > v[0]) {\n            std::pop_heap(v.begin(), v.end());\n\
    \            v.pop_back();\n            v.push_back(arr[i]);\n            std::push_heap(v.begin(),\
    \ v.end());\n        }\n    }\n    std::sort_heap(v.begin(), v.end());\n    return\
    \ v;", "    long N = arr.size();\n    assert(k <= N);\n    // Compare two elements\
    \ of the list or two elements of the array.\n    auto comp = [](const long& a,\
    \ const long& b) { return a > b; };\n    // This heap will be used to store the\
    \ k maximum elements.\n    std::priority_queue<long, std::vector<long>, decltype(comp)>\
    \ heap(comp);\n    // This heap will be used to store the k elements we are about\
    \ to return.\n    std::priority_queue<long, std::vector<long>, decltype(comp)>\
    \ ret_heap(comp);\n    // Count down from the end of the list.\n    for (long\
    \ i = N - 1; i >= 0; i--) {\n        if (heap.size() < k) {\n            heap.push(arr[i]);\n\
    \        } else {\n            // Remove the next smallest element from the heap.\n\
    \            if (arr[i] > heap.top()) {\n                heap.pop();\n       \
    \         heap.push(arr[i]);\n            }\n        }\n    }\n    // Then, add\
    \ the elements to the return heap.\n    while (!heap.empty()) {\n        ret_heap.push(heap.top());\n\
    \        heap.pop();\n    }\n    // Then, add the elements to the return vector.\n\
    \    std::vector<long> ret;\n    while (!ret_heap.empty()) {\n        ret.push_back(ret_heap.top());\n\
    \        ret_heap.pop();\n    }\n    return ret;", "    std::vector<long> result;\n\
    \    if (arr.size() == 0) {\n        return result;\n    }\n    // step 1: convert\
    \ vector to max heap.\n    std::make_heap(arr.begin(), arr.end());\n    while\
    \ (k--) {\n        // step 2: add root to result vector.\n        result.push_back(arr.front());\n\
    \        // step 3: pop root and shift elements.\n        std::pop_heap(arr.begin(),\
    \ arr.end());\n        arr.pop_back();\n    }\n    return result;", "    int n\
    \ = arr.size();\n    std::vector<long> ans;\n    std::priority_queue<std::pair<long,int>>\
    \ heap;\n    for(int i = 0; i < n; i++) {\n        heap.push({arr[i], i});\n \
    \   }\n    for(int i = 0; i < k; i++) {\n        ans.push_back(heap.top().first);\n\
    \        heap.pop();\n    }\n    return ans;", "    std::vector<long> solution;\n\
    \    // TODO: Write your code here\n    return solution;", "    std::priority_queue<long>\
    \ pq;\n    for (long i=0; i<arr.size(); i++) {\n        pq.push(arr[i]);\n   \
    \ }\n    std::vector<long> res;\n    while(k--) {\n        long temp = pq.top();\n\
    \        res.push_back(temp);\n        pq.pop();\n    }\n    return res;", " \
    \   std::vector<long> result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(arr[i]);\n\
    \    }\n    std::sort(result.begin(), result.end());\n    for (long i = k; i <\
    \ arr.size(); i++) {\n        long j = 0;\n        while (j < k) {\n         \
    \   if (arr[i] > result[j]) {\n                result.erase(result.begin() + j);\n\
    \                result.push_back(arr[i]);\n                std::sort(result.begin(),\
    \ result.end());\n                break;\n            }\n            j++;\n  \
    \      }\n    }\n    return result;", "    std::priority_queue<long> pq;\n   \
    \ std::vector<long> result;\n    for (long num : arr) {\n        pq.push(num);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while\
    \ (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n  \
    \  }\n    std::reverse(result.begin(), result.end());\n    return result;", " \
    \   std::vector<long> list;\n    std::vector<long>::iterator it;\n    for(int\
    \ i = 0; i < arr.size(); i++) {\n        // If the list is empty then insert first\
    \ element\n        if(list.size() == 0) {\n            list.push_back(arr[i]);\n\
    \        }\n        else {\n            // Find the iterator pointing to the position\
    \ of the value to be inserted\n            it = std::lower_bound(list.begin(),\
    \ list.end(), arr[i]);\n            // Check whether the list is sorted or not\
    \ and the size of the list does not exceed k\n            if(std::is_sorted(list.begin(),\
    \ list.end()) && (list.size() <= k)) {\n                // If the iterator is\
    \ pointing to the end then insert the element at the end\n                if(it\
    \ == list.end()) {\n                    list.push_back(arr[i]);\n            \
    \    }\n                // If the iterator is pointing to the beginning then insert\
    \ the element at the beginning\n                else if(it == list.begin()) {\n\
    \                    list.insert(it, arr[i]);\n                }\n           \
    \     // If the element is greater than the element pointed by iterator, then\
    \ insert the element at the position\n                else if(arr[i] > *it) {\n\
    \                    list.insert(it, arr[i]);\n                }\n           \
    \     // If the element is less than the element pointed by iterator and list\
    \ size is less than k,\n                // then insert the element at the end\
    \ of the list\n                else if(arr[i] < *it && list.size() < k) {\n  \
    \                  list.push_back(arr[i]);\n                }\n              \
    \  // If the element is less than the element pointed by iterator and list size\
    \ is greater than k,\n                // then replace the element in the list\
    \ which is greater than the element to be inserted\n                else if(arr[i]\
    \ < *it && list.size() > k) {\n                    it = std::lower_bound(list.begin(),\
    \ list.end(), arr[i]);\n                    if(it != list.end()) {\n         \
    \               list.erase(it);\n                        list.push_back(arr[i]);\n\
    \                    }\n                }\n            }\n            // If the",
  "  // 1. Sorting the array: Time-Complexity: O(nlogn)\n  std::sort(arr.begin(),\
    \ arr.end());\n  std::vector<long> ans;\n  int n = arr.size();\n  // 2. Taking\
    \ last K elements: Time-Complexity: O(n)\n  for(int i = n-1; i >= 0 && k > 0;\
    \ --i) {\n    ans.push_back(arr[i]);\n    --k;\n  }\n  return ans;", "    long\
    \ len = arr.size();\n    std::vector<long> result;\n    if (len <= k) {\n    \
    \    return arr;\n    }\n    for (long i = 0; i < k; i++) {\n        long idx\
    \ = 0;\n        for (long j = 1; j < len - i; j++) {\n            if (arr[j] >\
    \ arr[idx]) {\n                idx = j;\n            }\n        }\n        result.push_back(arr[idx]);\n\
    \        arr[idx] = arr[len - i - 1];\n    }\n    return result;", "    long size\
    \ = arr.size();\n    assert(k <= size);\n    std::priority_queue<long> maxHeap;\n\
    \    for (int i = 0; i < size; i++) {\n        maxHeap.push(arr[i]);\n    }\n\
    \    std::vector<long> res;\n    while (k--) {\n        res.push_back(maxHeap.top());\n\
    \        maxHeap.pop();\n    }\n    return res;", "    std::priority_queue<long>\
    \ pq;\n    for (long x : arr) {\n        pq.push(x);\n        if (pq.size() >\
    \ k) pq.pop();\n    }\n    std::vector<long> res;\n    while (!pq.empty()) {\n\
    \        res.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(res.begin(),\
    \ res.end());\n    return res;", "    int len = arr.size();\n    std::vector<long>\
    \ res;\n    if (k == 0) {\n        return res;\n    }\n    if (k == len) {\n \
    \       return arr;\n    }\n    std::make_heap(arr.begin(), arr.end());\n    int\
    \ i = 1;\n    while (i < k) {\n        std::pop_heap(arr.begin(), arr.end());\n\
    \        arr.pop_back();\n        i++;\n    }\n    return arr;", "  std::vector<long>\
    \ mx;\n  for (auto el : arr) {\n    while (mx.size() > 0 && el > mx.back() &&\
    \ mx.size()+arr.size()-1 > k) {\n      mx.pop_back();\n    }\n    if (mx.size()\
    \ < k) mx.push_back(el);\n  }\n  return mx;", "    std::priority_queue<long> pq;\n\
    \    std::vector<long> result;\n    for (auto num : arr) {\n        pq.push(num);\n\
    \        if (pq.size() > k) {\n            pq.pop();\n        }\n    }\n    while\
    \ (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n  \
    \  }\n    std::reverse(result.begin(), result.end());\n    return result;", " \
    \   long n = arr.size();\n    std::vector<long> answer;\n    assert(k <= n);\n\
    \    for (long i = 0; i < k; i++) {\n        answer.push_back(arr[i]);\n    }\n\
    \    std::sort(answer.begin(), answer.end());\n    for (long i = k; i < n; i++)\
    \ {\n        if (arr[i] > answer[0]) {\n            answer[0] = arr[i];\n    \
    \        std::sort(answer.begin(), answer.end());\n        }\n    }\n    return\
    \ answer;", "    std::priority_queue<long> heap;\n    std::vector<long> result;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        heap.push(arr[i]);\n   \
    \ }\n    for (long i = 0; i < k; i++) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return result;", "    assert(k <= arr.size());\n\
    \    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n    while (k--)\
    \ {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return\
    \ result;", "    std::priority_queue<long> pq;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        pq.push(arr[i]);\n    }\n    std::vector<long> result;\n   \
    \ while (k > 0) {\n        result.push_back(pq.top());\n        pq.pop();\n  \
    \      k--;\n    }\n    return result;", "    int size = arr.size();\n    std::vector<long>\
    \ vec;\n    for(int i = 0; i < size; i++) {\n        if(vec.size() == 0) {\n \
    \           vec.push_back(arr[i]);\n        } else {\n            int sizeVec\
    \ = vec.size();\n            int pos = sizeVec;\n            if(sizeVec > k) {\n\
    \                pos = sizeVec - 1;\n            }\n            if(vec[pos - 1]\
    \ < arr[i]) {\n                if(sizeVec == k) {\n                    vec.pop_back();\n\
    \                }\n                while(pos > 0 && vec[pos - 1] < arr[i]) {\n\
    \                    vec[pos] = vec[pos - 1];\n                    pos--;\n  \
    \              }\n                vec[pos] = arr[i];\n            }\n        }\n\
    \    }\n    return vec;", "  std::priority_queue<long> heap;\n  for (auto a :\
    \ arr) {\n    heap.push(a);\n    if (heap.size() > k) {\n      heap.pop();\n \
    \   }\n  }\n  std::vector<long> result;\n  while (!heap.empty()) {\n    result.push_back(heap.top());\n\
    \    heap.pop();\n  }\n  std::reverse(result.begin(), result.end());\n  return\
    \ result;", "    std::priority_queue<long> pq;\n    for (long x : arr) {\n   \
    \     pq.push(x);\n        if (pq.size() > k) pq.pop();\n    }\n    std::vector<long>\
    \ ans;\n    while (!pq.empty()) {\n        ans.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return ans;", "    std::vector<long> res;\n    std::priority_queue<long>\
    \ pq;\n    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \    }\n    for (long i = 0; i < k; i++) {\n        res.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return res;", "  std::vector<long> result;\n  if\
    \ (arr.size() == 0) {\n    return result;\n  }\n  for (auto i = 0; i < k; i++)\
    \ {\n    auto it = std::max_element(arr.begin(), arr.end());\n    result.push_back(*it);\n\
    \    arr.erase(it);\n  }\n  return result;", "    std::vector<long> result;\n\
    \    std::vector<long>::iterator it;\n    it = std::unique(arr.begin(), arr.end());\n\
    \    arr.resize(std::distance(arr.begin(), it));\n    std::sort(arr.begin(), arr.end());\n\
    \    for(long i = arr.size() - 1; i >= 0 && k > 0; i--) {\n        result.push_back(arr[i]);\n\
    \        k--;\n    }\n    return result;", "    std::vector<long> list;\n    if\
    \ (arr.size() == 0) {\n        return list;\n    }\n    std::priority_queue<long>\
    \ pq;\n    // Build a max heap from the numbers in arr\n    for (long num : arr)\
    \ {\n        pq.push(num);\n    }\n    // Get the kth maximum numbers from the\
    \ max heap\n    for (long i = 0; i < k; i++) {\n        list.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return list;", "  std::vector<long> res;\n  for\
    \ (long el : arr) {\n    while (!res.empty() && el > res.back() && res.size()\
    \ + arr.size() - std::find(arr.begin(), arr.end(), el) >= k)\n      res.pop_back();\n\
    \    res.push_back(el);\n  }\n  res.resize(k);\n  return res;", "    std::priority_queue<long>\
    \ pq;\n    for (auto a : arr) {\n        pq.push(a);\n        if (pq.size() >\
    \ k) {\n            pq.pop();\n        }\n    }\n    std::vector<long> ans;\n\
    \    while (k--) {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n\
    \    std::reverse(ans.begin(), ans.end());\n    return ans;", "    std::vector<long>\
    \ ret;\n    long ret_size = 0;\n    while (ret_size < k) {\n        long max_idx\
    \ = 0;\n        for (long i = 0; i < arr.size(); i++) {\n            if (ret_size\
    \ > 0 && ret[ret_size - 1] > arr[i]) {\n                continue;\n          \
    \  }\n            if (arr[i] > arr[max_idx]) {\n                max_idx = i;\n\
    \            }\n        }\n        ret.push_back(arr[max_idx]);\n        ret_size++;\n\
    \        arr.erase(arr.begin() + max_idx);\n    }\n    return ret;", "    std::priority_queue<long>\
    \ pq;\n    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \    }\n    std::vector<long> result;\n    for (long i = 0; i < k; i++) {\n  \
    \      result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
  "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto\
    \ num : arr) {\n        pq.push(num);\n        if (pq.size() > k) {\n        \
    \    pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return result;", "  long n = arr.size();\n  assert(n\
    \ > 0);\n  assert(k > 0);\n  std::priority_queue<long> q;\n  for (long i = 0;\
    \ i < n; i++) {\n    q.push(arr[i]);\n  }\n  std::vector<long> output;\n  for\
    \ (long i = 0; i < k; i++) {\n    output.push_back(q.top());\n    q.pop();\n \
    \ }\n  return output;", "    std::vector<long> result;\n    std::priority_queue<long>\
    \ pq;\n    for (int i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n\
    \    }\n    for (int i = 0; i < k; i++) {\n        result.push_back(pq.top());\n\
    \        pq.pop();\n    }\n    return result;", "    std::vector<long> result;\n\
    \    for (long i = 0; i < k; i++) {\n        result.push_back(arr[i]);\n    }\n\
    \    std::sort(result.begin(), result.end());\n    for (long i = k; i < arr.size();\
    \ i++) {\n        for (long j = 0; j < k; j++) {\n            if (arr[i] > result[j])\
    \ {\n                result[j] = arr[i];\n                break;\n           \
    \ }\n        }\n        std::sort(result.begin(), result.end());\n    }\n    return\
    \ result;", "  std::vector<long> result;\n  // Create a priority queue q that\
    \ sorts in descending order\n  std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ q;\n  // For every element in arr\n  for (long i = 0; i < arr.size(); i++) {\n\
    \    // If the number of elements in q is less than k, add the element to q\n\
    \    if (q.size() < k) {\n      q.push(arr[i]);\n    } else {\n      // If the\
    \ element is greater than the minimum in q\n      if (arr[i] > q.top()) {\n  \
    \      // Remove the minimum from q and add the element to q\n        q.pop();\n\
    \        q.push(arr[i]);\n      }\n    }\n  }\n  // Transfer the elements from\
    \ q to result\n  while (!q.empty()) {\n    result.push_back(q.top());\n    q.pop();\n\
    \  }\n  return result;", "    std::vector<long> output;\n    for (auto a : arr)\
    \ {\n        // if curr output size is < k, then add a directly\n        if (output.size()\
    \ < k) {\n            output.push_back(a);\n        } else {\n            std::sort(output.begin(),\
    \ output.end());\n            // if current output size is k and the last element\
    \ is smaller than a, then swap a and the last element.\n            if (output[output.size()\
    \ - 1] < a) {\n                output[output.size() - 1] = a;\n            }\n\
    \        }\n    }\n    return output;", "    std::vector<long> ret;\n    if (arr.size()\
    \ == 0) return ret;\n    std::priority_queue<long> pq;\n    for (int i = 0; i\
    \ < arr.size(); i++) {\n        pq.push(arr[i]);\n    }\n    for (int i = 0; i\
    \ < k; i++) {\n        ret.push_back(pq.top());\n        pq.pop();\n    }\n  \
    \  return ret;", "    if (arr.size() == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    std::deque<long> maximum_heap;\n    for (auto itr = arr.begin();\
    \ itr != arr.end(); ++itr) {\n        if (maximum_heap.size() < k) {\n       \
    \     maximum_heap.push_back(*itr);\n            std::push_heap(maximum_heap.begin(),\
    \ maximum_heap.end(), std::greater<long>());\n        } else {\n            if\
    \ (*itr > maximum_heap.front()) {\n                std::pop_heap(maximum_heap.begin(),\
    \ maximum_heap.end(), std::greater<long>());\n                maximum_heap.pop_back();\n\
    \                maximum_heap.push_back(*itr);\n                std::push_heap(maximum_heap.begin(),\
    \ maximum_heap.end(), std::greater<long>());\n            }\n        }\n    }\n\
    \    result.insert(result.begin(), maximum_heap.begin(), maximum_heap.end());\n\
    \    return result;", "  std::priority_queue<long> max_heap;\n  std::vector<long>\
    \ result;\n  for (const auto &el : arr) {\n    max_heap.push(el);\n    if (max_heap.size()\
    \ > k) {\n      max_heap.pop();\n    }\n  }\n  for (long i = 0; i < k; ++i) {\n\
    \    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;",
  "    // Build a max heap with the first k elements.\n    std::priority_queue<long>\
    \ heap;\n    for (long i = 0; i < k; i++) {\n        heap.push(arr[i]);\n    }\n\
    \    // Start iterating over the remaining elements.\n    for (long i = k; i <\
    \ arr.size(); i++) {\n        // If the current element is smaller than the\n\
    \        // top of the heap, ignore it.\n        if (arr[i] < heap.top()) {\n\
    \            continue;\n        }\n        // If the current element is larger\
    \ than the top of the heap,\n        // pop the top of the heap, and insert the\
    \ current element\n        // in its place.\n        heap.pop();\n        heap.push(arr[i]);\n\
    \    }\n    // Pop off the elements from the heap and store it in a vector.\n\
    \    std::vector<long> result;\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return result;", "    // return a vector with\
    \ maximum k values\n    // brute force: sort the array and return first k elements\n\
    \n    std::sort(arr.begin(), arr.end());\n\n    std::vector<long> ans;\n    for(long\
    \ i = arr.size() - 1; i >= arr.size() - k; i--) {\n        ans.push_back(arr[i]);\n\
    \    }\n    return ans;", "  std::priority_queue<long> queue;\n  std::vector<long>\
    \ result;\n  if (arr.size() == 0) {\n    return result;\n  }\n  for (auto num\
    \ : arr) {\n    queue.push(num);\n  }\n  for (long i = 0; i < k; i++) {\n    result.push_back(queue.top());\n\
    \    queue.pop();\n  }\n  return result;", "    std::vector<long> maxes(k);\n\
    \    int j = 0;\n    for (long i : arr) {\n        while (j > 0 && maxes[j - 1]\
    \ < i && j + arr.size() - k >= 0) {\n            j--;\n        }\n        if (j\
    \ < k) {\n            maxes[j] = i;\n            j++;\n        }\n    }\n    return\
    \ maxes;", "    std::vector<long> result;\n    if (arr.size() < k) {\n       \
    \ return result;\n    }\n    std::priority_queue<long> pq;\n    for (auto e :\
    \ arr) {\n        pq.push(e);\n    }\n    while (!pq.empty() && k > 0) {\n   \
    \     result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n  \
    \  return result;", "    std::priority_queue<long> queue;\n    for (const auto&\
    \ element : arr) {\n        queue.push(element);\n    }\n    std::vector<long>\
    \ result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(queue.top());\n\
    \        queue.pop();\n    }\n    return result;", "  std::vector<long> res;\n\
    \  std::priority_queue<long> pq;\n  for (auto i : arr) {\n    pq.push(i);\n  }\n\
    \  while (k--) {\n    res.push_back(pq.top());\n    pq.pop();\n  }\n  return res;",
  "    std::deque<long> q;\n    for (auto it = arr.begin(); it != arr.end(); ++it)\
    \ {\n        while (q.size() && *it > q.back()) {\n            q.pop_back();\n\
    \        }\n        q.push_back(*it);\n        if (q.size() > k) {\n         \
    \   q.pop_front();\n        }\n    }\n    std::vector<long> result;\n    while\
    \ (q.size()) {\n        result.push_back(q.front());\n        q.pop_front();\n\
    \    }\n    return result;", "    assert(k <= arr.size());\n    if (k == arr.size())\
    \ return arr;\n    std::vector<long> ans;\n    std::priority_queue<long> pq;\n\
    \    for (int i = 0; i < k; i++) {\n        pq.push(arr[i]);\n    }\n    for (int\
    \ i = k; i < arr.size(); i++) {\n        if (arr[i] > pq.top()) {\n          \
    \  pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n    while (!pq.empty())\
    \ {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(ans.begin(),\
    \ ans.end());\n    return ans;", "    std::vector<long> v;\n    for(long i = 0;\
    \ i < arr.size(); i++) {\n        // the list is empty\n        if(v.size() ==\
    \ 0) {\n            v.push_back(arr[i]);\n        } else {\n            // if\
    \ the next element is greater than the last element in the list\n            if(arr[i]\
    \ > v[v.size() - 1]) {\n                // then pop the last element as many times\
    \ as possible\n                while(v.size() > 0 && arr[i] > v[v.size() - 1])\
    \ {\n                    v.pop_back();\n                }\n                v.push_back(arr[i]);\n\
    \            } else {\n                // the next element is not greater than\
    \ the last element in the list\n                v.push_back(arr[i]);\n       \
    \     }\n        }\n        // if the size of the list exceeds k\n        if(v.size()\
    \ > k) {\n            // then pop the last element until the size of the list\
    \ is equal to k\n            while(v.size() > k) {\n                v.pop_back();\n\
    \            }\n        }\n    }\n    return v;", "    // Insert into a heap and\
    \ keep the heap size to k\n    auto cmp = [](const long& a, const long& b) {\n\
    \        return a > b;\n    };\n    std::priority_queue<long, std::vector<long>,\
    \ decltype(cmp)> heap(cmp);\n    for (long& val : arr) {\n        heap.push(val);\n\
    \        if (heap.size() > k) {\n            heap.pop();\n        }\n    }\n \
    \   std::vector<long> result;\n    while (!heap.empty()) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::vector<long> output;\n    long size = arr.size();\n\
    \    if (size == 0) {\n        return output;\n    }\n    std::sort(arr.begin(),\
    \ arr.end());\n    long i = size - 1;\n    long j = 0;\n    while (i >= j && output.size()\
    \ < k) {\n        if (abs(arr[i]) > abs(arr[j])) {\n            output.push_back(arr[i]);\n\
    \            i--;\n        } else {\n            output.push_back(arr[j]);\n \
    \           j++;\n        }\n    }\n    return output;", "    // write your code\
    \ here\n    std::vector<long> result;\n    int n = arr.size();\n    std::priority_queue<long>\
    \ pq;\n    for(int i = 0; i < n; i++) {\n        pq.push(arr[i]);\n    }\n   \
    \ for(int i = 0; i < k; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n\
    \    }\n    return result;", "    std::vector<long> output;\n    if (arr.size()\
    \ == 0) return output;\n    std::priority_queue<long> pq;\n    for (int i = 0;\
    \ i < arr.size(); i++) {\n        pq.push(arr[i]);\n        if (pq.size() > k)\
    \ {\n            pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n    \
    \    output.push_back(pq.top());\n        pq.pop();\n    }\n    return output;",
  "    std::priority_queue<long> max_heap;\n    std::vector<long> result;\n    for\
    \ (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n    }\n\
    \    for (long i = 0; i < k; i++) {\n        result.push_back(max_heap.top());\n\
    \        max_heap.pop();\n    }\n    return result;", "    std::priority_queue<long>\
    \ pq;\n    long N = arr.size();\n    for (long i = 0; i < N; i++) {\n        pq.push(arr[i]);\n\
    \    }\n    std::vector<long> ans;\n    for (long i = 0; i < k; i++) {\n     \
    \   ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;", "  \
    \  std::vector<long> result;\n    // TODO: Write your code here\n    return result;",
  "    // create max heap\n    std::make_heap(arr.begin(), arr.end());\n    // pop\
    \ k elements\n    for (int i = 0; i < k; i++) {\n        std::pop_heap(arr.begin(),\
    \ arr.end());\n        arr.pop_back();\n    }\n    // sort the elements\n    std::sort(arr.begin(),\
    \ arr.end());\n    return arr;", "    std::priority_queue<long> heap;\n    for\
    \ (long i = 0; i < arr.size(); i++) {\n        heap.push(arr[i]);\n    }\n   \
    \ std::vector<long> result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(heap.top());\n\
    \        heap.pop();\n    }\n    return result;", "    std::vector<long> result;\n\
    \    for (int i = 0; i < k; i++) {\n        int maxIndex = -1;\n        long maxValue\
    \ = LONG_MIN;\n        for (int j = 0; j < arr.size(); j++) {\n            if\
    \ (arr[j] > maxValue) {\n                maxValue = arr[j];\n                maxIndex\
    \ = j;\n            }\n        }\n        result.push_back(maxValue);\n      \
    \  arr.erase(arr.begin() + maxIndex);\n    }\n    return result;", "    // build\
    \ max heap\n    std::make_heap(arr.begin(), arr.end());\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < k; i++) {\n        result.push_back(arr.front());\n\
    \        std::pop_heap(arr.begin(), arr.end());\n        arr.pop_back();\n   \
    \ }\n    return result;", "    std::sort(arr.begin(), arr.end());\n    return\
    \ std::vector<long>(arr.rbegin(), arr.rbegin() + k);", "    std::vector<long>\
    \ res;\n    res.reserve(k);\n    for (auto i = 0; i < arr.size(); ++i) {\n   \
    \     for (auto j = res.size() - 1; j >= 0; --j) {\n            if (res[j] < arr[i])\
    \ {\n                res.insert(res.begin() + j + 1, arr[i]);\n              \
    \  if (res.size() > k) res.pop_back();\n                break;\n            }\n\
    \        }\n        if (res.size() < k) res.insert(res.begin(), arr[i]);\n   \
    \ }\n    return res;", "    std::vector<long> answer;\n    for (long i = 0; i\
    \ < k; i++) {\n        long max = arr[i];\n        long pos = i;\n        for\
    \ (long j = i + 1; j < arr.size(); j++) {\n            if (arr[j] > max) {\n \
    \               max = arr[j];\n                pos = j;\n            }\n     \
    \   }\n        answer.push_back(max);\n        std::swap(arr[i], arr[pos]);\n\
    \    }\n    return answer;", "  if (arr.size() == 0) {\n    return {};\n  }\n\
    \  std::priority_queue<long> max_heap;\n  for (long long i = 0; i < arr.size();\
    \ i++) {\n    max_heap.push(arr[i]);\n  }\n  std::vector<long> res;\n  while (k--)\
    \ {\n    res.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return res;",
  "    std::vector<long> max;\n    for (long i = 0; i < k; i++) {\n        max.push_back(arr[i]);\n\
    \    }\n    std::sort(max.begin(), max.end());\n    for (long i = k; i < arr.size();\
    \ i++) {\n        if (arr[i] > max[0]) {\n            max[0] = arr[i];\n     \
    \       std::sort(max.begin(), max.end());\n        }\n    }\n    return max;"]
stop_tokens:
- "\n}"
