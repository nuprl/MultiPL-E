language: cpp
name: HumanEval_143_words_in_sentence
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // 1. For every word in sentence:\n\
    \  //      1. If len(word) is prime then add it to new string\n  // 2. Return\
    \ new string\n  std::string new_string = \"\";\n  std::stringstream iss(sentence);\n\
    \  std::string word;\n  bool prime;\n  while (iss >> word) {\n    prime = true;\n\
    \    if (word.length() == 1) {\n      prime = false;\n    }\n    for (int i =\
    \ 2; i < word.length(); i++) {\n      if (word.length() % i == 0) {\n        prime\
    \ = false;\n        break;\n      }\n    }\n    if (prime) {\n      new_string\
    \ += word + \" \";\n    }\n  }\n  new_string.pop_back();\n  return new_string;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmps2qrn97c: /tmp/tmps2qrn97c.cpp:50: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    auto words = std::vector<std::string>();\n\
    \    auto result = std::string();\n    std::istringstream iss(sentence);\n   \
    \ std::copy(std::istream_iterator<std::string>(iss),\n    std::istream_iterator<std::string>(),\n\
    \    std::back_inserter(words));\n    auto v = std::vector<int>{2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97};\n    for (auto i = 0; i < words.size(); i++) {\n        auto n = words[i].size();\n\
    \        auto it = std::find(v.begin(), v.end(), n);\n        if (it != v.end())\
    \ {\n            result += words[i] + ' ';\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpyy3uz1fr: /tmp/tmpyy3uz1fr.cpp:42: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::unordered_set<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n  for (const auto& word : sentence) {\n    if\
    \ (primes.find(word.size()) != primes.end()) {\n      result += \" \" + word;\n\
    \    }\n  }\n  return result.substr(1);\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnsdhldrp.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpnsdhldrp.cpp:21:26: error: request for member \u2018size\u2019 in \u2018\
    word\u2019, which is of non-class type \u2018const char\u2019\n   21 |     if\
    \ (primes.find(word.size()) != primes.end()) {\n      |                      \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    std::string\
    \ temp;\n    std::stringstream ss(sentence);\n    while (std::getline(ss, temp,\
    \ ' ')) {\n        std::cout << temp << std::endl;\n        if (is_prime(temp.size()))\
    \ {\n            res.append(temp + \" \");\n        }\n    }\n    std::cout <<\
    \ res.size() << std::endl;\n    res.erase(res.end() - 1);\n    return res;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa7079lip.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpa7079lip.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(temp.size())) {\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    auto words = std::vector<std::string>{};\n\
    \    auto index = 0;\n    while (index < sentence.size()) {\n        if (sentence[index]\
    \ == ' ') {\n            index++;\n            continue;\n        }\n        auto\
    \ start = index;\n        while (index < sentence.size() && sentence[index] !=\
    \ ' ') {\n            index++;\n        }\n        words.push_back(sentence.substr(start,\
    \ index - start));\n    }\n    auto pwords = std::vector<std::string>{};\n   \
    \ for (const auto& word : words) {\n        auto is_prime = true;\n        if\
    \ (word.size() == 1) {\n            pwords.push_back(word);\n            continue;\n\
    \        }\n        for (auto i = 2; i <= std::sqrt(word.size()); i++) {\n   \
    \         if (word.size() % i == 0) {\n                is_prime = false;\n   \
    \             break;\n            }\n        }\n        if (is_prime) {\n    \
    \        pwords.push_back(word);\n        }\n    }\n    auto result = std::string{};\n\
    \    for (const auto& word : pwords) {\n        result += word + \" \";\n    }\n\
    \    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmptb_bc6f9: /tmp/tmptb_bc6f9.cpp:59: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream s(sentence);\n\
    \    std::vector<std::string> words;\n    std::copy(std::istream_iterator<std::string>(s),\
    \ std::istream_iterator<std::string>(), std::back_inserter(words));\n    std::vector<std::string>\
    \ ans;\n    for (auto &w : words) {\n        if (w.size() == 1) {\n          \
    \  ans.push_back(w);\n        } else {\n            // a word has a prime length\n\
    \            // iff it is either the smallest or second smallest word\n      \
    \      bool is_prime = false;\n            for (int i = 2; i <= w.size() / 2;\
    \ ++i) {\n                if (w.size() % i == 0) {\n                    is_prime\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if (!is_prime) {\n                ans.push_back(w);\n            }\n\
    \        }\n    }\n    std::string ans_str;\n    std::copy(ans.begin(), ans.end(),\
    \ std::back_inserter(ans_str));\n    return ans_str;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/specfun.h:45,\n         \
    \        from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp23nshiz2.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:\
    \ In instantiation of \u2018static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II,\
    \ _II, _OI) [with _II = std::__cxx11::basic_string<char>*; _OI = std::back_insert_iterator<std::__cxx11::basic_string<char>\
    \ >]\u2019:\n/usr/include/c++/9/bits/stl_algobase.h:404:30:   required from \u2018\
    _OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = std::__cxx11::basic_string<char>*;\
    \ _OI = std::back_insert_iterator<std::__cxx11::basic_string<char> >]\u2019\n\
    /usr/include/c++/9/bits/stl_algobase.h:441:30:   required from \u2018_OI std::__copy_move_a2(_II,\
    \ _II, _OI) [with bool _IsMove = false; _II = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OI = std::back_insert_iterator<std::__cxx11::basic_string<char>\
    \ >]\u2019\n/usr/include/c++/9/bits/stl_algobase.h:474:7:   required from \u2018\
    _OI std::copy(_II, _II, _OI) [with _II = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OI = std::back_insert_iterator<std::__cxx11::basic_string<char>\
    \ >]\u2019\n/tmp/tmp23nshiz2.cpp:41:66:   required from here\n/usr/include/c++/9/bits/stl_algobase.h:342:18:\
    \ error: no match for \u2018operator=\u2019 (operand types are \u2018std::back_insert_iterator<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018std::__cxx11::basic_string<char>\u2019)\n  342 |        *__result\
    \ = *__first;\n      |        ~~~~~~~~~~^~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp23nshiz2.cpp:2:\n/usr/include/c++/9/bits/stl_iterator."
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> w;\n\
    \    std::string word;\n    for (int i = 0; i < sentence.size(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            w.push_back(word);\n            word\
    \ = \"\";\n        } else {\n            word += sentence[i];\n        }\n   \
    \ }\n    if (word != \"\") {\n        w.push_back(word);\n    }\n    std::string\
    \ res;\n    for (int i = 0; i < w.size(); i++) {\n        bool prime = true;\n\
    \        for (int j = 2; j <= sqrt(w[i].size()); j++) {\n            if (w[i].size()\
    \ % j == 0) {\n                prime = false;\n                break;\n      \
    \      }\n        }\n        if (prime) {\n            res += w[i] + \" \";\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpql_486gh: /tmp/tmpql_486gh.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string out;\n  bool is_prime[20]\
    \ = {\n    false,  // 0\n    false,  // 1\n    true,   // 2\n    true,   // 3\n\
    \    false,  // 4\n    true,   // 5\n    false,  // 6\n    true,   // 7\n    false,\
    \  // 8\n    false,  // 9\n    false,  // 10\n    true,   // 11\n    false,  //\
    \ 12\n    true,   // 13\n    false,  // 14\n    false,  // 15\n    false,  //\
    \ 16\n    true,   // 17\n    false,  // 18\n    true,   // 19\n  };\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (is_prime[word.size()])\
    \ {\n      out += word + \" \";\n    }\n  }\n  if (out.size() > 0) {\n    out.pop_back();\n\
    \  }\n  return out;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098980
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::string res;\n  while (ss >> word) {\n    if (word.size()\
    \ <= 1) continue;\n    bool is_prime = true;\n    for (int i = 2; i < word.size();\
    \ ++i) {\n      if (word.size() % i == 0) {\n        is_prime = false;\n     \
    \   break;\n      }\n    }\n    if (is_prime) {\n      res += word + \" \";\n\
    \    }\n  }\n  if (res.size() > 0) {\n    res.pop_back();\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int len = 0;\n    std::vector<std::string>\
    \ words;\n    int sz = sentence.size();\n    for (int i = 0; i < sz; ++i) {\n\
    \        if (sentence[i] == ' ') {\n            words.push_back(sentence.substr(len,\
    \ i - len));\n            len = i + 1;\n        }\n    }\n    words.push_back(sentence.substr(len,\
    \ sz - len));\n    std::string result;\n    for (const auto& word : words) {\n\
    \        int wlen = word.size();\n        if (wlen <= 1) continue;\n        bool\
    \ flag = true;\n        for (int i = 2; i < wlen; ++i) {\n            if (wlen\
    \ % i == 0) {\n                flag = false;\n                break;\n       \
    \     }\n        }\n        if (flag) {\n            result += word + \" \";\n\
    \        }\n    }\n    return result.substr(0, result.size() - 1);\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words\
    \ = {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n  const std::vector<int>\
    \ prime_numbers = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23};\n  int i = 0;\n  for (const\
    \ char c : sentence) {\n    if (c == ' ') {\n      ++i;\n    } else {\n      words[i]\
    \ += c;\n    }\n  }\n  std::string s;\n  for (const std::string &word : words)\
    \ {\n    if (word.length() > 0 && std::find(prime_numbers.begin(), prime_numbers.end(),\
    \ word.length()) != prime_numbers.end()) {\n      s += word + \" \";\n    }\n\
    \  }\n  if (s.length() > 0) {\n    s.pop_back();\n  }\n  return s;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpuu35k3v7: /tmp/tmpuu35k3v7.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes = {2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, 101};\n    std::vector<std::string> words;\n    std::string\
    \ word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n\
    \            word.clear();\n        } else {\n            word.push_back(c);\n\
    \        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n\
    \    }\n    std::vector<std::string> output;\n    for (auto w : words) {\n   \
    \     if (std::find(primes.begin(), primes.end(), w.size()) != primes.end()) {\n\
    \            output.push_back(w);\n        }\n    }\n    std::string result;\n\
    \    for (auto o : output) {\n        result += o + \" \";\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp0_ij2eno: /tmp/tmp0_ij2eno.cpp:52: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::vector<std::string> words;\n    for (std::string word; ss >> word;)\
    \ {\n        words.push_back(word);\n    }\n    std::stringstream ss1;\n    for\
    \ (const auto &word : words) {\n        auto is_prime = [](size_t n) {\n     \
    \       if (n < 2) {\n                return false;\n            }\n         \
    \   size_t limit = (size_t) std::sqrt(n);\n            for (size_t i = 2; i <=\
    \ limit; ++i) {\n                if (n % i == 0) {\n                    return\
    \ false;\n                }\n            }\n            return true;\n       \
    \ };\n        if (is_prime(word.size())) {\n            ss1 << word << \" \";\n\
    \        }\n    }\n    std::string res = ss1.str();\n    res.pop_back();\n   \
    \ return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfx8slszh: /tmp/tmpfx8slszh.cpp:52: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> ret;\n\
    \    int current_index = 0;\n    bool prime = true;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            for (int j = 2; j < sentence.size()\
    \ / 2; j++) {\n                if (sentence.size() % j == 0) {\n             \
    \       prime = false;\n                    break;\n                }\n      \
    \      }\n            if (prime) {\n                ret.push_back(sentence.substr(current_index,\
    \ i - current_index));\n            }\n            current_index = i + 1;\n  \
    \          prime = true;\n        }\n    }\n    for (int j = 2; j < sentence.size()\
    \ / 2; j++) {\n        if (sentence.size() % j == 0) {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if (prime) {\n        ret.push_back(sentence.substr(current_index,\
    \ sentence.size() - current_index));\n    }\n    std::string ans;\n    for (int\
    \ i = 0; i < ret.size(); i++) {\n        ans += ret[i];\n        if (i != ret.size()\
    \ - 1) {\n            ans += \" \";\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp5bzjadpc: /tmp/tmp5bzjadpc.cpp:56: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::istringstream\
    \ ss(sentence);\n    std::string current_word;\n    while (std::getline(ss, current_word,\
    \ ' ')) {\n        if (current_word.size() > 1) {\n            if (current_word.size()\
    \ == 2) {\n                result += current_word + ' ';\n            } else {\n\
    \                bool is_prime = true;\n                for (int i = 2; i <= current_word.size()\
    \ / 2; ++i) {\n                    if (current_word.size() % i == 0) {\n     \
    \                   is_prime = false;\n                        break;\n      \
    \              }\n                }\n                if (is_prime) {\n       \
    \             result += current_word + ' ';\n                }\n            }\n\
    \        }\n    }\n    return result.substr(0, result.size() - 1);\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  words.reserve(sentence.size());\n  int idx = 0;\n  for (int i = 0; i < sentence.size();\
    \ ++i) {\n    if (sentence[i] == ' ') {\n      words.push_back(sentence.substr(idx,\
    \ i - idx));\n      idx = i + 1;\n    }\n  }\n  if (idx < sentence.size()) {\n\
    \    words.push_back(sentence.substr(idx));\n  }\n  bool is_prime[256] = {false};\n\
    \  std::vector<std::string> prime_words;\n  for (auto w : words) {\n    if (is_prime[w.size()])\
    \ {\n      prime_words.push_back(w);\n    }\n  }\n  std::string ans;\n  for (auto\
    \ w : prime_words) {\n    ans += w + \" \";\n  }\n  if (!ans.empty()) {\n    ans.pop_back();\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpenmuvm0j: /tmp/tmpenmuvm0j.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // TODO\n    return \"\";\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpowr7857d: /tmp/tmpowr7857d.cpp:23: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string word = \"\";\n  std::string\
    \ new_sentence = \"\";\n  for (auto c : sentence) {\n    if (c == ' ') {\n   \
    \   if (word.size() == 2 || word.size() == 3 || word.size() == 5 || word.size()\
    \ == 7) {\n        new_sentence += (word + \" \");\n      }\n      word = \"\"\
    ;\n    } else {\n      word += c;\n    }\n  }\n  // for last word\n  if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n    new_sentence\
    \ += word;\n  }\n  return new_sentence;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsbnxf0ue: /tmp/tmpsbnxf0ue.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    const int m = sentence.size();\n\
    \    std::string result = \"\";\n    std::vector<std::string> s = {\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"};\n    //std::vector<std::string> s(27);\n    //std::copy(sentence.begin(),\
    \ sentence.end(), s.begin());\n    //std::vector<std::string> v;\n    for (int\
    \ i = 0; i < m; i++) {\n        if (sentence[i] == ' ') {\n            result\
    \ += \" \";\n        } else {\n            for (int j = 0; j < 26; j++) {\n  \
    \              if (sentence[i] == s[j][0]) {\n                    result += s[j];\n\
    \                }\n            }\n        }\n    }\n    std::vector<std::string>\
    \ v;\n    std::string str = \"\";\n    for (int i = 0; i < result.size(); i++)\
    \ {\n        if (result[i] == ' ') {\n            v.push_back(str);\n        \
    \    str = \"\";\n        } else {\n            str += result[i];\n        }\n\
    \    }\n    v.push_back(str);\n    std::string res = \"\";\n    for (int i = 0;\
    \ i < v.size(); i++) {\n        if (v[i].size() > 1) {\n            int c = 0;\n\
    \            for (int j = 2; j <= v[i].size() / 2; j++) {\n                if\
    \ (v[i].size() % j == 0) {\n                    c++;\n                }\n    \
    \        }\n            if (c == 0) {\n                res += v[i];\n        \
    \        res += \" \";\n            }\n        }\n    }\n    res.pop_back();\n\
    \    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3wrccaug: /tmp/tmp3wrccaug.cpp:66: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  auto is_prime\
    \ = [](int x) {\n    if (x <= 1) {\n      return false;\n    }\n    for (int d\
    \ = 2; d * d <= x; ++d) {\n      if (x % d == 0) {\n        return false;\n  \
    \    }\n    }\n    return true;\n  };\n  std::stringstream ss(sentence);\n  std::string\
    \ word;\n  while (ss >> word) {\n    if (is_prime(word.size())) {\n      result\
    \ += word + \" \";\n    }\n  }\n  result.pop_back();\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpe2yn7b8t: /tmp/tmpe2yn7b8t.cpp:47: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words\
    \ = {\"a\", \"is\", \"the\", \"from\", \"in\", \"this\", \"for\", \"lets\", \"\
    go\", \"swimming\"};\n  std::vector<int> lengths = {1, 2, 3, 4, 2, 4, 3, 4, 2,\
    \ 8};\n  std::vector<int> is_prime = {0, 1, 1, 0, 1, 0, 0, 0, 1, 0};\n  std::unordered_map<std::string,\
    \ int> word_indices;\n  for (int i = 0; i < words.size(); ++i) {\n    word_indices[words[i]]\
    \ = i;\n  }\n  // assert(word_indices.size() == words.size());\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  std::string result;\n  while (ss >> word)\
    \ {\n    if (word_indices.find(word) != word_indices.end()) {\n      int index\
    \ = word_indices[word];\n      if (is_prime[index]) {\n        result += word\
    \ + \" \";\n      }\n    }\n  }\n  // assert(!result.empty());\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpc23_8z94: /tmp/tmpc23_8z94.cpp:44: int main(): Assertion `candidate(("lets
    go for swimming")) == ("go for")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  const int SIZE = sentence.size();\n\
    \  int index = 0;\n  bool exist[SIZE] = {false};\n  for (int i = 0; i < SIZE;\
    \ ++i) {\n    if (sentence[i] == ' ') {\n      bool is_prime = true;\n      for\
    \ (int j = 2; j < i - index; ++j) {\n        if ((i - index) % j == 0) {\n   \
    \       is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        exist[index] = true;\n      }\n      index = i + 1;\n    }\n  }\n\
    \  bool is_prime = true;\n  for (int j = 2; j < SIZE - index; ++j) {\n    if ((SIZE\
    \ - index) % j == 0) {\n      is_prime = false;\n      break;\n    }\n  }\n  if\
    \ (is_prime) {\n    exist[index] = true;\n  }\n  std::string result;\n  for (int\
    \ i = 0; i < SIZE; ++i) {\n    if (exist[i]) {\n      int j = i;\n      while\
    \ (sentence[j] != ' ' && j < SIZE) {\n        result += sentence[j];\n       \
    \ ++j;\n      }\n      result += ' ';\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpy0colfyv: /tmp/tmpy0colfyv.cpp:61: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098980
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> tokens;\n\
    \  std::string token;\n  std::istringstream token_stream(sentence);\n  while (std::getline(token_stream,\
    \ token, ' ')) {\n    tokens.push_back(token);\n  }\n  std::vector<bool> is_prime(101,\
    \ true);\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= 100; ++i)\
    \ {\n    if (is_prime[i]) {\n      for (int j = i * i; j <= 100; j += i) {\n \
    \       is_prime[j] = false;\n      }\n    }\n  }\n  std::string result;\n  for\
    \ (const auto& token : tokens) {\n    if (is_prime[token.size()]) {\n      result\
    \ += token + \" \";\n    }\n  }\n  if (!result.empty()) {\n    result.pop_back();\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result = \"\";\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  int len = -1;\n  bool is_prime = false;\n\
    \  for (int i = 2; i <= 100; i++) {\n    is_prime = true;\n    for (int j = 2;\
    \ j <= i/2; j++) {\n      if (i % j == 0) {\n        is_prime = false;\n     \
    \   break;\n      }\n    }\n    if (is_prime) {\n      len = i;\n      while (std::getline(ss,\
    \ word, ' ')) {\n        if (word.length() == len) {\n          result += word\
    \ + \" \";\n        }\n      }\n      if (result.length() > 0) {\n        result.pop_back();\n\
    \        return result;\n      }\n      ss.clear();\n      ss.str(sentence);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsxopywno: /tmp/tmpsxopywno.cpp:51: int main(): Assertion `candidate(("lets
    go for swimming")) == ("go for")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::istringstream iss(sentence);\n  std::copy(std::istream_iterator<std::string>(iss),\n\
    \    std::istream_iterator<std::string>(),\n    std::back_inserter(words));\n\
    \  std::vector<std::string> result;\n  int count = 0;\n  for (auto word : words)\
    \ {\n    if (std::find(std::begin(result), std::end(result), word) == std::end(result))\
    \ {\n      if (is_prime(word.size())) {\n        result.push_back(word);\n   \
    \   }\n    }\n  }\n  std::string final_result;\n  if (result.size() == 0) {\n\
    \    return final_result;\n  }\n  for (int i = 0; i < result.size() - 1; i++)\
    \ {\n    final_result += result[i] + \" \";\n  }\n  final_result += result[result.size()\
    \ - 1];\n  return final_result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl65ipxcs.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpl65ipxcs.cpp:27:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   27 |       if (is_prime(word.size())) {\n      |           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string tmp, output;\n    bool is_prime;\n    int n;\n    while (ss >>\
    \ tmp) {\n        n = tmp.size();\n        is_prime = true;\n        for (int\
    \ i = 2; i < n; ++i) {\n            if (n % i == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            output += tmp + \" \";\n        }\n    }\n    return output.substr(0,\
    \ output.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpbdoyo5hy: /tmp/tmpbdoyo5hy.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    int\
    \ size = sentence.size();\n    int start = 0;\n    int end = 0;\n    while (sentence[end]\
    \ != '\\0') {\n        //std::cout << \"End: \" << end << std::endl;\n       \
    \ //std::cout << \"Start: \" << start << std::endl;\n        if (sentence[end]\
    \ == ' ') {\n            //std::cout << \"Word: \" << sentence.substr(start, end\
    \ - start) << std::endl;\n            int word_length = end - start;\n       \
    \     bool is_prime = true;\n            for (int i = 2; i <= word_length / 2;\
    \ i++) {\n                if (word_length % i == 0) {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_prime) {\n                result.append(sentence.substr(start,\
    \ end - start));\n                result.append(\" \");\n            }\n     \
    \       start = end + 1;\n        }\n        end++;\n    }\n    //std::cout <<\
    \ \"Word: \" << sentence.substr(start, end - start) << std::endl;\n    int word_length\
    \ = end - start;\n    bool is_prime = true;\n    for (int i = 2; i <= word_length\
    \ / 2; i++) {\n        if (word_length % i == 0) {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if (is_prime) {\n        result.append(sentence.substr(start,\
    \ end - start));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpvlcu__03: /tmp/tmpvlcu__03.cpp:59: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098980
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    const std::vector<int> primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101};\n    std::unordered_set<int> prime_set(primes.begin(),\
    \ primes.end());\n    std::stringstream ss(sentence);\n    std::string word;\n\
    \    std::string result;\n    while (ss >> word) {\n        if (prime_set.count(word.size()))\
    \ {\n            result += (result.empty() ? \"\" : \" \") + word;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Use a set to store prime numbers\
    \ [2, 100]\n    std::set<int> primes({2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97});\n    std::string result;\n\
    \    // We will first use a stringstream object to split the input string\n  \
    \  // by space and store the result in a vector of strings.\n    std::stringstream\
    \ ss(sentence);\n    std::vector<std::string> words;\n    std::string word;\n\
    \    while (ss >> word) {\n        words.push_back(word);\n    }\n    // Next\
    \ we iterate over the vector and find words whose length is a prime number.\n\
    \    for (const auto& word : words) {\n        if (primes.find(word.length())\
    \ != primes.end()) {\n            // If a word's length is a prime number,\n \
    \           // we concatenate it to the result string.\n            result +=\
    \ (word + \" \");\n        }\n    }\n    // Finally, we remove the last space\
    \ character from the result string\n    // and return the result.\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmph02ne8yk: /tmp/tmph02ne8yk.cpp:49: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string current_word;\n  for (char c : sentence) {\n    if (c == ' ') {\n\
    \      words.push_back(current_word);\n      current_word = \"\";\n    } else\
    \ {\n      current_word += c;\n    }\n  }\n  if (current_word != \"\") {\n   \
    \ words.push_back(current_word);\n  }\n  std::string res;\n  for (const std::string&\
    \ word : words) {\n    if (is_prime(word.size())) {\n      res += word + \" \"\
    ;\n    }\n  }\n  if (res.back() == ' ') {\n    res.pop_back();\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuhls4jm_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpuhls4jm_.cpp:33:9: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   33 |     if (is_prime(word.size())) {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream iss(sentence);\n    for (std::string word; iss >> word;\
    \ ) {\n        words.push_back(word);\n    }\n    std::string ans = \"\";\n  \
    \  for (int i = 0; i < words.size(); ++i) {\n        if (words[i].size() == 1)\
    \ {\n            ans += words[i] + \" \";\n        } else {\n            int flag\
    \ = 1;\n            for (int j = 2; j < words[i].size(); ++j) {\n            \
    \    if (words[i].size() % j == 0) {\n                    flag = 0;\n        \
    \            break;\n                }\n            }\n            if (flag) {\n\
    \                ans += words[i] + \" \";\n            }\n        }\n    }\n \
    \   ans.pop_back();\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4x4k4z5x: /tmp/tmp4x4k4z5x.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // (1) replace the special character(except\
    \ ' ') with space to be able to split the string\n  for (auto c : sentence) {\n\
    \    if (c != ' ' && (c < 'a' || c > 'z')) { sentence[c] = ' '; }\n  }\n  // (2)\
    \ split the string into words, and collect the words that have prime number of\
    \ length\n  std::vector<std::string> words;\n  std::istringstream is(sentence);\n\
    \  for (std::string word; is >> word; ) {\n    if (word.length() == 1) { words.push_back(word);\
    \ }\n    else if (word.length() == 2) { words.push_back(word); }\n    else if\
    \ (word.length() == 3) { words.push_back(word); }\n    else if (word.length()\
    \ == 5) { words.push_back(word); }\n    else if (word.length() == 7) { words.push_back(word);\
    \ }\n    else if (word.length() == 11) { words.push_back(word); }\n    else if\
    \ (word.length() == 13) { words.push_back(word); }\n    else if (word.length()\
    \ == 17) { words.push_back(word); }\n    else if (word.length() == 19) { words.push_back(word);\
    \ }\n    else if (word.length() == 23) { words.push_back(word); }\n    else if\
    \ (word.length() == 29) { words.push_back(word); }\n    else if (word.length()\
    \ == 31) { words.push_back(word); }\n    else if (word.length() == 37) { words.push_back(word);\
    \ }\n    else if (word.length() == 41) { words.push_back(word); }\n    else if\
    \ (word.length() == 43) { words.push_back(word); }\n    else if (word.length()\
    \ == 47) { words.push_back(word); }\n    else if (word.length() == 53) { words.push_back(word);\
    \ }\n    else if (word.length()\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9y3pr4wa.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp9y3pr4wa.cpp:43:27: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   43 |     else if (word.length()\n      |             ~           \
    \  ^\n      |                           )\n   44 | }\n      | ~              \
    \            \n/tmp/tmp9y3pr4wa.cpp:44:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   44 | }\n      | ^\n/tmp/tmp9y3pr4wa.cpp:45:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   45\
    \ | int main() {\n      |            ^\n/tmp/tmp9y3pr4wa.cpp:54:1: error: expected\
    \ \u2018}\u2019 at end of input\n   54 | }\n      | ^\n/tmp/tmp9y3pr4wa.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp9y3pr4wa.cpp:54:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   54 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream iss(sentence);\n    std::string word;\n    while (iss\
    \ >> word) {\n        words.push_back(word);\n    }\n    std::string result;\n\
    \    for (const auto& w : words) {\n        int count = 0;\n        for (int i\
    \ = 1; i <= w.size(); ++i) {\n            if (w.size() % i == 0) {\n         \
    \       ++count;\n            }\n        }\n        if (count == 2) {\n      \
    \      result += w + \" \";\n        }\n    }\n    return result.substr(0, result.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  auto words = sentence.substr(0,\
    \ sentence.find_last_not_of(' ') + 1);\n  std::string ret = \"\";\n  std::stringstream\
    \ ss(words);\n  while(ss >> words) {\n    if (words.size() > 2 &&\n        ((words.size()\
    \ % 2 == 1) ||\n         (words.size() == 2) ||\n         (words.size() % 6 ==\
    \ 0) ||\n         (words.size() % 4 == 0) ||\n         (words.size() % 10 == 0)))\
    \ {\n      ret += words + \" \";\n    }\n  }\n  return ret.substr(0, ret.find_last_not_of('\
    \ ') + 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpa21z57hz: /tmp/tmpa21z57hz.cpp:35: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.size();\n  \
    \  std::string result;\n    std::string temp;\n    std::vector<int> len;\n   \
    \ std::vector<std::string> arr;\n    // Find the index of space character in sentence\
    \ and store in vector, push_back the number of spaces\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            arr.push_back(temp);\n\
    \            len.push_back(temp.size());\n            temp.clear();\n        }\
    \ else {\n            temp += sentence[i];\n        }\n    }\n    // Handle the\
    \ last word in sentence, if the sentence has no space, then the word with size\
    \ 1 is prime\n    // Otherwise, push_back the size of the last word\n    if (sentence[n\
    \ - 1] != ' ') {\n        arr.push_back(temp);\n        len.push_back(temp.size());\n\
    \    } else {\n        len.push_back(1);\n    }\n    // Handle the case that sentence\
    \ is empty\n    if (arr.size() == 0) {\n        return result;\n    }\n    //\
    \ Loop over the length vector, if the number is prime number, append the word\
    \ to result\n    for (int i = 0; i < len.size(); i++) {\n        bool prime =\
    \ true;\n        for (int j = 2; j <= std::sqrt(len[i]); j++) {\n            if\
    \ (len[i] % j == 0) {\n                prime = false;\n                break;\n\
    \            }\n        }\n        if (prime) {\n            result += arr[i];\n\
    \            if (i != len.size() - 1) {\n                result += ' ';\n    \
    \        }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpiioznlvj: /tmp/tmpiioznlvj.cpp:65: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> result_vector;\n\
    \    std::string result = \"\";\n    std::vector<std::string> vec;\n    std::stringstream\
    \ ss(sentence);\n    std::string buffer;\n    while (ss >> buffer) {\n       \
    \ vec.push_back(buffer);\n    }\n    std::vector<int> vec_int;\n    std::vector<int>\
    \ vec_primes;\n    int count;\n    for (int i = 2; i <= 100; i++) {\n        count\
    \ = 0;\n        for (int j = 2; j <= i/2; j++) {\n            if (i % j == 0)\
    \ {\n                count++;\n                break;\n            }\n       \
    \ }\n        if (count == 0) {\n            vec_primes.push_back(i);\n       \
    \ }\n    }\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0;\
    \ j < vec_primes.size(); j++) {\n            if (vec[i].length() == vec_primes[j])\
    \ {\n                result_vector.push_back(vec[i]);\n            }\n       \
    \ }\n    }\n    for (int i = 0; i < result_vector.size(); i++) {\n        result\
    \ += result_vector[i] + \" \";\n    }\n    if (result.back() == ' ') {\n     \
    \   result.pop_back();\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream words(sentence);\n\
    \    std::vector<std::string> word_vector;\n    std::copy(std::istream_iterator<std::string>(words),\n\
    \              std::istream_iterator<std::string>(),\n              std::back_inserter(word_vector));\n\
    \    std::vector<std::string> prime_vector;\n    std::copy_if(word_vector.begin(),\
    \ word_vector.end(),\n                 std::back_inserter(prime_vector),\n   \
    \              [](const std::string& word) -> bool {\n                     const\
    \ size_t len = word.length();\n                     switch (len) {\n         \
    \            case 1:\n                     case 2:\n                         return\
    \ true;\n                     default:\n                         for (size_t i\
    \ = 2; i < len; ++i) {\n                             if (len % i == 0) {\n   \
    \                              return false;\n                             }\n\
    \                         }\n                         return true;\n         \
    \            }\n                 });\n    return std::accumulate(prime_vector.begin(),\
    \ prime_vector.end(),\n                           std::string(\"\"),\n       \
    \                    [](const std::string& lhs, const std::string& rhs) -> std::string\
    \ {\n                               return lhs.empty() ? rhs : lhs + \" \" + rhs;\n\
    \                           });\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp3pu4g_xd: /tmp/tmp3pu4g_xd.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    auto is_prime = [](int v) ->\
    \ bool {\n        if (v == 2) {\n            return true;\n        }\n       \
    \ if (v < 2 || v % 2 == 0) {\n            return false;\n        }\n        for\
    \ (int i = 3; i <= std::sqrt(v); i += 2) {\n            if (v % i == 0) {\n  \
    \              return false;\n            }\n        }\n        return true;\n\
    \    };\n    std::string result{};\n    std::stringstream ss{sentence};\n    std::string\
    \ word{};\n    while (ss >> word) {\n        if (is_prime(word.size())) {\n  \
    \          result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4t_qs7mb: /tmp/tmp4t_qs7mb.cpp:50: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    const std::unordered_set<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97, 101};\n    while (ss >> word) {\n        if (primes.count(word.size()))\
    \ {\n            result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpf5its79_: /tmp/tmpf5its79_.cpp:37: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ < 2) {\n      continue;\n    }\n    int i{2};\n    for (; i < word.size(); ++i)\
    \ {\n      if (word.size() % i == 0) {\n        break;\n      }\n    }\n    if\
    \ (i == word.size()) {\n      result += word + \" \";\n    }\n  }\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpmly4h9ax: /tmp/tmpmly4h9ax.cpp:45: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    auto is_prime = [](const int\
    \ num) {\n        if (num < 2) return false;\n        for (int i = 2; i <= sqrt(num);\
    \ ++i) {\n            if (num % i == 0) return false;\n        }\n        return\
    \ true;\n    };\n    std::string result;\n    std::istringstream iss(sentence);\n\
    \    std::string word;\n    while (std::getline(iss, word, ' ')) {\n        if\
    \ (is_prime(word.size())) {\n            result += word + ' ';\n        }\n  \
    \  }\n    if (!result.empty()) result.pop_back();\n    return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // TODO: Your code here\n  std::stringstream\
    \ ss(sentence);\n  std::string temp;\n  std::string ans = \"\";\n  while(std::getline(ss,\
    \ temp, ' ')) {\n    if(is_prime(temp.length())) {\n      ans = ans + temp + \"\
    \ \";\n    }\n  }\n  if(ans.length() > 0) {\n    ans.pop_back();\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprfneqsey.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprfneqsey.cpp:23:8: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |     if(is_prime(temp.length())) {\n      |        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // TODO: Implement\n  // todo:\
    \ consider memory limits\n  std::string result = \"\";\n  std::stringstream ss(sentence);\n\
    \  std::string current;\n  while (ss >> current) {\n    if (current.length() ==\
    \ 2 || current.length() == 3 || current.length() == 5 || current.length() == 7)\
    \ {\n      result += \" \" + current;\n    }\n  }\n  return result.substr(1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 1) > this->size() (which is 0)\n"
  stdout: ''
  timestamp: 1660098981
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream iss(sentence);\n    std::copy(std::istream_iterator<std::string>(iss),\n\
    \              std::istream_iterator<std::string>(),\n              std::back_inserter(words));\n\
    \    std::ostringstream oss;\n    for (int i = 0; i < words.size(); ++i) {\n \
    \       bool is_prime = true;\n        if (words[i].size() > 1) {\n          \
    \  for (int j = 2; j < words[i].size(); ++j) {\n                if (words[i].size()\
    \ % j == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n        }\n        if (is_prime) {\n      \
    \      oss << words[i] << \" \";\n        }\n    }\n    return oss.str();\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpyucwwqwh: /tmp/tmpyucwwqwh.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string>  words\
    \ = split(sentence, ' ');\n  std::vector<std::string>  primes;\n  for (int i =\
    \ 0; i < words.size(); i++) {\n    int l = words[i].length();\n    if (is_prime(l))\
    \ {\n      primes.push_back(words[i]);\n    }\n  }\n  return join(primes, ' ');\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpajcm34jv.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpajcm34jv.cpp:18:37: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |   std::vector<std::string>  words = split(sentence, ' ');\n \
    \     |                                     ^~~~~\n/tmp/tmpajcm34jv.cpp:22:9:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   22 |     if (is_prime(l))\
    \ {\n      |         ^~~~~~~~\n/tmp/tmpajcm34jv.cpp:26:10: error: \u2018join\u2019\
    \ was not declared in this scope; did you mean \u2018jn\u2019?\n   26 |   return\
    \ join(primes, ' ');\n      |          ^~~~\n      |          jn\n"
  stdout: ''
  timestamp: 1660098980
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // return std::string(1, sentence[0]);\n\
    \    // return std::string(1, sentence[1]);\n    // return std::string(1, sentence[2]);\n\
    \    // return std::string(1, sentence[3]);\n    // return std::string(1, sentence[4]);\n\
    \    // return std::string(1, sentence[5]);\n    // return std::string(1, sentence[6]);\n\
    \    // return std::string(1, sentence[7]);\n    // return std::string(1, sentence[8]);\n\
    \    // return std::string(1, sentence[9]);\n    // return std::string(1, sentence[10]);\n\
    \    // return std::string(1, sentence[11]);\n    // return std::string(1, sentence[12]);\n\
    \    // return std::string(1, sentence[13]);\n    // return std::string(1, sentence[14]);\n\
    \    // return std::string(1, sentence[15]);\n    // return std::string(1, sentence[16]);\n\
    \    // return std::string(1, sentence[17]);\n    // return std::string(1, sentence[18]);\n\
    \    // return std::string(1, sentence[19]);\n    // return std::string(1, sentence[20]);\n\
    \    // return std::string(1, sentence[21]);\n    // return std::string(1, sentence[22]);\n\
    \    // return std::string(1, sentence[23]);\n    // return std::string(1, sentence[24]);\n\
    \    // return std::string(1, sentence[25]);\n    // return std::string(1, sentence[26]);\n\
    \    // return std::string(1, sentence[27]);\n    // return std::string(1, sentence[28]);\n\
    \    // return std::string(1, sentence[29]);\n    // return std::string(1, sentence[30]);\n\
    \    // return std::string(1, sentence[31]);\n    // return std::string(1, sentence[32]);\n\
    \    // return std::string(1, sentence[33]);\n    // return std::string(1, sentence[34]);\n\
    \    // return std::string(1, sentence[35]);\n    // return std::string(\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098981
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> answer;\n\
    \  std::string word = \"\";\n  for (int i = 0; i < sentence.size(); i++) {\n \
    \   if (sentence[i] == ' ') {\n      if (is_prime(word.size())) {\n        answer.push_back(word);\n\
    \      }\n      word = \"\";\n    } else {\n      word += sentence[i];\n    }\n\
    \  }\n  if (is_prime(word.size())) {\n    answer.push_back(word);\n  }\n  std::string\
    \ output = \"\";\n  for (int i = 0; i < answer.size(); i++) {\n    output += answer[i];\n\
    \    if (i != answer.size() - 1) {\n      output += \" \";\n    }\n  }\n  return\
    \ output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd7u1_5sb.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpd7u1_5sb.cpp:22:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |       if (is_prime(word.size())) {\n      |           ^~~~~~~~\n\
    /tmp/tmpd7u1_5sb.cpp:30:7: error: \u2018is_prime\u2019 was not declared in this\
    \ scope\n   30 |   if (is_prime(word.size())) {\n      |       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string prime_words;\n    std::vector<std::string>\
    \ prime_words_list;\n    while (ss >> word) {\n        if (word.length() > 1)\
    \ {\n            if (word.length() == 2) {\n                prime_words_list.push_back(word);\n\
    \            } else {\n                bool is_prime = true;\n               \
    \ for (int i = 2; i < word.length(); i++) {\n                    if (word.length()\
    \ % i == 0) {\n                        is_prime = false;\n                   \
    \     break;\n                    }\n                }\n                if (is_prime)\
    \ {\n                    prime_words_list.push_back(word);\n                }\n\
    \            }\n        }\n    }\n    for (auto w : prime_words_list) {\n    \
    \    prime_words += w + \" \";\n    }\n    if (prime_words.length() > 0) {\n \
    \       prime_words.pop_back();\n    }\n    return prime_words;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (int i = 0; i < sentence.size(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            words.push_back(word);\n         \
    \   word = \"\";\n        } else {\n            word += sentence[i];\n       \
    \ }\n    }\n    words.push_back(word);\n    std::string ret;\n    for (auto &word\
    \ : words) {\n        if (word.size() == 1) {\n            ret += word + \" \"\
    ;\n        } else {\n            bool is_prime = true;\n            for (int i\
    \ = 2; i < word.size(); i++) {\n                if (word.size() % i == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n            if (is_prime) {\n                ret +=\
    \ word + \" \";\n            }\n        }\n    }\n    return ret.substr(0, ret.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2630gpzj: /tmp/tmp2630gpzj.cpp:50: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> original_words\
    \ = std::vector<std::string>();\n  std::vector<std::string> primes = std::vector<std::string>();\n\
    \  std::string word = \"\";\n  int i = 0;\n  while (i < sentence.size()) {\n \
    \   if (sentence[i] == ' ') {\n      original_words.push_back(word);\n      word\
    \ = \"\";\n    } else {\n      word += sentence[i];\n    }\n    i++;\n  }\n  original_words.push_back(word);\n\
    \  for (auto &x : original_words) {\n    if (x.size() > 1) {\n      bool prime\
    \ = true;\n      for (int i = 2; i <= x.size() / 2; i++) {\n        if (x.size()\
    \ % i == 0) {\n          prime = false;\n          break;\n        }\n      }\n\
    \      if (prime) {\n        primes.push_back(x);\n      }\n    }\n  }\n  return\
    \ std::accumulate(primes.begin(), primes.end(), std::string(\"\"),\n         \
    \                [](std::string &s, std::string &word) {\n                   \
    \        if (s.size() == 0) {\n                             return word;\n   \
    \                        } else {\n                             return s + \"\
    \ \" + word;\n                           }\n                         });\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098983
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string prime_words_sentence{};\n\
    \    std::string word{};\n    int word_size{};\n    for (char c : sentence) {\n\
    \        if (c == ' ') {\n            if (word_size > 1 && is_prime(word_size))\
    \ {\n                prime_words_sentence += (word + ' ');\n            }\n  \
    \          word.clear();\n            word_size = 0;\n        } else {\n     \
    \       word += c;\n            ++word_size;\n        }\n    }\n    if (word_size\
    \ > 1 && is_prime(word_size)) {\n        prime_words_sentence += word;\n    }\n\
    \    return prime_words_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwy8inhq9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwy8inhq9.cpp:23:34: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |             if (word_size > 1 && is_prime(word_size)) {\n\
    \      |                                  ^~~~~~~~\n/tmp/tmpwy8inhq9.cpp:33:26:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   33 |     if (word_size\
    \ > 1 && is_prime(word_size)) {\n      |                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098982
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::string\
    \ word;\n  std::stringstream sstream(sentence);\n  while (sstream >> word) {\n\
    \    if (word.size() > 1 && is_prime(word.size())) {\n      result += word + \"\
    \ \";\n    }\n  }\n  if (!result.empty()) {\n    result.pop_back();\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2qed0wcp.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2qed0wcp.cpp:22:28: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |     if (word.size() > 1 && is_prime(word.size())) {\n  \
    \    |                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098982
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string w;\n  std::vector<std::string> v;\n  bool is_prime[100] = {false};\n\
    \  for (int i = 2; i < 100; ++i) {\n    for (int j = 2; j < i; ++j) {\n      if\
    \ (i % j == 0) {\n        is_prime[i] = true;\n        break;\n      }\n    }\n\
    \  }\n  while (ss >> w) {\n    if (!is_prime[w.size()]) {\n      v.push_back(w);\n\
    \    }\n  }\n  return std::accumulate(v.begin(), v.end(), std::string(\"\"),\n\
    \                         [](std::string a, std::string b) {\n               \
    \            return a.size() ? a + \" \" + b : b;\n                         });\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpd0k9074a: /tmp/tmpd0k9074a.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    words.push_back(word);\n  }\n  std::string result;\n  for (const auto&\
    \ word : words) {\n    int word_length = word.length();\n    bool is_prime = true;\n\
    \    if (word_length <= 1) {\n      is_prime = false;\n    }\n    if (word_length\
    \ > 2) {\n      for (int i = 2; i <= word_length / 2; ++i) {\n        if (word_length\
    \ % i == 0) {\n          is_prime = false;\n          break;\n        }\n    \
    \  }\n    }\n    if (is_prime) {\n      result += word + \" \";\n    }\n  }\n\
    \  if (!result.empty()) {\n    result.pop_back();\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result = \"\";\n  int\
    \ i = 0;\n  while (i < sentence.size()) {\n    int space_idx = sentence.find(\"\
    \ \", i);\n    std::string word = sentence.substr(i, space_idx-i);\n    if (space_idx\
    \ == std::string::npos) {\n      word = sentence.substr(i);\n    }\n    if (word.size()\
    \ > 1 && word.size() < 10) {\n      bool is_prime = true;\n      for (int j =\
    \ 2; j < word.size(); ++j) {\n        if (word.size() % j == 0) {\n          is_prime\
    \ = false;\n          break;\n        }\n      }\n      if (is_prime) {\n    \
    \    result += word + \" \";\n      }\n    }\n    if (space_idx == std::string::npos)\
    \ {\n      break;\n    }\n    i = space_idx + 1;\n  }\n  return result.substr(0,\
    \ result.size()-1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.size() <= 100);\n\
    \    std::vector<std::string> words;\n    std::string current_word;\n    for (const\
    \ auto c : sentence) {\n        if (c == ' ') {\n            words.push_back(current_word);\n\
    \            current_word.clear();\n        } else {\n            current_word.push_back(c);\n\
    \        }\n    }\n    words.push_back(current_word);\n    std::stringstream ret;\n\
    \    for (const auto& word : words) {\n        if (word.size() > 1 && word.size()\
    \ % 2 == 1) {\n            bool is_prime = true;\n            for (int i = 3;\
    \ i <= std::sqrt(word.size()); i += 2) {\n                if (word.size() % i\
    \ == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   ret << word << \" \";\n            }\n        }\n    }\n    return ret.str();\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmplid8q3dx: /tmp/tmplid8q3dx.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // TODO: Your code here.\n  std::string\
    \ output = \"\";\n  std::vector<std::string> words;\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  while (std::getline(ss, word, ' '))\n  {\n    words.push_back(word);\n\
    \  }\n  for (int i = 0; i < words.size(); i++)\n  {\n    if (words[i].length()\
    \ > 1)\n    {\n      if (words[i].length() == 2)\n      {\n        output += words[i]\
    \ + \" \";\n      }\n      else\n      {\n        bool isPrime = true;\n     \
    \   for (int j = 2; j < words[i].length(); j++)\n        {\n          if (words[i].length()\
    \ % j == 0)\n          {\n            isPrime = false;\n            break;\n \
    \         }\n        }\n        if (isPrime)\n        {\n          output += words[i]\
    \ + \" \";\n        }\n      }\n    }\n  }\n  output.pop_back();\n  return output;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpqj6lawni: /tmp/tmpqj6lawni.cpp:63: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss;\n    ss.str(sentence);\n    std::string word;\n    while (ss >> word) {\n\
    \        auto len = word.length();\n        bool is_prime = true;\n        for\
    \ (int i = 2; i <= std::sqrt(len); ++i) {\n            if (len % i == 0) {\n \
    \               is_prime = false;\n                break;\n            }\n   \
    \     }\n        if (is_prime) {\n            result += word + \" \";\n      \
    \  }\n    }\n    if (!result.empty()) {\n        result.pop_back();\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpff9dftj7: /tmp/tmpff9dftj7.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::istringstream iss(sentence);\n\
    \  std::vector<std::string> words{std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{}};\n\
    \  std::string s;\n  for (const auto &word : words) {\n    if (word.size() > 1)\
    \ {\n      bool prime = true;\n      for (int divisor = 2; divisor < word.size();\
    \ ++divisor) {\n        if (word.size() % divisor == 0) {\n          prime = false;\n\
    \          break;\n        }\n      }\n      if (prime) {\n        s += word +\
    \ \" \";\n      }\n    }\n  }\n  if (!s.empty()) {\n    s.pop_back();\n  }\n \
    \ return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    int len = sentence.length();\n    if (len == 0) {\n        return result;\n\
    \    }\n    int i = 0;\n    int j = 0;\n    while (j < len) {\n        if (sentence[j]\
    \ == ' ') {\n            int dist = j - i;\n            bool prime = true;\n \
    \           for (int k = 2; k < dist / 2; ++k) {\n                if (dist % k\
    \ == 0) {\n                    prime = false;\n                    break;\n  \
    \              }\n            }\n            if (prime) {\n                result\
    \ += sentence.substr(i, dist);\n                result += \" \";\n           \
    \ }\n            i = j + 1;\n        }\n        ++j;\n    }\n    int dist = j\
    \ - i;\n    bool prime = true;\n    for (int k = 2; k < dist / 2; ++k) {\n   \
    \     if (dist % k == 0) {\n            prime = false;\n            break;\n \
    \       }\n    }\n    if (prime) {\n        result += sentence.substr(i, dist);\n\
    \    }\n    if (result[result.length() - 1] == ' ') {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp22ihqkid: /tmp/tmp22ihqkid.cpp:61: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string token;\n  while (getline(ss, token, ' ')) {\n \
    \   if (token.size() > 1 && token.size() < 100) {\n      bool prime = true;\n\
    \      for (int i = 2; i <= token.size() / 2; ++i) {\n        if (token.size()\
    \ % i == 0) {\n          prime = false;\n          break;\n        }\n      }\n\
    \      if (prime) {\n        result += token + \" \";\n      }\n    }\n  }\n \
    \ if (!result.empty()) {\n    result.pop_back();\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream s(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (s >> word)\
    \ {\n        int len = word.length();\n        bool prime = true;\n        for\
    \ (int i = 2; i < len; ++i) {\n            if (len % i == 0) {\n             \
    \   prime = false;\n                break;\n            }\n        }\n       \
    \ if (prime) {\n            words.push_back(word);\n        }\n    }\n    std::string\
    \ result;\n    for (int i = 0; i < words.size(); ++i) {\n        result += words[i];\n\
    \        if (i != words.size() - 1) {\n            result += \" \";\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpla_rd6ox: /tmp/tmpla_rd6ox.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    //    std::transform(sentence.begin(),\
    \ sentence.end(), sentence.begin(), ::tolower);\n    if (sentence.size() == 0)\
    \ {\n        return \"\";\n    }\n    std::vector<std::string> word_list;\n  \
    \  std::string word;\n    for (auto it = sentence.begin(); it != sentence.end();\
    \ ++it) {\n        if (*it == ' ') {\n            word_list.push_back(word);\n\
    \            word.clear();\n        } else {\n            word.push_back(*it);\n\
    \        }\n    }\n    word_list.push_back(word);\n    std::vector<std::string>\
    \ result;\n    for (auto &word : word_list) {\n        if (word.size() == 1) {\n\
    \            result.push_back(word);\n        } else {\n            for (int i\
    \ = 2; i < word.size(); ++i) {\n                if (word.size() % i == 0) {\n\
    \                    break;\n                }\n                if (i == word.size()\
    \ - 1) {\n                    result.push_back(word);\n                }\n   \
    \         }\n        }\n    }\n    if (result.size() == 0) {\n        return \"\
    \";\n    }\n    std::string ret(result[0]);\n    for (int i = 1; i < result.size();\
    \ ++i) {\n        ret += \" \" + result[i];\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpy5cpt6ui: /tmp/tmpy5cpt6ui.cpp:59: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.size() <= 100);\n\
    \    std::string res;\n    std::string word;\n    std::stringstream iss(sentence);\n\
    \    while (iss >> word) {\n        // check word is length of prime\n       \
    \ int word_len = word.size();\n        bool is_prime = true;\n        for (int\
    \ i = 2; i <= sqrt(word_len); ++i) {\n            if (word_len % i == 0) {\n \
    \               is_prime = false;\n                break;\n            }\n   \
    \     }\n        if (is_prime) {\n            res += word + \" \";\n        }\n\
    \    }\n    return res.substr(0, res.size() - 1);\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmprh54au35: /tmp/tmprh54au35.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string w;\n    std::vector<std::string> v;\n    while (ss >> w) {\n\
    \        bool is_prime = true;\n        for (int i = 2; i <= w.size() / 2; ++i)\
    \ {\n            if (w.size() % i == 0) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (is_prime) {\n \
    \           v.push_back(w);\n        }\n    }\n    sentence = v[0];\n    for (int\
    \ i = 1; i < v.size(); ++i) {\n        sentence += \" \" + v[i];\n    }\n    return\
    \ sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_2385wsw: /tmp/tmp_2385wsw.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    std::stringstream ss(sentence);\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> lengths;\n\
    \    int size = words.size();\n    for (int i = 0; i < size; ++i) {\n        lengths.push_back(words[i].size());\n\
    \    }\n    std::vector<int> primes;\n    primes.push_back(2);\n    for (int i\
    \ = 3; i < 1000; i += 2) {\n        bool is_prime = true;\n        for (int j\
    \ = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n    \
    \            is_prime = false;\n                break;\n            }\n      \
    \  }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n \
    \   }\n    std::string result;\n    for (int i = 0; i < size; ++i) {\n       \
    \ for (int j = 0; j < primes.size(); ++j) {\n            if (lengths[i] == primes[j])\
    \ {\n                result += words[i] + \" \";\n                break;\n   \
    \         }\n        }\n    }\n    result.pop_back();\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxsg26im4: /tmp/tmpxsg26im4.cpp:62: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Variables to store the result.\n\
    \    std::string result = \"\";\n    std::string aux_word = \"\";\n    bool first_word\
    \ = true;\n    // Split the sentence and obtain the words.\n    for (int i = 0;\
    \ i < sentence.size(); i++) {\n        if (sentence[i] == ' ') {\n           \
    \ // Check if word length is prime and add it to the result.\n            if (is_prime(aux_word.size()))\
    \ {\n                if (first_word) {\n                    result += aux_word;\n\
    \                    first_word = false;\n                } else {\n         \
    \           result += \" \" + aux_word;\n                }\n            }\n  \
    \          aux_word = \"\";\n        } else {\n            aux_word += sentence[i];\n\
    \        }\n    }\n    // Check if word length is prime and add it to the result.\n\
    \    if (is_prime(aux_word.size())) {\n        if (first_word) {\n           \
    \ result += aux_word;\n            first_word = false;\n        } else {\n   \
    \         result += \" \" + aux_word;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx8flc20s.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpx8flc20s.cpp:26:17: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   26 |             if (is_prime(aux_word.size())) {\n      |  \
    \               ^~~~~~~~\n/tmp/tmpx8flc20s.cpp:40:9: error: \u2018is_prime\u2019\
    \ was not declared in this scope\n   40 |     if (is_prime(aux_word.size())) {\n\
    \      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> result;\n\
    \  std::vector<std::string> words;\n  for (int i = 0; i < sentence.size(); ++i)\
    \ {\n    std::string word;\n    while (i < sentence.size() && sentence[i] != '\
    \ ') {\n      word += sentence[i];\n      ++i;\n    }\n    words.push_back(word);\n\
    \  }\n  for (auto word : words) {\n    int size = word.size();\n    if (size ==\
    \ 2 || size == 3 || size == 5 || size == 7 || size == 11 || size == 13 || size\
    \ == 17 || size == 19) {\n      result.push_back(word);\n    }\n  }\n  std::string\
    \ sentence_with_prime_words;\n  for (auto word : result) {\n    sentence_with_prime_words\
    \ += word + \" \";\n  }\n  return sentence_with_prime_words;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp5mdxjq55: /tmp/tmp5mdxjq55.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    // Since the words are separated by a space,\n    // the string can be treated\
    \ as an array of strings and iterated through by use of std::getline()\n    std::istringstream\
    \ iss(sentence);\n    // The words from the sentence\n    std::string word;\n\
    \    // A boolean to check if the current word is a prime number\n    bool prime;\n\
    \    // Iterate through the sentence\n    while (std::getline(iss, word, ' '))\
    \ {\n        // Set prime to true initially\n        prime = true;\n        //\
    \ If the current word length is 1 or 0, skip it\n        if (word.length() < 2)\
    \ {\n            continue;\n        }\n        // Iterate through the word and\
    \ check if the current word length is a prime number\n        for (int i = 2;\
    \ i <= word.length() / 2; i++) {\n            if (word.length() % i == 0) {\n\
    \                prime = false;\n                break;\n            }\n     \
    \   }\n        // If the current word length is a prime number\n        if (prime)\
    \ {\n            // If the result is not empty, add a space\n            if (!result.empty())\
    \ {\n                result += \" \";\n            }\n            // Add the current\
    \ word to the result\n            result += word;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    if (word.size()\
    \ >= 2) {\n      if (word.size() == 2) {\n        result += word + \" \";\n  \
    \    } else {\n        if (word.size() % 2 == 0) {\n          continue;\n    \
    \    }\n        int num = word.size();\n        for (int i = 3; i <= sqrt(num);\
    \ i += 2) {\n          if (num % i == 0) {\n            continue;\n          }\n\
    \        }\n        result += word + \" \";\n      }\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2x520a6b: /tmp/tmp2x520a6b.cpp:43: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::vector<int>\
    \ len;\n  int start = 0;\n  for (int i = 0; i < sentence.size(); i++) {\n    if\
    \ (sentence[i] == ' ') {\n      len.push_back(i - start);\n      start = i + 1;\n\
    \    }\n  }\n  len.push_back(sentence.size() - start);\n  std::vector<int> primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97};\n  for (int i = 0; i < len.size(); i++) {\n    for (int\
    \ j = 0; j < primes.size(); j++) {\n      if (len[i] == primes[j]) {\n       \
    \ for (int k = 0; k < len[i]; k++) {\n          result += sentence[start + k];\n\
    \        }\n        if (i != len.size() - 1) {\n          result += ' ';\n   \
    \     }\n        break;\n      }\n    }\n    start += len[i] + 1;\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpzxdbiedg: /tmp/tmpzxdbiedg.cpp:47: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    //in case the sentence is empty\n\
    \    if(sentence.size()==0)\n        return \"\";\n    //split the string into\
    \ words\n    std::stringstream iss(sentence);\n    std::vector<std::string> words{std::istream_iterator<std::string>{iss},\n\
    \                                   std::istream_iterator<std::string>{}};\n \
    \   std::vector<std::string> prime_words;\n    //push the word in vector if its\
    \ length is prime\n    for(auto word:words){\n        int count = 0;\n       \
    \ for(int i=1;i<=word.size();i++){\n            if(word.size()%i==0)\n       \
    \         count++;\n        }\n        if(count==2)\n            prime_words.push_back(word);\n\
    \    }\n    //convert the vector into string\n    std::string result;\n    for(auto\
    \ word:prime_words)\n        result += word + \" \";\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpiaubv0_s: /tmp/tmpiaubv0_s.cpp:50: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.size();\n  \
    \  assert(n > 0);\n    std::vector<std::string> words;\n    int i = 0;\n    while\
    \ (i < n) {\n        int j = i;\n        while (j < n && sentence[j] != ' ') ++j;\n\
    \        std::string w = sentence.substr(i, j - i);\n        i = j + 1;\n    \
    \    words.push_back(w);\n    }\n    std::vector<std::string> res;\n    for (const\
    \ auto& w : words) {\n        int len = w.size();\n        if (len == 1) {\n \
    \           res.push_back(w);\n            continue;\n        }\n        bool\
    \ is_prime = true;\n        for (int i = 2; i < len; ++i) {\n            if (len\
    \ % i == 0) {\n                is_prime = false;\n                break;\n   \
    \         }\n        }\n        if (is_prime) res.push_back(w);\n    }\n    return\
    \ std::accumulate(std::begin(res), std::end(res), std::string(),\n        [](std::string\
    \ acc, std::string x) { return acc + x + \" \"; }\n    );\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpjorec5fp: /tmp/tmpjorec5fp.cpp:51: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream stream{sentence};\n\
    \    std::string word;\n    std::ostringstream stream_out;\n    const std::unordered_set<int>\
    \ prime_numbers {\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101\n    };\n    while (stream >>\
    \ word) {\n        if (prime_numbers.count(word.size())) {\n            stream_out\
    \ << word << \" \";\n        }\n    }\n    std::string s = stream_out.str();\n\
    \    s.pop_back();\n    return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp9s77gu07: /tmp/tmp9s77gu07.cpp:40: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int len = sentence.length();\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < len; i++) {\n        std::string\
    \ temp = \"\";\n        while (sentence[i] != ' ' && i < len) {\n            temp\
    \ += sentence[i];\n            i++;\n        }\n        if (isPrime(temp.length()))\
    \ {\n            ans += temp + \" \";\n        }\n    }\n    if (ans.size() >\
    \ 0) {\n        ans.pop_back();\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptwj7639w.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptwj7639w.cpp:26:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   26 |         if (isPrime(temp.length())) {\n      |         \
    \    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int count = 0;\n  std::string result\
    \ = \"\";\n  for (int i = 0; i < sentence.length(); i++) {\n    if (sentence[i]\
    \ == ' ') {\n      if (std::is_prime(count)) {\n        result += (result.length()\
    \ > 0 ? \" \" : \"\") + sentence.substr(i - count, count);\n      }\n      count\
    \ = 0;\n    } else {\n      count++;\n    }\n  }\n  if (std::is_prime(count))\
    \ {\n    result += (result.length() > 0 ? \" \" : \"\") + sentence.substr(sentence.length()\
    \ - count, count);\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_axwcn52.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_axwcn52.cpp:22:16: error: \u2018is_prime\u2019 is not a member of\
    \ \u2018std\u2019\n   22 |       if (std::is_prime(count)) {\n      |        \
    \        ^~~~~~~~\n/tmp/tmp_axwcn52.cpp:30:12: error: \u2018is_prime\u2019 is\
    \ not a member of \u2018std\u2019\n   30 |   if (std::is_prime(count)) {\n   \
    \   |            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // \\todo: implement your solution\
    \ here\n  std::string final_string;\n  std::stringstream ss(sentence);\n  std::string\
    \ temp;\n  while(ss >> temp) {\n    std::cout << temp << std::endl;\n    int len\
    \ = temp.length();\n    int prime = 0;\n    for(int i = 2; i <= len/2; i++) {\n\
    \      if(len % i == 0) {\n        prime = 1;\n        break;\n      }\n    }\n\
    \    if(prime == 0) {\n      final_string = final_string + temp + \" \";\n   \
    \ }\n  }\n  return final_string;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp9u2edmja: /tmp/tmp9u2edmja.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: 'This

    is

    a

    test

    '
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream sin(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (sin >>\
    \ word) {\n        words.push_back(word);\n    }\n    bool is_prime[100];\n  \
    \  for (int i = 0; i < 100; ++i) {\n        is_prime[i] = true;\n    }\n    for\
    \ (int i = 2; i < 100; ++i) {\n        if (is_prime[i]) {\n            for (int\
    \ j = i * i; j < 100; j += i) {\n                is_prime[j] = false;\n      \
    \      }\n        }\n    }\n    std::string result;\n    for (int i = 0; i < words.size();\
    \ ++i) {\n        int len = words[i].size();\n        if (is_prime[len]) {\n \
    \           result += words[i];\n            result += \" \";\n        }\n   \
    \ }\n    if (result.size() > 0) {\n        result.pop_back();\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4ks3602h: /tmp/tmp4ks3602h.cpp:50: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    bool is_prime(int n) {\n    \
    \    // '3' is the first prime and hence the base case\n        if (n < 3) return\
    \ n == 2;\n        // if the number is not even and can be divided by an odd number,\
    \ it's not prime\n        for (int i = 3; i * i <= n; i += 2)\n            if\
    \ (n % i == 0) return false;\n        return true;\n    }\n    std::string res;\n\
    \    std::stringstream ss;\n    ss << sentence;\n    std::string temp;\n    while\
    \ (getline(ss, temp, ' ')) {\n        if (is_prime(temp.size())) {\n         \
    \   res += temp + ' ';\n        }\n    }\n    return res.substr(0, res.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2ucep7qi.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2ucep7qi.cpp:18:26: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   18 |     bool is_prime(int n) {\n      |    \
    \                      ^\n/tmp/tmp2ucep7qi.cpp:31:13: error: \u2018is_prime\u2019\
    \ was not declared in this scope\n   31 |         if (is_prime(temp.size())) {\n\
    \      |             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // parse each word in sentence\n\
    \    std::string word;\n    std::stringstream word_stream(sentence);\n    std::vector<std::string>\
    \ words;\n    while (word_stream >> word) {\n        words.push_back(word);\n\
    \    }\n    // find words that are prime lengths\n    std::string prime_length_words;\n\
    \    for (auto w: words) {\n        int len = w.length();\n        bool is_prime\
    \ = true;\n        if (len == 1) {\n            is_prime = false;\n        }\n\
    \        for (int i = 2; i <= len / 2; ++i) {\n            if (len % i == 0) {\n\
    \                is_prime = false;\n                break;\n            }\n  \
    \      }\n        if (is_prime) {\n            prime_length_words += w + \" \"\
    ;\n        }\n    }\n    // remove the last space in the string\n    prime_length_words.pop_back();\n\
    \    return prime_length_words;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpf9njhjxk: /tmp/tmpf9njhjxk.cpp:54: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::vector<std::string>\
    \ words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while\
    \ (ss >> word) {\n        words.push_back(word);\n    }\n    for (int i = 0; i\
    \ < words.size(); i++) {\n        if (words[i].size() == 1) {\n            result.append(words[i]\
    \ + \" \");\n        } else {\n            bool prime = true;\n            for\
    \ (int j = 2; j < words[i].size(); j++) {\n                if (words[i].size()\
    \ % j == 0) {\n                    prime = false;\n                    break;\n\
    \                }\n            }\n            if (prime) {\n                result.append(words[i]\
    \ + \" \");\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpol2xd9xu: /tmp/tmpol2xd9xu.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    auto token = [](const std::string&\
    \ str, const std::string& delimiters) {\n        std::vector<std::string> tokens;\n\
    \        size_t prev = 0, pos = 0;\n        do {\n            pos = str.find_first_of(delimiters,\
    \ prev);\n            if (pos == std::string::npos) {\n                pos = str.length();\n\
    \            }\n            std::string token = str.substr(prev, pos - prev);\n\
    \            if (!token.empty()) {\n                tokens.push_back(token);\n\
    \            }\n            prev = pos + 1;\n        } while (pos < str.length()\
    \ && prev < str.length());\n        return tokens;\n    };\n    std::vector<std::string>\
    \ tokens = token(sentence, \" \");\n    bool prime[tokens.size()] = {false};\n\
    \    for (size_t i = 0; i < tokens.size(); ++i) {\n        size_t len = tokens[i].length();\n\
    \        if (len == 2 || len == 3 || len == 5 || len == 7) {\n            prime[i]\
    \ = true;\n        }\n    }\n    std::string result;\n    for (size_t i = 0; i\
    \ < tokens.size(); ++i) {\n        if (prime[i]) {\n            result += tokens[i]\
    \ + \" \";\n        }\n    }\n    result.pop_back();\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmphh5du3ji: /tmp/tmphh5du3ji.cpp:58: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss;\n    ss\
    \ << sentence;\n    std::string word;\n    std::string result;\n    while (ss\
    \ >> word) {\n        if (word.size() <= 1) {\n            continue;\n       \
    \ }\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(word.size());\
    \ ++i) {\n            if (word.size() % i == 0) {\n                is_prime =\
    \ false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            result += word + \" \";\n        }\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    std::string current_word = \"\";\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (std::count(current_word.begin(),\
    \ current_word.end(), '1') == 1) {\n                result += current_word + \"\
    \ \";\n            }\n            current_word = \"\";\n        } else {\n   \
    \         current_word += sentence[i];\n        }\n    }\n    if (std::count(current_word.begin(),\
    \ current_word.end(), '1') == 1) {\n        result += current_word;\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpis2otezs: /tmp/tmpis2otezs.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::istringstream sin(sentence);\n  for (std::string token; sin >> token;)\
    \ {\n    words.push_back(token);\n  }\n  std::vector<std::string> primes;\n  for\
    \ (auto word : words) {\n    if (word.size() == 1 && word[0] != '0') {\n     \
    \ primes.push_back(word);\n    } else if (word.size() == 2 && word[0] != '0' &&\
    \ word[1] != '0') {\n      primes.push_back(word);\n    } else if (word.size()\
    \ == 3 && word[0] != '0' && word[1] != '0' && word[2] != '0') {\n      primes.push_back(word);\n\
    \    } else if (word.size() == 5 && word[0] != '0' && word[1] != '0' && word[2]\
    \ != '0' && word[3] != '0' && word[4] != '0') {\n      primes.push_back(word);\n\
    \    } else if (word.size() == 7 && word[0] != '0' && word[1] != '0' && word[2]\
    \ != '0' && word[3] != '0' && word[4] != '0' && word[5] != '0' && word[6] != '0')\
    \ {\n      primes.push_back(word);\n    }\n  }\n  std::string ret;\n  for (auto\
    \ prime : primes) {\n    ret += prime + \" \";\n  }\n  return ret.substr(0, ret.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp85536w4e: /tmp/tmp85536w4e.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (iss >> word) {\n \
    \       if (word.size() > 1) {\n            // We do not need to check 1, 2, or\
    \ 3\n            // because they will not be in a sentence\n            if (word.size()\
    \ % 2 == 0) {\n                continue;\n            }\n            // Check\
    \ if word.size() is divisible by\n            // any odd numbers between 3 and\
    \ the\n            // integer square root of word.size()\n            bool is_prime\
    \ = true;\n            for (int i = 3; i * i <= word.size(); i += 2) {\n     \
    \           if (word.size() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                result += word + \" \";\n            }\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpgxcbgf16: /tmp/tmpgxcbgf16.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::istringstream\
    \ iss(sentence);\n  std::string word;\n  while (iss >> word) {\n    if (word.size()\
    \ == 2) {\n      result += word + \" \";\n    } else if (word.size() == 3) {\n\
    \      result += word + \" \";\n    } else if (word.size() == 5) {\n      result\
    \ += word + \" \";\n    } else if (word.size() == 7) {\n      result += word +\
    \ \" \";\n    } else if (word.size() == 11) {\n      result += word + \" \";\n\
    \    } else if (word.size() == 13) {\n      result += word + \" \";\n    } else\
    \ if (word.size() == 17) {\n      result += word + \" \";\n    } else if (word.size()\
    \ == 19) {\n      result += word + \" \";\n    } else if (word.size() == 23) {\n\
    \      result += word + \" \";\n    } else if (word.size() == 29) {\n      result\
    \ += word + \" \";\n    } else if (word.size() == 31) {\n      result += word\
    \ + \" \";\n    } else if (word.size() == 37) {\n      result += word + \" \"\
    ;\n    } else if (word.size() == 41) {\n      result += word + \" \";\n    } else\
    \ if (word.size() == 43) {\n      result += word + \" \";\n    } else if (word.size()\
    \ == 47) {\n      result += word + \" \";\n    } else if (word.size() == 53) {\n\
    \      result += word + \" \";\n    } else if (word.size() == 59) {\n      result\
    \ += word + \" \";\n    } else if (word.size() == 61) {\n      result += word\
    \ + \" \";\n    } else if (word.size() == 67) {\n      result += word + \" \"\
    ;\n    } else if (word.size() == 71) {\n      result += word + \" \";\n    } else\
    \ if (word.size() == 73) {\n      result += word\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp324823tl.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp324823tl.cpp:63:21: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   63 |       result += word\n      |                     ^\n      |\
    \                     ;\n   64 | }\n      | ~                    \n/tmp/tmp324823tl.cpp:65:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   65 | int main() {\n      |            ^\n/tmp/tmp324823tl.cpp:74:1: error:\
    \ expected \u2018}\u2019 at end of input\n   74 | }\n      | ^\n/tmp/tmp324823tl.cpp:21:23:\
    \ note: to match this \u2018{\u2019\n   21 |   while (iss >> word) {\n      |\
    \                       ^\n/tmp/tmp324823tl.cpp:74:1: error: expected \u2018}\u2019\
    \ at end of input\n   74 | }\n      | ^\n/tmp/tmp324823tl.cpp:17:53: note: to\
    \ match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp324823tl.cpp:74:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   74 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::istringstream in(sentence);\n\
    \  std::string word;\n  std::ostringstream out;\n  bool first = true;\n  int primes[]\
    \ = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97 };\n  while (in >> word) {\n    size_t length = word.length();\n\
    \    if (std::binary_search(std::begin(primes), std::end(primes), length)) {\n\
    \      if (first) {\n        first = false;\n      } else {\n        out << \"\
    \ \";\n      }\n      out << word;\n    }\n  }\n  return out.str();\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098984
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::stringstream\
    \ ss(sentence);\n    for(std::string word; ss >> word; ) {\n        int len =\
    \ word.size();\n        if(len == 1 || len == 2) {\n            ans += word +\
    \ \" \";\n            continue;\n        }\n        bool prime = true;\n     \
    \   for(int i = 2; i * i <= len; ++i) {\n            if(len % i == 0) {\n    \
    \            prime = false;\n                break;\n            }\n        }\n\
    \        if(prime) {\n            ans += word + \" \";\n        }\n    }\n   \
    \ if(ans.size() > 0) {\n        ans.pop_back();\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpnz0royzb: /tmp/tmpnz0royzb.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098984
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result = \"\";\n  std::string\
    \ word = \"\";\n  for (char ch : sentence) {\n    if (ch == ' ') {\n      if (is_prime(word.size()))\
    \ {\n        result += word + \" \";\n      }\n      word = \"\";\n    } else\
    \ {\n      word += ch;\n    }\n  }\n  if (is_prime(word.size())) {\n    result\
    \ += word;\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3b1ecd3i.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp3b1ecd3i.cpp:22:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |       if (is_prime(word.size())) {\n      |           ^~~~~~~~\n\
    /tmp/tmp3b1ecd3i.cpp:30:7: error: \u2018is_prime\u2019 was not declared in this\
    \ scope\n   30 |   if (is_prime(word.size())) {\n      |       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098983
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::vector<std::string>\
    \ words;\n  words.reserve(10);\n  std::string current_word;\n  current_word.reserve(10);\n\
    \  int  sentence_size = sentence.size();\n  for (int i = 0; i < sentence_size;\
    \ ++i) {\n    if (sentence[i] == ' ') {\n      words.push_back(current_word);\n\
    \      current_word.clear();\n    } else {\n      current_word.push_back(sentence[i]);\n\
    \    }\n  }\n  words.push_back(current_word);\n  int  words_size = words.size();\n\
    \  for (int i = 0; i < words_size; ++i) {\n    if (words[i].size() < 2) {\n  \
    \    continue;\n    }\n    int current_word_size = words[i].size();\n    bool\
    \ is_prime = true;\n    for (int j = 2; j < current_word_size; ++j) {\n      if\
    \ (current_word_size % j == 0) {\n        is_prime = false;\n        break;\n\
    \      }\n    }\n    if (is_prime) {\n      result.append(words[i]);\n      result.push_back('\
    \ ');\n    }\n  }\n  if (result.size() > 0) {\n    result.pop_back();\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098984
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    for\
    \ (int i = 0; i < sentence.size(); ++i) {\n        if (sentence[i] == ' ') {\n\
    \            continue;\n        }\n        int j = i;\n        while (sentence[j]\
    \ != ' ' && j < sentence.size()) {\n            ++j;\n        }\n        if (j\
    \ - i == 1) {\n            continue;\n        }\n        bool is_prime = true;\n\
    \        for (int k = 2; k <= (j - i) / 2; ++k) {\n            if ((j - i) % k\
    \ == 0) {\n                is_prime = false;\n                break;\n       \
    \     }\n        }\n        if (is_prime) {\n            result += sentence.substr(i,\
    \ j - i) + \" \";\n        }\n        i = j;\n    }\n    return result.substr(0,\
    \ result.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098984
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string result;\n  int len = sentence.length();\n  for (int i = 0; i <\
    \ len; ++i) {\n    int j = i;\n    while (sentence[j] != ' ' && j < len) {\n \
    \     ++j;\n    }\n    words.push_back(sentence.substr(i, j - i));\n    i = j;\n\
    \  }\n  std::unordered_set<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  for (auto word :\
    \ words) {\n    if (primes.find(word.length()) != primes.end()) {\n      result\
    \ += word + \" \";\n    }\n  }\n  return result.substr(0, result.length() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes = {2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97};\n    std::string res = \"\";\n    std::vector<std::string>\
    \ words;\n    std::istringstream iss(sentence);\n    for(std::string s; iss >>\
    \ s; ) {\n        words.push_back(s);\n    }\n    for(int i = 0; i < words.size();\
    \ i++) {\n        for(int j = 0; j < primes.size(); j++) {\n            if(words[i].size()\
    \ == primes[j]) {\n                res += words[i] + \" \";\n            }\n \
    \       }\n    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2vbus8os: /tmp/tmp2vbus8os.cpp:36: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string primes_sentence;\n\
    \  std::stringstream sstream(sentence);\n  std::string word;\n  while (sstream\
    \ >> word) {\n    int count = 0;\n    for (int i = 1; i <= word.size(); i++) {\n\
    \      if (word.size() % i == 0) {\n        count++;\n      }\n    }\n    if (count\
    \ == 2) {\n      primes_sentence += word + \" \";\n    }\n  }\n  primes_sentence.pop_back();\n\
    \  return primes_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp93yjqws4: /tmp/tmp93yjqws4.cpp:42: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098985
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::string result;\n  \
    \  for (std::string word : words) {\n        if (is_prime(word.size())) {\n  \
    \          result += word + \" \";\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdfo05c1i.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdfo05c1i.cpp:26:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   26 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098985
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::unordered_set<int> primes\
    \ = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97, 101 };\n  std::stringstream ss(sentence);\n  std::string\
    \ word;\n  std::string r;\n  while (std::getline(ss, word, ' ')) {\n    if (primes.find(word.size())\
    \ != primes.end()) {\n      r += word + \" \";\n    }\n  }\n  return r.empty()\
    \ ? \"\" : r.substr(0, r.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098985
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string result;\n    int pos = 0;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            words.push_back(sentence.substr(pos,\
    \ i - pos));\n            pos = i + 1;\n        }\n    }\n    words.push_back(sentence.substr(pos,\
    \ sentence.size() - pos));\n    for (int i = 0; i < words.size(); i++) {\n   \
    \     if (words[i].size() == 1) {\n            continue;\n        }\n        bool\
    \ is_prime = true;\n        for (int j = 2; j <= words[i].size() / 2; j++) {\n\
    \            if (words[i].size() % j == 0) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (is_prime) {\n \
    \           result += words[i] + \" \";\n        }\n    }\n    if (result.size()\
    \ > 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Simple sentence parsing\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  std::vector<std::string> words;\n  while\
    \ (ss >> word) {\n    words.push_back(word);\n  }\n  // We will use a vector of\
    \ bools to mark each word in the sentence,\n  // words that should be added to\
    \ the result are marked true, the rest are marked false.\n  std::vector<bool>\
    \ result_word(words.size(), false);\n  // Loop through the words in the sentence\n\
    \  for (size_t i = 0; i < words.size(); ++i) {\n    // Check if this is a prime\
    \ number\n    bool is_prime = true;\n    // Loop through all the numbers from\
    \ 2 to word.size() - 1\n    for (size_t j = 2; j < words[i].size(); ++j) {\n \
    \     // If the current word size divides the number j,\n      // then it is not\
    \ a prime number and we can break the inner loop\n      if (words[i].size() %\
    \ j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    //\
    \ If it is a prime number then we should mark it as such\n    if (is_prime) {\n\
    \      result_word[i] = true;\n    }\n  }\n  // We now have the result vector\
    \ of bools, let's loop through it\n  // and build the result string\n  std::string\
    \ result;\n  for (size_t i = 0; i < result_word.size(); ++i) {\n    // If the\
    \ current word is prime, we should add it to the result\n    if (result_word[i])\
    \ {\n      result += words[i];\n      // If this is not the last word then we\
    \ should add a space to the result\n      if (i != result_word.size() - 1) {\n\
    \        result += \" \";\n      }\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2_hc8_4v: /tmp/tmp2_hc8_4v.cpp:63: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Remove all leading whitespace.\n\
    \    while(!sentence.empty() && isspace(sentence.front())) {\n        sentence.erase(sentence.begin());\n\
    \    }\n    // Remove all trailing whitespace.\n    while(!sentence.empty() &&\
    \ isspace(sentence.back())) {\n        sentence.pop_back();\n    }\n    std::istringstream\
    \ iss(sentence);\n    std::vector<std::string> words;\n    for(std::string word;\
    \ iss >> word; ) {\n        words.push_back(word);\n    }\n    std::vector<std::string>\
    \ ans;\n    for(const auto& word : words) {\n        if(word.size() > 1 && std::find(ans.begin(),\
    \ ans.end(), word) == ans.end()) {\n            bool prime = true;\n         \
    \   for(int i = 2; i < word.size(); ++i) {\n                if(word.size() % i\
    \ == 0) {\n                    prime = false;\n                    break;\n  \
    \              }\n            }\n            if(prime) {\n                ans.push_back(word);\n\
    \            }\n        }\n    }\n    return std::accumulate(ans.begin(), ans.end(),\
    \ std::string(), [](const std::string& a, const std::string& b) {\n        return\
    \ a.empty() ? b : a + \" \" + b;\n    });\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098985
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string output;\n  size_t start\
    \ = 0;\n  while (start < sentence.size()) {\n    // find first non-space character\n\
    \    while (start < sentence.size() && isspace(sentence[start])) ++start;\n  \
    \  // if end of sentence is reached, break loop\n    if (start == sentence.size())\
    \ break;\n    // find space after word\n    size_t end = start;\n    while (end\
    \ < sentence.size() && !isspace(sentence[end])) ++end;\n    // find prime length\
    \ of the word\n    if (sentence[start] != ' ') {\n      if (is_prime(end - start))\
    \ {\n        output += sentence.substr(start, end - start);\n        output +=\
    \ ' ';\n      }\n    }\n    start = end;\n  }\n  // remove trailing space\n  if\
    \ (!output.empty()) output.pop_back();\n  return output;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc27e2y_6.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpc27e2y_6.cpp:30:11: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   30 |       if (is_prime(end - start)) {\n      |           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098985
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n\
    \    std::string word;\n    std::string retval;\n    while (std::getline(iss,\
    \ word, ' ')) {\n        if (is_prime(word.size())) {\n            retval += word\
    \ + \" \";\n        }\n    }\n    return retval.substr(0, retval.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd61iunko.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpd61iunko.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ s(sentence);\n  std::string word;\n  std::vector<std::string> words;\n  while\
    \ (std::getline(s, word, ' ')) {\n    words.push_back(word);\n  }\n  for (const\
    \ auto& word : words) {\n    if (word.length() == 2 || word.length() == 3 || word.length()\
    \ == 5 || word.length() == 7) {\n      result += word + \" \";\n    }\n  }\n \
    \ result.pop_back();\n  return result;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxc2c2wvh: /tmp/tmpxc2c2wvh.cpp:40: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::regex word_regex(\"\\\\w+\"\
    );\n  std::sregex_iterator word_it(sentence.begin(), sentence.end(), word_regex);\n\
    \  std::sregex_iterator end;\n  std::string output;\n  for (; word_it != end;\
    \ ++word_it) {\n    auto match = *word_it;\n    auto word = match.str();\n   \
    \ bool is_prime = true;\n    for (int i = 2; i <= word.size() / 2; ++i) {\n  \
    \    if (word.size() % i == 0) {\n        is_prime = false;\n        break;\n\
    \      }\n    }\n    if (is_prime) {\n      output += word + \" \";\n    }\n \
    \ }\n  output.pop_back();\n  return output;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpu8broie6: /tmp/tmpu8broie6.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ret;\n    std::istringstream\
    \ iss(sentence);\n    std::vector<std::string> words;\n    std::copy(std::istream_iterator<std::string>(iss),\n\
    \              std::istream_iterator<std::string>(),\n              std::back_inserter(words));\n\
    \    for (const auto& word : words) {\n        if (word.size() < 2) continue;\n\
    \        if (word.size() == 2) {\n            ret += word + \" \";\n         \
    \   continue;\n        }\n        bool ok = true;\n        for (int i = 2; i <\
    \ word.size(); ++i) {\n            if (word.size() % i == 0) {\n             \
    \   ok = false;\n                break;\n            }\n        }\n        if\
    \ (ok) ret += word + \" \";\n    }\n    return ret.substr(0, ret.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098986
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words\
    \ = {\"\", \"\"};\n    std::string word;\n    std::istringstream stream(sentence);\n\
    \    while (std::getline(stream, word, ' ')) {\n        int word_length = word.length();\n\
    \        int counter = 0;\n        for (int i = 1; i <= word_length; i++) {\n\
    \            if (word_length % i == 0) {\n                counter++;\n       \
    \     }\n        }\n        if (counter == 2) {\n            words.push_back(word);\n\
    \        }\n    }\n    return std::accumulate(words.begin(), words.end(), std::string(\"\
    \"),\n            [](std::string& a, std::string& b) { return a.empty() ? b :\
    \ a + \" \" + b; });\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    const std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\n    std::string\
    \ word = \"\";\n    for (char ch : sentence) {\n        if (ch == ' ') {\n   \
    \         if (std::find(primes.begin(), primes.end(), word.size()) != primes.end())\
    \ {\n                result += word + \" \";\n            }\n            word\
    \ = \"\";\n        } else {\n            word += ch;\n        }\n    }\n    if\
    \ (std::find(primes.begin(), primes.end(), word.size()) != primes.end()) {\n \
    \       result += word;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpiqrj7o1m: /tmp/tmpiqrj7o1m.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::stringstream iss(sentence);\n  std::string word;\n  while (std::getline(iss,\
    \ word, ' ')) {\n    words.push_back(word);\n  }\n  auto result = std::string(\"\
    \");\n  for (auto s : words) {\n    if (s.size() == 2 || s.size() == 3 || s.size()\
    \ == 5 || s.size() == 7 || s.size() == 11 || s.size() == 13 || s.size() == 17\
    \ || s.size() == 19 || s.size() == 23 || s.size() == 29 || s.size() == 31 || s.size()\
    \ == 37 || s.size() == 41 || s.size() == 43 || s.size() == 47 || s.size() == 53\
    \ || s.size() == 59 || s.size() == 61 || s.size() == 67 || s.size() == 71 || s.size()\
    \ == 73 || s.size() == 79 || s.size() == 83 || s.size() == 89 || s.size() == 97)\
    \ {\n      result += s + \" \";\n    }\n  }\n  result.pop_back();\n  return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp44ky978k: /tmp/tmp44ky978k.cpp:40: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    for (int i = 0; i < sentence.size(); i++) {\n        std::string current_word;\n\
    \        while (sentence[i] != ' ' && i < sentence.size()) {\n            current_word\
    \ += sentence[i];\n            i++;\n        }\n        words.push_back(current_word);\n\
    \    }\n    std::string result;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        int word_length = words[i].size();\n        bool is_prime = true;\n \
    \       for (int divisor = 2; divisor < word_length; divisor++) {\n          \
    \  if (word_length % divisor == 0) {\n                is_prime = false;\n    \
    \            break;\n            }\n        }\n        if (is_prime) {\n     \
    \       result += words[i] + \" \";\n        }\n    }\n    if (result.size() >\
    \ 0) {\n        result.pop_back();\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpge04fks8: /tmp/tmpge04fks8.cpp:48: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int w_len = 0;\n  std::string result\
    \ = \"\";\n  std::istringstream iss(sentence);\n  do {\n    std::string word;\n\
    \    iss >> word;\n    // check if word is a prime number\n    if (word.size()\
    \ > 1) {\n      bool is_prime = true;\n      for (int i = 2; i < word.size();\
    \ i++) {\n        if (word.size() % i == 0) {\n          is_prime = false;\n \
    \         break;\n        }\n      }\n      if (is_prime) {\n        result +=\
    \ word + \" \";\n      }\n    }\n  } while (iss);\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp74h_p8vs: /tmp/tmp74h_p8vs.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes = { 2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997 };\n    std::vector<std::string> splitted_words;\n    std::stringstream\
    \       ss(sentence);\n    std::string             word;\n    while (ss >> word)\
    \ {\n        splitted_words.push_back(word);\n    }\n    int                 \
    \ size = splitted_words.size();\n    std::vector<int>     indices;\n\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098987
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    bool is_prime[101] = {false};\n    is_prime[2] = true;\n    for (int i =\
    \ 3; i <= 100; i += 2) {\n        is_prime[i] = true;\n    }\n    for (int i =\
    \ 3; i <= 10; i += 2) {\n        if (is_prime[i]) {\n            for (int j =\
    \ i * i; j <= 100; j += i) {\n                is_prime[j] = false;\n         \
    \   }\n        }\n    }\n    std::stringstream ss(sentence);\n    std::string\
    \ word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n   \
    \ std::string ans;\n    for (const auto& word : words) {\n        if (is_prime[word.size()])\
    \ {\n            ans += (word + \" \");\n        }\n    }\n    if (ans.size()\
    \ > 0) {\n        ans.pop_back();\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::unordered_set<int> primes\
    \ = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97, 101 };\n  std::string output;\n  std::string word;\n\
    \  std::istringstream s(sentence);\n  while (s >> word) {\n    if (primes.find(word.size())\
    \ != primes.end()) {\n      output += word + \" \";\n    }\n  }\n  output.pop_back();\n\
    \  return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp0il64psd: /tmp/tmp0il64psd.cpp:37: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string token;\n    std::vector<std::string> tokens;\n    while (std::getline(ss,\
    \ token, ' ')) {\n        tokens.push_back(token);\n    }\n    std::vector<std::string>\
    \ prime_length_tokens;\n    for (int i = 0; i < tokens.size(); i++) {\n      \
    \  if (is_prime(tokens[i].length())) {\n            prime_length_tokens.push_back(tokens[i]);\n\
    \        }\n    }\n    std::string result = prime_length_tokens[0];\n    for (int\
    \ i = 1; i < prime_length_tokens.size(); i++) {\n        result += \" \" + prime_length_tokens[i];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7eo1d0k7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp7eo1d0k7.cpp:26:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   26 |         if (is_prime(tokens[i].length())) {\n      |   \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098985
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Use the regex library to tokenize\
    \ the sentence\n    std::regex re(\"[^\\\\s]+\");\n    std::vector<std::string>\
    \ tokens;\n    std::copy(std::sregex_token_iterator(sentence.begin(), sentence.end(),\
    \ re, -1),\n              std::sregex_token_iterator(),\n              std::back_inserter(tokens));\n\
    \    // Return a list of words whose lengths are prime numbers\n    std::vector<std::string>\
    \ prime_words;\n    for (std::string token : tokens) {\n        if (token.length()\
    \ > 1) {\n            if (is_prime(token.length())) {\n                prime_words.push_back(token);\n\
    \            }\n        }\n    }\n    // Reconstruct the sentence with the prime\
    \ words\n    std::string prime_sentence = \"\";\n    for (std::string prime_word\
    \ : prime_words) {\n        prime_sentence += prime_word + \" \";\n    }\n   \
    \ prime_sentence.pop_back();\n    return prime_sentence;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1fds8vyd.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp1fds8vyd.cpp:28:17: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   28 |             if (is_prime(token.length())) {\n      |   \
    \              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // parse the sentence into words\
    \ (use std::stringstream)\n    // create a vector of words\n    // create a vector\
    \ of prime numbers (use std::vector<bool>)\n    // for each word in vector of\
    \ words\n    //     if length of word is prime number\n    //         add the\
    \ word to the result string (use std::stringstream)\n    // return the string\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpqi2973bv: /tmp/tmpqi2973bv.cpp:29: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::istringstream iss(sentence);\n\
    \  std::ostringstream oss;\n  std::string word;\n  while (iss >> word) {\n   \
    \ if (word.size() % 2 == 1) {\n      oss << word << \" \";\n    }\n  }\n  std::string\
    \ result = oss.str();\n  result.pop_back();\n  return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4gmocgsu: /tmp/tmp4gmocgsu.cpp:32: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    std::vector<std::string> tokens;\n    std::istringstream iss(sentence);\n\
    \    for(std::string token; iss >> token; ) {\n        tokens.push_back(token);\n\
    \    }\n    for(std::string token : tokens) {\n        int length = token.length();\n\
    \        bool is_prime = false;\n        if(length == 1) {\n            is_prime\
    \ = true;\n        } else if(length == 2) {\n            is_prime = true;\n  \
    \      } else {\n            int divisor = 2;\n            while(divisor <= length\
    \ / 2) {\n                if(length % divisor == 0) {\n                    break;\n\
    \                }\n                divisor++;\n            }\n            if(divisor\
    \ > length / 2) {\n                is_prime = true;\n            }\n        }\n\
    \        if(is_prime) {\n            result += token + \" \";\n        }\n   \
    \ }\n    result.pop_back();\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmplp2dk4t9: /tmp/tmplp2dk4t9.cpp:52: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  std::set<size_t> primes = {2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97};\n  while (ss >> word) {\n    if (primes.find(word.size()) != primes.end())\
    \ {\n      result += word + \" \";\n    }\n  }\n  if (!result.empty()) {\n   \
    \ result.pop_back();\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::vector<int> prime_lengths;\n\
    \    std::vector<int> composite_lengths;\n    for (int i = 0; i < words.size();\
    \ ++i) {\n        if (words[i].size() == 1) {\n            prime_lengths.push_back(i);\n\
    \        } else {\n            bool is_prime = true;\n            for (int j =\
    \ 2; j < words[i].size(); ++j) {\n                if (words[i].size() % j == 0)\
    \ {\n                    is_prime = false;\n                    break;\n     \
    \           }\n            }\n            if (is_prime) {\n                prime_lengths.push_back(i);\n\
    \            } else {\n                composite_lengths.push_back(i);\n     \
    \       }\n        }\n    }\n    std::string result;\n    for (int i = 0; i <\
    \ prime_lengths.size(); ++i) {\n        result += words[prime_lengths[i]];\n \
    \       if (i < prime_lengths.size() - 1) {\n            result += \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < composite_lengths.size(); ++i) {\n  \
    \      result += words[composite_lengths[i]];\n        if (i < composite_lengths.size()\
    \ - 1) {\n            result += \" \";\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpqv0frpfd: /tmp/tmpqv0frpfd.cpp:61: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // TODO\n  std::string s = \"\"\
    ;\n  std::vector<std::string> words;\n  std::istringstream iss(sentence);\n  while\
    \ (iss) {\n    std::string word;\n    iss >> word;\n    words.push_back(word);\n\
    \  }\n  std::cout << words.size() << '\\n';\n  for (int i = 0; i < words.size();\
    \ i++) {\n    std::cout << words[i] << '\\n';\n  }\n  std::vector<int> prime =\
    \ {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97};\n  for (int i = 0; i < words.size(); i++) {\n    std::string\
    \ word = words[i];\n    if (std::find(prime.begin(), prime.end(), word.size())\
    \ != prime.end()) {\n      s += word + \" \";\n    }\n  }\n  s.pop_back();\n \
    \ return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpgl2cgti5: /tmp/tmpgl2cgti5.cpp:48: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Define base case and create\
    \ a vector to store the indicies of the words in the sentence\n    std::vector<size_t>\
    \ indicies;\n    // Check if the sentence is empty\n    if (sentence.empty())\
    \ {\n        return \"\";\n    }\n    // Find the indicies of the spaces in the\
    \ sentence\n    // Add the index of the final letter since it will not be registered\
    \ by the function call,\n    // as it does not end with a space.\n    for (size_t\
    \ i = 0; i < sentence.size(); ++i) {\n        if (sentence[i] == ' ') {\n    \
    \        indicies.push_back(i);\n        }\n    }\n    indicies.push_back(sentence.size());\n\
    \    // Create a variable to keep track of how many words the sentence has\n \
    \   size_t num_words = indicies.size();\n    // Create a variable to keep track\
    \ of the current word in the sentence\n    size_t current_word = 0;\n    // Create\
    \ a vector of strings to store the words that have lengths that are prime numbers\n\
    \    std::vector<std::string> primes;\n    // Iterate over the indicies vector\
    \ and if the space at the end of the word is at a prime number,\n    // append\
    \ it to the primes vector of strings\n    for (size_t i = 0; i < num_words; ++i)\
    \ {\n        // Create a variable to keep track of the length of the word to be\
    \ tested\n        int len = indicies[i] - current_word;\n        // Check if the\
    \ length of the word is a prime number\n        // If it is, add it to the primes\
    \ vector of strings\n        if (len == 2 || len == 3 || len == 5 || len == 7\
    \ || len == 11 || len == 13 || len == 17 || len == 19 || len == 23 || len == 29\
    \ || len == 31 || len == 37 || len == 41 || len == 43 || len == 47 || len == 53\
    \ || len == 59 || len == 61 || len == 67 || len == 71 || len == 73 || len == 79\
    \ || len == 83 || len == 89 || len == 97) {\n            // Create a substring\
    \ of the word to be added to the vector\n            std::string word\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprcrx8t0r.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprcrx8t0r.cpp:49:1: error: expected initializer before \u2018}\u2019\
    \ token\n   49 | }\n      | ^\n/tmp/tmprcrx8t0r.cpp:50:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   50 | int main() {\n     \
    \ |            ^\n/tmp/tmprcrx8t0r.cpp:59:1: error: expected \u2018}\u2019 at\
    \ end of input\n   59 | }\n      | ^\n/tmp/tmprcrx8t0r.cpp:41:44: note: to match\
    \ this \u2018{\u2019\n   41 |     for (size_t i = 0; i < num_words; ++i) {\n \
    \     |                                            ^\n/tmp/tmprcrx8t0r.cpp:59:1:\
    \ error: expected \u2018}\u2019 at end of input\n   59 | }\n      | ^\n/tmp/tmprcrx8t0r.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmprcrx8t0r.cpp:59:1: warning: control reaches end of non-void function [-Wreturn-type]\n\
    \   59 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::string result;\n  std::set<int> s;\n  // Unroll the\
    \ loop so to not use while/for loop\n  while (std::getline(ss, word, ' ')) {\n\
    \    s.insert(word.size());\n  }\n  ss.clear();\n  ss.str(sentence);\n  while\
    \ (std::getline(ss, word, ' ')) {\n    if (s.find(word.size()) != s.end()) {\n\
    \      result += word + \" \";\n    }\n  }\n  // Remove the ending space\n  result.pop_back();\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxbtejfci: /tmp/tmpxbtejfci.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    const std::string delimiter =\
    \ \" \";\n    size_t pos = 0;\n    std::string token;\n    std::string result;\n\
    \    while ((pos = sentence.find(delimiter)) != std::string::npos) {\n       \
    \ token = sentence.substr(0, pos);\n        sentence.erase(0, pos + delimiter.length());\n\
    \        if (token.length() == 1 ||\n            token.length() == 2 ||\n    \
    \        token.length() == 3 ||\n            token.length() == 5 ||\n        \
    \    token.length() == 7) {\n            result += token + \" \";\n        }\n\
    \    }\n    if (sentence.length() == 1 ||\n        sentence.length() == 2 ||\n\
    \        sentence.length() == 3 ||\n        sentence.length() == 5 ||\n      \
    \  sentence.length() == 7) {\n        result += sentence;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmppy1690cu: /tmp/tmppy1690cu.cpp:44: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream str_stream(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (str_stream >> word)\
    \ {\n        if (is_prime(word.size())) {\n            result += word + \" \"\
    ;\n        }\n    }\n    return result.substr(0, result.size() - 1);\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpckshtdii.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpckshtdii.cpp:22:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  size_t count_prime_words = 0;\n\
    \  std::string words[sentence.size()];\n  std::string word;\n  std::stringstream\
    \ sentencestream(sentence);\n  while (sentencestream >> word) {\n    words[count_prime_words]\
    \ = word;\n    count_prime_words++;\n  }\n  size_t prime_word_count = 0;\n  for\
    \ (size_t i = 0; i < count_prime_words; i++) {\n    bool is_prime = true;\n  \
    \  for (size_t j = 2; j <= words[i].size() / 2; j++) {\n      if (words[i].size()\
    \ % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n   \
    \ if (is_prime) {\n      prime_word_count++;\n    }\n  }\n  std::string res[prime_word_count];\n\
    \  size_t index = 0;\n  for (size_t i = 0; i < count_prime_words; i++) {\n   \
    \ bool is_prime = true;\n    for (size_t j = 2; j <= words[i].size() / 2; j++)\
    \ {\n      if (words[i].size() % j == 0) {\n        is_prime = false;\n      \
    \  break;\n      }\n    }\n    if (is_prime) {\n      res[index] = words[i];\n\
    \      index++;\n    }\n  }\n  std::string result;\n  for (size_t i = 0; i < prime_word_count;\
    \ i++) {\n    result += res[i];\n    if (i != prime_word_count - 1) {\n      result\
    \ += \" \";\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpt7v8tm8n: /tmp/tmpt7v8tm8n.cpp:65: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream s(sentence);\n\
    \    std::string word;\n    std::vector<std::string> primes;\n    std::string\
    \ result;\n    std::vector<int> prime_numbers = {2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    while\
    \ (s >> word) {\n        if (std::find(prime_numbers.begin(), prime_numbers.end(),\
    \ word.length()) != prime_numbers.end()) {\n            primes.push_back(word);\n\
    \        }\n    }\n    for (int i = 0; i < primes.size(); i++) {\n        result\
    \ += primes[i];\n        if (i < primes.size() - 1) result += \" \";\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // split the string based on\
    \ spaces\n    std::vector<std::string> a;\n    std::stringstream ssin(sentence);\n\
    \    std::string s;\n    while (ssin >> s)\n        a.push_back(s);\n    std::vector<std::string>\
    \ b;\n    // iterate over the vector\n    for (auto s : a) {\n        int n =\
    \ s.length();\n        bool is_prime = true;\n        // check whether the length\
    \ of each word is prime or not\n        for (int i = 2; i * i <= n; ++i) {\n \
    \           if (n % i == 0) {\n                is_prime = false;\n           \
    \     break;\n            }\n        }\n        if (is_prime)\n            b.push_back(s);\n\
    \    }\n    // join the vector of selected words\n    std::stringstream result;\n\
    \    if (!b.empty()) {\n        std::copy(b.begin(), b.end() - 1, std::ostream_iterator<std::string>(result,\
    \ \" \"));\n        result << b.back();\n    }\n    return result.str();\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdh7ldjth: /tmp/tmpdh7ldjth.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res = \"\";\n   \
    \ std::stringstream ss(sentence);\n    int tmp = 0;\n    while (ss >> tmp) {\n\
    \        // is prime ?\n        if (tmp == 1) continue;\n        int i = 2;\n\
    \        for (; i < tmp; ++i) {\n            if (tmp % i == 0) break;\n      \
    \  }\n        if (i == tmp) {\n            res += \" \" + std::to_string(tmp);\n\
    \        }\n    }\n    return res.substr(1);\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 1) > this->size() (which is 0)\n"
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    int count = 0;\n    while (ss >> sentence) {\n        count++;\n\
    \        bool is_prime = true;\n        for (int i = 2; i < sentence.size(); i++)\
    \ {\n            if (sentence.size() % i == 0) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (sentence.size()\
    \ > 1 && is_prime) {\n            result += sentence;\n            if (count !=\
    \ sentence.size()) {\n                result += \" \";\n            }\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpp_raa6t5: /tmp/tmpp_raa6t5.cpp:42: int main(): Assertion `candidate(("lets
    go for swimming")) == ("go for")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string>words;\n\
    \    bool primes[26] = {false};\n    int primes_count = 0;\n    for(int i = 2;\
    \ i < 26; i++) {\n        bool prime = true;\n        for(int j = 2; j <= i/2;\
    \ j++) {\n            if(i % j == 0) {\n                prime = false;\n     \
    \           break;\n            }\n        }\n        if(prime) {\n          \
    \  primes[i] = true;\n            primes_count++;\n        }\n    }\n    int i\
    \ = 0;\n    while(i < sentence.size()) {\n        std::string word;\n        while(i\
    \ < sentence.size() && sentence[i] != ' ') {\n            word.push_back(sentence[i]);\n\
    \            i++;\n        }\n        if(primes[word.size()]) {\n            words.push_back(word);\n\
    \        }\n        i++;\n    }\n    std::string answer;\n    for(auto &word :\
    \ words) {\n        answer += word + \" \";\n    }\n    return answer.substr(0,\
    \ answer.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::vector<std::string>\
    \ words;\n    std::stringstream ss(sentence);\n    std::string temp;\n    while\
    \ (ss >> temp) {\n        words.push_back(temp);\n    }\n    // mark whether a\
    \ number is prime\n    bool is_prime[101];\n    std::fill(is_prime, is_prime +\
    \ 101, true);\n    for (int i = 2; i < 101; ++i) {\n        if (is_prime[i]) {\n\
    \            for (int j = i + i; j < 101; j += i) {\n                is_prime[j]\
    \ = false;\n            }\n        }\n    }\n    for (auto word : words) {\n \
    \       if (is_prime[word.size()]) {\n            ans += word + \" \";\n     \
    \   }\n    }\n    ans.pop_back();\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpm2b9ufu_: /tmp/tmpm2b9ufu_.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> sub_strings\
    \ = {\"\", \"\"};\n  int i = 0;\n  while(sentence[i] != '\\0') {\n    int j =\
    \ i;\n    while(sentence[j] != ' ' && sentence[j] != '\\0') {\n      sub_strings[i\
    \ % 2] += sentence[j];\n      ++j;\n    }\n    i = j + 1;\n  }\n  return sub_strings[0].size()\
    \ > sub_strings[1].size() ? sub_strings[0] : sub_strings[1];\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4gi83_tq: /tmp/tmp4gi83_tq.cpp:32: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string output = \"\";\n\
    \    std::istringstream iss(sentence);\n    std::string word;\n    while (iss\
    \ >> word) {\n        if (word.length() == 1 || word.length() == 2) {\n      \
    \      output += word + \" \";\n        } else {\n            int count = 0;\n\
    \            for (int i = 2; i <= word.length() / 2; i++) {\n                if\
    \ (word.length() % i == 0) {\n                    count++;\n                 \
    \   break;\n                }\n            }\n            if (count == 0) {\n\
    \                output += word + \" \";\n            }\n        }\n    }\n  \
    \  return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp7bvzmk51: /tmp/tmp7bvzmk51.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n\tconst int n = sentence.size();\n\
    \tif (n < 1 || n > 100) {\n\t\tassert(0);\n\t}\n\tfor (int i = 0; i < n; ++i)\
    \ {\n\t\tif (!isalpha(sentence[i])) {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tstd::vector<std::string>\
    \ res;\n\tstd::string token;\n\tstd::istringstream iss(sentence);\n\twhile (std::getline(iss,\
    \ token, ' ')) {\n\t\tif (is_prime(token.size())) {\n\t\t\tres.push_back(token);\n\
    \t\t}\n\t}\n\tstd::string ans = \"\";\n\tfor (const auto& x : res) {\n\t\tans\
    \ += x + \" \";\n\t}\n\tans.pop_back();\n\treturn ans;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkfbwphkh.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpkfbwphkh.cpp:31:7: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   31 |   if (is_prime(token.size())) {\n      |       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream iss(sentence);\n    std::string word;\n    while (iss\
    \ >> word)\n        words.push_back(word);\n    std::string result;\n    for (auto&\
    \ w : words) {\n        int L = w.size();\n        bool prime = true;\n      \
    \  for (int i = 2; i < L; ++i)\n            if (L % i == 0) {\n              \
    \  prime = false;\n                break;\n            }\n        if (prime)\n\
    \            result += \" \" + w;\n    }\n    return result.substr(1);\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp_vv9irrw: /tmp/tmp_vv9irrw.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    const std::string result = \"\
    \";\n    std::vector<std::string> words;\n    std::istringstream stream(sentence);\n\
    \    std::string word;\n    while (stream >> word) {\n        words.push_back(word);\n\
    \    }\n    const std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n    for (const\
    \ int prime : primes) {\n        const auto position = std::find(words.begin(),\
    \ words.end(), word);\n        if (position != words.end()) {\n            words.erase(position);\n\
    \        }\n    }\n    for (const std::string word : words) {\n        result\
    \ += word + \" \";\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi1kr41__.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpi1kr41__.cpp:33:16: error: no match for \u2018operator+=\u2019 (operand\
    \ types are \u2018const string\u2019 {aka \u2018const std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::__cxx11::basic_string<char>\u2019)\n   33 |         result +=\
    \ word + \" \";\n      |         ~~~~~~~^~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi1kr41__.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1172:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator+=(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>]\u2019 <near match>\n 1172 |       operator+=(const basic_string&\
    \ __str)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1172:7:\
    \ note:   passing \u2018const string*\u2019 {aka \u2018const std::__cxx11::basic_string<char>*\u2019\
    } as \u2018this\u2019 argument discards qualifiers\n/usr/include/c++/9/bits/basic_string.h:1181:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator+=(const _CharT*)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 1181 |       operator+=(const _CharT* __s)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1181:32:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const char*\u2019\n 1181 |       ope"
  stdout: ''
  timestamp: 1660098986
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    std::string\
    \ word;\n    std::stringstream ss(sentence);\n    while (ss >> word) {\n     \
    \   int len = word.length();\n        if (len < 2) {\n            continue;\n\
    \        }\n        if (len == 2 || len == 3) {\n            res += \" \" + word;\n\
    \            continue;\n        }\n        bool is_prime = true;\n        for\
    \ (int i = 2; i < len / 2; ++i) {\n            if (len % i == 0) {\n         \
    \       is_prime = false;\n                break;\n            }\n        }\n\
    \        if (is_prime) {\n            res += \" \" + word;\n        }\n    }\n\
    \    return res.substr(1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpkgvncauw: /tmp/tmpkgvncauw.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098987
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result = \"\";\n    while (ss >> word)\
    \ {\n        if (word.size() < 2) {\n            continue;\n        }\n      \
    \  int flag = 0;\n        for (int i = 2; i <= std::sqrt(word.size()); i++) {\n\
    \            if (word.size() % i == 0) {\n                flag = 1;\n        \
    \        break;\n            }\n        }\n        if (flag == 0) {\n        \
    \    result += word + \" \";\n        }\n    }\n    return result.substr(0, result.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098987
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n\tstd::stringstream ss(sentence);\n\
    \tstd::string word;\n\tstd::stringstream ss_result;\n\tconst std::vector<int>\
    \ primes{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97 };\n\tstd::unordered_set<int> prime_set(primes.begin(),\
    \ primes.end());\n\twhile (ss >> word) {\n\t\tif (prime_set.find(word.size())\
    \ != prime_set.end())\n\t\t\tss_result << word << \" \";\n\t}\n\t// remove the\
    \ final space\n\treturn ss_result.str().substr(0, ss_result.str().size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    while (ss >> sentence) {\n        if (sentence.size() ==\
    \ 1) { result += sentence + \" \"; continue; }\n        if (sentence.size() ==\
    \ 2) { result += sentence + \" \"; continue; }\n        if (sentence.size() ==\
    \ 3) { result += sentence + \" \"; continue; }\n        bool prime = true;\n \
    \       for (int i = 2; i < sentence.size(); ++i) {\n            if (sentence.size()\
    \ % i == 0) {\n                prime = false;\n                break;\n      \
    \      }\n        }\n        if (prime) { result += sentence + \" \"; }\n    }\n\
    \    return result.substr(0, result.size() - 1);\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpr4esgwx4: /tmp/tmpr4esgwx4.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098988
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string w;\n  for (auto c : sentence) {\n    if (c == ' ') {\n      words.push_back(w);\n\
    \      w.clear();\n    } else {\n      w.push_back(c);\n    }\n  }\n  words.push_back(w);\n\
    \  std::string result;\n  for (auto &w : words) {\n    if (w.size() == 2 || w.size()\
    \ == 3 || w.size() == 5 || w.size() == 7) {\n      result += w + ' ';\n    }\n\
    \  }\n  if (!result.empty()) {\n    result.pop_back();\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::stringstream result;\n    std::vector<int> primes{2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\
    \    for(std::string s; ss >> s; ) {\n        auto it = std::find(primes.begin(),\
    \ primes.end(), s.size());\n        if (it != primes.end()) {\n            result\
    \ << s << \" \";\n        }\n    }\n    return result.str();\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp4uoy45bj: /tmp/tmp4uoy45bj.cpp:31: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098988
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.size() >= 1 &&\
    \ sentence.size() <= 100);\n    std::vector<std::string> words;\n    std::string\
    \ word;\n    std::istringstream iss(sentence);\n    while (iss >> word) {\n  \
    \      words.push_back(word);\n    }\n    std::string ans = \"\";\n    for (const\
    \ auto& word : words) {\n        bool is_prime = word.size() > 1;\n        for\
    \ (size_t i = 2; i < word.size(); ++i) {\n            if (word.size() % i == 0)\
    \ {\n                is_prime = false;\n                break;\n            }\n\
    \        }\n        if (is_prime) {\n            ans += word + \" \";\n      \
    \  }\n    }\n    if (ans.size() >= 1) {\n        ans.pop_back();\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098988
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::vector<std::string>\
    \ words;\n    size_t pos=0;\n    while(true) {\n        size_t p=sentence.find(\"\
    \ \",pos);\n        if(p==std::string::npos) {\n            if(sentence.size()>pos)\
    \ {\n                words.push_back(sentence.substr(pos));\n            }\n \
    \           break;\n        }\n        words.push_back(sentence.substr(pos,p-pos));\n\
    \        pos=p+1;\n    }\n    std::vector<size_t> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\n\
    \    for(size_t i=0;i<words.size();++i) {\n        for(size_t j=0;j<primes.size();++j)\
    \ {\n            if(words[i].size()==primes[j]) {\n                result.append(words[i]).append(\"\
    \ \");\n                break;\n            }\n        }\n    }\n    if(result.size()>0)\
    \ {\n        result.pop_back();\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::vector<std::string> sentences;\n  std::string result;\n  std::string word;\n\
    \  while (ss >> word) {\n    sentences.push_back(word);\n  }\n  for (int i = 0;\
    \ i < sentences.size(); i++) {\n    if (sentences[i].size() == 2 || sentences[i].size()\
    \ == 3 || sentences[i].size() == 5 || sentences[i].size() == 7 || sentences[i].size()\
    \ == 11 || sentences[i].size() == 13 || sentences[i].size() == 17 || sentences[i].size()\
    \ == 19 || sentences[i].size() == 23 || sentences[i].size() == 29 || sentences[i].size()\
    \ == 31 || sentences[i].size() == 37 || sentences[i].size() == 41 || sentences[i].size()\
    \ == 43 || sentences[i].size() == 47 || sentences[i].size() == 53 || sentences[i].size()\
    \ == 59 || sentences[i].size() == 61 || sentences[i].size() == 67 || sentences[i].size()\
    \ == 71 || sentences[i].size() == 73 || sentences[i].size() == 79 || sentences[i].size()\
    \ == 83 || sentences[i].size() == 89 || sentences[i].size() == 97) {\n      result\
    \ = result + sentences[i] + \" \";\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp8aaeal5k: /tmp/tmp8aaeal5k.cpp:34: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098988
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words\
    \ = split(sentence, ' ');\n    std::string result;\n    for (int i = 0; i < words.size();\
    \ i++) {\n        if (is_prime(words[i].size())) {\n            result += words[i]\
    \ + \" \";\n        }\n    }\n    if (result.size() != 0) {\n        result.pop_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptum9k31r.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptum9k31r.cpp:18:38: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |     std::vector<std::string> words = split(sentence, ' ');\n\
    \      |                                      ^~~~~\n/tmp/tmptum9k31r.cpp:21:13:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   21 |        \
    \ if (is_prime(words[i].size())) {\n      |             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    int\
    \ l = 0;\n    while (l < sentence.size()) {\n        if (sentence[l] == ' ') {\n\
    \            ++l;\n            continue;\n        }\n        int r = l + 1;\n\
    \        while (r < sentence.size() && sentence[r] != ' ') {\n            ++r;\n\
    \        }\n        const int len = r - l;\n        if (len == 1 || len == 2 ||\
    \ len == 3 || len == 5 || len == 7 || len == 11 || len == 13 || len == 17 || len\
    \ == 19) {\n            if (!result.empty()) {\n                result += ' ';\n\
    \            }\n            result += sentence.substr(l, len);\n        }\n  \
    \      l = r;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdg2dw251: /tmp/tmpdg2dw251.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Build words from sentence\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string>\
    \ words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n  \
    \  // Build a set of prime numbers between 0 and 100\n    std::set<size_t> primes;\n\
    \    size_t cnt = 0;\n    for (size_t i = 2; i <= 100; ++i) {\n        bool flag\
    \ = true;\n        for (size_t j = 2; j <= i / 2; ++j) {\n            if (i %\
    \ j == 0) {\n                flag = false;\n                break;\n         \
    \   }\n        }\n        if (flag) {\n            primes.insert(i);\n       \
    \     ++cnt;\n        }\n    }\n    // Filter the words\n    std::stringstream\
    \ res;\n    std::set<size_t>::iterator it;\n    for (auto& word : words) {\n \
    \       it = primes.find(word.size());\n        if (it != primes.end()) {\n  \
    \          res << word << \" \";\n        }\n    }\n    return res.str();\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp1slabewc: /tmp/tmp1slabewc.cpp:54: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >>\
    \ word) {\n        words.push_back(word);\n    }\n    std::string result;\n  \
    \  for (auto &word : words) {\n        int i = 2;\n        for (; i <= word.size()\
    \ / 2; ++i) {\n            if (word.size() % i == 0) {\n                break;\n\
    \            }\n        }\n        if (i > word.size() / 2) {\n            result\
    \ += word + \" \";\n        }\n    }\n    if (!result.empty()) {\n        result.erase(result.size()\
    \ - 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpl0lrvwmf: /tmp/tmpl0lrvwmf.cpp:43: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes = {2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97};\n    std::vector<std::string> sentence_words;\n    sentence.push_back('\
    \ ');\n    int count = 0;\n    int i = 0;\n    while (i < sentence.size()) {\n\
    \        if (sentence[i] == ' ') {\n            sentence_words.push_back(sentence.substr(i\
    \ - count, count));\n            count = 0;\n        } else {\n            count++;\n\
    \        }\n        i++;\n    }\n    std::string result;\n    for (int i = 0;\
    \ i < sentence_words.size(); i++) {\n        if (std::find(primes.begin(), primes.end(),\
    \ sentence_words[i].size()) != primes.end()) {\n            result.append(sentence_words[i]);\n\
    \            result.push_back(' ');\n        }\n    }\n    result.pop_back();\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpyqecz0vq: /tmp/tmpyqecz0vq.cpp:49: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::vector<std::string>\
    \ words;\n  int start = 0;\n  for (int i = 0; i < sentence.size(); ++i) {\n  \
    \  if (sentence[i] == ' ') {\n      words.push_back(sentence.substr(start, i -\
    \ start));\n      start = i + 1;\n    }\n  }\n  words.push_back(sentence.substr(start,\
    \ sentence.size() - start));\n  for (const auto& word : words) {\n    if (word.size()\
    \ == 2 || word.size() == 3 || word.size() == 5 || word.size() == 7) {\n      result\
    \ += (word + \" \");\n    }\n  }\n  return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n\
    \    std::vector<std::string> words;\n    std::copy(std::istream_iterator<std::string>(iss),\n\
    \            std::istream_iterator<std::string>(),\n            std::back_inserter(words));\n\
    \    std::ostringstream oss;\n    for (const auto& word : words) {\n        if\
    \ (word.length() > 1 && word.length() % 2 == 1) {\n            bool is_prime =\
    \ true;\n            for (int i = 3; i < word.length(); i += 2) {\n          \
    \      if (word.length() % i == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                oss << word << \" \";\n            }\n       \
    \ }\n    }\n    return oss.str();\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfoxhgxzj: /tmp/tmpfoxhgxzj.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Define a set of prime numbers,\n\
    \    // and a string to store the words whose lengths are prime numbers.\n   \
    \ std::set<int> primes({ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 });\n    std::string result = \"\";\n\
    \    // Go through the words separated by a space.\n    for (int i = 0; i < sentence.size();\
    \ ++i) {\n        std::string word = \"\";\n        // Extract each word.\n  \
    \      while (i < sentence.size() && sentence[i] != ' ') {\n            word +=\
    \ sentence[i];\n            ++i;\n        }\n        // Check if the length of\
    \ current word is a prime number.\n        if (primes.find(word.size()) != primes.end())\
    \ {\n            result += word + \" \";\n        }\n    }\n    // Remove the\
    \ tailing space.\n    result.pop_back();\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp06watanv: /tmp/tmp06watanv.cpp:46: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string res = \"\";\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    bool prime =\
    \ true;\n    for (int i = 2; i < word.size(); i++) {\n      if (word.size() %\
    \ i == 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime)\
    \ {\n      res += word + \" \";\n    }\n  }\n  res.pop_back();\n  return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp9d0_dsp1: /tmp/tmp9d0_dsp1.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.size();\n  \
    \  std::vector<std::string> sent;\n    std::string x;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            sent.push_back(x);\n\
    \            x = \"\";\n        } else {\n            x.push_back(sentence[i]);\n\
    \        }\n    }\n    sent.push_back(x);\n    std::string ret = \"\";\n    std::vector<int>\
    \ prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n    for (auto x : sent) {\n        if (std::find(prime.begin(),\
    \ prime.end(), x.size()) != prime.end()) {\n            ret.append(x);\n     \
    \       ret.push_back(' ');\n        }\n    }\n    if (ret.back() == ' ') ret.pop_back();\n\
    \    return ret;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  // TODO:\
    \ You should probably process the sentence in a different way, maybe break the\
    \ sentence into a vector of words?\n  std::vector<std::string> words = {};\n \
    \ std::string curr_word = \"\";\n  for (char const & character : sentence) {\n\
    \    if (character == ' ') {\n      words.push_back(curr_word);\n      curr_word\
    \ = \"\";\n    } else {\n      curr_word += character;\n    }\n  }\n  if (curr_word\
    \ != \"\") {\n    words.push_back(curr_word);\n  }\n  for (int i = 0; i < words.size();\
    \ i++) {\n    int length = words[i].length();\n    if (length <= 1) {\n      continue;\n\
    \    }\n    bool is_prime = true;\n    for (int j = 2; j < length; j++) {\n  \
    \    if (length % j == 0) {\n        is_prime = false;\n        break;\n     \
    \ }\n    }\n    if (is_prime) {\n      result += (words[i] + \" \");\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpxue3ujh1: /tmp/tmpxue3ujh1.cpp:53: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    const int LEN = sentence.length();\n\
    \    std::string answer;\n    for (int i = 0; i < LEN; ++i) {\n        int j =\
    \ i;\n        for (; j < LEN && sentence[j] != ' '; ++j);\n        int word_len\
    \ = j - i;\n        if (word_len > 1) {\n            bool flag = true;\n     \
    \       for (int k = 2; k < word_len; ++k) {\n                if (word_len % k\
    \ == 0) {\n                    flag = false;\n                    break;\n   \
    \             }\n            }\n            if (flag) {\n                answer\
    \ += sentence.substr(i, word_len);\n                answer += ' ';\n         \
    \   }\n        }\n        i = j;\n    }\n    answer.pop_back();\n    return answer;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpqyc9rfh2: /tmp/tmpqyc9rfh2.cpp:49: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  if (sentence.size() == 0) {\n \
    \   return \"\";\n  }\n  std::string ret;\n  std::string s;\n  std::stringstream\
    \ ss(sentence);\n  bool flag = false;\n  while (ss >> s) {\n    bool is_prime\
    \ = true;\n    for (size_t d = 2; d * d <= s.size(); ++d) {\n      if (s.size()\
    \ % d == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n   \
    \ if (is_prime) {\n      if (flag) {\n        ret += \" \";\n      }\n      ret\
    \ += s;\n      flag = true;\n    }\n  }\n  return ret;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpfbo49x6e: /tmp/tmpfbo49x6e.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream str_s(sentence);\n\
    \    std::string word;\n    std::vector<std::string> words;\n    while (str_s\
    \ >> word) {\n        words.push_back(word);\n    }\n    std::unordered_set<int>\
    \ primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97};\n    std::string ret;\n    for (const auto& w :\
    \ words) {\n        if (primes.count(w.size())) {\n            ret += w + \" \"\
    ;\n        }\n    }\n    return ret.substr(0, ret.size() - 1);\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    // parse\
    \ the sentence\n    std::stringstream ss(sentence);\n    std::string word;\n \
    \   while (std::getline(ss, word, ' ')) {\n        // check if length of word\
    \ is prime\n        bool is_prime = true;\n        for (int i = 2; i < word.length();\
    \ i++) {\n            if (word.length() % i == 0) {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\n\
    \            result += word + \" \";\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp8lbmysl6: /tmp/tmp8lbmysl6.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::istringstream iss(sentence);\n\
    \  std::string word;\n  std::string result = \"\";\n  while (iss >> word) {\n\
    \    int length = word.length();\n    bool is_prime = true;\n    for (int i =\
    \ 2; i <= length / 2; i++) {\n      if (length % i == 0) {\n        is_prime =\
    \ false;\n        break;\n      }\n    }\n    if (is_prime) {\n      result +=\
    \ (word + \" \");\n    }\n  }\n  if (result.length() > 0) {\n    result.pop_back();\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsjqpjpqc: /tmp/tmpsjqpjpqc.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::stringstream\
    \ ss(sentence);\n  std::string token;\n  while (getline(ss, token, ' ')) {\n \
    \   if (std::all_of(token.begin(), token.end(), ::isdigit)) {\n      int n = stoi(token);\n\
    \      if (n < 2) {\n        continue;\n      }\n      bool is_prime = true;\n\
    \      for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n\
    \          is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result += token + \" \";\n      }\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpgaq0q5aa: /tmp/tmpgaq0q5aa.cpp:43: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert(not sentence.empty());\n\
    \  auto const is_prime = [](auto const& n) {\n    assert(n > 0);\n    auto result\
    \ = true;\n    for (auto divisor = 2; divisor < n; ++divisor) {\n      if (n %\
    \ divisor == 0) {\n        result = false;\n        break;\n      }\n    }\n \
    \   return result;\n  };\n  std::stringstream ss(sentence);\n  std::string word;\n\
    \  std::string result;\n  while (ss >> word) {\n    if (is_prime(word.size()))\
    \ {\n      result += word + \" \";\n    }\n  }\n  if (not result.empty()) {\n\
    \    result.pop_back();\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsp3gy_zc: /tmp/tmpsp3gy_zc.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string word;\n  std::string result;\n  while (ss >> word) {\n    if (is_prime(word.size()))\
    \ {\n      result += word + \" \";\n    }\n  }\n  result.pop_back();\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp518xeuik.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp518xeuik.cpp:22:9: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |     if (is_prime(word.size())) {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // use std::set<int> where int\
    \ is the length of word\n  std::set<int> primes {2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  // words\
    \ are separated by space char\n  std::stringstream ss(sentence);\n  std::string\
    \ word;\n  std::string prime_words;\n  // iterate over words in stream\n  while\
    \ (ss >> word) {\n    if (primes.find(word.length()) != primes.end()) {\n    \
    \  // found prime length\n      prime_words += word + \" \";\n    }\n  }\n  //\
    \ remove the extra space\n  prime_words.pop_back();\n  return prime_words;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmprsx0li9s: /tmp/tmprsx0li9s.cpp:42: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    for\
    \ (auto it = sentence.begin(); it != sentence.end();) {\n        if (std::isspace(*it))\
    \ {\n            it++;\n            continue;\n        }\n        auto it2 = std::find(it,\
    \ sentence.end(), ' ');\n        if (it2 == sentence.end()) it2 = sentence.end();\n\
    \        int l = it2 - it;\n        if (l == 1 || l == 2) {\n            it =\
    \ it2;\n            continue;\n        }\n        bool is_prime = true;\n    \
    \    for (int i = 2; i < std::floor(std::sqrt(l)) + 1; i++) {\n            if\
    \ (l % i == 0) {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        if (is_prime) {\n            result += std::string(it,\
    \ it2);\n            result += ' ';\n        }\n        it = it2;\n    }\n   \
    \ if (result.back() == ' ') result.pop_back();\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpv8urkg0i: /tmp/tmpv8urkg0i.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098989
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::istringstream iss(sentence);\n\
    \  std::string word;\n  bool is_prime[100] = {};\n  for (int i = 2; i < 100; ++i)\
    \ is_prime[i] = true;\n  for (int i = 2; i < std::sqrt(100); ++i) {\n    if (is_prime[i])\
    \ {\n      for (int j = i * i; j < 100; j += i) is_prime[j] = false;\n    }\n\
    \  }\n  std::vector<std::string> v;\n  while (iss >> word) {\n    if (is_prime[word.size()])\
    \ v.push_back(word);\n  }\n  std::string result;\n  for (const auto& s : v) result\
    \ += (s + \" \");\n  return result.substr(0, result.size() - 1);\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::string result;\n    while (ss >> word) {\n  \
    \      if (word.length() == 1 || word.length() == 2) {\n            continue;\n\
    \        }\n        for (int i = 2; i < word.length(); i++) {\n            if\
    \ (word.length() % i == 0) {\n                break;\n            }\n        \
    \    if (i == word.length() - 1) {\n                result += word + \" \";\n\
    \            }\n        }\n    }\n    result.pop_back();\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpmmh3hzfq: /tmp/tmpmmh3hzfq.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<int> primes = {2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97};\n  std::vector<std::string> words;\n  std::string word = \"\";\n\
    \  for (char ch : sentence) {\n    if (ch == ' ') {\n      words.push_back(word);\n\
    \      word = \"\";\n    } else {\n      word += ch;\n    }\n  }\n  words.push_back(word);\n\
    \  std::string res = \"\";\n  for (std::string word : words) {\n    if (std::find(primes.begin(),\
    \ primes.end(), word.size()) != primes.end()) {\n      res += word + \" \";\n\
    \    }\n  }\n  return res.size() ? res.substr(0, res.size() - 1) : res;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098989
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string res;\n  for (int i\
    \ = 0; i < sentence.size(); ++i) {\n    std::string word;\n    while (i < sentence.size()\
    \ && sentence[i] != ' ') {\n      word += sentence[i];\n      ++i;\n    }\n  \
    \  if (std::find(std::begin(primes), std::end(primes), word.size()) != std::end(primes))\
    \ {\n      res += word + ' ';\n    }\n  }\n  if (!res.empty()) res.pop_back();\n\
    \  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsmufrpb1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpsmufrpb1.cpp:25:30: error: \u2018primes\u2019 was not declared in this\
    \ scope\n   25 |     if (std::find(std::begin(primes), std::end(primes), word.size())\
    \ != std::end(primes)) {\n      |                              ^~~~~~\n"
  stdout: ''
  timestamp: 1660098989
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string primes;\n  auto i =\
    \ 0;\n  while (i < sentence.size()) {\n    auto count = 0;\n    while (sentence[i]\
    \ != ' ' && i < sentence.size()) {\n      ++count;\n      ++i;\n    }\n    if\
    \ (is_prime(count)) {\n      auto start = i - count;\n      primes += sentence.substr(start,\
    \ count);\n      primes += ' ';\n    }\n    ++i;\n  }\n  return primes;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc3v30lol.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpc3v30lol.cpp:26:9: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   26 |     if (is_prime(count)) {\n      |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::string word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n\
    \            words.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\
    \    std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n    std::string result;\n\
    \    for (const auto& word : words) {\n        if (std::find(primes.begin(), primes.end(),\
    \ word.size()) != primes.end()) {\n            result += word + \" \";\n     \
    \   }\n    }\n    result.pop_back();\n    return result;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp2bc3xkh8: /tmp/tmp2bc3xkh8.cpp:46: int main(): Assertion `candidate(("here"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    std::stringstream\
    \ ss(sentence);\n    std::string tmp;\n    while (ss >> tmp) {\n        if (tmp.size()\
    \ == 1) {\n            res += tmp + \" \";\n            continue;\n        }\n\
    \        bool is_prime = true;\n        for (int i = 2; i < tmp.size(); ++i) {\n\
    \            if (tmp.size() % i == 0) {\n                is_prime = false;\n \
    \               break;\n            }\n        }\n        if (is_prime) {\n  \
    \          res += tmp + \" \";\n        }\n    }\n    res.pop_back();\n    return\
    \ res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmptp7vfj0v: /tmp/tmptp7vfj0v.cpp:42: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int size = sentence.size();\n\
    \    std::string word;\n    std::string res;\n    bool is_prime;\n    for (int\
    \ i = 0; i < size; i++) {\n        if (sentence[i] == ' ') {\n            is_prime\
    \ = true;\n            for (int j = 2; j <= sqrt(word.size()); j++) {\n      \
    \          if (word.size() % j == 0) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (is_prime) {\n                res += word + \" \";\n            }\n        \
    \    word.clear();\n        } else {\n            word += sentence[i];\n     \
    \   }\n    }\n    is_prime = true;\n    for (int j = 2; j <= sqrt(word.size());\
    \ j++) {\n        if (word.size() % j == 0) {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if (is_prime) {\n        res += word;\n\
    \    }\n    if (res.size() > 0) {\n        res.pop_back();\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpijkhmqo5: /tmp/tmpijkhmqo5.cpp:56: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> result;\n\
    \  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word)\
    \ {\n    if (std::find(result.begin(), result.end(), word) == result.end()) {\n\
    \      int length = word.length();\n      bool is_prime = true;\n      for (int\
    \ i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n         \
    \ is_prime = false;\n          break;\n        }\n      }\n      if (is_prime)\
    \ {\n        result.push_back(word);\n      }\n    }\n  }\n  return std::accumulate(std::next(result.begin()),\
    \ result.end(), result[0],\n    [](std::string a, std::string b) {\n      return\
    \ a + \" \" + b;\n    });\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpsqt5dejd: /tmp/tmpsqt5dejd.cpp:43: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> v(std::istream_iterator<std::string>{std::istringstream(sentence)},\
    \ {});\n  auto is_prime = [](int n) {\n    for (int i = 2; i < n; ++i) {\n   \
    \   if (n % i == 0) {\n        return false;\n      }\n    }\n    return true;\n\
    \  };\n  std::vector<std::string> result;\n  std::copy_if(v.begin(), v.end(),\
    \ std::back_inserter(result), [&is_prime](std::string s) { return is_prime(s.size());\
    \ });\n  return std::accumulate(result.begin(), result.end(), std::string{}, [](std::string\
    \ a, std::string b) { return a.empty() ? b : a + \" \" + b; });\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl1wozqn9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpl1wozqn9.cpp:18:70: error: cannot bind non-const lvalue reference of\
    \ type \u2018std::istream_iterator<std::__cxx11::basic_string<char> >::istream_type&\u2019\
    \ {aka \u2018std::basic_istream<char>&\u2019} to an rvalue of type \u2018std::basic_istream<char>\u2019\
    \n   18 |   std::vector<std::string> v(std::istream_iterator<std::string>{std::istringstream(sentence)},\
    \ {});\n      |                                                              \
    \        ^~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpl1wozqn9.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:68:38:\
    \ note:   initializing argument 1 of \u2018std::istream_iterator<_Tp, _CharT,\
    \ _Traits, _Dist>::istream_iterator(std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>::istream_type&) [with _Tp = std::__cxx11::basic_string<char>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Dist = long int; std::istream_iterator<_Tp,\
    \ _CharT, _Traits, _Dist>::istream_type = std::basic_istream<char>]\u2019\n  \
    \ 68 |       istream_iterator(istream_type& __s)\n      |                    \
    \    ~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // First, remove whitespace on\
    \ the front and back of sentence.\n  sentence.erase(0, sentence.find_first_not_of('\
    \ '));\n  sentence.erase(sentence.find_last_not_of(' ') + 1);\n  // Now, find\
    \ all the words in sentence, we can do this by\n  // splitting on the ' ' character.\n\
    \  // Also, we can find all the prime numbers in sentence,\n  // we can make use\
    \ of the fact that all primes are of the form\n  // 6k + 1 or 6k - 1\n  // and\
    \ save them as a set.\n  std::set<int> s;\n  for (int i = 1; i <= 100; i++) {\n\
    \    if (i % 6 == 1 || i % 6 == 5) {\n      s.insert(i);\n    }\n  }\n  // Now,\
    \ we want to iterate over the words in sentence,\n  // and check if the word has\
    \ length in the set.\n  // If so, add to result.\n  std::string result;\n  std::string\
    \ delimiter = \" \";\n  size_t pos = 0;\n  std::string token;\n  while ((pos =\
    \ sentence.find(delimiter)) != std::string::npos) {\n    token = sentence.substr(0,\
    \ pos);\n    sentence.erase(0, pos + delimiter.length());\n    if (s.find(token.length())\
    \ != s.end()) {\n      result.append(token + \" \");\n    }\n  }\n  // Don't forget\
    \ to add the last word if it's prime.\n  if (s.find(sentence.length()) != s.end())\
    \ {\n    result.append(sentence);\n  }\n  // We want to remove the whitespace\
    \ on the back of result.\n  result.erase(result.find_last_not_of(' ') + 1);\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpw9jfqxaa: /tmp/tmpw9jfqxaa.cpp:57: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n\
    \    std::ostringstream oss;\n    std::vector<std::string> words;\n    std::string\
    \ word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n  \
    \  for (auto& word : words) {\n        if (word.size() == 2) {\n            oss\
    \ << word << \" \";\n        } else if (word.size() > 2) {\n            bool is_prime\
    \ = true;\n            for (int i = 2; i < word.size(); ++i) {\n             \
    \   if (word.size() % i == 0) {\n                    is_prime = false;\n     \
    \               break;\n                }\n            }\n            if (is_prime)\
    \ {\n                oss << word << \" \";\n            }\n        }\n    }\n\
    \    return oss.str();\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpnhb8udt_: /tmp/tmpnhb8udt_.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    for (std::string word : sentence.split(\" \")) {\n        if (is_prime(word.length()))\
    \ {\n            words.push_back(word);\n        }\n    }\n    return join(words,\
    \ \" \");\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpteu3jy6e.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpteu3jy6e.cpp:19:38: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   19 |     for (std::string word : sentence.split(\" \")) {\n      |      \
    \                                ^~~~~\n/tmp/tmpteu3jy6e.cpp:20:13: error: \u2018\
    is_prime\u2019 was not declared in this scope\n   20 |         if (is_prime(word.length()))\
    \ {\n      |             ^~~~~~~~\n/tmp/tmpteu3jy6e.cpp:24:12: error: \u2018join\u2019\
    \ was not declared in this scope; did you mean \u2018jn\u2019?\n   24 |     return\
    \ join(words, \" \");\n      |            ^~~~\n      |            jn\n"
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    int start_index = 0;\n    for (int end_index = 0; end_index < sentence.size();\
    \ ++end_index) {\n        if (sentence[end_index] == ' ') {\n            int length\
    \ = end_index - start_index;\n            // length = 2 -> if prime, add to result\n\
    \            if (length > 1) {\n                bool is_prime = true;\n      \
    \          for (int i = 2; i < length; ++i) {\n                    if (length\
    \ % i == 0) {\n                        is_prime = false;\n                   \
    \     break;\n                    }\n                }\n                if (is_prime)\
    \ {\n                    result += sentence.substr(start_index, length);\n   \
    \                 result += ' ';\n                }\n            }\n         \
    \   start_index = end_index + 1;\n        }\n    }\n    if (start_index < sentence.size())\
    \ {\n        // length = 2 -> if prime, add to result\n        int length = sentence.size()\
    \ - start_index;\n        if (length > 1) {\n            bool is_prime = true;\n\
    \            for (int i = 2; i < length; ++i) {\n                if (length %\
    \ i == 0) {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if (is_prime) {\n             \
    \   result += sentence.substr(start_index, length);\n            }\n        }\n\
    \    }\n    if (result.size() > 0) {\n        result.pop_back();\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpyro3j6oa: /tmp/tmpyro3j6oa.cpp:66: int main(): Assertion `candidate(("Hi
    I am Hussein")) == ("Hi am Hussein")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Hint: you can implement the\
    \ Sieve of Eratosthenes\n    // to find all prime numbers in [2, max_word_length],\n\
    \    // then for each word check if its length is a prime number\n    // and if\
    \ so, concatenate it to the result\n    // std::vector<bool> is_prime(100);\n\
    \    // for (int i = 2; i < is_prime.size(); ++i) {\n    //     is_prime[i] =\
    \ true;\n    // }\n    // for (int i = 2; i < is_prime.size(); ++i) {\n    //\
    \     if (is_prime[i]) {\n    //         for (int j = i * i; j < is_prime.size();\
    \ j += i) {\n    //             is_prime[j] = false;\n    //         }\n    //\
    \     }\n    // }\n    // int start = 0;\n    // std::string result;\n    // for\
    \ (int i = 0; i < sentence.size(); ++i) {\n    //     if (sentence[i] == ' ')\
    \ {\n    //         if (is_prime[i - start]) {\n    //             result += sentence.substr(start,\
    \ i - start);\n    //             result += ' ';\n    //         }\n    //   \
    \      start = i + 1;\n    //     }\n    // }\n    // if (is_prime[sentence.size()\
    \ - start]) {\n    //     result += sentence.substr(start, sentence.size() - start);\n\
    \    // }\n    // if (!result.empty()) {\n    //     result.pop_back();\n    //\
    \ }\n    // return result;\n    std::vector<bool> is_prime(100);\n    std::fill(is_prime.begin(),\
    \ is_prime.end(), true);\n    for (int i = 2; i < is_prime.size(); ++i) {\n  \
    \      if (is_prime[i]) {\n            for (int j = i * i; j < is_prime.size();\
    \ j += i) {\n                is_prime[j] = false;\n            }\n        }\n\
    \    }\n    std::vector<\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwgfrinvm.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwgfrinvm.cpp:60:16: error: template argument 1 is invalid\n   60 |\
    \     std::vector<\n      |                ^\n/tmp/tmpwgfrinvm.cpp:60:16: error:\
    \ template argument 2 is invalid\n/tmp/tmpwgfrinvm.cpp:61:1: error: expected unqualified-id\
    \ before \u2018}\u2019 token\n   61 | }\n      | ^\n/tmp/tmpwgfrinvm.cpp:61:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660098989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n\
    \  std::string res;\n  std::string cur;\n  bool is_prime = true;\n  while (ss\
    \ >> cur) {\n    int n = cur.size();\n    for (int i = 2; i <= n / 2; ++i) {\n\
    \      if (n % i == 0) {\n        is_prime = false;\n        break;\n      }\n\
    \    }\n    if (is_prime) {\n      res += cur + \" \";\n    }\n    is_prime =\
    \ true;\n  }\n  return res.substr(0, res.size() - 1);\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpcajxfmcq: /tmp/tmpcajxfmcq.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Track characters in sentence.\n\
    \  std::vector<std::string> words;\n  size_t start_index = 0;\n  for (size_t i\
    \ = 0; i < sentence.size(); ++i) {\n    if (sentence[i] == ' ') {\n      words.push_back(sentence.substr(start_index,\
    \ i - start_index));\n      start_index = i + 1;\n    }\n  }\n  words.push_back(sentence.substr(start_index,\
    \ sentence.size() - start_index));\n  // Find primes.\n  std::vector<bool> primes(101,\
    \ true);\n  for (size_t i = 2; i <= 100; ++i) {\n    if (primes[i]) {\n      for\
    \ (size_t j = i * i; j <= 100; j += i) {\n        primes[j] = false;\n      }\n\
    \    }\n  }\n  // Rebuild sentence with prime length words.\n  std::string result;\n\
    \  for (auto const &word : words) {\n    if (primes[word.size()]) {\n      result\
    \ += word + \" \";\n    }\n  }\n  result.pop_back();\n  return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp8j3pdq02: /tmp/tmp8j3pdq02.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (std::getline(ss, word, ' '))\
    \ {\n        if (word.size() < 2) {\n            continue;\n        }\n      \
    \  if (word.size() == 2) {\n            result += (word + \" \");\n          \
    \  continue;\n        }\n        bool is_prime = true;\n        for (std::size_t\
    \ i = 2; i < word.size(); ++i) {\n            if (word.size() % i == 0) {\n  \
    \              is_prime = false;\n                break;\n            }\n    \
    \    }\n        if (is_prime) {\n            result += (word + \" \");\n     \
    \   }\n    }\n    if (result.size() > 0) {\n        result.pop_back();\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert(sentence.size() <= 100);\n\
    \  std::string s;\n  std::vector<std::string> v;\n  for (auto c : sentence) {\n\
    \    if (c == ' ') {\n      v.push_back(s);\n      s.clear();\n    } else {\n\
    \      s.push_back(c);\n    }\n  }\n  v.push_back(s);\n  std::string result;\n\
    \  for (auto s : v) {\n    if (s.size() == 1) {\n      result.append(s);\n   \
    \   result.push_back(' ');\n    } else if (s.size() == 2) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 3) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 5) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 7) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 11) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 13) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 17) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 19) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 23) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 29) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 31) {\n      result.append(s);\n\
    \      result.push_back(' ');\n    } else if (s.size() == 37) {\n\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcnk4eifx.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpcnk4eifx.cpp:71:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n/tmp/tmpcnk4eifx.cpp:80:1:\
    \ error: expected \u2018}\u2019 at end of input\n   80 | }\n      | ^\n/tmp/tmpcnk4eifx.cpp:31:20:\
    \ note: to match this \u2018{\u2019\n   31 |   for (auto s : v) {\n      |   \
    \                 ^\n/tmp/tmpcnk4eifx.cpp:80:1: error: expected \u2018}\u2019\
    \ at end of input\n   80 | }\n      | ^\n/tmp/tmpcnk4eifx.cpp:17:53: note: to\
    \ match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpcnk4eifx.cpp:80:1: warning: control reaches end of non-void function [-Wreturn-type]\n\
    \   80 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string temp = \"\";\n  \
    \  std::string result = \"\";\n    for (auto ch : sentence) {\n        if (ch\
    \ == ' ') {\n            if (is_prime(temp.size())) {\n                result\
    \ += temp + \" \";\n            }\n            temp = \"\";\n        } else {\n\
    \            temp += ch;\n        }\n    }\n    if (is_prime(temp.size())) {\n\
    \        result += temp;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc04f0b56.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpc04f0b56.cpp:22:17: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   22 |             if (is_prime(temp.size())) {\n      |      \
    \           ^~~~~~~~\n/tmp/tmpc04f0b56.cpp:30:9: error: \u2018is_prime\u2019 was\
    \ not declared in this scope\n   30 |     if (is_prime(temp.size())) {\n     \
    \ |         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // get the words of the sentence\n\
    \  std::vector<std::string> words;\n  std::stringstream ss(sentence);\n  std::string\
    \ word;\n  while (ss >> word)\n    words.push_back(word);\n  // build the vector\
    \ of primes\n  std::vector<int> primes(101, 1);\n  for (int x = 2; x < 101; ++x)\n\
    \    for (int y = 2; y < 101; ++y)\n      if (x % y == 0)\n        primes[x] =\
    \ 0;\n  // put the words whose length is prime in a string\n  std::string ans\
    \ = \"\";\n  for (auto word : words)\n    if (primes[word.size()])\n      ans\
    \ += word + \" \";\n  // remove the last space\n  ans.pop_back();\n  return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpn2mpra0i: /tmp/tmpn2mpra0i.cpp:41: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::vector<std::string> sentence_words;\n    std::istringstream iss(sentence);\n\
    \    for(std::string str; iss >> str; )\n        sentence_words.push_back(str);\n\
    \    for(auto str : sentence_words) {\n        int len = str.length();\n     \
    \   if(len == 1) {\n            ans += str + \" \";\n            continue;\n \
    \       }\n        if(len == 2) {\n            ans += str + \" \";\n         \
    \   continue;\n        }\n        int is_prime = 1;\n        for(int i = 2; i\
    \ < len; ++i) {\n            if(len % i == 0) {\n                is_prime = 0;\n\
    \                break;\n            }\n        }\n        if(is_prime) {\n  \
    \          ans += str + \" \";\n        }\n    }\n    ans.pop_back();\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp0b6tc44v: /tmp/tmp0b6tc44v.cpp:49: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  std::vector<std::string>\
    \ v;\n  std::stringstream ss(sentence);\n  while (ss >> sentence) {\n    v.push_back(sentence);\n\
    \  }\n  for (int i = 0; i < v.size(); i++) {\n    int n = v[i].size();\n    int\
    \ count = 0;\n    for (int j = 1; j <= n; j++) {\n      if (n % j == 0)\n    \
    \    count++;\n    }\n    if (count == 2)\n      result += v[i] + \" \";\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpw4jj1j9e: /tmp/tmpw4jj1j9e.cpp:38: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream iss(sentence);\n    for (std::string s; iss >> s; ) {\n\
    \        words.push_back(s);\n    }\n    std::string result;\n    for (int i =\
    \ 0; i < words.size(); ++i) {\n        bool is_prime = true;\n        for (int\
    \ j = 2; j <= words[i].size() / 2; ++j) {\n            if (words[i].size() % j\
    \ == 0) {\n                is_prime = false;\n                break;\n       \
    \     }\n        }\n        if (is_prime) {\n            result += words[i] +\
    \ \" \";\n        }\n    }\n    return result.substr(0, result.size() - 1);\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp0fggun8p: /tmp/tmp0fggun8p.cpp:40: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098991
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Figure out what are all the\
    \ words in the sentence\n    std::vector<std::string> words;\n    std::string\
    \ current_word;\n    for (auto c : sentence) {\n        if (c == ' ') {\n    \
    \        words.push_back(current_word);\n            current_word = \"\";\n  \
    \      } else {\n            current_word += c;\n        }\n    }\n    words.push_back(current_word);\n\
    \    // Figure out what are all the prime words\n    std::vector<int> primes_up_to_100\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97};\n    std::vector<int> word_lens;\n    for (auto word :\
    \ words) {\n        word_lens.push_back(word.size());\n    }\n    std::vector<bool>\
    \ is_prime_len(101, false);\n    for (auto prime : primes_up_to_100) {\n     \
    \   is_prime_len[prime] = true;\n    }\n    std::vector<bool> is_prime_word(word_lens.size(),\
    \ false);\n    for (int i = 0; i < word_lens.size(); ++i) {\n        if (is_prime_len[word_lens[i]])\
    \ {\n            is_prime_word[i] = true;\n        }\n    }\n    // Make the new\
    \ sentence\n    std::string new_sentence;\n    for (int i = 0; i < words.size();\
    \ ++i) {\n        if (is_prime_word[i]) {\n            new_sentence += words[i];\n\
    \            new_sentence += \" \";\n        }\n    }\n    return new_sentence.substr(0,\
    \ new_sentence.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098991
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string output;\n    std::stringstream\
    \ ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        bool\
    \ prime = true;\n        for (int i = 2; i < word.size(); i++) {\n           \
    \ if (word.size() % i == 0) {\n                prime = false;\n              \
    \  break;\n            }\n        }\n        if (prime) {\n            output\
    \ += word + \" \";\n        }\n    }\n    return output.substr(0, output.size()\
    \ - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpdl1m3s8r: /tmp/tmpdl1m3s8r.cpp:37: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string s;\n  size_t l = sentence.length();\n\
    \  for (size_t i = 0; i < l; i++) {\n    int j = i + 1;\n    while (j < l && sentence[j]\
    \ != ' ') {\n      j++;\n    }\n    std::string word = sentence.substr(i, j -\
    \ i);\n    if (word.size() > 1 && word.size() % 2 == 1) {\n      bool flag = true;\n\
    \      for (int k = 3; k < word.size(); k += 2) {\n        if (word.size() % k\
    \ == 0) {\n          flag = false;\n          break;\n        }\n      }\n   \
    \   if (flag) {\n        s += word + \" \";\n      }\n    }\n    i = j;\n  }\n\
    \  s.pop_back();\n  return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmptwfyvoqw: /tmp/tmptwfyvoqw.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string word;\n    std::vector<std::string> answer;\n    int space_at_end\
    \ = sentence.back() == ' ';\n    while (std::getline(ss, word, ' ')) {\n     \
    \   if (is_prime(word.size())) {\n            answer.push_back(word);\n      \
    \  }\n    }\n    return std::accumulate(answer.begin(), answer.end(), std::string(\"\
    \"), [](std::string &a, std::string &b) {\n        return a.empty() ? b : a +\
    \ \" \" + b;\n    }) + (space_at_end ? \" \" : \"\");\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsz_hkbp_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpsz_hkbp_.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.size())) {\n      |          \
    \   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098990
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes = {\n\
    \        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\
    \ 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,\
    \ 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,\
    \ 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433,\
    \ 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\
    \ 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641,\
    \ 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743,\
    \ 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857,\
    \ 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971,\
    \ 977, 983, 991, 997, 1009};\n    std::unordered_set<int> prime_set(primes.begin(),\
    \ primes.end());\n    std::istringstream iss(sentence);\n    std::vector<std::string>\
    \ words;\n    for (std::string word; iss >> word; ) {\n        words.push_back(word);\n\
    \    }\n    std\n}\nint main() {\n    auto candidate = words_in_sentence;\n  \
    \  assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdbjbrysf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdbjbrysf.cpp:27:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   27 | }\n      | ^\n/tmp/tmpdbjbrysf.cpp:27:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    int i = 0;\n    for (i = 0; i < sentence.size(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            words.push_back(sentence.substr(0, i));\n           \
    \ sentence = sentence.substr(i + 1);\n            i = 0;\n        }\n    }\n \
    \   words.push_back(sentence);\n    std::string ans;\n    for (i = 0; i < words.size();\
    \ i++) {\n        int flag = 0;\n        for (int j = 2; j < words[i].size();\
    \ j++) {\n            if (words[i].size() % j == 0) {\n                flag =\
    \ 1;\n                break;\n            }\n        }\n        if (flag == 0)\
    \ {\n            ans += words[i] + \" \";\n        }\n    }\n    return ans.substr(0,\
    \ ans.size() - 1);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp9fllen4x: /tmp/tmp9fllen4x.cpp:45: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098991
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.size() >= 1 &&\
    \ sentence.size() <= 100);\n    assert(std::all_of(sentence.begin(), sentence.end(),\
    \ isalpha));\n    sentence += ' ';\n    std::string word = \"\";\n    std::string\
    \ answer = \"\";\n    for (const char& c : sentence) {\n        if (isspace(c))\
    \ {\n            if (is_prime(word.size())) {\n                answer += word\
    \ + ' ';\n            }\n            word = \"\";\n        } else {\n        \
    \    word += c;\n        }\n    }\n    answer.pop_back();\n    return answer;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv8qbjk4n.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpv8qbjk4n.cpp:25:17: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   25 |             if (is_prime(word.size())) {\n      |      \
    \           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660098990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::vector<std::string>\
    \ word_vec;\n    std::vector<std::string> prime_word_vec;\n    // Populate the\
    \ word_vec\n    std::istringstream iss(sentence);\n    for (std::string word;\
    \ iss >> word; ) {\n        word_vec.push_back(word);\n    }\n    // For each\
    \ word in the word_vec,\n    // check if the word length is a prime number\n \
    \   for (int i = 0; i < word_vec.size(); i++) {\n        int len = word_vec[i].length();\n\
    \        if (len == 1) {\n            prime_word_vec.push_back(word_vec[i]);\n\
    \        } else {\n            // If a number is divisible by any number other\
    \ than 1 and itself,\n            // it is not a prime number\n            //\
    \ For example, 6 is not a prime number, because it is divisible by 1, 2, 3, and\
    \ 6.\n            // Another example, 11 is a prime number, because it is divisible\
    \ by 1 and 11 only.\n            // 1 is not a prime number, because it is divisible\
    \ by 1 only.\n            for (int j = 2; j < len; j++) {\n                if\
    \ (len % j == 0) {\n                    break;\n                } else if (j ==\
    \ len - 1) {\n                    prime_word_vec.push_back(word_vec[i]);\n   \
    \             }\n            }\n        }\n    }\n    // Construct the result\
    \ from the prime_word_vec\n    for (int i = 0; i < prime_word_vec.size(); i++)\
    \ {\n        result += prime_word_vec[i];\n        if (i != prime_word_vec.size()\
    \ - 1) {\n            result += \" \";\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmpla21r4u5: /tmp/tmpla21r4u5.cpp:58: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098991
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> result;\n\
    \  std::istringstream iss(sentence);\n  for (std::string s; iss >> s; ) {\n  \
    \  result.push_back(s);\n  }\n  std::string output;\n  for (int i = 0; i < result.size();\
    \ i++) {\n    int count = 0;\n    for (int j = 1; j <= result[i].size(); j++)\
    \ {\n      if (result[i].size() % j == 0) {\n        count++;\n      }\n    }\n\
    \    if (count == 2) {\n      output += result[i] + \" \";\n    }\n  }\n  return\
    \ output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  status: Exception
  stderr: 'tmp8exm8hry: /tmp/tmp8exm8hry.cpp:39: int main(): Assertion `candidate(("This
    is a test")) == ("is")'' failed.

    '
  stdout: ''
  timestamp: 1660098991
