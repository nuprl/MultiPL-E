name: HumanEval_153_Strongest_Extension
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name\
  \ of a class (a string) and a list of extensions.\n// The extensions are to be used\
  \ to load additional classes to the class. The\n// strength of the extension is\
  \ as follows: Let CAP be the number of the uppercase\n// letters in the extension's\
  \ name, and let SM be the number of lowercase letters \n// in the extension's name,\
  \ the strength is given by the fraction CAP - SM. \n// You should find the strongest\
  \ extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n\
  // If there are two or more extensions with the same strength, you should\n// choose\
  \ the one that comes first in the list.\n// For example, if you are given \"Slices\"\
  \ as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed']\
  \ then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the\
  \ strongest extension \n// (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string\
  \ class_name, std::vector<std::string> extensions) {\n"
tests: "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
  Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"\
  Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
  nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
  ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
  eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
  ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"\
  t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
  Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
  YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\",\
  \ \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
  finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"})))\
  \ == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
  Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
  671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
completions: ["\tfloat maxStrength = 0;\n\tstd::string strongest;\n\tfor (std::string\
    \ s : extensions) {\n\t\tfloat CAP = 0;\n\t\tfloat SM = 0;\n\t\tfor (char c :\
    \ s) {\n\t\t\tif (c >= 'A' && c <= 'Z') {\n\t\t\t\tCAP++;\n\t\t\t}\n\t\t\telse\
    \ if (c >= 'a' && c <= 'z') {\n\t\t\t\tSM++;\n\t\t\t}\n\t\t}\n\t\tfloat strength\
    \ = CAP - SM;\n\t\tif (strength > maxStrength) {\n\t\t\tmaxStrength = strength;\n\
    \t\t\tstrongest = s;\n\t\t}\n\t}\n\treturn class_name + \".\" + strongest;", "\t\
    float strength = -1.0;\n\tstd::string strongest_extension = \"\";\n\tint lower_case\
    \ = 0;\n\tint upper_case = 0;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\
    \t\tlower_case = 0;\n\t\tupper_case = 0;\n\t\tfor (int j = 0; j < extensions[i].length();\
    \ j++) {\n\t\t\tif (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\
    \t\tlower_case++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'A' && extensions[i][j]\
    \ <= 'Z') {\n\t\t\t\tupper_case++;\n\t\t\t}\n\t\t}\n\t\tif (strength < (upper_case\
    \ - lower_case)) {\n\t\t\tstrength = upper_case - lower_case;\n\t\t\tstrongest_extension\
    \ = extensions[i];\n\t\t}\n\t}\n\tclass_name += \".\";\n\tclass_name += strongest_extension;\n\
    \treturn class_name;", "  float strength = 0;\n  std::string result;\n  std::map<float,\
    \ std::string> map;\n  std::map<float, std::string>::iterator it;\n  for (auto\
    \ i : extensions) {\n    int CAP = 0;\n    int SM = 0;\n    for (auto j : i) {\n\
    \      if (isupper(j)) {\n        CAP++;\n      } else {\n        SM++;\n    \
    \  }\n    }\n    map.insert(std::pair<float, std::string>(CAP - SM, i));\n  }\n\
    \  for (it = map.begin(); it != map.end(); it++) {\n    if (it->first >= strength)\
    \ {\n      strength = it->first;\n      result = it->second;\n    }\n  }\n  return\
    \ class_name + \".\" + result;", "\tfloat max = -2;\n\tint s, l;\n\tfor (int i\
    \ = 0; i < extensions.size(); i++) {\n\t\ts = 0;\n\t\tl = 0;\n\t\tfor (int j =\
    \ 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j]\
    \ <= 'Z') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' &&\
    \ extensions[i][j] <= 'z') {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (s - l > max)\
    \ {\n\t\t\tmax = s - l;\n\t\t}\n\t}\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\ts = 0;\n\t\tl = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\
    \t\ts++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j]\
    \ <= 'z') {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (s - l == max) {\n\t\t\treturn\
    \ class_name + \".\" + extensions[i];\n\t\t}\n\t}", "    assert(extensions.size()\
    \ > 0);\n    int mx = -1;\n    int idx = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        int cap = 0, sm = 0;\n        for (auto x : extensions[i]) {\n\
    \            if (isupper(x)) {\n                cap++;\n            } else {\n\
    \                sm++;\n            }\n        }\n        if (cap - sm > mx) {\n\
    \            mx = cap - sm;\n            idx = i;\n        }\n    }\n    std::string\
    \ ans = class_name + \".\" + extensions[idx];\n    return ans;", "    std::string\
    \ strongest_extension = \"\";\n    double strength = 0.0;\n    for (auto ext :\
    \ extensions) {\n        int cap = 0;\n        int sm = 0;\n        for (auto\
    \ c : ext) {\n            if (isupper(c)) cap++;\n            else if (islower(c))\
    \ sm++;\n        }\n        double curr_strength = (double)cap - (double)sm;\n\
    \        if (curr_strength > strength) {\n            strength = curr_strength;\n\
    \            strongest_extension = ext;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;", "    std::string res = class_name;\n    int\
    \ max = INT_MIN;\n    for (auto it = extensions.begin(); it != extensions.end();\
    \ ++it) {\n        int cap = 0, small = 0;\n        for (char& x : *it) {\n  \
    \          if (isupper(x)) cap++;\n            else small++;\n        }\n    \
    \    int str = cap - small;\n        if (str > max) {\n            max = str;\n\
    \            res += '.' + *it;\n        }\n    }\n    return res;", "\tdouble\
    \ strong=0;\n\tstd::string str = \"\";\n\tfor(int i=0;i<extensions.size();i++){\n\
    \t\tint up=0,low=0;\n\t\tfor(int j=0;j<extensions[i].length();j++){\n\t\t\tif(extensions[i][j]>='A'\
    \ && extensions[i][j]<='Z'){\n\t\t\t\tup++;\n\t\t\t}\n\t\t\telse if(extensions[i][j]>='a'\
    \ && extensions[i][j]<='z'){\n\t\t\t\tlow++;\n\t\t\t}\n\t\t}\n\t\tif(strong <\
    \ (up-low)){\n\t\t\tstrong = up-low;\n\t\t\tstr = extensions[i];\n\t\t}\n\t}\n\
    \treturn class_name+\".\"+str;", "    assert(class_name.length() > 0);\n    //\
    \ your code here\n    std::string ans;\n    std::string str;\n    // -1 is to\
    \ make sure we do not consider the '\\0' at the end of the string\n    int difference\
    \ = -1;\n    int diff;\n    int uppercase_count;\n    int lowercase_count;\n \
    \   for (int i = 0; i < extensions.size(); i++) {\n        // reset the values\
    \ of lowercase and uppercase count\n        uppercase_count = 0;\n        lowercase_count\
    \ = 0;\n        for (int j = 0; j < extensions[i].length(); j++) {\n         \
    \   if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n              \
    \  uppercase_count++;\n            }\n            else if (extensions[i][j] >=\
    \ 'a' && extensions[i][j] <= 'z') {\n                lowercase_count++;\n    \
    \        }\n        }\n        diff = uppercase_count - lowercase_count;\n   \
    \     if (diff > difference) {\n            difference = diff;\n            ans\
    \ = extensions[i];\n        }\n    }\n    str = class_name + \".\" + ans;\n  \
    \  return str;", "\tfloat maxStrength{-1};\n\tstd::string maxName;\n\tfor (auto\
    \ extension : extensions) {\n\t\tfloat strength{0};\n\t\tfor (auto ch : extension)\
    \ {\n\t\t\tif (isupper(ch)) {\n\t\t\t\tstrength++;\n\t\t\t} else if (islower(ch))\
    \ {\n\t\t\t\tstrength--;\n\t\t\t}\n\t\t}\n\t\tif (strength > maxStrength) {\n\t\
    \t\tmaxStrength = strength;\n\t\t\tmaxName = extension;\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + maxName;", "  std::string sol=\"\";\n  int cap,cap_max=0,sm,sm_max=0;\n\
    \  for(int i=0;i<extensions.size();i++){\n    cap=0;sm=0;\n    for(int j=0;j<extensions[i].size();j++){\n\
    \      if(extensions[i][j]>='A' && extensions[i][j]<='Z')\n      cap++;\n    \
    \  else if(extensions[i][j]>='a' && extensions[i][j]<='z')\n      sm++;\n    }\n\
    \    if(cap-sm>cap_max-sm_max){\n      cap_max=cap;\n      sm_max=sm;\n      sol=extensions[i];\n\
    \    }\n  }\n  return class_name+\".\"+sol;", "    // your code here\n    float\
    \ max = -20;\n    int pos = 0;\n    for(int i = 0; i < extensions.size(); i++){\n\
    \        int count = 0;\n        int count1 = 0;\n        for(int j = 0; j < extensions[i].size();\
    \ j++){\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z'){\n\
    \                count++;\n            }\n            else if(extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z'){\n                count1++;\n           \
    \ }\n        }\n        float val = (float)count - (float)count1;\n        if(val\
    \ > max){\n            max = val;\n            pos = i;\n        }\n    }\n  \
    \  return class_name + \".\" + extensions[pos];", "\tint strongest = 0;\n\tstd::string\
    \ strongest_extension;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\t\
    int CAP = 0;\n\t\tint SM = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++)\
    \ {\n\t\t\tif (isupper(extensions[i][j])) {\n\t\t\t\tCAP++;\n\t\t\t}\n\t\t\telse\
    \ if (islower(extensions[i][j])) {\n\t\t\t\tSM++;\n\t\t\t}\n\t\t}\n\t\tint strength\
    \ = CAP - SM;\n\t\tif (strength > strongest) {\n\t\t\tstrongest = strength;\n\t\
    \t\tstrongest_extension = extensions[i];\n\t\t}\n\t}\n\treturn class_name + \"\
    .\" + strongest_extension;", "  std::string strongest;\n  double strongest_strength\
    \ = -100.0;\n  double strength;\n  int up_count;\n  int down_count;\n  for (int\
    \ i = 0; i < extensions.size(); i++) {\n    up_count = 0;\n    down_count = 0;\n\
    \    for (int j = 0; j < extensions[i].size(); j++) {\n      if (isupper(extensions[i][j]))\
    \ {\n        up_count++;\n      } else {\n        down_count++;\n      }\n   \
    \ }\n    strength = up_count - down_count;\n    if (strength > strongest_strength)\
    \ {\n      strongest_strength = strength;\n      strongest = extensions[i];\n\
    \    }\n  }\n  return class_name + \".\" + strongest;", "    std::string output;\n\
    \    int max = 0;\n    int count = 0;\n    for (std::string i : extensions) {\n\
    \        int j = 0;\n        int k = 0;\n        while (i[j]) {\n            if\
    \ (std::isupper(i[j])) {\n                k++;\n            }\n            j++;\n\
    \        }\n        if (max < k - (j - k)) {\n            max = k - (j - k);\n\
    \            output = i;\n        }\n    }\n    return class_name + \".\" + output;",
  "    double cap = 0;\n    double sm = 0;\n    std::string result = \"\";\n    double\
    \ temp_strongest = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n   \
    \     cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] > 64 && extensions[i][j] < 91) {\n\
    \                cap++;\n            }\n            else if (extensions[i][j]\
    \ > 96 && extensions[i][j] < 123) {\n                sm++;\n            }\n  \
    \      }\n        if (i == 0) {\n            temp_strongest = cap - sm;\n    \
    \        result = extensions[i];\n        }\n        else if (cap - sm > temp_strongest)\
    \ {\n            temp_strongest = cap - sm;\n            result = extensions[i];\n\
    \        }\n    }\n    return class_name + \".\" + result;", "\tint max_strength\
    \ = 0;\n\tint idx = 0;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\t\
    int up = 0;\n\t\tint low = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++)\
    \ {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\t\
    up++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <=\
    \ 'z') {\n\t\t\t\tlow++;\n\t\t\t}\n\t\t}\n\t\tif (up - low > max_strength) {\n\
    \t\t\tmax_strength = up - low;\n\t\t\tidx = i;\n\t\t}\n\t}\n\treturn class_name\
    \ + \".\" + extensions[idx];", "    // write your code here\n    int n = extensions.size();\n\
    \    int max_strength = -100000;\n    std::string res = \"\";\n    for(int i =\
    \ 0; i < n; i++) {\n        int cap = 0, sm = 0;\n        for(int j = 0; j < extensions[i].size();\
    \ j++) {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\
    \                cap++;\n            }\n            else if(extensions[i][j] >=\
    \ 'a' && extensions[i][j] <= 'z') {\n                sm++;\n            }\n  \
    \      }\n        if(cap - sm > max_strength) {\n            max_strength = cap\
    \ - sm;\n            res = extensions[i];\n        }\n    }\n    return class_name\
    \ + \".\" + res;", "    double max = INT_MIN;\n    int i = 0;\n    std::string\
    \ ret = \"\";\n    while(i < extensions.size()) {\n        double cap = 0, sm\
    \ = 0;\n        for(int j = 0; j < extensions[i].size(); j++) {\n            if(isupper(extensions[i][j]))\
    \ {\n                cap++;\n            } else {\n                sm++;\n   \
    \         }\n        }\n        if(cap-sm > max) {\n            max = cap-sm;\n\
    \            ret = extensions[i];\n        }\n        i++;\n    }\n    return\
    \ class_name + \".\" + ret;", "  int max_strength = -1;\n  int max_index = -1;\n\
    \  for (int i = 0; i < extensions.size(); i++) {\n    int upper = 0;\n    int\
    \ lower = 0;\n    for (char c : extensions[i]) {\n      if (isupper(c)) {\n  \
    \      upper++;\n      } else {\n        lower++;\n      }\n    }\n    int strength\
    \ = upper - lower;\n    if (strength > max_strength) {\n      max_strength = strength;\n\
    \      max_index = i;\n    }\n  }\n  if (max_index == -1) {\n    return class_name;\n\
    \  }\n  return class_name + \".\" + extensions[max_index];", "\tif (extensions.size()\
    \ == 0)\n\t\treturn class_name;\n\tint max_strength = 0;\n\tint max_index = 0;\n\
    \tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint cap = 0;\n\t\tint sm\
    \ = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (isupper(extensions[i][j]))\n\
    \t\t\t\tcap++;\n\t\t\telse\n\t\t\t\tsm++;\n\t\t}\n\t\tif (cap - sm > max_strength)\
    \ {\n\t\t\tmax_strength = cap - sm;\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + extensions[max_index];", "    int max_strength = -1;\n\
    \    std::string strongest_extension;\n    for (auto& extension : extensions)\
    \ {\n        int strength = 0;\n        for (auto& ch : extension) {\n       \
    \     if (std::isupper(ch)) {\n                strength++;\n            } else\
    \ {\n                strength--;\n            }\n        }\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;",
  "    float max = 0.0f;\n    std::string result;\n    for (auto extension : extensions)\
    \ {\n        int uppers = 0;\n        int lowers = 0;\n        for (auto letter\
    \ : extension) {\n            if (isupper(letter)) {\n                uppers++;\n\
    \            } else {\n                lowers++;\n            }\n        }\n \
    \       float curr_strength = (float)uppers - (float)lowers;\n        if (curr_strength\
    \ > max) {\n            max = curr_strength;\n            result = extension;\n\
    \        }\n    }\n    return class_name + \".\" + result;", "\tstd::cout << \"\
    Got class_name = \" << class_name << \"\\n\";\n\tstd::cout << \"Got extensions\
    \ = \";\n\tfor (auto s : extensions) {\n\t\tstd::cout << s << \" \";\n\t}\n\t\
    std::cout << \"\\n\";\n\tdouble maxStrength = 0;\n\tstd::string maxExtension =\
    \ \"\";\n\tfor (auto s : extensions) {\n\t\tint upper = 0;\n\t\tint lower = 0;\n\
    \t\tfor (auto ch : s) {\n\t\t\tif (std::isupper(ch)) {\n\t\t\t\tupper++;\n\t\t\
    \t} else {\n\t\t\t\tlower++;\n\t\t\t}\n\t\t}\n\t\tdouble currStrength = (double)upper\
    \ - (double)lower;\n\t\tif (currStrength > maxStrength) {\n\t\t\tmaxStrength =\
    \ currStrength;\n\t\t\tmaxExtension = s;\n\t\t}\n\t}\n\treturn class_name + \"\
    .\" + maxExtension;", "\t// Write your code here\n\tdouble max = -1;\n\tint index\
    \ = 0;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tdouble strength =\
    \ 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (isupper(extensions[i][j]))\
    \ {\n\t\t\t\tstrength += 1;\n\t\t\t}\n\t\t\telse if (islower(extensions[i][j]))\
    \ {\n\t\t\t\tstrength -= 1;\n\t\t\t}\n\t\t}\n\t\tif (strength > max) {\n\t\t\t\
    max = strength;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tstd::string result = class_name\
    \ + \".\" + extensions[index];\n\treturn result;", "  int strength = 0;\n  std::string\
    \ answer = \"\";\n  for (int i = 0; i < extensions.size(); i++) {\n    std::string\
    \ current = extensions[i];\n    int sm = 0;\n    int cap = 0;\n    for (int j\
    \ = 0; j < current.length(); j++) {\n      if (isupper(current[j])) {\n      \
    \  cap++;\n      } else {\n        sm++;\n      }\n    }\n    int current_strength\
    \ = cap - sm;\n    if (current_strength > strength) {\n      strength = current_strength;\n\
    \      answer = class_name + \".\" + current;\n    }\n  }\n  return answer;",
  "    float max_strength = INT_MIN;\n    std::string strongest_ext;\n    for(std::string&\
    \ i : extensions) {\n        float temp = 0;\n        for(char c : i) {\n    \
    \        if(std::isupper(c)) {\n                temp++;\n            } else {\n\
    \                temp--;\n            }\n        }\n        if(temp > max_strength)\
    \ {\n            max_strength = temp;\n            strongest_ext = i;\n      \
    \  }\n    }\n    return class_name + \".\" + strongest_ext;", "    //Find the\
    \ number of upper case letters\n    auto NumerUpper = [](std::string name) {\n\
    \        auto NumUpper = [](char c) { return c >= 'A' && c <= 'Z'; };\n      \
    \  return std::count_if(name.begin(), name.end(), NumUpper);\n    };\n    //Find\
    \ the number of lower case letters\n    auto NumLower = [](std::string name) {\n\
    \        auto NumLower = [](char c) { return c >= 'a' && c <= 'z'; };\n      \
    \  return std::count_if(name.begin(), name.end(), NumLower);\n    };\n    //Calculate\
    \ the strength of a string\n    auto Strength = [NumerUpper, NumLower](std::string\
    \ name) {\n        return NumerUpper(name) - NumLower(name);\n    };\n    //Find\
    \ the strongest extension\n    auto Strongest = [&Strength](std::string name1,\
    \ std::string name2) {\n        return Strength(name1) < Strength(name2);\n  \
    \  };\n    std::string str = class_name + \".\" + *std::max_element(extensions.begin(),\
    \ extensions.end(), Strongest);\n    return str;", "    int max = 0;\n    int\
    \ uppercase = 0;\n    int lowercase = 0;\n    int index = 0;\n    for (int i =\
    \ 0; i < extensions.size(); i++) {\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\
    \ {\n                uppercase++;\n            } else if (extensions[i][j] >=\
    \ 'a' && extensions[i][j] <= 'z') {\n                lowercase++;\n          \
    \  }\n        }\n        int current = uppercase - lowercase;\n        if (current\
    \ > max) {\n            max = current;\n            index = i;\n        }\n  \
    \      uppercase = 0;\n        lowercase = 0;\n    }\n    return class_name +\
    \ \".\" + extensions[index];", "    double strength = INT_MIN;\n    std::string\
    \ strongest_extension = \"\";\n    for (std::string extension : extensions) {\n\
    \        int cap = 0, sm = 0;\n        for (char c : extension) {\n          \
    \  if (isupper(c)) cap++;\n            else sm++;\n        }\n        double curr_strength\
    \ = (double)cap - sm;\n        if (curr_strength > strength) {\n            strength\
    \ = curr_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension;", "\tint max = 0;\n\
    \tstd::string strong;\n\tfor (std::string s : extensions) {\n\t\tint num_cap =\
    \ 0;\n\t\tint num_sm = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\
    if (std::isupper(s[i])) {\n\t\t\t\tnum_cap++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\
    num_sm++;\n\t\t\t}\n\t\t}\n\t\tif (max < num_cap - num_sm) {\n\t\t\tmax = num_cap\
    \ - num_sm;\n\t\t\tstrong = s;\n\t\t}\n\t}\n\treturn class_name + \".\" + strong;",
  "    std::string result = class_name;\n    double max_strength = INT_MIN;\n    for\
    \ (auto e : extensions) {\n        double strength = 0;\n        for (auto c :\
    \ e) {\n            if (isupper(c)) {\n                strength++;\n         \
    \   } else {\n                strength--;\n            }\n        }\n        if\
    \ (strength > max_strength) {\n            max_strength = strength;\n        \
    \    result += \".\" + e;\n        }\n    }\n    return result;", "    float max\
    \ = 0;\n    int index = 0;\n    for(unsigned int i = 0; i < extensions.size();\
    \ i++) {\n        int CAP = 0;\n        int SM = 0;\n        for(unsigned int\
    \ j = 0; j < extensions[i].size(); j++) {\n            if(extensions[i][j] >=\
    \ 'A' && extensions[i][j] <= 'Z') {\n                CAP++;\n            }\n \
    \           else if(extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n  \
    \              SM++;\n            }\n        }\n        float s = CAP - SM;\n\
    \        if(s >= max) {\n            max = s;\n            index = i;\n      \
    \  }\n    }\n    return class_name + \".\" + extensions[index];", "\tint cap =\
    \ 0, sm = 0, max = -2;\n\tstd::string str;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tstd::string s = extensions[i];\n\t\tfor (int j = 0; j < s.length();\
    \ j++) {\n\t\t\tif (isupper(s[j])) {\n\t\t\t\tcap++;\n\t\t\t}\n\t\t\telse {\n\t\
    \t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tif (cap - sm > max) {\n\t\t\tmax = cap - sm;\n\
    \t\t\tstr = s;\n\t\t}\n\t\tcap = 0;\n\t\tsm = 0;\n\t}\n\treturn class_name + \"\
    .\" + str;", "    std::string result = class_name + \".\";\n    float max = 0;\n\
    \    for (int i = 0; i < extensions.size(); i++) {\n        int cap = 0;\n   \
    \     int sm = 0;\n        for (int j = 0; j < extensions[i].size(); j++) {\n\
    \            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n       \
    \         cap++;\n            else\n                sm++;\n        }\n       \
    \ float a = (float)cap - (float)sm;\n        if (i == 0) {\n            max =\
    \ a;\n            result += extensions[i];\n        }\n        else {\n      \
    \      if (a > max) {\n                max = a;\n                result = class_name\
    \ + \".\" + extensions[i];\n            }\n        }\n    }\n    return result;",
  "\tfloat max_strength = 0;\n\tstd::string result = \"\";\n\tfor (int i = 0; i <\
    \ extensions.size(); i++) {\n\t\tfloat uppercase = 0;\n\t\tfloat lowercase = 0;\n\
    \t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tuppercase++;\n\t\t\t}\n\t\t\t\
    else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\t\tlowercase++;\n\
    \t\t\t}\n\t\t}\n\t\tif (uppercase - lowercase > max_strength) {\n\t\t\tmax_strength\
    \ = uppercase - lowercase;\n\t\t\tresult = extensions[i];\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + result;", "\tfloat strength, max_strength = 0;\n\tstd::string\
    \ strongest_extension;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\t\
    strength = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif\
    \ (isupper(extensions[i][j]))\n\t\t\t\tstrength++;\n\t\t\telse\n\t\t\t\tstrength--;\n\
    \t\t}\n\t\tif (strength > max_strength) {\n\t\t\tmax_strength = strength;\n\t\t\
    \tstrongest_extension = extensions[i];\n\t\t}\n\t}\n\treturn class_name + \".\"\
    \ + strongest_extension;", "    std::string result = class_name;\n    int strength\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        std::string\
    \ temp = extensions[i];\n        int cap = 0;\n        int sm = 0;\n        for\
    \ (int j = 0; j < temp.length(); j++) {\n            if (temp[j] >= 'A' && temp[j]\
    \ <= 'Z') {\n                cap++;\n            } else if (temp[j] >= 'a' &&\
    \ temp[j] <= 'z') {\n                sm++;\n            }\n        }\n       \
    \ if (cap - sm > strength) {\n            strength = cap - sm;\n            result\
    \ = class_name + \".\" + temp;\n        }\n    }\n    return result;", "    int\
    \ num_uppercase = 0;\n    int num_lowercase = 0;\n    double strength = 0;\n \
    \   int index = 0;\n    double max_strength = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        for (int j = 0; j < extensions[i].size(); j++) {\n         \
    \   if (isupper(extensions[i][j])) {\n                num_uppercase++;\n     \
    \       } else {\n                num_lowercase++;\n            }\n        }\n\
    \        strength = num_uppercase - num_lowercase;\n        if (strength > max_strength)\
    \ {\n            max_strength = strength;\n            index = i;\n        }\n\
    \        num_uppercase = 0;\n        num_lowercase = 0;\n    }\n    return class_name\
    \ + \".\" + extensions[index];", "    // Your code here\n    double max = 0;\n\
    \    int index = 0;\n    int i = 0;\n    for(auto &el : extensions){\n       \
    \ double cap = 0;\n        double small = 0;\n        double fraction = 0;\n \
    \       for(auto &c : el){\n            if(isupper(c))\n                cap++;\n\
    \            else if(islower(c))\n                small++;\n        }\n      \
    \  fraction = cap - small;\n        if(fraction > max){\n            max = fraction;\n\
    \            index = i;\n        }\n        i++;\n    }\n    return class_name\
    \ + \".\" + extensions[index];", "  int max = 0;\n  int index = 0;\n  for (int\
    \ i = 0; i < extensions.size(); i++) {\n    int c = 0;\n    int l = 0;\n    for\
    \ (int j = 0; j < extensions[i].size(); j++) {\n      if (isupper(extensions[i][j]))\n\
    \        c++;\n      else\n        l++;\n    }\n    if (c - l > max) {\n     \
    \ max = c - l;\n      index = i;\n    }\n  }\n  std::string class_extension =\
    \ class_name + \".\" + extensions[index];\n  return class_extension;", "    //\
    \ write your code here...\n    float max_val = 0;\n    std::string max_extension;\n\
    \    for(int i = 0; i < extensions.size(); i++) {\n        int CAP = 0;\n    \
    \    int SM = 0;\n        for(int j = 0; j < extensions[i].size(); j++) {\n  \
    \          if(isupper(extensions[i][j])) {\n                CAP++;\n         \
    \   } else {\n                SM++;\n            }\n        }\n        if(CAP-SM\
    \ > max_val) {\n            max_val = CAP-SM;\n            max_extension = extensions[i];\n\
    \        }\n    }\n    return class_name + \".\" + max_extension;", "  double\
    \ streng = 0;\n  int i;\n  std::string strongest_extension;\n  for (i = 0; i <\
    \ extensions.size(); i++) {\n    int upperCase = 0;\n    int lowerCase = 0;\n\
    \    int j;\n    for (j = 0; j < extensions[i].size(); j++) {\n      if (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n        upperCase++;\n      } else if\
    \ (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n        lowerCase++;\n\
    \      }\n    }\n    if (upperCase - lowerCase > streng) {\n      streng = upperCase\
    \ - lowerCase;\n      strongest_extension = extensions[i];\n    }\n  }\n  return\
    \ class_name + \".\" + strongest_extension;", "    // Your code here\n    std::string\
    \ res;\n    int max = 0;\n    for(int i = 0; i < extensions.size(); i++) {\n \
    \       int up = 0;\n        int low = 0;\n        for(int j = 0; j < extensions[i].size();\
    \ j++) {\n            if(isupper(extensions[i][j])) {\n                up++;\n\
    \            } else {\n                low++;\n            }\n        }\n    \
    \    int stre = up - low;\n        if(stre > max) {\n            max = stre;\n\
    \            res = extensions[i];\n        }\n    }\n    return class_name + \"\
    .\" + res;", "    std::string bestExtension;\n    double bestStrength = -999999;\n\
    \    for (int i = 0; i < extensions.size(); i++) {\n        int upperCount = 0;\n\
    \        int lowerCount = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                upperCount++;\n\
    \            } else {\n                lowerCount++;\n            }\n        }\n\
    \        double strength = (double)upperCount / (double)lowerCount;\n        if\
    \ (strength > bestStrength) {\n            bestStrength = strength;\n        \
    \    bestExtension = extensions[i];\n        }\n    }\n    return class_name +\
    \ \".\" + bestExtension;", "\tstd::string ans = class_name;\n\tfloat f = 0;\n\t\
    for (std::string x : extensions) {\n\t\tfloat fx = 0;\n\t\tfor (int i = 0; i <\
    \ x.size(); i++) {\n\t\t\tif (isupper(x[i])) {\n\t\t\t\tfx += 1;\n\t\t\t}\n\t\t\
    \telse if (islower(x[i])) {\n\t\t\t\tfx -= 1;\n\t\t\t}\n\t\t}\n\t\tif (f < fx)\
    \ {\n\t\t\tf = fx;\n\t\t\tans = class_name + \".\" + x;\n\t\t}\n\t}\n\treturn\
    \ ans;", "\tint count1=0,count2=0,count3=0,count4=0;\n\tstd::string extension1,extension2,extension3,extension4;\n\
    \tfloat  str1=0,str2=0,str3=0,str4=0;\n\tfor(int i=0;i<extensions.size();i++)\n\
    \t{\n\t\tcount1=0;count2=0;\n\t\tfor(int j=0;j<extensions[i].size();j++)\n\t\t\
    {\n\t\t\tif(isupper(extensions[i][j]))\n\t\t\t{\n\t\t\t\tcount1++;\n\t\t\t}\n\t\
    \t\telse if(islower(extensions[i][j]))\n\t\t\t{\n\t\t\t\tcount2++;\n\t\t\t}\n\t\
    \t}\n\t\tif(count1-count2 > str1)\n\t\t{\n\t\t\tstr1=count1-count2;\n\t\t\textension1=extensions[i];\n\
    \t\t}\n\t\telse if(count1-count2 == str1)\n\t\t{\n\t\t\textension1=extensions[i];\n\
    \t\t}\n\t}\n\tfor(int i=0;i<extensions.size();i++)\n\t{\n\t\tcount3=0;count4=0;\n\
    \t\tfor(int j=0;j<extensions[i].size();j++)\n\t\t{\n\t\t\tif(isupper(extensions[i][j]))\n\
    \t\t\t{\n\t\t\t\tcount3++;\n\t\t\t}\n\t\t\telse if(islower(extensions[i][j]))\n\
    \t\t\t{\n\t\t\t\tcount4++;\n\t\t\t}\n\t\t}\n\t\tif(count3-count4 > str2)\n\t\t\
    {\n\t\t\tstr2=count3-count4;\n\t\t\textension2=extensions[i];\n\t\t}\n\t\telse\
    \ if(count3-count4 == str2)\n\t\t{\n\t\t\textension2=extensions[i];\n\t\t}\n\t\
    }\n\tfor", "\t// converts the string to upper case and finds the longest one\n\
    \tauto getUpper = [](std::string s) {\n\t\tstd::transform(s.begin(), s.end(),\
    \ s.begin(), ::toupper);\n\t\treturn s;\n\t};\n\t// converts the string to lower\
    \ case and finds the longest one\n\tauto getLower = [](std::string s) {\n\t\t\
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n\t\treturn s;\n\t};\n\
    \t// calculates the strength of the extension\n\tauto strength = [](std::string\
    \ s) {\n\t\treturn (int)std::count_if(s.begin(), s.end(), ::isupper) -\n\t\t\t\
    (int)std::count_if(s.begin(), s.end(), ::islower);\n\t};\n\t// gets the first\
    \ extension with the maximum strength\n\tauto maxStrength = [](std::vector<std::string>\
    \ v) {\n\t\tauto max = std::max_element(v.begin(), v.end(), [](std::string s1,\
    \ std::string s2) {\n\t\t\treturn strength(s1) < strength(s2);\n\t\t});\n\t\t\
    return max != v.end() ? *max : \"\";\n\t};\n\t// gets the extension with the max\
    \ strength\n\tstd::string strongest_extension = maxStrength(extensions);\n\t//\
    \ returns the string with format: ClassName.StrongestExtensionName\n\treturn class_name\
    \ + \".\" + strongest_extension;", "\tint strength = -2147483647;\n\tstd::string\
    \ result = \"\";\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint cap\
    \ = 0;\n\t\tint sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\
    \t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tcap++;\n\
    \t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\
    \t\t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tint temp = cap - sm;\n\t\tif (temp > strength)\
    \ {\n\t\t\tstrength = temp;\n\t\t\tresult = extensions[i];\n\t\t}\n\t}\n\tresult\
    \ = class_name + \".\" + result;\n\treturn result;", "    if (extensions.size()\
    \ == 0) return class_name;\n    double max = 0;\n    int idx = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        int cap = 0;\n        int small\
    \ = 0;\n        for (int j = 0; j < extensions[i].size(); j++) {\n           \
    \ if (isupper(extensions[i][j])) cap++;\n            else small++;\n        }\n\
    \        double tmp = cap - small;\n        if (max < tmp) {\n            max\
    \ = tmp;\n            idx = i;\n        }\n    }\n    return class_name + \".\"\
    \ + extensions[idx];", "    double d = -100.0;\n    std::string result = \"\"\
    ;\n    int i, j;\n    for (i = 0; i < extensions.size(); i++) {\n        int CAP\
    \ = 0, SM = 0;\n        for (j = 0; j < extensions[i].size(); j++) {\n       \
    \     if (isupper(extensions[i][j])) {\n                CAP++;\n            }\
    \ else {\n                SM++;\n            }\n        }\n        double temp\
    \ = CAP - SM;\n        if (temp > d) {\n            d = temp;\n            result\
    \ = extensions[i];\n        }\n    }\n    return class_name + \".\" + result;",
  "  double max = 0;\n  std::string res = \"\";\n  std::vector<double> strengths;\n\
    \  for (int i = 0; i < extensions.size(); i++) {\n    int cap = 0;\n    int sm\
    \ = 0;\n    for (int j = 0; j < extensions[i].size(); j++) {\n      if (isupper(extensions[i][j]))\
    \ {\n        cap++;\n      } else {\n        sm++;\n      }\n    }\n    double\
    \ strength = cap - sm;\n    if (strength > max) {\n      max = strength;\n   \
    \   res = extensions[i];\n    }\n  }\n  return class_name + \".\" + res;", " \
    \   int max = INT_MIN;\n    std::string ans = \"\";\n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        int caps = 0, small = 0;\n        for(char a : extensions[i])\
    \ {\n            if(isupper(a)) caps++;\n            else small++;\n        }\n\
    \        int strength = caps - small;\n        if(strength > max) {\n        \
    \    max = strength;\n            ans = extensions[i];\n        }\n    }\n   \
    \ return class_name + \".\" + ans;", "    size_t uppercase_letters, lowercase_letters;\n\
    \    float strength, max_strength = 0;\n    std::string strongest_extension;\n\
    \    for (auto& extension : extensions) {\n        uppercase_letters = std::count_if(extension.begin(),\
    \ extension.end(), isupper);\n        lowercase_letters = std::count_if(extension.begin(),\
    \ extension.end(), islower);\n        strength = uppercase_letters - lowercase_letters;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;", "\tdouble best = -1.0;\n\tstd::string strongest\
    \ = \"\";\n\tfor (std::string s : extensions) {\n\t\tint CAP = 0;\n\t\tint SM\
    \ = 0;\n\t\tfor (char c : s) {\n\t\t\tif (isupper(c)) CAP++;\n\t\t\telse if (islower(c))\
    \ SM++;\n\t\t}\n\t\tdouble strength = CAP - SM;\n\t\tif (strength > best) {\n\t\
    \t\tbest = strength;\n\t\t\tstrongest = s;\n\t\t}\n\t}\n\treturn class_name +\
    \ \".\" + strongest;", "    std::string strongest = \"\";\n    double strongest_strength\
    \ = 0;\n    std::transform(class_name.begin(), class_name.end(), class_name.begin(),\
    \ ::tolower);\n    for (auto i = extensions.begin(); i != extensions.end(); i++)\
    \ {\n        int capital_letters = 0;\n        int small_letters = 0;\n      \
    \  for (auto j = i->begin(); j != i->end(); j++) {\n            if (*j >= 'A'\
    \ && *j <= 'Z') {\n                capital_letters++;\n            } else if (*j\
    \ >= 'a' && *j <= 'z') {\n                small_letters++;\n            }\n  \
    \      }\n        double strength = double(capital_letters - small_letters);\n\
    \        if (strength >= strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest = *i;\n        }\n    }\n    std::transform(strongest.begin(),\
    \ strongest.end(), strongest.begin(), ::toupper);\n    return class_name + \"\
    .\" + strongest;", "\tfloat strongest_strength = 0.0;\n\tstd::string strongest_extension\
    \ = \"\";\n\tfor (std::string s : extensions) {\n\t\tfloat strength = 0.0;\n\t\
    \tfor (char c : s) {\n\t\t\tif (isupper(c)) {\n\t\t\t\tstrength++;\n\t\t\t}\n\t\
    \t\telse if (islower(c)) {\n\t\t\t\tstrength--;\n\t\t\t}\n\t\t}\n\t\tif (strength\
    \ > strongest_strength) {\n\t\t\tstrongest_strength = strength;\n\t\t\tstrongest_extension\
    \ = s;\n\t\t}\n\t}\n\treturn class_name + \".\" + strongest_extension;", "\tauto\
    \ strongest = std::max_element(\n\t\textensions.begin(),\n\t\textensions.end(),\n\
    \t\t[](const std::string& a, const std::string& b) {\n\t\t\treturn std::count_if(a.begin(),\
    \ a.end(), isupper) -\n\t\t\t\tstd::count_if(a.begin(), a.end(), islower) >\n\t\
    \t\t\tstd::count_if(b.begin(), b.end(), isupper) -\n\t\t\t\tstd::count_if(b.begin(),\
    \ b.end(), islower);\n\t\t});\n\tif (strongest == extensions.end()) {\n\t\treturn\
    \ class_name;\n\t}\n\treturn class_name + \".\" + *strongest;", "    int strength\
    \ = 0;\n    int idx = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n\
    \        int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                cap++;\n\
    \            } else {\n                sm++;\n            }\n        }\n     \
    \   if (cap - sm > strength) {\n            strength = cap - sm;\n           \
    \ idx = i;\n        }\n    }\n    return class_name + \".\" + extensions[idx];",
  "    double strongest = INT_MIN;\n    std::string extension;\n    for (int i = 0;\
    \ i < extensions.size(); i++) {\n        int lower = 0;\n        int upper = 0;\n\
    \        for (int j = 0; j < extensions[i].size(); j++) {\n            if (extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z') {\n                lower++;\n           \
    \ } else if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n         \
    \       upper++;\n            }\n        }\n        double curr = upper - lower;\n\
    \        if (curr > strongest) {\n            strongest = curr;\n            extension\
    \ = extensions[i];\n        }\n    }\n    return class_name + \".\" + extension;",
  "    int max_strength = 0;\n    std::string class_and_extension = class_name;\n\
    \    for (auto ext : extensions) {\n        int CAP = std::count_if(ext.begin(),\
    \ ext.end(), [](char ch) { return std::isupper(ch); });\n        int SM = std::count_if(ext.begin(),\
    \ ext.end(), [](char ch) { return std::islower(ch); });\n        int strength\
    \ = CAP - SM;\n        if (strength > max_strength) {\n            max_strength\
    \ = strength;\n            class_and_extension = class_name + \".\" + ext;\n \
    \       }\n    }\n    return class_and_extension;", "\tauto result = std::make_pair(0,0);\n\
    \tfor (size_t i = 0; i < extensions.size(); i++) {\n\t\tint upper = 0;\n\t\tint\
    \ lower = 0;\n\t\tfor (size_t j = 0; j < extensions[i].size(); j++) {\n\t\t\t\
    if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tupper++;\n\t\
    \t\t}\n\t\t\telse {\n\t\t\t\tlower++;\n\t\t\t}\n\t\t}\n\t\tif (upper - lower >\
    \ result.first) {\n\t\t\tresult.first = upper - lower;\n\t\t\tresult.second =\
    \ i;\n\t\t}\n\t}\n\treturn class_name + \".\" + extensions[result.second];", "\t\
    if (extensions.size() == 0)\n\t\treturn class_name;\n\tdouble max_score = 0.0;\n\
    \tint max_index = 0;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tdouble\
    \ caps = 0.0;\n\t\tdouble sm = 0.0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (isupper(extensions[i][j]))\n\t\t\t\tcaps++;\n\t\t\telse if\
    \ (islower(extensions[i][j]))\n\t\t\t\tsm++;\n\t\t}\n\t\tif (caps - sm > max_score)\
    \ {\n\t\t\tmax_score = caps - sm;\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + extensions[max_index];", "    float ratio = 0;\n    int\
    \ caps = 0;\n    int smalls = 0;\n    float strength = 0;\n    std::string result;\n\
    \    for (auto & ext: extensions) {\n        caps = std::count_if(ext.begin(),\
    \ ext.end(), [](char c) {return isupper(c);});\n        smalls = std::count_if(ext.begin(),\
    \ ext.end(), [](char c) {return islower(c);});\n        strength = (float)caps\
    \ - (float)smalls;\n        if (strength >= ratio) {\n            ratio = strength;\n\
    \            result = ext;\n        }\n    }\n    return class_name + \".\" +\
    \ result;", "    // Write your code here\n    std::string longest_string;\n  \
    \  std::string result;\n    int max_length = 0;\n    int count = 0;\n    std::vector<int>\
    \ v;\n    for(auto word : extensions) {\n        for(int i = 0; i < word.length();\
    \ i++) {\n            if(isupper(word[i])) {\n                count++;\n     \
    \       }\n        }\n        v.push_back(count);\n        count = 0;\n    }\n\
    \    for(int i = 0; i < extensions.size(); i++) {\n        for(int j = 0; j <\
    \ extensions[i].length(); j++) {\n            if(islower(extensions[i][j])) {\n\
    \                count++;\n            }\n        }\n        v[i] -= count;\n\
    \        count = 0;\n    }\n    int index = 0;\n    for(int i = 0; i < v.size();\
    \ i++) {\n        if(v[i] > max_length) {\n            max_length = v[i];\n  \
    \          index = i;\n        }\n    }\n    longest_string = extensions[index];\n\
    \    result = class_name + \".\" + longest_string;\n    return result;", "   \
    \ std::string best = \"\";\n    double strength = 0.0;\n    for (int i = 0; i\
    \ < extensions.size(); i++) {\n        int ca = 0;\n        int sm = 0;\n    \
    \    for (int j = 0; j < extensions[i].size(); j++) {\n            if (isupper(extensions[i][j]))\
    \ {\n                ca++;\n            } else {\n                sm++;\n    \
    \        }\n        }\n        double str = (double)ca - (double)sm;\n       \
    \ if (str >= strength) {\n            strength = str;\n            best = extensions[i];\n\
    \        }\n    }\n    return class_name + \".\" + best;", "    int strength =\
    \ 0;\n    int temp = 0;\n    int CAP;\n    int SM;\n    std::string res;\n   \
    \ for (auto i : extensions) {\n        CAP = 0;\n        SM = 0;\n        for\
    \ (auto j : i) {\n            if (isupper(j))\n                CAP++;\n      \
    \      else\n                SM++;\n        }\n        temp = CAP - SM;\n    \
    \    if (temp > strength) {\n            strength = temp;\n            res = i;\n\
    \        }\n    }\n    return class_name + \".\" + res;", "\tfloat result_strength\
    \ = 0.0;\n\tstd::string result_name;\n\tfor (auto i : extensions) {\n\t\tint cap\
    \ = 0;\n\t\tint sm = 0;\n\t\tfor (auto j : i) {\n\t\t\tif (isupper(j)) {\n\t\t\
    \t\tcap++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tfloat curr_strength\
    \ = (float)cap - (float)sm;\n\t\tif (curr_strength > result_strength) {\n\t\t\t\
    result_strength = curr_strength;\n\t\t\tresult_name = i;\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + result_name;", "\t// Write your code here\n\tstd::string\
    \ strong_exten = \"\";\n\tfloat count_cap = 0, count_sm = 0, strength = 0;\n\t\
    for (int i = 0; i < extensions.size(); i++) {\n\t\tfor (int j = 0; j < extensions[i].length();\
    \ j++) {\n\t\t\tif (isupper(extensions[i][j]))\n\t\t\t\tcount_cap++;\n\t\t\telse\
    \ if (islower(extensions[i][j]))\n\t\t\t\tcount_sm++;\n\t\t}\n\t\tif (strength\
    \ < count_cap - count_sm) {\n\t\t\tstrength = count_cap - count_sm;\n\t\t\tstrong_exten\
    \ = extensions[i];\n\t\t}\n\t\tcount_cap = 0;\n\t\tcount_sm = 0;\n\t}\n\treturn\
    \ class_name + \".\" + strong_exten;", "  int max_cap = -1, max_sm = -1;\n  std::string\
    \ max_extension;\n  for (std::string extension : extensions) {\n    int cap =\
    \ 0, sm = 0;\n    for (char c : extension) {\n      if (isupper(c)) {\n      \
    \  cap++;\n      } else {\n        sm++;\n      }\n    }\n    if (cap-sm > max_cap-max_sm)\
    \ {\n      max_cap = cap;\n      max_sm = sm;\n      max_extension = extension;\n\
    \    }\n  }\n  return class_name + \".\" + max_extension;", "    if (extensions.size()\
    \ == 0) return class_name;\n    int strongest_count = 0;\n    std::string strongest\
    \ = extensions[0];\n    for (auto ext : extensions) {\n        int count = 0;\n\
    \        for (auto c : ext) {\n            if (isupper(c)) count++;\n        \
    \    else if (islower(c)) count--;\n        }\n        if (count > strongest_count)\
    \ {\n            strongest_count = count;\n            strongest = ext;\n    \
    \    }\n    }\n    return class_name + \".\" + strongest;", "\t// your code here\n\
    \tstd::map<float, std::string> m;\n\tstd::map<float, std::string>::iterator itr;\n\
    \tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint cap = 0, small = 0;\n\
    \t\tfor (int j = 0; j < extensions[i].length(); j++) {\n\t\t\tif (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z')\n\t\t\t\tcap++;\n\t\t\telse\n\t\t\t\tsmall++;\n\
    \t\t}\n\t\tm.insert(std::pair<float, std::string>(cap - small, extensions[i]));\n\
    \t}\n\tfloat max = -10;\n\tstd::string s;\n\tfor (itr = m.begin(); itr != m.end();\
    \ itr++) {\n\t\tif (itr->first > max) {\n\t\t\tmax = itr->first;\n\t\t\ts = itr->second;\n\
    \t\t}\n\t}\n\treturn class_name + \".\" + s;", "\tif (extensions.size() == 0)\n\
    \t\treturn \"\";\n\tint max = 0;\n\tint index = 0;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tint capital_count = 0;\n\t\tint small_count = 0;\n\t\tfor (int j\
    \ = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j] >= 'A' &&\
    \ extensions[i][j] <= 'Z')\n\t\t\t\tcapital_count++;\n\t\t\telse if (extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z')\n\t\t\t\tsmall_count++;\n\t\t}\n\t\tif (capital_count\
    \ - small_count > max) {\n\t\t\tmax = capital_count - small_count;\n\t\t\tindex\
    \ = i;\n\t\t}\n\t}\n\treturn class_name + \".\" + extensions[index];", "    int\
    \ max_strength = 0;\n    int index = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        int strength = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                strength++;\n\
    \            } else {\n                strength--;\n            }\n        }\n\
    \        if (max_strength < strength) {\n            max_strength = strength;\n\
    \            index = i;\n        }\n    }\n    return class_name + \".\" + extensions[index];",
  "    int CAP;\n    int SM;\n    int strength;\n    int strongest_strength = 0;\n\
    \    std::string strongest_extension;\n    // loop through extensions, calculate\
    \ strength and store strongest \n    for (int i = 0; i < extensions.size(); i++)\
    \ {\n        std::string extension = extensions[i];\n        CAP = 0;\n      \
    \  SM = 0;\n        for (int j = 0; j < extension.length(); j++) {\n         \
    \   if (isupper(extension[j])) {\n                CAP++;\n            } else {\n\
    \                SM++;\n            }\n        }\n        strength = CAP - SM;\n\
    \        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension;", "\tstd::string best_extension;\n\
    \tint highest_count = 0;\n\tfor (auto extension : extensions) {\n\t\tint upper_count\
    \ = 0;\n\t\tint lower_count = 0;\n\t\tfor (auto c : extension) {\n\t\t\tif (isupper(c))\
    \ {\n\t\t\t\tupper_count++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlower_count++;\n\t\
    \t\t}\n\t\t}\n\t\tint count = upper_count - lower_count;\n\t\tif (count >= highest_count)\
    \ {\n\t\t\thighest_count = count;\n\t\t\tbest_extension = extension;\n\t\t}\n\t\
    }\n\treturn class_name + \".\" + best_extension;", "    int max = -1;\n    std::string\
    \ extension = \"\";\n    std::string strongest_extension = \"\";\n    for (auto\
    \ e : extensions) {\n        max = 0;\n        extension = \"\";\n        for\
    \ (auto ch : e) {\n            if (isupper(ch)) {\n                max += 1;\n\
    \            } else {\n                max -= 1;\n            }\n        }\n \
    \       if (max > 0) {\n            extension = e;\n        }\n        if (extension\
    \ != \"\") {\n            strongest_extension = extension;\n            break;\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;", "  \
    \  int maximum = 0;\n    int upper_count = 0;\n    int lower_count = 0;\n    int\
    \ temp_maximum = 0;\n    std::string strongest;\n    for(auto &i : extensions)\
    \ {\n        std::transform(i.begin(), i.end(), i.begin(), ::toupper);\n     \
    \   upper_count = std::count_if(i.begin(), i.end(), [](unsigned char c){ return\
    \ std::isupper(c); });\n        std::transform(i.begin(), i.end(), i.begin(),\
    \ ::tolower);\n        lower_count = std::count_if(i.begin(), i.end(), [](unsigned\
    \ char c){ return std::islower(c); });\n        temp_maximum = upper_count - lower_count;\n\
    \        if(temp_maximum > maximum) {\n            maximum = temp_maximum;\n \
    \           strongest = i;\n        }\n    }\n    return class_name + \".\" +\
    \ strongest;", "    std::string final_string;\n    int max_strength = -1;\n  \
    \  for(int i = 0; i < extensions.size(); i++) {\n        int CAP = 0;\n      \
    \  int SM = 0;\n        for(int j = 0; j < extensions[i].size(); j++) {\n    \
    \        if(isupper(extensions[i][j])) {\n                CAP++;\n           \
    \ }\n            else {\n                SM++;\n            }\n        }\n   \
    \     if(max_strength < (CAP - SM)) {\n            max_strength = CAP - SM;\n\
    \            final_string = class_name + \".\" + extensions[i];\n        }\n \
    \   }\n    return final_string;", "    double strength = 0;\n    std::string ext_name\
    \ = extensions[0];\n    for (auto ext : extensions) {\n        int total_caps\
    \ = 0;\n        int total_sm = 0;\n        for (auto ch : ext) {\n           \
    \ if (std::isupper(ch)) {\n                total_caps++;\n            } else {\n\
    \                total_sm++;\n            }\n        }\n        if (total_caps\
    \ - total_sm > strength) {\n            strength = total_caps - total_sm;\n  \
    \          ext_name = ext;\n        }\n    }\n    return class_name + \".\" +\
    \ ext_name;", "    size_t number_of_upper_case_letters {0};\n    size_t number_of_lower_case_letters\
    \ {0};\n    std::string strongest_extension {\"\"};\n    double strength {0};\n\
    \    double max_strength {0};\n    std::string extension_to_print {\"\"};\n  \
    \  for (auto extension : extensions) {\n        number_of_upper_case_letters =\
    \ std::count_if(extension.begin(), extension.end(),\n            [](char c) {\
    \ return std::isupper(c); });\n        number_of_lower_case_letters = std::count_if(extension.begin(),\
    \ extension.end(),\n            [](char c) { return std::islower(c); });\n   \
    \     strength = static_cast<double>(number_of_upper_case_letters) - static_cast<double>(number_of_lower_case_letters);\n\
    \        if (strength >= max_strength) {\n            max_strength = strength;\n\
    \            extension_to_print = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + extension_to_print;", "    std::vector<std::pair<int, std::string>>\
    \ v;\n    for (const auto& e : extensions) {\n        int cap{}, sm{};\n     \
    \   for (const auto& c : e) {\n            if (isupper(c)) {\n               \
    \ ++cap;\n            } else {\n                ++sm;\n            }\n       \
    \ }\n        v.push_back(std::make_pair(cap - sm, e));\n    }\n    std::sort(v.begin(),\
    \ v.end(), std::greater<std::pair<int, std::string>>());\n    return class_name\
    \ + \".\" + v[0].second;", "    double max = -1;\n    double k = 0;\n    int index\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        for (int j\
    \ = 0; j < extensions[i].size(); j++) {\n            if (isupper(extensions[i][j]))\
    \ {\n                k++;\n            }\n            else if (islower(extensions[i][j]))\
    \ {\n                k--;\n            }\n        }\n        if (k > max) {\n\
    \            max = k;\n            index = i;\n        }\n        k = 0;\n   \
    \ }\n    return class_name + \".\" + extensions[index];", "\t// Your code goes\
    \ here.\n\tint max = -1;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\t\
    int caps = 0;\n\t\tint sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (isupper(extensions[i][j])) {\n\t\t\t\tcaps++;\n\t\t\t}\n\t\
    \t\telse {\n\t\t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tif (caps - sm > max) {\n\t\t\t\
    max = caps - sm;\n\t\t}\n\t}\n\tfor (int i = 0; i < extensions.size(); i++) {\n\
    \t\tint caps = 0;\n\t\tint sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (isupper(extensions[i][j])) {\n\t\t\t\tcaps++;\n\t\t\t}\n\t\
    \t\telse {\n\t\t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tif (caps - sm == max) {\n\t\t\t\
    return class_name + \".\" + extensions[i];\n\t\t}\n\t}\n\treturn class_name;",
  "  double best = -100.0;\n  std::string best_extension;\n  for (auto e : extensions)\
    \ {\n    int n_caps = 0;\n    int n_smalls = 0;\n    for (auto c : e) {\n    \
    \  if (isupper(c)) {\n        n_caps++;\n      } else {\n        n_smalls++;\n\
    \      }\n    }\n    double score = (double)n_caps - (double)n_smalls;\n    if\
    \ (score > best) {\n      best = score;\n      best_extension = e;\n    }\n  }\n\
    \  return class_name + \".\" + best_extension;", "   int strongest_index = 0;\n\
    \   double strongest_value = 0;\n   for (int i = 0; i < extensions.size(); i++)\
    \ {\n       double CAP = 0;\n       double SM = 0;\n       for (int j = 0; j <\
    \ extensions[i].size(); j++) {\n           if (isupper(extensions[i][j])) {\n\
    \               CAP++;\n           } else {\n               SM++;\n          \
    \ }\n       }\n       if (strongest_value < CAP - SM) {\n           strongest_value\
    \ = CAP - SM;\n           strongest_index = i;\n       }\n   }\n   return class_name\
    \ + \".\" + extensions[strongest_index];", "\tfloat strongest = -1;\n\tfloat current_strength;\n\
    \tstd::string strongest_name;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\
    \t\tcurrent_strength = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++)\
    \ {\n\t\t\tif (isupper(extensions[i][j])) {\n\t\t\t\tcurrent_strength++;\n\t\t\
    \t}\n\t\t\telse {\n\t\t\t\tcurrent_strength--;\n\t\t\t}\n\t\t}\n\t\tif (current_strength\
    \ > strongest) {\n\t\t\tstrongest = current_strength;\n\t\t\tstrongest_name =\
    \ extensions[i];\n\t\t}\n\t}\n\treturn class_name + \".\" + strongest_name;",
  "    if (extensions.size() == 0) return class_name;\n    std::string strongest_ext;\n\
    \    int strength = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n  \
    \      int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\
    \ cap++;\n            else sm++;\n        }\n        if (cap - sm > strength)\
    \ {\n            strength = cap - sm;\n            strongest_ext = extensions[i];\n\
    \        }\n    }\n    return class_name + \".\" + strongest_ext;", "\t//your\
    \ code here\n\tdouble highest_strength = -1.0;\n\tstd::string highest_extension\
    \ = \"\";\n\tdouble current_strength = 0.0;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tcurrent_strength = 0.0;\n\t\tint upper_case = 0;\n\t\tint lower_case\
    \ = 0;\n\t\tfor (int j = 0; j < extensions[i].length(); j++) {\n\t\t\tif (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tupper_case++;\n\t\t\t}\n\t\t\t\
    else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\t\tlower_case++;\n\
    \t\t\t}\n\t\t}\n\t\tcurrent_strength = double(upper_case) - double(lower_case);\n\
    \t\tif (current_strength > highest_strength) {\n\t\t\thighest_strength = current_strength;\n\
    \t\t\thighest_extension = extensions[i];\n\t\t}\n\t}\n\treturn class_name + \"\
    .\" + highest_extension;", "    struct extension {\n        float strength;\n\
    \        std::string name;\n    };\n    extension strongest;\n    float strength;\n\
    \    unsigned uppercase, lowercase;\n    // iterate through extensions to find\
    \ the strongest one\n    for (auto &ext : extensions) {\n        uppercase = std::count_if(ext.begin(),\
    \ ext.end(), [](char c) { return std::isupper(c); });\n        lowercase = std::count_if(ext.begin(),\
    \ ext.end(), [](char c) { return std::islower(c); });\n        strength = (float)uppercase\
    \ / (float)lowercase;\n        if (strength > strongest.strength) {\n        \
    \    strongest.strength = strength;\n            strongest.name = ext;\n     \
    \   }\n    }\n    return class_name + \".\" + strongest.name;", "  std::vector<std::string>\
    \ extension_names;\n  std::vector<double> extension_strengths;\n  double strength;\n\
    \  int i;\n  for (i = 0; i < extensions.size(); i++) {\n    extension_names.push_back(extensions[i]);\n\
    \    strength = 0;\n    for (int j = 0; j < extensions[i].length(); j++) {\n \
    \     if (isupper(extensions[i][j])) {\n        strength++;\n      } else {\n\
    \        strength--;\n      }\n    }\n    extension_strengths.push_back(strength);\n\
    \  }\n  double max_strength = -1;\n  for (i = 0; i < extension_strengths.size();\
    \ i++) {\n    if (extension_strengths[i] > max_strength) {\n      max_strength\
    \ = extension_strengths[i];\n    }\n  }\n  std::string strongest_extension = \"\
    \";\n  for (i = 0; i < extension_strengths.size(); i++) {\n    if (extension_strengths[i]\
    \ == max_strength) {\n      strongest_extension = extension_names[i];\n      break;\n\
    \    }\n  }\n  return class_name + \".\" + strongest_extension;", "    // if there\
    \ are no extensions\n    if (extensions.size() == 0) {\n        return class_name;\n\
    \    }\n    // First sorting the extensions in ascending order\n    std::sort(extensions.begin(),\
    \ extensions.end());\n    int max = -1;\n    // getting the number of capital\
    \ and small letters\n    for (auto &extension : extensions) {\n        int number_of_upper_case\
    \ = 0;\n        int number_of_lower_case = 0;\n        for (auto &character :\
    \ extension) {\n            if (isupper(character)) {\n                number_of_upper_case++;\n\
    \            } else {\n                number_of_lower_case++;\n            }\n\
    \        }\n        int temp = number_of_upper_case - number_of_lower_case;\n\
    \        if (temp > max) {\n            max = temp;\n        }\n    }\n    //\
    \ getting the first extension with the same strength\n    for (auto &extension\
    \ : extensions) {\n        int number_of_upper_case = 0;\n        int number_of_lower_case\
    \ = 0;\n        for (auto &character : extension) {\n            if (isupper(character))\
    \ {\n                number_of_upper_case++;\n            } else {\n         \
    \       number_of_lower_case++;\n            }\n        }\n        int temp =\
    \ number_of_upper_case - number_of_lower_case;\n        if (temp == max) {\n \
    \           class_name += \".\";\n            class_name += extension;\n     \
    \       return class_name;\n        }\n    }\n    return class_name;", "  // your\
    \ code here\n  float max_strength = -FLT_MAX;\n  std::string max_strength_name\
    \ = \"\";\n  for(int i = 0; i < extensions.size(); i++) {\n    float strength\
    \ = 0;\n    for(int j = 0; j < extensions[i].size(); j++) {\n      if(isupper(extensions[i][j]))\
    \ {\n        strength++;\n      }\n      else if(islower(extensions[i][j])) {\n\
    \        strength--;\n      }\n    }\n    if(strength > max_strength) {\n    \
    \  max_strength = strength;\n      max_strength_name = extensions[i];\n    }\n\
    \  }\n  return class_name + \".\" + max_strength_name;", "\tint mn = INT_MIN;\n\
    \tstd::string ans = \"\";\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\
    \tint cap = 0, sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\
    \t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tcap++;\n\
    \t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\
    \t\t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tint curr = cap - sm;\n\t\tif (curr > mn) {\n\
    \t\t\tmn = curr;\n\t\t\tans = extensions[i];\n\t\t}\n\t}\n\treturn class_name\
    \ + \".\" + ans;", "    std::string ans = class_name;\n    double mx = 0;\n  \
    \  for (const auto& e : extensions) {\n        double sm = 0, cap = 0;\n     \
    \   for (const auto& c : e) {\n            if (std::isupper(c)) {\n          \
    \      cap++;\n            } else {\n                sm++;\n            }\n  \
    \      }\n        double cur = cap - sm;\n        if (cur > mx) {\n          \
    \  mx = cur;\n            ans = class_name + \".\" + e;\n        }\n    }\n  \
    \  return ans;", "  int score = INT_MIN;\n  std::string result;\n  for (int i\
    \ = 0; i < extensions.size(); i++) {\n    int ca = 0, sm = 0;\n    for (int j\
    \ = 0; j < extensions[i].size(); j++) {\n      if (isupper(extensions[i][j]))\
    \ {\n        ca++;\n      } else {\n        sm++;\n      }\n    }\n    int current_score\
    \ = ca - sm;\n    if (current_score > score) {\n      score = current_score;\n\
    \      result = extensions[i];\n    }\n  }\n  return class_name + \".\" + result;",
  "    std::string extension = \"\";\n    int strength = 0;\n    for (std::string\
    \ ext: extensions) {\n        int capital = 0;\n        int small = 0;\n     \
    \   for (char c: ext) {\n            if (std::isupper(c)) {\n                capital++;\n\
    \            } else {\n                small++;\n            }\n        }\n  \
    \      if (capital - small > strength) {\n            strength = capital - small;\n\
    \            extension = ext;\n        }\n    }\n    return class_name + \".\"\
    \ + extension;", "    std::sort(extensions.begin(), extensions.end(), [](std::string\
    \ s1, std::string s2) {\n        int cap1 = 0, cap2 = 0, sm1 = 0, sm2 = 0;\n \
    \       for (auto c : s1) {\n            if (isupper(c)) cap1++;\n           \
    \ else sm1++;\n        }\n        for (auto c : s2) {\n            if (isupper(c))\
    \ cap2++;\n            else sm2++;\n        }\n        return cap1 - sm1 > cap2\
    \ - sm2;\n    });\n    return class_name + \".\" + extensions[0];", "    assert(extensions.size()\
    \ > 0);\n    std::string strongest_extension = extensions[0];\n    double strongest_extension_strength\
    \ = -1000;\n    for (int i = 0; i < extensions.size(); i++) {\n        int count_caps\
    \ = 0;\n        int count_smalls = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                count_caps++;\n\
    \            } else {\n                count_smalls++;\n            }\n      \
    \  }\n        double current_extension_strength = (double)count_caps - (double)count_smalls;\n\
    \        if (current_extension_strength > strongest_extension_strength) {\n  \
    \          strongest_extension_strength = current_extension_strength;\n      \
    \      strongest_extension = extensions[i];\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;", "  \t\n  \tint CAP, SM, strength, max_strength\
    \ = -1;\n  \tstd::string extension, chosen_extension;\n  \tchar c;\n  \tstd::vector<std::string>::iterator\
    \ it;\n  \t\n  \tfor(it = extensions.begin(); it != extensions.end(); it++) {\n\
    \  \t\tCAP = 0;\n  \t\tSM = 0;\n  \t\textension = *it;\n  \t\tfor(int i = 0; i\
    \ < extension.length(); i++) {\n  \t\t\tc = extension[i];\n  \t\t\tif(c >= 'A'\
    \ && c <= 'Z') {\n  \t\t\t\tCAP++;\n  \t\t\t}\n  \t\t\telse if(c >= 'a' && c <=\
    \ 'z') {\n  \t\t\t\tSM++;\n  \t\t\t}\n  \t\t}\n  \t\tstrength = CAP - SM;\n  \t\
    \tif(strength > max_strength) {\n  \t\t\tmax_strength = strength;\n  \t\t\tchosen_extension\
    \ = extension;\n  \t\t}\n  \t}\n  \t\n  \treturn class_name + \".\" + chosen_extension;",
  "  // your code here\n  return \"\";", "    int i, max_strength = INT_MIN, index;\n\
    \    double CAP, SM;\n    for(i = 0; i < extensions.size(); i++) {\n        CAP\
    \ = 0, SM = 0;\n        for(auto j : extensions[i]) {\n            if(j >= 'A'\
    \ && j <= 'Z') {\n                CAP++;\n            }\n            else if(j\
    \ >= 'a' && j <= 'z') {\n                SM++;\n            }\n        }\n   \
    \     if(max_strength < (CAP - SM)) {\n            max_strength = CAP - SM;\n\
    \            index = i;\n        }\n    }\n    return class_name + \".\" + extensions[index];",
  "\tint i,j,a,b,c,d,count1,count2,count3,count4,count5,count6,count7,count8,count9,count10,count11,count12,count13,count14,count15,count16,count17,count18,count19,count20,count21,count22,count23,count24,count25,count26,count27,count28,count29,count30,count31,count32,count33,count34,count35,count36,count37,count38,count39,count40,count41,count42,count43,count44,count45,count46,count47,count48,count49,count50,count51,count52,count53,count54,count55,count56,count57,count58,count59,count60,count61,count62,count63,count64,count65,count66,count67,count68,count69,count70,count71,count72,count73,count74,count75,count76,count77,count78,count79,count80,count81,count82,count83,count84,count85,count86,count87,count88,count89,count90,count91,count92,count93,count94,count95,count96,count97,count98,count99,count100,count101,count102,count103,count104,count105,count106,count107,count108,count109,count110,count111,count112,count113,count114,count115,count116,count117,count118,count119,count120,count121,count122,count123,count124,count125,count126,count127,count128,count129,count130,count131,count132,count133,count134,count135,count136,count137,count138,count139,count140,count141,count142,count143,count144,count145,count146,count147,count148,count149,count150,count151,count152,count153,count154,count155,count156,count157,count158,count159,count160,count161,count162,count163,count164,count165,count166",
  '    // write your code here', "    int strength;\n    int i, l = extensions.size();\n\
    \    int max_strength = 0;\n    int count;\n    std::string ext;\n    std::string\
    \ max_ext;\n    for(i = 0; i < l; i++) {\n        ext = extensions[i];\n     \
    \   strength = 0;\n        for(auto c : ext) {\n            if(isupper(c)) {\n\
    \                strength++;\n            }\n            else if(islower(c)) {\n\
    \                strength--;\n            }\n        }\n        if(strength >\
    \ max_strength) {\n            max_strength = strength;\n            max_ext =\
    \ ext;\n        }\n    }\n    return class_name + \".\" + max_ext;", "    int\
    \ cnt_capital = 0, cnt_small = 0;\n    int capital = 0, small = 0;\n    std::string\
    \ ans;\n    for (const auto &extension : extensions) {\n        for (const auto\
    \ &ch : extension) {\n            if (std::isupper(ch)) {\n                ++cnt_capital;\n\
    \            } else {\n                ++cnt_small;\n            }\n        }\n\
    \        if (cnt_capital - cnt_small > capital - small) {\n            capital\
    \ = cnt_capital;\n            small = cnt_small;\n            ans = extension;\n\
    \        }\n        cnt_capital = 0;\n        cnt_small = 0;\n    }\n    return\
    \ class_name + \".\" + ans;", "    int lowest = 0;\n    int low_index = 0;\n \
    \   for (int i = 0; i < extensions.size(); i++) {\n        int count_low = 0;\n\
    \        int count_high = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\
    \ {\n                count_low++;\n            }\n            else if (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n                count_high++;\n      \
    \      }\n        }\n        if (count_high - count_low < lowest) {\n        \
    \    lowest = count_high - count_low;\n            low_index = i;\n        }\n\
    \    }\n    return class_name + \".\" + extensions[low_index];", "\tint num =\
    \ 0;\n\tint strength = 0;\n\tstd::string strongest = extensions[0];\n\tfor (int\
    \ i = 0; i < extensions.size(); i++) {\n\t\tint cap = 0;\n\t\tint sm = 0;\n\t\t\
    for (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j] >\
    \ 'Z') {\n\t\t\t\tsm++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcap++;\n\t\t\t}\n\t\t\
    }\n\t\tint str = cap - sm;\n\t\tif (str > strength) {\n\t\t\tstrength = str;\n\
    \t\t\tstrongest = extensions[i];\n\t\t}\n\t}\n\tclass_name.append(\".\");\n\t\
    class_name.append(strongest);\n\treturn class_name;", "    int max = 0;\n    std::string\
    \ max_extension = \"\";\n    for (int i = 0; i < extensions.size(); i++) {\n \
    \       int cap = 0;\n        int sm = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\
    \ {\n                cap++;\n            } else {\n                sm++;\n   \
    \         }\n        }\n        if (cap - sm > max) {\n            max = cap -\
    \ sm;\n            max_extension = extensions[i];\n        }\n    }\n    return\
    \ class_name + \".\" + max_extension;", "\tint s = -999;\n\tint s_index = 0;\n\
    \tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint s_cap = 0;\n\t\tint s_sm\
    \ = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\ts_cap++;\n\t\t\t}\n\t\t\telse\
    \ if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\t\ts_sm++;\n\
    \t\t\t}\n\t\t}\n\t\tif (s_cap - s_sm > s) {\n\t\t\ts = s_cap - s_sm;\n\t\t\ts_index\
    \ = i;\n\t\t}\n\t}\n\tstd::string result = class_name + \".\" + extensions[s_index];\n\
    \treturn result;", "    // get the class name\n    std::string original_class_name\
    \ = class_name;\n    // get the strongest extension\n    std::string strongest_extension;\n\
    \    // get the strength of the strongest extension\n    double strength = 0;\n\
    \    // loop over the extensions\n    for (auto extension : extensions) {\n  \
    \      // get the strength of the extension\n        double cap = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) { return std::isupper(c); });\n        double sm\
    \ = std::count_if(extension.begin(), extension.end(), [](char c) { return std::islower(c);\
    \ });\n        // check whether the current extension is stronger\n        if\
    \ (cap - sm > strength) {\n            // update the strongest extension\n   \
    \         strongest_extension = extension;\n            // update the strength\n\
    \            strength = cap - sm;\n        }\n    }\n    // return the concatenation\
    \ of the class name and the strongest extension\n    return original_class_name\
    \ + \".\" + strongest_extension;", "  // Write your code here\n  int maxStrength\
    \ = INT_MIN;\n  std::string maxExtension;\n  for(auto ext : extensions) {\n  \
    \  int strength = 0;\n    for(auto ch : ext) {\n      if(std::isupper(ch)) {\n\
    \        strength++;\n      } else {\n        strength--;\n      }\n    }\n  \
    \  if(strength > maxStrength) {\n      maxStrength = strength;\n      maxExtension\
    \ = ext;\n    }\n  }\n  return class_name + \".\" + maxExtension;", "    auto\
    \ str_comp = [](const std::string &a, const std::string &b) {\n        auto a_strength\
    \ = 0, b_strength = 0;\n        for (const auto &ch : a) {\n            if (isupper(ch))\
    \ a_strength++;\n            else a_strength--;\n        }\n        for (const\
    \ auto &ch : b) {\n            if (isupper(ch)) b_strength++;\n            else\
    \ b_strength--;\n        }\n        return a_strength > b_strength;\n    };\n\
    \    std::string strongest_ext;\n    for (const auto &ext : extensions) {\n  \
    \      if (str_comp(ext, strongest_ext)) strongest_ext = ext;\n    }\n    return\
    \ class_name + \".\" + strongest_ext;", "    if (extensions.size() == 0) {\n \
    \       return class_name;\n    }\n\n    float max = 0;\n    int pos = 0;\n  \
    \  float cur;\n    int cap;\n    int sm;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        cap = 0;\n        sm = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                cap++;\n\
    \            } else {\n                sm++;\n            }\n        }\n     \
    \   cur = cap - sm;\n        if (cur > max) {\n            max = cur;\n      \
    \      pos = i;\n        }\n    }\n    return class_name + \".\" + extensions[pos];",
  "    std::string strongest = \"\";\n    double strongest_strength = 0;\n    int\
    \ strongest_index = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n  \
    \      double strength = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                strength++;\n\
    \            } else {\n                strength--;\n            }\n        }\n\
    \        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_index = i;\n        }\n    }\n    strongest\
    \ = class_name + \".\" + extensions[strongest_index];\n    return strongest;",
  "    std::string result = class_name + \".\";\n    int cur_strength = 0;\n    for\
    \ (auto ext : extensions) {\n        int upper = 0;\n        int lower = 0;\n\
    \        for (auto letter : ext) {\n            if (isupper(letter))\n       \
    \         upper++;\n            else\n                lower++;\n        }\n  \
    \      if (upper - lower > cur_strength) {\n            cur_strength = upper -\
    \ lower;\n            result = class_name + \".\" + ext;\n        }\n    }\n \
    \   return result;", "    assert(!class_name.empty());\n    assert(!extensions.empty());\n\
    \    auto max_strength_in_extensions = std::max_element(extensions.begin(), extensions.end(),\n\
    \        [](const std::string& lhs, const std::string& rhs) -> bool\n        {\n\
    \            assert(!lhs.empty());\n            assert(!rhs.empty());\n      \
    \      auto count_of_upper_lhs = std::count_if(lhs.begin(), lhs.end(), [](const\
    \ char& ch)\n                {\n                    return std::isupper(ch);\n\
    \                });\n            auto count_of_upper_rhs = std::count_if(rhs.begin(),\
    \ rhs.end(), [](const char& ch)\n                {\n                    return\
    \ std::isupper(ch);\n                });\n            auto count_of_lower_lhs\
    \ = std::count_if(lhs.begin(), lhs.end(), [](const char& ch)\n               \
    \ {\n                    return std::islower(ch);\n                });\n     \
    \       auto count_of_lower_rhs = std::count_if(rhs.begin(), rhs.end(), [](const\
    \ char& ch)\n                {\n                    return std::islower(ch);\n\
    \                });\n            return ((static_cast<double>(count_of_upper_lhs)\
    \ - static_cast<double>(count_of_lower_lhs)) >\n                (static_cast<double>(count_of_upper_rhs)\
    \ - static_cast<double>(count_of_lower_rhs)));\n        });\n    assert(max_strength_in_extensions\
    \ != extensions.end());\n    return class_name + \".\" + *max_strength_in_extensions;",
  "\tstd::string best_extension;\n\tdouble best_strength = 0;\n\tfor (std::string\
    \ extension : extensions) {\n\t\tdouble strength = 0;\n\t\tfor (auto c : extension)\
    \ {\n\t\t\tif (std::isupper(c)) {\n\t\t\t\tstrength++;\n\t\t\t}\n\t\t\telse if\
    \ (std::islower(c)) {\n\t\t\t\tstrength--;\n\t\t\t}\n\t\t}\n\t\tif (strength >\
    \ best_strength) {\n\t\t\tbest_strength = strength;\n\t\t\tbest_extension = extension;\n\
    \t\t}\n\t}\n\treturn class_name + \".\" + best_extension;", "\tfloat _max = 0;\n\
    \tfloat _temp = 0;\n\tstd::string ext_name;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tint CAPS = 0;\n\t\tint small = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (isupper(extensions[i][j])) {\n\t\t\t\tCAPS++;\n\t\t\t}\n\t\
    \t\telse if (islower(extensions[i][j])) {\n\t\t\t\tsmall++;\n\t\t\t}\n\t\t}\n\t\
    \t_temp = (float)CAPS - small;\n\t\tif (_temp > _max) {\n\t\t\t_max = _temp;\n\
    \t\t\text_name = extensions[i];\n\t\t}\n\t}\n\treturn class_name + \".\" + ext_name;",
  "    int sm,cap,sm2,cap2;\n    float st,st2;\n    float max=0;\n    std::string\
    \ maxstring;\n    for(auto it=extensions.begin();it!=extensions.end();it++)\n\
    \    {\n        st=0;\n        sm=0;\n        cap=0;\n        for(auto it1=it->begin();it1!=it->end();it1++)\n\
    \        {\n            if(*it1>='A' && *it1<='Z')\n            {\n          \
    \      cap++;\n            }\n            else\n            {\n              \
    \  sm++;\n            }\n        }\n        st=cap-sm;\n        if(st>max)\n \
    \       {\n            max=st;\n            maxstring=*it;\n        }\n    }\n\
    \    return class_name+\".\"+maxstring;", "    float strength = 0.0;\n    std::string\
    \ ext;\n    for (auto i : extensions) {\n        float cur = std::count_if(i.begin(),\
    \ i.end(), ::isupper) - std::count_if(i.begin(), i.end(), ::islower);\n      \
    \  if (cur > strength) {\n            strength = cur;\n            ext = i;\n\
    \        }\n    }\n    return class_name + \".\" + ext;", "\tint max_strength\
    \ = 0;\n\tint sz = extensions.size();\n\tint min_i = 0;\n\tfor (int i = 0; i <\
    \ sz; i++) {\n\t\tint CAP = 0;\n\t\tint SM = 0;\n\t\tint sz_i = extensions[i].size();\n\
    \t\tfor (int j = 0; j < sz_i; j++) {\n\t\t\tif (isupper(extensions[i][j])) {\n\
    \t\t\t\tCAP++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSM++;\n\t\t\t}\n\t\t}\n\t\tif (CAP\
    \ - SM > max_strength) {\n\t\t\tmax_strength = CAP - SM;\n\t\t\tmin_i = i;\n\t\
    \t}\n\t}\n\treturn class_name + \".\" + extensions[min_i];", "\tdouble maxstrength\
    \ = 0;\n\tint i = 0;\n\tstd::string result = \"\";\n\t// We want the index of\
    \ the extension with the largest strength, so we\n\t// use a for loop to keep\
    \ track of that index. Then, if we find an extension\n\t// with strength larger\
    \ than the largest that we've seen so far, we store\n\t// the index of that extension\
    \ so we can return it later.\n\tfor (int i = 0; i < extensions.size(); i++) {\n\
    \t\tint capCount = 0;\n\t\tint smCount = 0;\n\t\tfor (char c : extensions[i])\
    \ {\n\t\t\tif (std::isupper(c)) {\n\t\t\t\tcapCount++;\n\t\t\t}\n\t\t\telse {\n\
    \t\t\t\tsmCount++;\n\t\t\t}\n\t\t}\n\t\tdouble strength = (double)capCount - (double)smCount;\n\
    \t\tif (strength > maxstrength) {\n\t\t\tmaxstrength = strength;\n\t\t\tresult\
    \ = extensions[i];\n\t\t}\n\t}\n\t// The result is the class name with the extension\
    \ with the maximum strength\n\t// appended.\n\treturn class_name + \".\" + result;",
  "    if (extensions.size() == 0) return class_name;\n    int max = -9, ccap = 0,\
    \ csm = 0, idx = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n     \
    \   for (int j = 0; j < extensions[i].size(); j++) {\n            if (isupper(extensions[i][j]))\
    \ ccap++;\n            else csm++;\n        }\n        if (ccap - csm > max) {\n\
    \            max = ccap - csm;\n            idx = i;\n        }\n        ccap\
    \ = 0;\n        csm = 0;\n    }\n    return class_name + \".\" + extensions[idx];",
  "    int n = extensions.size();\n    float strength = -100000;\n    int idx = -1;\n\
    \    for(int i = 0; i < n; i++) {\n        int small = 0, cap = 0;\n        for(int\
    \ j = 0; j < extensions[i].size(); j++) {\n            if(isupper(extensions[i][j]))\
    \ {\n                cap++;\n            } else {\n                small++;\n\
    \            }\n        }\n        float curr_strength = (float)cap / (float)small;\n\
    \        if(curr_strength > strength) {\n            strength = curr_strength;\n\
    \            idx = i;\n        }\n    }\n    return class_name + \".\" + extensions[idx];",
  "\tstd::string extension_name;\n\tdouble strength = 0.0;\n\tfor (auto& ext : extensions)\
    \ {\n\t\tint cap_count = 0;\n\t\tint sm_count = 0;\n\t\tfor (auto& c : ext) {\n\
    \t\t\tif (isupper(c)) cap_count++;\n\t\t\telse if (islower(c)) sm_count++;\n\t\
    \t}\n\t\tdouble tmp_strength = cap_count - sm_count;\n\t\tif (tmp_strength > strength)\
    \ {\n\t\t\tstrength = tmp_strength;\n\t\t\textension_name = ext;\n\t\t}\n\t}\n\
    \treturn class_name + \".\" + extension_name;", "\tdouble max_strength = 0;\n\t\
    std::string strongest_extension;\n\tfor (int i = 0; i < extensions.size(); i++)\
    \ {\n\t\tint caps = 0;\n\t\tint smalls = 0;\n\t\tfor (char c : extensions[i])\
    \ {\n\t\t\tif (isupper(c)) {\n\t\t\t\tcaps++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\
    smalls++;\n\t\t\t}\n\t\t}\n\t\tdouble current_strength = caps - smalls;\n\t\t\
    if (current_strength > max_strength) {\n\t\t\tmax_strength = current_strength;\n\
    \t\t\tstrongest_extension = extensions[i];\n\t\t}\n\t}\n\treturn class_name +\
    \ \".\" + strongest_extension;", "    auto strongest = std::make_pair(extensions[0],\
    \ 0);\n    for (auto &ext : extensions) {\n        int cap = 0, sm = 0;\n    \
    \    for (auto &ch : ext) {\n            if (std::isupper(ch)) cap++;\n      \
    \      else sm++;\n        }\n        auto strength = cap - sm;\n        if (strength\
    \ > strongest.second) {\n            strongest = std::make_pair(ext, strength);\n\
    \        }\n    }\n    return class_name + \".\" + strongest.first;", "  int i;\n\
    \  int CAP, SM;\n  float max = -1;\n  std::string strongest_extension;\n  std::string\
    \ answer;\n  int max_index;\n  std::vector<float> strengths;\n  // first, let's\
    \ find the highest strength.\n  for (i = 0; i < extensions.size(); i++) {\n  \
    \  CAP = 0;\n    SM = 0;\n    for (std::string::size_type j = 0; j < extensions[i].size();\
    \ j++) {\n      if (isupper(extensions[i][j])) {\n        CAP++;\n      } else\
    \ {\n        SM++;\n      }\n    }\n    strengths.push_back(CAP - SM);\n    if\
    \ (max < CAP - SM) {\n      max = CAP - SM;\n      max_index = i;\n    }\n  }\n\
    \  // now find the strongest extension of that strength.\n  // we will find the\
    \ first extension of that strength.\n  // we don't want to find the last extension\
    \ of that strength.\n  for (i = 0; i < extensions.size(); i++) {\n    if (strengths[i]\
    \ == max) {\n      strongest_extension = extensions[i];\n      break;\n    }\n\
    \  }\n  answer = class_name + \".\" + strongest_extension;\n  return answer;",
  "\tint cap = 0, sm = 0, cap_temp = 0, sm_temp = 0;\n\tstd::string strongest = \"\
    \", temp = \"\";\n\tfloat strongest_strength = 0, temp_strength = 0;\n\tfor (std::string\
    \ s : extensions) {\n\t\tfor (char c : s) {\n\t\t\tif (c >= 'A' && c <= 'Z') cap_temp++;\n\
    \t\t\telse if (c >= 'a' && c <= 'z') sm_temp++;\n\t\t}\n\t\ttemp_strength = (float)cap_temp\
    \ - sm_temp;\n\t\tif (temp_strength > strongest_strength) {\n\t\t\tstrongest_strength\
    \ = temp_strength;\n\t\t\tstrongest = s;\n\t\t}\n\t\tcap_temp = 0;\n\t\tsm_temp\
    \ = 0;\n\t}\n\treturn class_name + \".\" + strongest;", "    std::string ans =\
    \ class_name;\n    double max_stren = -1000000;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        double strength = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] < 'a') {\n                strength\
    \ += 1;\n            } else {\n                strength -= 1;\n            }\n\
    \        }\n        if (strength > max_stren) {\n            max_stren = strength;\n\
    \            ans = class_name + \".\" + extensions[i];\n        }\n    }\n   \
    \ return ans;", "  float max = 0;\n  std::string str = \"\";\n  for(int i = 0;\
    \ i < extensions.size(); i++) {\n    float cap = 0;\n    float sm = 0;\n    for(int\
    \ j = 0; j < extensions[i].size(); j++) {\n      if(extensions[i][j] >= 'A' &&\
    \ extensions[i][j] <= 'Z') {\n        cap++;\n      }\n      else if(extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z') {\n        sm++;\n      }\n    }\n    float\
    \ temp = cap - sm;\n    if(temp > max) {\n      max = temp;\n      str = extensions[i];\n\
    \    }\n  }\n  return class_name + \".\" + str;", "    if (extensions.size() ==\
    \ 0) {\n        return class_name;\n    }\n    int strongest_extension_index =\
    \ 0;\n    double strongest_extension_strength = -100;\n    for (int i = 0; i <\
    \ extensions.size(); i++) {\n        double extension_strength = 0;\n        for\
    \ (int j = 0; j < extensions[i].size(); j++) {\n            if (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n                extension_strength++;\n\
    \            } else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\
    \                extension_strength--;\n            }\n        }\n        if (extension_strength\
    \ > strongest_extension_strength) {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension_index = i;\n        }\n\
    \    }\n    return class_name + \".\" + extensions[strongest_extension_index];",
  "    std::string result;\n    std::vector<double> strengths;\n    double str_max\
    \ = 0;\n    int max_index = 0;\n    for (int i = 0; i < extensions.size(); i++)\
    \ {\n        int str_uppercase = 0;\n        int str_lowercase = 0;\n        for\
    \ (int j = 0; j < extensions[i].size(); j++) {\n            if (isupper(extensions[i][j]))\
    \ {\n                str_uppercase++;\n            } else {\n                str_lowercase++;\n\
    \            }\n        }\n        strengths.push_back(str_uppercase - str_lowercase);\n\
    \        if (strengths[i] > str_max) {\n            str_max = strengths[i];\n\
    \            max_index = i;\n        }\n    }\n    result = class_name + \".\"\
    \ + extensions[max_index];\n    return result;", "\t// Write your code here\n\t\
    int bestStrength = INT_MIN;\n\tint bestIndex = -1;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tint CAP = 0;\n\t\tint SM = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n\t\t\t\
    \tCAP++;\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z')\n\
    \t\t\t\tSM++;\n\t\t}\n\t\tint strength = CAP - SM;\n\t\tif (strength > bestStrength)\
    \ {\n\t\t\tbestStrength = strength;\n\t\t\tbestIndex = i;\n\t\t}\n\t}\n\treturn\
    \ class_name + \".\" + extensions[bestIndex];", "    double total_strength = 0.0;\n\
    \    int uppercase = 0;\n    int lowercase = 0;\n    std::string extension;\n\
    \    std::string class_and_extension;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        for (int j = 0; j < extensions[i].size(); j++) {\n         \
    \   if (isupper(extensions[i][j])) {\n                uppercase++;\n         \
    \   } else {\n                lowercase++;\n            }\n        }\n       \
    \ total_strength = (double)uppercase/(double)lowercase;\n        if (total_strength\
    \ > 0) {\n            class_and_extension = class_name + \".\" + extensions[i];\n\
    \            return class_and_extension;\n        }\n    }\n    return class_and_extension;",
  "\t// Write your code here and remove the below line.\n\tint num1, num2, len, max;\n\
    \tmax = 0;\n\tstd::string Strongest_Extension;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tnum1 = 0;\n\t\tnum2 = 0;\n\t\tlen = extensions[i].length();\n\t\t\
    for (int j = 0; j < len; j++) {\n\t\t\tif (islower(extensions[i][j])) {\n\t\t\t\
    \tnum2++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum1++;\n\t\t\t}\n\t\t}\n\t\tif (num1\
    \ - num2 > max) {\n\t\t\tmax = num1 - num2;\n\t\t\tStrongest_Extension = extensions[i];\n\
    \t\t}\n\t}\n\treturn (class_name + \".\" + Strongest_Extension);", "    int max_strength\
    \ = INT_MIN;\n    std::string answer = \"\";\n    for (auto ex : extensions) {\n\
    \        int strength = 0;\n        for (auto x : ex) {\n            if (x >=\
    \ 'A' && x <= 'Z') {\n                strength++;\n            } else if (x >=\
    \ 'a' && x <= 'z') {\n                strength--;\n            }\n        }\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            answer = ex;\n        }\n    }\n    return class_name + \".\" + answer;",
  "\tint max_strength = 0;\n\tstd::string strongest_extension;\n\tfor (std::string\
    \ extension : extensions) {\n\t\tint cap = 0, sm = 0;\n\t\tfor (char ch : extension)\
    \ {\n\t\t\tif (isupper(ch))\n\t\t\t\tcap++;\n\t\t\telse\n\t\t\t\tsm++;\n\t\t}\n\
    \t\tint strength = cap - sm;\n\t\tif (strength > max_strength) {\n\t\t\tmax_strength\
    \ = strength;\n\t\t\tstrongest_extension = extension;\n\t\t}\n\t}\n\treturn class_name\
    \ + \".\" + strongest_extension;", "  int max = 0;\n  int index = 0;\n  for (int\
    \ i = 0; i < extensions.size(); i++) {\n    int up = 0;\n    int lo = 0;\n   \
    \ for (int j = 0; j < extensions[i].size(); j++) {\n      if (islower(extensions[i][j]))\
    \ {\n        lo++;\n      } else {\n        up++;\n      }\n    }\n    int strength\
    \ = up - lo;\n    if (strength > max) {\n      max = strength;\n      index =\
    \ i;\n    }\n  }\n  return class_name + \".\" + extensions[index];", "  int max_strength\
    \ = 0;\n  std::string result = class_name;\n  std::vector<int> strenghts;\n  int\
    \ CAP = 0;\n  int SM = 0;\n  for (std::string extension : extensions) {\n    CAP\
    \ = 0;\n    SM = 0;\n    for (char letter : extension) {\n      if (isupper(letter))\
    \ {\n        CAP++;\n      } else {\n        SM++;\n      }\n    }\n    strenghts.push_back(CAP\
    \ - SM);\n  }\n  for (int i = 0; i < strenghts.size(); i++) {\n    if (strenghts[i]\
    \ > max_strength) {\n      max_strength = strenghts[i];\n      result += '.' +\
    \ extensions[i];\n    }\n  }\n  return result;", "    // write your code here\n\
    \    int greatest = 0;\n    int greatest_position = 0;\n    int caps = 0;\n  \
    \  int smalls = 0;\n    int strength = 0;\n    for(int i = 0; i < extensions.size();\
    \ i++){\n        caps = std::count_if(extensions[i].begin(), extensions[i].end(),\
    \ [](char c){return std::isupper(c);});\n        smalls = std::count_if(extensions[i].begin(),\
    \ extensions[i].end(), [](char c){return std::islower(c);});\n        strength\
    \ = caps - smalls;\n        if(strength > greatest){\n            greatest = strength;\n\
    \            greatest_position = i;\n        }\n    }\n    return class_name +\
    \ \".\" + extensions[greatest_position];", "\tstd::string strong_ext;\n\tint strong_value\
    \ = -1;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint upp = 0;\n\t\
    \tint low = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif\
    \ (isupper(extensions[i][j])) {\n\t\t\t\tupp++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\
    \tlow++;\n\t\t\t}\n\t\t}\n\t\tint temp = upp - low;\n\t\tif (temp > strong_value)\
    \ {\n\t\t\tstrong_value = temp;\n\t\t\tstrong_ext = extensions[i];\n\t\t}\n\t\
    }\n\treturn class_name + \".\" + strong_ext;", "    int max_strength = 0;\n  \
    \  std::string strongest_extension;\n    for (auto& ext : extensions) {\n    \
    \    int capital_letters = 0;\n        int small_letters = 0;\n        for (auto\
    \ letter : ext) {\n            if (isupper(letter)) {\n                capital_letters++;\n\
    \            } else {\n                small_letters++;\n            }\n     \
    \   }\n        int strength = capital_letters - small_letters;\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            strongest_extension\
    \ = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;",
  "    double maxStrength = -1;\n    double currentStrength = 0;\n    std::string\
    \ strongestExtension = \"\";\n    for (int i = 0; i < extensions.size(); i++)\
    \ {\n        for (int j = 0; j < extensions[i].length(); j++) {\n            if\
    \ (isupper(extensions[i][j])) {\n                currentStrength += 1;\n     \
    \       } else {\n                currentStrength -= 1;\n            }\n     \
    \   }\n        if (currentStrength > maxStrength) {\n            maxStrength =\
    \ currentStrength;\n            strongestExtension = extensions[i];\n        }\n\
    \        currentStrength = 0;\n    }\n    return class_name + \".\" + strongestExtension;",
  "    std::string best_extension = \"\";\n    double best_extension_value = 0;\n\
    \    for (std::string extension : extensions) {\n        double value = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::isupper(c);\n       \
    \ }) - std::count_if(extension.begin(), extension.end(), [](char c) {\n      \
    \      return std::islower(c);\n        });\n        if (value > best_extension_value)\
    \ {\n            best_extension_value = value;\n            best_extension = extension;\n\
    \        }\n    }\n    return class_name + \".\" + best_extension;", "\tfloat\
    \ max = 0;\n\tint index = 0;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\
    \t\tfloat cap = 0;\n\t\tfloat sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (isupper(extensions[i][j])) {\n\t\t\t\tcap++;\n\t\t\t}\n\t\t\
    \telse if (islower(extensions[i][j])) {\n\t\t\t\tsm++;\n\t\t\t}\n\t\t}\n\t\tfloat\
    \ strength = cap - sm;\n\t\tif (strength > max) {\n\t\t\tmax = strength;\n\t\t\
    \tindex = i;\n\t\t}\n\t}\n\tstd::string max_strength = extensions[index];\n\t\
    return class_name + \".\" + max_strength;", "\tint cap_max = 0;\n\tint sm_max\
    \ = 0;\n\tint final_index = 0;\n\tfor (int i = 0; i < extensions.size(); i++)\
    \ {\n\t\tint cap = 0;\n\t\tint sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (islower(extensions[i][j]))\n\t\t\t\tsm++;\n\t\t\telse\n\t\t\
    \t\tcap++;\n\t\t}\n\t\tif (cap - sm > cap_max - sm_max) {\n\t\t\tcap_max = cap;\n\
    \t\t\tsm_max = sm;\n\t\t\tfinal_index = i;\n\t\t}\n\t}\n\tstd::string result =\
    \ class_name + \".\" + extensions[final_index];\n\treturn result;", '  // Your
    code here.', "    assert(class_name.length() > 0);\n    assert(extensions.size()\
    \ > 0);\n    std::string result;\n    std::vector<std::pair<int, int>> num_cap_sm;\n\
    \    // calculate # of CAP and SM\n    for (auto extension : extensions) {\n \
    \       int num_cap = 0;\n        int num_sm = 0;\n        for (auto letter :\
    \ extension) {\n            if (isupper(letter)) {\n                num_cap++;\n\
    \            } else {\n                num_sm++;\n            }\n        }\n \
    \       num_cap_sm.push_back(std::make_pair(num_cap, num_sm));\n    }\n    //\
    \ find the index of strongest extension\n    int index = 0;\n    double max_strength\
    \ = -1.0;\n    for (int i = 0; i < num_cap_sm.size(); i++) {\n        auto element\
    \ = num_cap_sm[i];\n        double strength = element.first - element.second;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            index = i;\n        }\n    }\n    // concatenate the class name and\
    \ the strongest extension\n    result = class_name + \".\" + extensions[index];\n\
    \    return result;", "\tstd::string result = class_name;\n\tint max_strength\
    \ = 0;\n\tfor (std::string extension : extensions) {\n\t\tint strength = 0;\n\t\
    \tfor (char c : extension) {\n\t\t\tif (isupper(c)) strength++;\n\t\t\telse if\
    \ (islower(c)) strength--;\n\t\t}\n\t\tif (strength > max_strength) {\n\t\t\t\
    max_strength = strength;\n\t\t\tresult += \".\" + extension;\n\t\t}\n\t}\n\treturn\
    \ result;", "\tint i, j, c, max;\n\tstd::string str, max_str;\n\tif(extensions.size()\
    \ == 0) {\n\t\treturn \"\";\n\t}\n\tmax = -extensions[0].size();\n\tmax_str =\
    \ extensions[0];\n\tfor(i = 0; i < extensions.size(); i++) {\n\t\tstr = extensions[i];\n\
    \t\tc = 0;\n\t\tfor(j = 0; j < str.size(); j++) {\n\t\t\tif(isupper(str[j])) {\n\
    \t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c - (str.size() - c) > max) {\n\t\t\tmax\
    \ = c - (str.size() - c);\n\t\t\tmax_str = str;\n\t\t}\n\t}\n\treturn class_name\
    \ + \".\" + max_str;", "    int i = 0;\n    int maximum = 0;\n    std::string\
    \ result = \"\";\n    for (auto extension : extensions) {\n        int capital_letters\
    \ = 0;\n        int small_letters = 0;\n        for (int i = 0; i < extension.length();\
    \ i++) {\n            if (extension[i] <= 'Z' && extension[i] >= 'A') {\n    \
    \            capital_letters++;\n            } else if (extension[i] <= 'z' &&\
    \ extension[i] >= 'a') {\n                small_letters++;\n            }\n  \
    \      }\n        if (maximum < capital_letters - small_letters) {\n         \
    \   maximum = capital_letters - small_letters;\n            result = extension;\n\
    \        }\n    }\n    return class_name + \".\" + result;", "  // place your\
    \ code here\n  int max_strength = -100;\n  int max_index = 0;\n  for(int i = 0;\
    \ i < extensions.size(); i++) {\n    int strength = 0;\n    for(int j = 0; j <\
    \ extensions[i].size(); j++) {\n      if(isupper(extensions[i][j])) {\n      \
    \  strength++;\n      }\n      else {\n        strength--;\n      }\n    }\n \
    \   if(strength > max_strength) {\n      max_strength = strength;\n      max_index\
    \ = i;\n    }\n  }\n  std::string s = class_name + \".\" + extensions[max_index];\n\
    \  return s;", "\t// transform to lower case\n\tstd::transform(class_name.begin(),\
    \ class_name.end(), class_name.begin(), ::tolower);\n\tstd::transform(extensions.begin(),\
    \ extensions.end(), extensions.begin(), [](std::string extension) {\n\t\tstd::transform(extension.begin(),\
    \ extension.end(), extension.begin(), ::tolower);\n\t\treturn extension;\n\t});\n\
    \t// determine number of uppercase letters\n\tauto num_uppercase = [](std::string\
    \ str) {\n\t\tsize_t num_uc = 0;\n\t\tfor (size_t i = 0; i < str.size(); ++i)\
    \ {\n\t\t\tif (str[i] >= 'A' && str[i] <= 'Z')\n\t\t\t\t++num_uc;\n\t\t}\n\t\t\
    return num_uc;\n\t};\n\t// determine number of lowercase letters\n\tauto num_lowercase\
    \ = [](std::string str) {\n\t\tsize_t num_lc = 0;\n\t\tfor (size_t i = 0; i <\
    \ str.size(); ++i) {\n\t\t\tif (str[i] >= 'a' && str[i] <= 'z')\n\t\t\t\t++num_lc;\n\
    \t\t}\n\t\treturn num_lc;\n\t};\n\tsize_t max_strength = 0;\n\tsize_t max_ext_idx\
    \ = 0;\n\tfor (size_t i = 0; i < extensions.size(); ++i) {\n\t\t// get num of\
    \ uppercase and lowercase\n\t\tsize_t num_uc = num_uppercase(extensions[i]);\n\
    \t\tsize_t num_lc = num_lowercase(extensions[i]);\n\t\t// compute strength\n\t\
    \tsize_t strength = num_uc - num_lc;\n\t\tif (strength > max_strength) {\n\t\t\
    \tmax_strength = strength;\n\t\t\tmax_ext_idx = i;\n\t\t}\n\t}\n\treturn class_name\
    \ + \".\" + extensions[max_ext_idx];", "    std::string result = class_name;\n\
    \    std::sort(extensions.begin(), extensions.end(),\n    [](std::string &a, std::string\
    \ &b) {\n        return (std::count_if(a.begin(), a.end(), ::isupper()) - std::count_if(a.begin(),\
    \ a.end(), ::islower())) > (std::count_if(b.begin(), b.end(), ::isupper()) - std::count_if(b.begin(),\
    \ b.end(), ::islower()));\n    });\n    result += '.' + extensions[0];\n    return\
    \ result;", "  int best_strength = INT_MIN;\n  std::string best_ext;\n  for (auto\
    \ extension : extensions) {\n    int lower = 0;\n    int upper = 0;\n    for (auto\
    \ c : extension) {\n      if (std::isupper(c))\n        upper++;\n      else\n\
    \        lower++;\n    }\n    if (upper - lower > best_strength) {\n      best_strength\
    \ = upper - lower;\n      best_ext = extension;\n    }\n  }\n  return class_name\
    \ + \".\" + best_ext;", "    std::string res = class_name + \".\";\n    int str\
    \ = 0;\n    for (auto ext : extensions) {\n        int cap = 0, sm = 0;\n    \
    \    for (char c : ext) {\n            if (isupper(c))\n                cap++;\n\
    \            else if (islower(c))\n                sm++;\n        }\n        if\
    \ (cap - sm > str) {\n            str = cap - sm;\n            res += ext;\n \
    \       }\n    }\n    return res;", "    std::string result;\n    int strength,\
    \ max_strength = 0;\n    int CAP, SM;\n    int e_size = extensions.size();\n \
    \   for (int i = 0; i < e_size; i++) {\n        CAP = 0;\n        SM = 0;\n  \
    \      for (int j = 0; j < extensions[i].size(); j++) {\n            if (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n                CAP++;\n            }\
    \ else if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n           \
    \     SM++;\n            }\n        }\n        strength = CAP - SM;\n        if\
    \ (strength > max_strength) {\n            max_strength = strength;\n        \
    \    result = class_name + \".\" + extensions[i];\n        }\n    }\n    return\
    \ result;", "\t\n\tint max = 0;\n\tint index = 0;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tint upper = 0;\n\t\tint lower = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (extensions[i][j] > 64 && extensions[i][j] < 91) {\n\t\t\t\t\
    upper++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlower++;\n\t\t\t}\n\t\t}\n\t\tif (upper\
    \ - lower > max) {\n\t\t\tmax = upper - lower;\n\t\t\tindex = i;\n\t\t}\n\t}\n\
    \treturn class_name + \".\" + extensions[index];", "\tint cmp = INT_MIN;\n\tstd::string\
    \ cmp_str;\n\tfor (auto& s : extensions) {\n\t\tint cnt_upper = 0, cnt_lower =\
    \ 0;\n\t\tfor (auto& ch : s) {\n\t\t\tif (std::isupper(ch)) {\n\t\t\t\t++cnt_upper;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\t++cnt_lower;\n\t\t\t}\n\t\t}\n\t\tint tmp = cnt_upper\
    \ - cnt_lower;\n\t\tif (tmp > cmp) {\n\t\t\tcmp = tmp;\n\t\t\tcmp_str = s;\n\t\
    \t}\n\t}\n\treturn class_name + \".\" + cmp_str;", "\tint cap_cnt = 0, sm_cnt\
    \ = 0;\n\tstd::string res;\n\tint max_diff = 0;\n\tfor (std::string e : extensions)\
    \ {\n\t\tcap_cnt = 0, sm_cnt = 0;\n\t\tfor (int i = 0; i < e.size(); i++) {\n\t\
    \t\tif (e[i] >= 'A' && e[i] <= 'Z')\n\t\t\t\tcap_cnt++;\n\t\t\telse\n\t\t\t\t\
    sm_cnt++;\n\t\t}\n\t\tif (max_diff < cap_cnt - sm_cnt) {\n\t\t\tmax_diff = cap_cnt\
    \ - sm_cnt;\n\t\t\tres = e;\n\t\t}\n\t}\n\treturn class_name + \".\" + res;",
  "    std::string strongest;\n    double strength = 0;\n    double next_strength\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        next_strength\
    \ = 0;\n        for (int j = 0; j < extensions[i].size(); j++) {\n           \
    \ if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n                next_strength\
    \ += 1;\n            } else if (extensions[i][j] >= 'a' && extensions[i][j] <=\
    \ 'z') {\n                next_strength -= 1;\n            }\n        }\n    \
    \    if (next_strength > strength) {\n            strength = next_strength;\n\
    \            strongest = extensions[i];\n        }\n    }\n    return class_name\
    \ + \".\" + strongest;", "  double max_strength{0.0};\n  std::string ans{\"\"\
    };\n  for (const auto& extension : extensions) {\n    int upper_case{0};\n   \
    \ int lower_case{0};\n    for (const auto& c : extension) {\n      if (isupper(c))\
    \ {\n        ++upper_case;\n      } else {\n        ++lower_case;\n      }\n \
    \   }\n    double strength{static_cast<double>(upper_case - lower_case)};\n  \
    \  if (strength > max_strength) {\n      max_strength = strength;\n      ans =\
    \ extension;\n    }\n  }\n  return class_name + \".\" + ans;", "  // your code\
    \ here\n  std::string classe;\n  std::string extensione;\n  int strength = 0;\n\
    \  for(int i = 0; i < extensions.size(); i++){\n    int caps = 0;\n    int smalls\
    \ = 0;\n    for(int j = 0; j < extensions[i].size(); j++){\n      if(extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z')\n        caps++;\n      else if(extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z')\n        smalls++;\n    }\n    if(caps -\
    \ smalls > strength){\n      strength = caps - smalls;\n      classe = class_name;\n\
    \      extensione = extensions[i];\n    }\n  }\n  return classe + \".\" + extensione;",
  "\t// Write your code here!", "  int count = 0;\n  float strength = 0;\n  int index;\n\
    \  int sz = extensions.size();\n  for(int i = 0; i < sz; i++) {\n    count = 0;\n\
    \    std::string curr = extensions[i];\n    for(int j = 0; j < curr.length();\
    \ j++) {\n      if(isupper(curr[j]))\n        count++;\n    }\n    if(strength\
    \ < (float)(count - (curr.length() - count))) {\n      strength = (float)(count\
    \ - (curr.length() - count));\n      index = i;\n    }\n  }\n  std::string result\
    \ = class_name + \".\" + extensions[index];\n  return result;", "    auto calc_strength\
    \ = [](std::string ext) {\n        int CAP = 0, SM = 0;\n        for (auto i :\
    \ ext) {\n            if (isupper(i)) CAP++;\n            else if (islower(i))\
    \ SM++;\n        }\n        return static_cast<double>(CAP - SM);\n    };\n  \
    \  std::vector<std::pair<std::string, double>> answer(extensions.size());\n  \
    \  std::transform(extensions.begin(), extensions.end(), answer.begin(), [calc_strength](auto\
    \ e) {\n        return std::make_pair(e, calc_strength(e));\n    });\n    std::stable_sort(answer.begin(),\
    \ answer.end(), [](auto a, auto b) {\n        return a.second > b.second;\n  \
    \  });\n    return answer[0].second < 0 ? class_name + \".\" + answer[0].first\
    \ : class_name;", "\tint max_strength = 0;\n\tstd::string max_strength_extension\
    \ = extensions[0];\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint lower_case_count\
    \ = 0;\n\t\tint upper_case_count = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\
    \t\tlower_case_count++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'A' && extensions[i][j]\
    \ <= 'Z') {\n\t\t\t\tupper_case_count++;\n\t\t\t}\n\t\t}\n\t\tif (max_strength\
    \ < upper_case_count - lower_case_count) {\n\t\t\tmax_strength = upper_case_count\
    \ - lower_case_count;\n\t\t\tmax_strength_extension = extensions[i];\n\t\t}\n\t\
    }\n\treturn class_name + \".\" + max_strength_extension;", "    std::string str\
    \ = class_name;\n    std::string ext;\n    std::string res = class_name;\n   \
    \ int s,ss = 0;\n    int cap,sm;\n    for(auto i : extensions){\n        cap =\
    \ 0;\n        sm = 0;\n        for(auto j : i){\n            if(isupper(j)) cap++;\n\
    \            else sm++;\n        }\n        if(cap - sm > ss){\n            ss\
    \ = cap - sm;\n            ext = i;\n        }\n    }\n    res += \".\" + ext;\n\
    \    return res;", "    int a = 0,b = 0,c = 0,d = 0;\n    std::string ans;\n \
    \   for(int i = 0; i < extensions.size(); i++) {\n        for(int j = 0; j < extensions[i].size();\
    \ j++) {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n\
    \                a++;\n            else\n                b++;\n        }\n   \
    \     if(a-b > c-d) {\n            c = a;\n            d = b;\n            ans\
    \ = extensions[i];\n        }\n        a = 0;\n        b = 0;\n    }\n    return\
    \ class_name + \".\" + ans;", "    //initialise the strength\n    float strength\
    \ = -100;\n    int index = 0;\n    //traverse through the vector of strings\n\
    \    for(int i = 0; i < extensions.size(); i++) {\n        float temp = (extensions[i].length()\
    \ - std::count_if(extensions[i].begin(), extensions[i].end(), ::islower));\n \
    \       //check which is bigger and save the index of the biggest string\n   \
    \     if(temp > strength) {\n            strength = temp;\n            index =\
    \ i;\n        }\n    }\n    //return the string in the format of className.strongestExtensionName\n\
    \    return class_name + \".\" + extensions[index];", "    float str_cap_sm,max_cap_sm=-10;\n\
    \    int cap,sm,i;\n    std::string strongest_extension;\n    for(auto x:extensions)\n\
    \    {\n        cap=0;\n        sm=0;\n        for(i=0;i<x.length();i++)\n   \
    \     {\n            if(isupper(x[i]))\n            {\n                cap++;\n\
    \            }\n            else\n            {\n                sm++;\n     \
    \       }\n        }\n        str_cap_sm=cap-sm;\n        if(str_cap_sm>max_cap_sm)\n\
    \        {\n            max_cap_sm=str_cap_sm;\n            strongest_extension=x;\n\
    \        }\n    }\n    return class_name+\".\"+strongest_extension;", "  std::string\
    \ strongest_extension;\n  float strength = 0;\n  for (auto && extension : extensions)\
    \ {\n    float cap = 0;\n    float sm = 0;\n    for (auto && c : extension) {\n\
    \      if (isupper(c)) {\n        cap++;\n      } else {\n        sm++;\n    \
    \  }\n    }\n    float current_strength = cap - sm;\n    if (current_strength\
    \ > strength) {\n      strength = current_strength;\n      strongest_extension\
    \ = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;",
  "  double strongest_extension_strength = -2.0;\n  std::string strongest_extension_name\
    \ = \"\";\n  for (int i = 0; i < extensions.size(); i++) {\n    double current_extension_strength\
    \ = 0.0;\n    for (int j = 0; j < extensions[i].size(); j++) {\n      if (isupper(extensions[i][j]))\
    \ {\n        current_extension_strength += 1.0;\n      } else {\n        current_extension_strength\
    \ -= 1.0;\n      }\n    }\n    if (current_extension_strength > strongest_extension_strength)\
    \ {\n      strongest_extension_strength = current_extension_strength;\n      strongest_extension_name\
    \ = extensions[i];\n    }\n  }\n  return class_name + \".\" + strongest_extension_name;",
  "  std::string result;\n  double max = 0;\n  std::vector<int>ext(extensions.size());\n\
    \  for(int i = 0; i < extensions.size(); i++){\n    for(int j = 0; j < extensions[i].size();\
    \ j++){\n      if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z'){\n     \
    \   ext[i]++;\n      }\n    }\n    for(int j = 0; j < extensions[i].size(); j++){\n\
    \      if(extensions[i][j] >= 'a' && extensions[i][j] <= 'z'){\n        ext[i]--;\n\
    \      }\n    }\n    if(ext[i] > max){\n      max = ext[i];\n      result = class_name\
    \ + \".\" + extensions[i];\n    }\n  }\n  return result;", "    std::string strongest_extension;\n\
    \    float max_strength = -100.0;\n    float strength;\n    int lc = 0;\n    int\
    \ uc = 0;\n    int len;\n    for (int i = 0; i < extensions.size(); i++) {\n \
    \       lc = 0;\n        uc = 0;\n        len = extensions[i].length();\n    \
    \    for (int j = 0; j < len; j++) {\n            if (extensions[i][j] >= 'a'\
    \ && extensions[i][j] <= 'z')\n                lc++;\n            else if (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z')\n                uc++;\n        }\n     \
    \   strength = (float) uc / lc;\n        if (strength > max_strength) {\n    \
    \        max_strength = strength;\n            strongest_extension = extensions[i];\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;", "\t\
    std::vector<std::string> answer;\n\tstd::string answer_str = \"\";\n\tdouble CAP\
    \ = 0;\n\tdouble SM = 0;\n\tdouble max_strength = 0;\n\tfor (std::string extension\
    \ : extensions) {\n\t\tfor (char ch : extension) {\n\t\t\tif (isupper(ch)) {\n\
    \t\t\t\tCAP++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSM++;\n\t\t\t}\n\t\t}\n\t\tdouble\
    \ strength = CAP - SM;\n\t\tif (strength == max_strength) {\n\t\t\tanswer.push_back(extension);\n\
    \t\t}\n\t\telse if (strength > max_strength) {\n\t\t\tmax_strength = strength;\n\
    \t\t\tanswer.clear();\n\t\t\tanswer.push_back(extension);\n\t\t}\n\t\tCAP = 0;\n\
    \t\tSM = 0;\n\t}\n\tstd::sort(answer.begin(), answer.end());\n\tanswer_str = class_name\
    \ + \".\" + answer[0];\n\treturn answer_str;", "    std::string extension = \"\
    \";\n    int caps = 0;\n    int sm = 0;\n    double max = 0;\n    double current\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        caps = 0;\n\
    \        sm = 0;\n        for (int j = 0; j < extensions[i].size(); j++) {\n \
    \           if (std::isupper(extensions[i][j])) {\n                caps++;\n \
    \           } else {\n                sm++;\n            }\n        }\n      \
    \  current = (double)caps - (double)sm;\n        if (current > max) {\n      \
    \      max = current;\n            extension = extensions[i];\n        }\n   \
    \ }\n    return class_name + \".\" + extension;", "    int max_strength = -100;\n\
    \    int count_extension = extensions.size();\n    int max_strength_index = 0;\n\
    \    // find the strongest extension.\n    for (int i = 0; i < count_extension;\
    \ i++) {\n        int strength = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\
    \ {\n                strength++;\n            } else if (extensions[i][j] >= 'a'\
    \ && extensions[i][j] <= 'z') {\n                strength--;\n            }\n\
    \        }\n        if (strength > max_strength) {\n            max_strength =\
    \ strength;\n            max_strength_index = i;\n        }\n    }\n    return\
    \ class_name + \".\" + extensions[max_strength_index];", "    int i;\n    int\
    \ cap, sm;\n    double max;\n    int index = 0;\n    for(i = 0; i < extensions.size();\
    \ i++) {\n        cap = sm = 0;\n        for(int j = 0; j < extensions[i].size();\
    \ j++) {\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n\
    \                cap++;\n            else if(extensions[i][j] >= 'a' && extensions[i][j]\
    \ <= 'z')\n                sm++;\n        }\n        if(i == 0) {\n          \
    \  max = (double)cap - sm;\n            index = i;\n        }\n        else {\n\
    \            if(((double)cap - sm) > max) {\n                max = (double)cap\
    \ - sm;\n                index = i;\n            }\n        }\n    }\n    return\
    \ class_name + \".\" + extensions[index];", "\tint str_class=0;\n\tfor(int i=0;i<class_name.length();i++){\n\
    \t\tif(isupper(class_name[i]))\n\t\t\tstr_class++;\n\t}\n\tint max=-1,max_index=-1;\n\
    \tfor(int i=0;i<extensions.size();i++){\n\t\tint str_ext=0;\n\t\tfor(int j=0;j<extensions[i].length();j++){\n\
    \t\t\tif(isupper(extensions[i][j]))\n\t\t\t\tstr_ext++;\n\t\t}\n\t\tif(str_ext-str_class>max){\n\
    \t\t\tmax=str_ext-str_class;\n\t\t\tmax_index=i;\n\t\t}\n\t}\n\treturn class_name+\"\
    .\"+extensions[max_index];", "\tfloat strength = 0;\n\tstd::string name;\n\tint\
    \ len = extensions.size();\n\tif (len == 0)\n\t\treturn class_name;\n\telse {\n\
    \t\tint count = 0;\n\t\tfor (auto i : extensions) {\n\t\t\tint temp1 = 0, temp2\
    \ = 0;\n\t\t\tfor (auto j : i) {\n\t\t\t\tif (j <= 'Z' && j >= 'A')\n\t\t\t\t\t\
    temp1++;\n\t\t\t\telse if (j <= 'z' && j >= 'a')\n\t\t\t\t\ttemp2++;\n\t\t\t}\n\
    \t\t\tfloat temp = (float)temp1 - (float)temp2;\n\t\t\tif (temp == strength) {\n\
    \t\t\t\tif (count < i.size()) {\n\t\t\t\t\tcount = i.size();\n\t\t\t\t\tname =\
    \ i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (temp > strength) {\n\t\t\t\tstrength\
    \ = temp;\n\t\t\t\tname = i;\n\t\t\t\tcount = i.size();\n\t\t\t}\n\t\t}\n\t\t\
    class_name += \".\";\n\t\tclass_name += name;\n\t\treturn class_name;\n\t}", " \
    \   double max = -100;\n    std::string str = \"\";\n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        int num_upper = 0;\n        int num_lower = 0;\n        for(int\
    \ j = 0; j < extensions[i].size(); j++) {\n            if(islower(extensions[i][j]))\
    \ {\n                num_lower++;\n            }\n            else {\n       \
    \         num_upper++;\n            }\n        }\n        if(static_cast<double>(num_upper)\
    \ - static_cast<double>(num_lower) > max) {\n            max = static_cast<double>(num_upper)\
    \ - static_cast<double>(num_lower);\n            str = extensions[i];\n      \
    \  }\n    }\n    return class_name + \".\" + str;", "   std::string strongest_ext;\n\
    \   int strongest_strength = 0;\n   int upper_case = 0;\n   int lower_case = 0;\n\
    \   for (auto ext: extensions) {\n      upper_case = 0;\n      lower_case = 0;\n\
    \      for (auto ch: ext) {\n         if (std::isupper(ch))\n            upper_case++;\n\
    \         else if (std::islower(ch))\n            lower_case++;\n      }\n   \
    \   if (strongest_strength <= upper_case - lower_case) {\n         strongest_strength\
    \ = upper_case - lower_case;\n         strongest_ext = ext;\n      }\n   }\n \
    \  std::string answer = class_name + \".\" + strongest_ext;\n   return answer;",
  "    std::string strongest_extension;\n    int strongest_extension_strength = -1;\n\
    \    for (auto extension : extensions) {\n        int uppercase_letters = 0;\n\
    \        int lowercase_letters = 0;\n        for (auto c : extension) {\n    \
    \        if (std::isupper(c)) {\n                uppercase_letters++;\n      \
    \      } else {\n                lowercase_letters++;\n            }\n       \
    \ }\n        if (uppercase_letters - lowercase_letters > strongest_extension_strength)\
    \ {\n            strongest_extension_strength = uppercase_letters - lowercase_letters;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;", "    int caps = 0;\n    int smalls = 0;\n \
    \   int *max = new int;\n    *max = -100;\n    std::string result = \"\";\n  \
    \  for (auto extension : extensions) {\n        int caps = 0;\n        int smalls\
    \ = 0;\n        for (auto it : extension) {\n            if (it >= 'A' && it <=\
    \ 'Z') {\n                caps++;\n            } else if (it >= 'a' && it <= 'z')\
    \ {\n                smalls++;\n            }\n        }\n        if ((caps -\
    \ smalls) > *max) {\n            *max = caps - smalls;\n            result = extension;\n\
    \        }\n    }\n    return class_name + \".\" + result;", "\t// Create a function\
    \ that takes a string and a list of extensions as arguments,\n\t// and returns\
    \ the strongest extension.\n\n\tstd::string strongest = \"\";\n\tdouble cap =\
    \ 0;\n\tdouble sm = 0;\n\tint count = 0;\n\tdouble first = 0;\n\tdouble second\
    \ = 0;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tfirst = 0;\n\t\t\
    second = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\telse\
    \ if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\t\tsecond++;\n\
    \t\t\t}\n\t\t}\n\t\tif (first - second > cap - sm) {\n\t\t\tcap = first;\n\t\t\
    \tsm = second;\n\t\t\tstrongest = extensions[i];\n\t\t}\n\t}\n\tstd::string ret\
    \ = class_name + \".\" + strongest;\n\treturn ret;", "    std::sort(extensions.begin(),\
    \ extensions.end(), [](std::string a, std::string b) {\n        int uppercase_a\
    \ = 0, lowercase_a = 0, uppercase_b = 0, lowercase_b = 0;\n        for (char letter\
    \ : a) {\n            if (isupper(letter)) {\n                uppercase_a++;\n\
    \            } else {\n                lowercase_a++;\n            }\n       \
    \ }\n        for (char letter : b) {\n            if (isupper(letter)) {\n   \
    \             uppercase_b++;\n            } else {\n                lowercase_b++;\n\
    \            }\n        }\n        if (uppercase_a - lowercase_a == uppercase_b\
    \ - lowercase_b) {\n            return a < b;\n        }\n        return uppercase_a\
    \ - lowercase_a > uppercase_b - lowercase_b;\n    });\n    return class_name +\
    \ \".\" + extensions[0];", "    // your code here\n    std::string strongest =\
    \ \"\";\n    float count = -100;\n    for(int i = 0; i < extensions.size(); i++){\n\
    \        int CAP = 0;\n        int SM = 0;\n        for(int j = 0; j < extensions[i].size();\
    \ j++){\n            if(extensions[i][j] >= 'A' && extensions[i][j] <= 'Z'){\n\
    \                CAP++;\n            }\n            else{\n                SM++;\n\
    \            }\n        }\n        float strength = (float)CAP - SM;\n       \
    \ if(strength > count){\n            count = strength;\n            strongest\
    \ = extensions[i];\n        }\n    }\n    return class_name + \".\" + strongest;",
  "\tint CAP = 0, SM = 0, index = 0;\n\tfor (int i = 0; i < extensions.size(); i++)\
    \ {\n\t\tint current_cap = 0, current_sm = 0;\n\t\tfor (int j = 0; j < extensions[i].size();\
    \ j++) {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z')\n\t\t\t\
    \tcurrent_cap++;\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <=\
    \ 'z')\n\t\t\t\tcurrent_sm++;\n\t\t}\n\t\tif (current_cap - current_sm > CAP -\
    \ SM) {\n\t\t\tCAP = current_cap;\n\t\t\tSM = current_sm;\n\t\t\tindex = i;\n\t\
    \t}\n\t}\n\treturn class_name + \".\" + extensions[index];", "  std::string strongest_extension_name;\n\
    \  float strongest_extension_strength = -999.0;\n  for (auto extension : extensions)\
    \ {\n    int upper_count = 0;\n    int lower_count = 0;\n    for (auto c : extension)\
    \ {\n      if (isupper(c))\n        upper_count++;\n      else if (islower(c))\n\
    \        lower_count++;\n    }\n    float extension_strength = float(upper_count\
    \ - lower_count);\n    if (extension_strength > strongest_extension_strength)\
    \ {\n      strongest_extension_strength = extension_strength;\n      strongest_extension_name\
    \ = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension_name;",
  "    // write your code here\n    float max = INT_MIN;\n    std::string output;\n\
    \    for(int i = 0; i < extensions.size(); i++) {\n        float cap = 0, sm =\
    \ 0;\n        std::cout << extensions[i] << std::endl;\n        for(int j = 0;\
    \ j < extensions[i].length(); j++) {\n            if(extensions[i][j] >= 'A' &&\
    \ extensions[i][j] <= 'Z') {\n                cap++;\n            } else {\n \
    \               sm++;\n            }\n        }\n        std::cout << cap << \"\
    \ \" << sm << std::endl;\n        if(cap - sm > max) {\n            max = cap\
    \ - sm;\n            output = extensions[i];\n        }\n    }\n    output = class_name\
    \ + \".\" + output;\n    return output;", "\tint strength = -1;\n\tstd::string\
    \ name;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\tint CAP = 0;\n\t\
    \tint SM = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif\
    \ (extensions[i][j] > 64 && extensions[i][j] < 91) {\n\t\t\t\tCAP++;\n\t\t\t}\n\
    \t\t\telse if (extensions[i][j] > 96 && extensions[i][j] < 123) {\n\t\t\t\tSM++;\n\
    \t\t\t}\n\t\t}\n\t\tif (CAP - SM > strength) {\n\t\t\tstrength = CAP - SM;\n\t\
    \t\tname = extensions[i];\n\t\t}\n\t}\n\tstd::string result = class_name + \"\
    .\" + name;\n\treturn result;", "  int sm = 0, cap = 0, strongest_extension_index\
    \ = 0;\n  for (int i = 0; i < extensions.size(); i++) {\n    int current_sm =\
    \ 0, current_cap = 0;\n    for (int j = 0; j < extensions[i].size(); j++) {\n\
    \      if (isupper(extensions[i][j])) {\n        current_cap++;\n      } else\
    \ {\n        current_sm++;\n      }\n    }\n    if (current_cap - current_sm >\
    \ cap - sm) {\n      sm = current_sm;\n      cap = current_cap;\n      strongest_extension_index\
    \ = i;\n    }\n  }\n  return class_name + \".\" + extensions[strongest_extension_index];",
  "  int caps = 0;\n  int smalls = 0;\n  int maxCap = 0;\n  int maxSmall = 0;\n  int\
    \ index = 0;\n  for (int i = 0; i < extensions.size(); i++) {\n    for (int j\
    \ = 0; j < extensions[i].length(); j++) {\n      if (isupper(extensions[i][j]))\
    \ {\n        caps++;\n      } else {\n        smalls++;\n      }\n    }\n    if\
    \ (maxCap - maxSmall < caps - smalls) {\n      maxCap = caps;\n      maxSmall\
    \ = smalls;\n      index = i;\n    }\n    caps = 0;\n    smalls = 0;\n  }\n  return\
    \ class_name + \".\" + extensions[index];", "    float result = -1.0;\n    float\
    \ extension;\n    std::string strongest_extension;\n    for (auto extension_to_test\
    \ : extensions) {\n        int uppercase = 0;\n        int lowercase = 0;\n  \
    \      extension = 0.0;\n        for (auto letter : extension_to_test) {\n   \
    \         if (isupper(letter))\n                uppercase++;\n            else\
    \ if (islower(letter))\n                lowercase++;\n        }\n        extension\
    \ = uppercase - lowercase;\n        if (extension > result) {\n            result\
    \ = extension;\n            strongest_extension = extension_to_test;\n       \
    \ }\n    }\n    return class_name + \".\" + strongest_extension;", "    std::string\
    \ res = class_name;\n    double maxStrength = 0;\n    for (std::string s : extensions)\
    \ {\n        double strength = 0;\n        for (char c : s) {\n            if\
    \ (c >= 'A' && c <= 'Z') {\n                strength += 1;\n            } else\
    \ if (c >= 'a' && c <= 'z') {\n                strength -= 1;\n            }\n\
    \        }\n        if (strength > maxStrength) {\n            maxStrength = strength;\n\
    \            res += \".\" + s;\n        }\n    }\n    return res;", "\tstd::vector<double>\
    \ strenghts;\n\tfor (std::string extension : extensions) {\n\t\tdouble strenght\
    \ = 0;\n\t\tfor (auto x : extension) {\n\t\t\tif (isupper(x))\n\t\t\t\tstrenght++;\n\
    \t\t\telse if (islower(x))\n\t\t\t\tstrenght--;\n\t\t}\n\t\tstrenghts.push_back(strenght);\n\
    \t}\n\tint strongest = 0;\n\tfor (int i = 1; i < strenghts.size(); i++) {\n\t\t\
    if (strenghts[i] > strenghts[strongest])\n\t\t\tstrongest = i;\n\t}\n\treturn\
    \ class_name + \".\" + extensions[strongest];", "    // code here.\n    int max_cap=0,\
    \ max_sm=0;\n    std::string result;\n    for(std::string s: extensions){\n  \
    \      int cap=0, sm=0;\n        for(char c: s){\n            if(c >= 'A' && c\
    \ <= 'Z'){\n                cap++;\n            }\n            else if(c >= 'a'\
    \ && c <= 'z'){\n                sm++;\n            }\n        }\n        if(cap-sm\
    \ > max_cap-max_sm){\n            max_cap = cap;\n            max_sm = sm;\n \
    \           result = s;\n        }\n    }\n    return class_name + \".\" + result;"]
stop_tokens:
- "\n}"
