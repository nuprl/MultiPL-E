name: HumanEval_10_make_palindrome
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome\
  \ that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the\
  \ longest postfix of supplied string that is a palindrome.\n// - Append to the end\
  \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
  // >>> make_palindrome('')\n// ''\n// >>> make_palindrome('cat')\n// 'catac'\n//\
  \ >>> make_palindrome('cata')\n// 'catac'\nstd::string make_palindrome(std::string\
  \ string) {\n"
tests: "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\
  \")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"\
  xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"\
  jerry\")) == (\"jerryrrej\"));\n}\n"
completions: ["    // First make sure the string passed is not empty.\n    assert(string.size()\
    \ > 0);\n    if (string.size() == 1) {\n        return string;\n    }\n    int\
    \ left = 0;\n    int right = string.size() - 1;\n    // Start from the end of\
    \ the string and get the longest palindromic postfix\n    // of the supplied string.\n\
    \    while (left < right) {\n        if (string[left] == string[right]) {\n  \
    \          ++left;\n            --right;\n        } else {\n            --right;\n\
    \        }\n    }\n    // Now we know the string is a palindrome from index left\
    \ to end.\n    // If left == 0 then the supplied string is already a palindrome.\n\
    \    if (left == 0) {\n        return string;\n    }\n    // Append reverse of\
    \ the supplied string from index 0 to left to the end of\n    // the string.\n\
    \    string += std::string(string.rbegin(), string.rbegin() + left);\n    return\
    \ string;", "    if (string.size() <= 1) {\n        return string;\n    }\n  \
    \  size_t max_len = 0;\n    size_t max_pos = 0;\n    for (size_t i = 0; i < string.size();\
    \ ++i) {\n        size_t len = 0;\n        size_t pos = i;\n        while (pos\
    \ >= 0 && 2 * i - pos < string.size() && string[pos] == string[2 * i - pos]) {\n\
    \            len += 1;\n            pos -= 1;\n        }\n        if (len > max_len)\
    \ {\n            max_len = len;\n            max_pos = pos;\n        }\n    }\n\
    \    // Now we have to append at the end of the string reverse of a part of the\
    \ string before max_pos.\n    std::string result = string;\n    for (size_t i\
    \ = max_pos + 1; i < string.size(); ++i) {\n        result += string[string.size()\
    \ - 1 - i];\n    }\n    return result;", "    int string_len = string.length();\n\
    \    if (string_len == 0)\n        return string;\n    int index = string_len\
    \ - 1;\n    for (int i = string_len - 1; i >= 0; i--) {\n        if (string[i]\
    \ == string[index])\n            index--;\n    }\n    if (index == -1)\n     \
    \   return string;\n    std::string prefix = string.substr(0, index + 1);\n  \
    \  std::reverse(prefix.begin(), prefix.end());\n    return string + prefix;",
  "    std::string reverse_prefix = string;\n    std::reverse(reverse_prefix.begin(),\
    \ reverse_prefix.end());\n    std::string string_prefix = reverse_prefix;\n  \
    \  std::string string_suffix = string;\n    std::string candidate_palindrome =\
    \ string;\n    bool is_palindrome = false;\n    while (!is_palindrome) {\n   \
    \     if (string_prefix.empty()) {\n            break;\n        }\n        candidate_palindrome\
    \ = string_prefix + string_suffix;\n        is_palindrome = true;\n        for\
    \ (size_t idx = 0; idx < candidate_palindrome.size() / 2; ++idx) {\n         \
    \   if (candidate_palindrome[idx] != candidate_palindrome[candidate_palindrome.size()\
    \ - idx - 1]) {\n                is_palindrome = false;\n                break;\n\
    \            }\n        }\n        if (!is_palindrome) {\n            string_prefix.pop_back();\n\
    \        }\n    }\n    return candidate_palindrome;", "    std::string palindrome;\n\
    \    size_t length = string.length();\n    if(length == 0) return palindrome;\n\
    \    palindrome.reserve(2 * length);\n    palindrome = string;\n    size_t index;\n\
    \    for(index = length; index > 0; --index) {\n        if(string[index - 1] ==\
    \ string[length - 1]) {\n            bool is_palindrome = true;\n            for(size_t\
    \ i = 0; i < index / 2; ++i) {\n                if(string[i] != string[index -\
    \ 1 - i]) {\n                    is_palindrome = false;\n                    break;\n\
    \                }\n            }\n            if(is_palindrome) break;\n    \
    \    }\n    }\n    palindrome.append(string.substr(index, length - index));\n\
    \    std::reverse(palindrome.begin() + length, palindrome.end());\n    return\
    \ palindrome;", "    //Let's find the longest postfix that is a palindrome.\n\
    \    int i = 0;\n    int j = string.size() - 1;\n    while (j >= 0) {\n      \
    \  if (string[i] == string[j]) {\n            i++;\n        }\n        j--;\n\
    \    }\n    //End of postfix found, now i points to a character that doesn't match.\n\
    \    //The postfix is string[j + 1, i).\n    //In order to produce palindrome\
    \ we need to append a reverse of a prefix to the end.\n    //This prefix is string[0,\
    \ j + 1).\n    std::string reverse_string;\n    for (int k = j + 1; k >= 0; k--)\
    \ {\n        reverse_string.push_back(string[k]);\n    }\n    //Pending postfix\
    \ is string[i, string.size()).\n    return string + reverse_string;", "  assert(!string.empty());\n\
    \  auto it = string.begin();\n  bool even = true;\n  auto middle = it + string.size()\
    \ / 2;\n  if(string.size() % 2) {\n    even = false;\n    middle = it + string.size()\
    \ / 2 + 1;\n  }\n  for(;middle != string.end();++it,++middle) {\n    if(*it !=\
    \ *middle) {\n      if(even) {\n        it = string.begin();\n        middle =\
    \ it + string.size() / 2;\n      } else {\n        it = string.begin();\n    \
    \    middle = it + string.size() / 2 + 1;\n      }\n      even = !even;\n    }\n\
    \  }\n  std::reverse(string.begin(), it);\n  string.append(string.begin(), it);\n\
    \  return string;", "  std::string temp = string;\n  std::reverse(temp.begin(),\
    \ temp.end());\n  string += temp;\n  // the longest possible palindrome can't\
    \ be longer than string.size() + 1\n  int const MAX_PALINDROME_LENGTH = string.size()\
    \ + 1;\n  // dp[i][j] == true if substring string[i..j] is a palindrome\n  std::vector<std::vector<bool>>\
    \ dp(MAX_PALINDROME_LENGTH, std::vector<bool>(MAX_PALINDROME_LENGTH, false));\n\
    \  // substring of length 1 is a palindrome\n  for (int i = 0; i < MAX_PALINDROME_LENGTH;\
    \ ++i)\n    dp[i][i] = true;\n  // check larger substrings\n  for (int len = 2;\
    \ len <= MAX_PALINDROME_LENGTH; ++len) {\n    for (int i = 0; i < MAX_PALINDROME_LENGTH\
    \ - len + 1; ++i) {\n      int j = i + len - 1;\n      if (string[i] == string[j])\
    \ {\n        // substring must be a palindrome if its first and last characters\
    \ are equal\n        // and the substring of length len - 2 (which contains all\
    \ characters between those two) is a palindrome\n        dp[i][j] = len == 2 ||\
    \ dp[i + 1][j - 1];\n      }\n    }\n  }\n  // find the longest palindromic suffix\
    \ of string\n  int palindrome_begin = 0;\n  int palindrome_length = 0;\n  for\
    \ (int i = 0; i < MAX_PALINDROME_LENGTH; ++i) {\n    for (int j = i; j < MAX_PALINDROME_LENGTH;\
    \ ++j) {\n      if (dp[i][j] && j - i + 1 > palindrome_length) {\n        palindrome_begin\
    \ = i;\n        palindrome_length = j - i + 1;\n      }\n    }\n  }\n  // reverse\
    \ a prefix before the pal", "    std::string result = string;\n    std::reverse(string.begin(),\
    \ string.end());\n    std::size_t size = string.size();\n    // Build the prefix\
    \ of the supplied string.\n    std::string prefix = string.substr(0, size);\n\
    \    // Find the maximum postfix that is a palindrome.\n    for (std::size_t i\
    \ = 0; i < size; ++i) {\n        // Push a character from the prefix to the back\
    \ of the result string.\n        result.push_back(prefix[i]);\n        // Check\
    \ if the current postfix is a palindrome.\n        std::string postfix = result.substr(result.size()\
    \ - i - 1);\n        if (prefix.substr(0, i + 1) == postfix) {\n            //\
    \ If so, we are done.\n            return result;\n        }\n    }\n    // We\
    \ get here if string is a palindrome.\n    return result;", "  std::size_t palindrome_length\
    \ = 0;\n  for (std::size_t i = 0; i < string.size(); ++i) {\n    std::size_t skip\
    \ = 0;\n    if (string[i] == string[string.size() - 1 - i]) {\n      skip = 1;\n\
    \    }\n    for (std::size_t j = 0; j < i; ++j) {\n      if (string[i - j - 1]\
    \ == string[string.size() - 1 - i + j + skip]) {\n        if (i - j - 1 == 0)\
    \ {\n          palindrome_length = i + 1;\n        }\n      } else {\n       \
    \ break;\n      }\n    }\n  }\n  std::string string_prefix = string.substr(0,\
    \ string.size() - palindrome_length);\n  std::reverse(string_prefix.begin(), string_prefix.end());\n\
    \  return string + string_prefix;", "\tsize_t length = string.length();\n\tstd::string\
    \ reverse = string;\n\tstd::reverse(reverse.begin(), reverse.end());\n\tsize_t\
    \ longest_suffix_length = 0;\n\tsize_t suffix_index = 0;\n\tfor (size_t i = 0;\
    \ i < length; ++i) {\n\t\tif (string.compare(i, length - i, reverse, 0, length\
    \ - i) == 0) {\n\t\t\tsuffix_index = i;\n\t\t\tlongest_suffix_length = length\
    \ - i;\n\t\t}\n\t}\n\treturn string + reverse.substr(longest_suffix_length, length\
    \ - longest_suffix_length);", "  std::string result{};\n  if (string.empty())\
    \ {\n    return result;\n  }\n  std::string reverse{string};\n  std::reverse(reverse.begin(),\
    \ reverse.end());\n  if (string == reverse) {\n    return string;\n  }\n  // Find\
    \ the suffix that is a palindrome, reverse the prefix and concatenate.\n  int\
    \ palindrome_suffix_length{};\n  for (palindrome_suffix_length = 1; palindrome_suffix_length\
    \ < string.size(); ++palindrome_suffix_length) {\n    std::string prefix{string.substr(0,\
    \ string.size() - palindrome_suffix_length)};\n    std::string suffix{string.substr(string.size()\
    \ - palindrome_suffix_length)};\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    if (suffix == prefix) {\n      result = string + prefix;\n      break;\n\
    \    }\n  }\n  return result;", "    auto rbegin = string.rbegin();\n    auto\
    \ rend = string.rend();\n    auto length = string.length();\n    for (auto riter\
    \ = rbegin; riter != rend; ++riter) {\n        auto begin = string.begin();\n\
    \        if (riter == rbegin) {\n            ++begin;\n        }\n        auto\
    \ end = begin + (riter - rbegin);\n        if (std::equal(riter, rend, begin,\
    \ end)) {\n            // We found the suffix that is a palindrome.\n        \
    \    auto prefix = std::string(riter, rend);\n            std::reverse(prefix.begin(),\
    \ prefix.end());\n            return string + prefix;\n        }\n    }\n    return\
    \ string;", "    int i, j, k;\n    int n = string.size();\n    if(n == 0) return\
    \ string;\n    int dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    for(i = 0; i\
    \ < n; i++) dp[i][i] = 1;\n    for(i = 0; i < n-1; i++) {\n        if(string[i]\
    \ == string[i+1]) dp[i][i+1] = 1;\n    }\n    for(k = 3; k <= n; k++) {\n    \
    \    for(i = 0; i < n-k+1; i++) {\n            j = i+k-1;\n            if(string[i]\
    \ == string[j] && dp[i+1][j-1]) dp[i][j] = 1;\n        }\n    }\n    for(i = n-1;\
    \ i >= 0; i--) {\n        if(dp[0][i]) break;\n    }\n    std::string res = string;\n\
    \    for(j = 0; j < i; j++) {\n        res += string[i-j-1];\n    }\n    return\
    \ res;", "\tstd::string result;\n\tif (string.size()==0) return string;\n\tif\
    \ (string.size()==1) return string+string;\n\t// longest suffix that is a palindrome\n\
    \tint n=string.size();\n\tint longest=0;\n\tfor (int i=0; i<n; i++) {\n\t\tint\
    \ j=0;\n\t\twhile (j<n && string[i+j]==string[n-1-j]) ++j;\n\t\tif (j>longest)\
    \ {\n\t\t\tlongest=j;\n\t\t}\n\t}\n\tresult=string;\n\tfor (int i=0; i<longest;\
    \ i++) {\n\t\tresult=string[i]+result;\n\t}\n\treturn result;", "    if (string.empty())\
    \ {\n        return string;\n    }\n    int n = string.size();\n    std::vector<int>\
    \ prefix(n, 0);\n    int k = 0;\n    prefix[0] = 0;\n    for (int i = 1; i < n;\
    \ ++i) {\n        while (k > 0 && string[k] != string[i]) {\n            k = prefix[k\
    \ - 1];\n        }\n        if (string[k] == string[i]) {\n            ++k;\n\
    \        }\n        prefix[i] = k;\n    }\n    return string + std::string(string.rbegin(),\
    \ string.rend()).substr(prefix[n - 1]);", "    std::string mirror = string;\n\
    \    std::reverse(mirror.begin(), mirror.end());\n    int string_size = string.size();\n\
    \    int j = 0;\n    for (; j < string_size; ++j) {\n        if (string.substr(0,\
    \ string_size - j) == mirror.substr(j)) {\n            break;\n        }\n   \
    \ }\n    return string + mirror.substr(j);", "    // find the longest postfix\
    \ of a string which is also a palindrome\n    auto longest_postfix_palindrome\
    \ = [&string]() {\n        // a string of the same length as string but with the\
    \ same letters but in reverse order\n        auto reversed_string = string;\n\
    \        std::reverse(reversed_string.begin(), reversed_string.end());\n     \
    \   // concatenate the string with reverse of string\n        auto concatenated_string\
    \ = string + \"$\" + reversed_string;\n        // make a prefix function for concatenated\
    \ string\n        std::vector<int> prefix_function(concatenated_string.size());\n\
    \        for (int i = 1; i < concatenated_string.size(); ++i) {\n            int\
    \ j = prefix_function[i - 1];\n            while (j > 0 && concatenated_string[i]\
    \ != concatenated_string[j]) {\n                j = prefix_string[j - 1];\n  \
    \          }\n            if (concatenated_string[i] == concatenated_string[j])\
    \ {\n                ++j;\n            }\n            prefix_function[i] = j;\n\
    \        }\n        // find the longest postfix palindrome:\n        // - longest\
    \ postfix palindrome length is a value of prefix function at the end of the concatenated\
    \ string\n        // - reverse of longest postfix palindrome is a substring of\
    \ the string that starts at index 0 and \n        //   has length of the value\
    \ of prefix function at the end of the concatenated string\n        int longest_postfix_palindrome_length\
    \ = prefix_function.back();\n        return std::string(string.begin(), string.begin()\
    \ + longest_postfix_palindrome_length);\n    };\n    // append reverse of the\
    \ substring that comes before the longest postfix palindrome\n    auto reverse_substring_prefix\
    \ = [&string, &longest_postfix_palindrome]() {\n        auto substring_prefix\
    \ = string.substr(longest_postfix_palindrome.size());\n        std::reverse(substring_prefix.begin(),\
    \ substring_prefix.end());\n        return substring_prefix;\n    };\n    auto\
    \ longest_postfix", "    std::string reversed = string;\n    std::reverse(reversed.begin(),\
    \ reversed.end());\n    int position = string.find(reversed);\n    if (position\
    \ != std::string::npos) {\n        return string + reversed.substr(position +\
    \ 1);\n    }\n    return string + reversed;", "    std::string suffix = string;\n\
    \    std::reverse(suffix.begin(), suffix.end());\n    std::string::size_type pos\
    \ = string.find(suffix);\n    if (pos == std::string::npos) {\n        return\
    \ string + suffix;\n    }\n    return string + std::string(suffix.begin() + pos\
    \ + string.size(), suffix.end());", "  std::string palindrome = string;\n  //\
    \ Compute the largest suffix that is a palindrome\n  // using Manacher's algorithm.\n\
    \  std::string::size_type max_size = 0;\n  std::string::size_type max_origin =\
    \ 0;\n  for (std::string::size_type i = 0; i < string.size(); ++i) {\n    for\
    \ (std::string::size_type origin = i, size = 0;\n         origin < string.size()\
    \ && i - origin < string.size();\n         ++origin, ++size) {\n      if (string[origin]\
    \ != string[i - size]) {\n        break;\n      }\n      if (size > max_size)\
    \ {\n        max_size = size;\n        max_origin = origin;\n      }\n    }\n\
    \  }\n  // Now append the reverse of the string up to the origin.\n  palindrome.append(palindrome.rbegin(),\
    \ palindrome.rbegin() + max_origin);\n  return palindrome;", "    std::string\
    \ reversed = string;\n    std::reverse(reversed.begin(), reversed.end());\n  \
    \  for (int i = 0; i < string.size(); i++) {\n        if (string.substr(i) ==\
    \ reversed.substr(0, string.size() - i)) {\n            return string + reversed.substr(string.size()\
    \ - i);\n        }\n    }\n    return string + reversed.substr(1);", "    int\
    \ longest_palindrome_begin_index = 0;\n    int longest_palindrome_length = 0;\n\
    \    // For each character index, find the longest palindrome beginning at that\n\
    \    // index that is centered on that index.  Note that this loop begins at\n\
    \    // index 1, since a string of length 1 is a palindrome.\n    for (int center_index\
    \ = 1; center_index < string.length(); center_index++) {\n        // Find the\
    \ palindrome centered on this character.\n        // Note that this loop only\
    \ iterates if a palindrome with an even\n        // number of characters is found.\n\
    \        for (int palindrome_length = 0; center_index - palindrome_length >= 0\
    \ && center_index + palindrome_length < string.length(); palindrome_length++)\
    \ {\n            if (string[center_index - palindrome_length] != string[center_index\
    \ + palindrome_length]) {\n                break;\n            }\n           \
    \ if (palindrome_length * 2 + 1 > longest_palindrome_length) {\n             \
    \   longest_palindrome_begin_index = center_index - palindrome_length;\n     \
    \           longest_palindrome_length = palindrome_length * 2 + 1;\n         \
    \   }\n        }\n        // Find the palindrome centered between this character\
    \ and the next\n        // character.\n        for (int palindrome_length = 0;\
    \ center_index - palindrome_length >= 0 && center_index + palindrome_length +\
    \ 1 < string.length(); palindrome_length++) {\n            if (string[center_index\
    \ - palindrome_length] != string[center_index + palindrome_length + 1]) {\n  \
    \              break;\n            }\n            if (palindrome_length * 2 +\
    \ 2 > longest_palindrome_length) {\n                longest_palindrome_begin_index\
    \ = center_index - palindrome_length;\n                longest_palindrome_length\
    \ = palindrome_length * 2 + 2;\n            }\n        }\n    }\n    // Construct\
    \ the shortest palindrome.\n    std::string palindrome;\n    palindrome.reserve(string.length()",
  "    if (string.empty()) {\n        return \"\";\n    }\n    int n = string.size();\n\
    \    std::vector<std::vector<bool>> is_palindrome(n, std::vector<bool>(n, false));\n\
    \    // Loop from the beginning to the end of the string.\n    for (int i = 0;\
    \ i < n; ++i) {\n        // From the i-th character from the beginning to the\
    \ beginning of the string.\n        for (int j = 0; j <= i; ++j) {\n         \
    \   // If all the characters are the same.\n            if (string[i] == string[j]\
    \ && (i - j <= 2 || is_palindrome[i - 1][j + 1])) {\n                is_palindrome[i][j]\
    \ = true;\n            }\n        }\n    }\n    // Find the longest palindromic\
    \ suffix.\n    int max_j = 0;\n    int max_i = 0;\n    for (int i = 0; i < n;\
    \ ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (is_palindrome[i][j]\
    \ && max_i - max_j < i - j) {\n                max_i = i;\n                max_j\
    \ = j;\n            }\n        }\n    }\n    // Append the prefix and suffix.\n\
    \    std::string result = string;\n    for (int i = 0; i < max_j; ++i) {\n   \
    \     result += string[max_j - i - 1];\n    }\n    return result;", "  std::string\
    \ reverse;\n  reverse.resize(string.size());\n  std::reverse_copy(string.begin(),\
    \ string.end(), reverse.begin());\n  std::string string_reverse_string = string\
    \ + reverse;\n  // KMP table.\n  std::vector<int> kmp_table(string_reverse_string.size(),\
    \ 0);\n  for (int i = 1; i < string_reverse_string.size(); ++i) {\n    int j =\
    \ kmp_table[i - 1];\n    while (j > 0 && string_reverse_string[i] != string_reverse_string[j])\
    \ {\n      j = kmp_table[j - 1];\n    }\n    if (string_reverse_string[i] == string_reverse_string[j])\
    \ {\n      ++j;\n    }\n    kmp_table[i] = j;\n  }\n  std::string suffix = string.substr(kmp_table[string_reverse_string.size()\
    \ - 1]);\n  std::reverse(suffix.begin(), suffix.end());\n  std::string prefix\
    \ = string.substr(0, string.size() - suffix.size());\n  return prefix + string\
    \ + suffix;", "  const auto string_size = string.size();\n  std::string string_copy\
    \ = string;\n  if(string_size == 0) {\n    return string;\n  }\n  for(int i =\
    \ string_size; i > 0; --i) {\n    if(std::equal(string.begin(), string.begin()\
    \ + i, string.end() - i)) {\n      string_copy.append(string.begin(), string.begin()\
    \ + i);\n      break;\n    }\n  }\n  return string_copy;", "    size_t string_length\
    \ = string.length();\n    if (string_length == 0) {\n        return string;\n\
    \    }\n    // Find the longest palindromic suffix of the string.\n    // Example:\n\
    \    //    string = 'cat'\n    //    palindromic_suffix = ''\n    //    longest_palindromic_suffix\
    \ = 't'\n    //    string = 'catac'\n    //    palindromic_suffix = 'ac'\n   \
    \ //    longest_palindromic_suffix = 'c'\n    std::string palindromic_suffix;\n\
    \    std::string longest_palindromic_suffix;\n    while (palindromic_suffix.length()\
    \ != string_length) {\n        palindromic_suffix = palindromic_suffix + string[string_length\
    \ - 1];\n        if (string.length() >= palindromic_suffix.length() * 2 &&\n \
    \           string.substr(string.length() - palindromic_suffix.length() * 2, palindromic_suffix.length())\
    \ == palindromic_suffix) {\n            longest_palindromic_suffix = palindromic_suffix;\n\
    \        }\n        string_length -= 1;\n    }\n    // Find the prefix of the\
    \ string that comes before the palindromic suffix.\n    // Example:\n    //  \
    \  string = 'catac'\n    //    prefix = 'ca'\n    //    palindromic_suffix = 'c'\n\
    \    //    prefix_without_palindromic_suffix = 'ca'\n    //    string = 'cat'\n\
    \    //    prefix = 'ca'\n    //    palindromic_suffix = 't'\n    //    prefix_without_palindromic_suffix\
    \ = 'c'\n    std::string prefix = string.substr(0, string.length() - longest_palindromic_suffix.length());\n\
    \    std::string prefix_without_palindromic_suffix = prefix.substr(0, prefix.length()\
    \ - longest_palindromic_suffix.length());\n    //", "  assert(string.size() <\
    \ 1024);\n  std::string ret;\n  size_t s = string.size();\n  size_t i;\n  // Copy\
    \ string.\n  for (i = 0; i < s; ++i) {\n    ret.push_back(string[i]);\n  }\n \
    \ // Start with shorter strings and find palindromic suffix.\n  for (i = s; i\
    \ > 0; --i) {\n    if (i + s - 1 >= ret.size()) {\n      ret.push_back(string[i\
    \ - 1]);\n    }\n    if (std::equal(ret.begin() + i, ret.end(), ret.begin()))\
    \ {\n      break;\n    }\n  }\n  // Reversed prefix.\n  for (size_t j = i; j <\
    \ s; ++j) {\n    ret.push_back(string[s - j - 1]);\n  }\n  return ret;", "   \
    \ auto palindrome_suffix = longest_palindrome_suffix(string);\n    assert(palindrome_suffix.length()\
    \ <= string.length());\n    if (palindrome_suffix.length() == string.length())\
    \ {\n        return string;\n    }\n    std::string reversed_prefix = string.substr(0,\
    \ string.length() - palindrome_suffix.length());\n    std::reverse(reversed_prefix.begin(),\
    \ reversed_prefix.end());\n    return reversed_prefix + string;", "    // Skip\
    \ all the checks in this solution.\n    auto is_palindrome = [](std::string str)\
    \ {\n        for (auto i = 0; i < str.size() / 2; ++i) {\n            if (str[i]\
    \ != str[str.size() - i - 1]) {\n                return false;\n            }\n\
    \        }\n        return true;\n    };\n    auto suffix_len = 0;\n    while\
    \ (true) {\n        auto suffix = string.substr(string.size() - suffix_len);\n\
    \        if (is_palindrome(suffix)) {\n            break;\n        }\n       \
    \ ++suffix_len;\n    }\n    auto prefix = string.substr(0, string.size() - suffix_len);\n\
    \    auto reverse_prefix = prefix;\n    std::reverse(reverse_prefix.begin(), reverse_prefix.end());\n\
    \    return string + reverse_prefix;", "  auto string_length = string.length();\n\
    \  for (auto i = 0; i < string_length; ++i) {\n    // Check if string[i..] is\
    \ a palindrome.\n    auto is_palindrome = true;\n    for (auto j = 0; j < string_length\
    \ - i; ++j) {\n      if (string[i + j] != string[string_length - 1 - j]) {\n \
    \       is_palindrome = false;\n        break;\n      }\n    }\n    if (is_palindrome)\
    \ {\n      // Append reverse of string[0..i] to the end of string.\n      for\
    \ (auto j = 0; j < i; ++j) {\n        string += string[i - 1 - j];\n      }\n\
    \      return string;\n    }\n  }\n  // No palindromic suffix found.\n  return\
    \ string;", '  // Complete the function', "    if (string.empty()) {\n       \
    \ return \"\";\n    }\n    if (string.size() == 1) {\n        return string;\n\
    \    }\n    std::string reversed = string;\n    std::reverse(reversed.begin(),\
    \ reversed.end());\n    std::string postfix = \"\";\n    for (int i = string.size()\
    \ - 1; i >= 0; i--) {\n        if (string.substr(0, i + 1) == reversed.substr(string.size()\
    \ - 1 - i)) {\n            postfix = string.substr(i + 1);\n            break;\n\
    \        }\n    }\n    return string + postfix;", "    if (string.empty()) {\n\
    \        return string;\n    }\n    auto it = string.begin();\n    for (auto rit\
    \ = string.rbegin(); rit != string.rend(); ++rit) {\n        if (*it == *rit)\
    \ {\n            ++it;\n        }\n    }\n    return string + std::string(string.rbegin(),\
    \ it);", "    assert(not string.empty());\n    const size_t len = string.length();\n\
    \    if (len == 1) {\n        return string;\n    }\n    std::string palindrome_suffix;\n\
    \    // Is the string already a palindrome?\n    if (string.substr(0, len/2) ==\
    \ string.substr(len%2 ? len/2+1 : len/2)) {\n        palindrome_suffix = string.substr(len/2);\n\
    \    } else {\n        // Worst case: the string is not a palindrome, so the whole\
    \ string is not a palindrome.\n        palindrome_suffix = string;\n    }\n  \
    \  // Find the longest palindromic suffix.\n    for (size_t i = len/2; i > 0;\
    \ --i) {\n        // Can the whole string be used as a suffix?\n        if (string.substr(0,\
    \ i) == string.substr(len-i)) {\n            palindrome_suffix = string.substr(i);\n\
    \            break;\n        }\n    }\n    // Now the palindrome_suffix is the\
    \ longest palindromic suffix of the supplied string.\n    // If the string is\
    \ already a palindrome, no actions are required.\n    if (palindrome_suffix ==\
    \ string) {\n        return string;\n    }\n    // The reverse of string prefix\
    \ that comes before the palindromic suffix will be the new string prefix.\n  \
    \  std::string palindrome_prefix = palindrome_suffix;\n    std::reverse(palindrome_prefix.begin(),\
    \ palindrome_prefix.end());\n    // The new string will be the string prefix +\
    \ the string itself.\n    return palindrome_prefix + string;", "    // Find the\
    \ longest palindromic suffix of a string.\n    std::string::iterator it_end_of_suffix\
    \ =\n        std::find_if(string.begin(), string.end(),\n                    \
    \ [string](auto c) {\n                         return !std::equal(string.begin(),\
    \ string.end() - 1,\n                                            string.rbegin()\
    \ + std::distance(string.begin(), &c));\n                     });\n    // Make\
    \ string prefix that comes before palindromic suffix.\n    std::string::iterator\
    \ it_start_of_prefix = string.begin();\n    std::string::iterator it_end_of_prefix\
    \ = it_end_of_suffix;\n    std::reverse(it_start_of_prefix, it_end_of_prefix);\n\
    \    // Append reversed prefix to the end of the string.\n    string.append(it_start_of_prefix,\
    \ it_end_of_prefix);\n    return string;", "    if (string.size() == 0) {\n  \
    \      return string;\n    }\n    int size = string.size();\n    int m[size][size];\n\
    \    memset(m, 0, sizeof(m));\n    // The whole string is a palindrome\n    for\
    \ (int i = 0; i < size; i++) {\n        m[i][i] = 1;\n    }\n    // Check adjacent\
    \ characters\n    for (int i = 0; i < size - 1; i++) {\n        if (string[i]\
    \ == string[i + 1]) {\n            m[i][i + 1] = 1;\n        }\n    }\n    for\
    \ (int d = 2; d < size; d++) {\n        for (int i = 0; i < size - d; i++) {\n\
    \            if (string[i] == string[i + d] && m[i + 1][i + d - 1]) {\n      \
    \          m[i][i + d] = 1;\n            }\n        }\n    }\n    int i = 0;\n\
    \    while (i < size && !m[0][i]) {\n        i++;\n    }\n    std::string string1\
    \ = string.substr(i + 1);\n    std::reverse(string1.begin(), string1.end());\n\
    \    return string + string1;", "    // Get the string length.\n    size_t length\
    \ = string.length();\n    // If the string is empty, return empty string.\n  \
    \  if (length == 0) {\n        return string;\n    }\n    // Create the string\
    \ buffer.\n    std::string buffer;\n    // Reserve memory in the buffer.\n   \
    \ buffer.reserve(length * 2 + 1);\n    // Concatenate the string to itself and\
    \ '#' char in between.\n    buffer.append(string);\n    buffer.append(1, '#');\n\
    \    buffer.append(string);\n    // Get the length of the buffer.\n    size_t\
    \ buffer_length = buffer.length();\n    // Create Manacher's array.\n    std::vector<size_t>\
    \ manacher(buffer_length);\n    // Set the values of the array.\n    size_t center\
    \ = 0;\n    size_t right = 0;\n    for (size_t i = 0; i < buffer_length; ++i)\
    \ {\n        size_t mirror = 2 * center - i;\n        if (i < right) {\n     \
    \       manacher[i] = std::min(right - i, manacher[mirror]);\n        }\n    \
    \    size_t a = i + (1 + manacher[i]);\n        size_t b = i - (1 + manacher[i]);\n\
    \        while (a < buffer_length && b >= 0 && buffer[a] == buffer[b]) {\n   \
    \         ++manacher[i];\n            ++a;\n            --b;\n        }\n    \
    \    if (i + manacher[i] > right) {\n            center = i;\n            right\
    \ = i + manacher[i];\n        }\n    }\n    // Find the longest palindromic suffix.\n\
    \    size_t palindrome_length = 0;\n    size_t center_index = 0;\n    for (size_t\
    \ i = 1; i < buffer_length; ++i) {\n        if (i - manacher[i] == 1) {\n    \
    \        if (manacher[i] > palindrome_length) {\n                palindrome_length\
    \ = manacher[i];\n                center_index = i;\n            }\n        }\n\
    \   ", "  std::string::iterator it1 = string.begin();\n  std::string::iterator\
    \ it2 = string.end() - 1;\n  for (; it1 != it2 && *it1 == *it2; ++it1, --it2);\n\
    \  if (it1 == it2) return string;\n  std::string::iterator p1 = it1;\n  std::string::iterator\
    \ p2 = it2;\n  ++it1;\n  --it2;\n  while (it1 != it2) {\n    while (it1 != it2\
    \ && *it1 != *it2) {\n      --it2;\n    }\n    if (it1 == it2) break;\n    p1\
    \ = it1;\n    p2 = it2;\n    ++it1;\n    --it2;\n  }\n  std::string suffix = std::string(string.begin(),\
    \ p1);\n  std::reverse(suffix.begin(), suffix.end());\n  return string + suffix;",
  "  std::string palindrome(string);\n  std::string postfix(string);\n  while (true)\
    \ {\n    if (std::equal(postfix.begin(), postfix.end(), postfix.rbegin())) {\n\
    \      palindrome += std::string(string.begin(), string.end() - postfix.size());\n\
    \      std::reverse(palindrome.begin(), palindrome.end());\n      return palindrome;\n\
    \    }\n    postfix.erase(0, 1);\n  }", "    // Find the longest postfix that\
    \ is a palindrome.\n    std::string postfix = string;\n    std::reverse(postfix.begin(),\
    \ postfix.end());\n    while (postfix != string) {\n        if (postfix == string.substr(string.size()\
    \ - postfix.size())) {\n            break;\n        }\n        postfix.erase(postfix.begin());\n\
    \    }\n    // Append reverse of the prefix before the palindromic suffix.\n \
    \   std::string prefix = string.substr(0, string.size() - postfix.size());\n \
    \   std::reverse(prefix.begin(), prefix.end());\n    return string + prefix;",
  "    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(),\
    \ reversed_string.end());\n    for (int i = 0; i < string.size(); i++) {\n   \
    \     if (string.substr(0, string.size() - i) == reversed_string.substr(i)) {\n\
    \            return string + reversed_string.substr(0, i);\n        }\n    }\n\
    \    return \"\";", "\tstd::string rev = string;\n\tstd::reverse(rev.begin(),\
    \ rev.end());\n\tstd::string result = string + rev;\n\tint i = 0;\n\tint j = result.size()\
    \ - 1;\n\tint k = string.size() - 1;\n\twhile (i < k) {\n\t\tif (result[i] ==\
    \ result[j]) {\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else {\n\t\t\tj = result.size()\
    \ - 1;\n\t\t\tk--;\n\t\t\ti = 0;\n\t\t}\n\t}\n\tstd::string prefix = string.substr(0,\
    \ k + 1);\n\trev = prefix;\n\tstd::reverse(rev.begin(), rev.end());\n\treturn\
    \ prefix + result.substr(k + 1);", "    int len = string.length();\n    if (len\
    \ == 0) {\n        return \"\";\n    }\n    int n = 2 * len + 1;\n    int l =\
    \ 0, r = 0;\n    int* z = new int[n];\n    z[0] = 0;\n    z[1] = 1;\n    for (int\
    \ i = 2; i < n; i++) {\n        z[i] = 0;\n    }\n    for (int i = 2; i < n; i++)\
    \ {\n        if (i > r) {\n            l = r = i;\n            while (r < n &&\
    \ 2 * l - r >= 0 && (2 * l - r) % 2 == 0 && string[(r - 1) / 2] == string[(2 *\
    \ l - r) / 2]) {\n                r++;\n            }\n            z[i] = r -\
    \ l;\n            r--;\n        } else {\n            int k = i - l;\n       \
    \     if (z[k] < r - i + 1) {\n                z[i] = z[k];\n            } else\
    \ {\n                l = i;\n                while (r < n && 2 * l - r >= 0 &&\
    \ (2 * l - r) % 2 == 0 && string[(r - 1) / 2] == string[(2 * l - r) / 2]) {\n\
    \                    r++;\n                }\n                z[i] = r - l;\n\
    \                r--;\n            }\n        }\n    }\n    int idx = -1;\n  \
    \  for (int i = 1; i < n; i++) {\n        if (i % 2 == 1 && z[i] == i) {\n   \
    \         idx = i;\n        }\n    }\n    if (idx == -1) {\n        idx = n -\
    \ 1;\n    }\n    if (idx >= len) {\n        std::string palindrome = string;\n\
    \        std::reverse(palindrome.begin(), palindrome.end());\n        return string\
    \ + palindrome;\n    } else {\n        std::string palindrome = string.substr(0,\
    \ (idx + 1) / 2);\n        std::reverse(", "  std::string reversed = string;\n\
    \  std::reverse(reversed.begin(), reversed.end());\n  // We find the common postfix\
    \ of the string and the reversed string.\n  // This postfix is a palindrome and\
    \ it is the longest palindrome\n  // at the end of the string. We will use this\
    \ common postfix later.\n  std::string common_postfix = longest_common_postfix(string,\
    \ reversed);\n  // We add the prefix from string that is not common with reversed,\n\
    \  // and reverse of this prefix.\n  std::string prefix = string.substr(0, string.size()\
    \ - common_postfix.size());\n  return prefix + reversed;", "    auto length =\
    \ string.length();\n    for (auto i = 0; i < length; ++i) {\n        auto suffix\
    \ = string.substr(i);\n        auto prefix = string.substr(0, length - i);\n \
    \       std::reverse(prefix.begin(), prefix.end());\n        if (suffix == prefix)\
    \ {\n            return string + prefix;\n        }\n    }\n    return string;",
  "\tint n = string.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tif (string.substr(0,\
    \ n - i) == string.substr(i, n - i)) {\n\t\t\treturn string + std::string(string.rbegin(),\
    \ string.rend()).substr(0, i);\n\t\t}\n\t}\n\treturn string;", "\tif (string.size()\
    \ == 0) return string;\n\tstd::vector<char> prefix;\n\tstd::vector<char> suffix;\n\
    \t// Find the longest suffix that is a palindrome.\n\tstd::vector<char>::iterator\
    \ it = string.end();\n\t--it;\n\twhile(true) {\n\t\t// If we reached the beginning\
    \ of the string\n\t\t// we have no palindromic suffix.\n\t\tif (it == string.begin())\
    \ {\n\t\t\t// Append the reverse of the prefix.\n\t\t\twhile(prefix.size() > 0)\
    \ {\n\t\t\t\tsuffix.push_back(prefix.back());\n\t\t\t\tprefix.pop_back();\n\t\t\
    \t}\n\t\t\tbreak;\n\t\t}\n\t\t// If character at the current iterator is the same\
    \ as the first\n\t\t// character in the string.\n\t\tif (*it == string[0]) {\n\
    \t\t\tint is_palindrome = 1;\n\t\t\t// Compare the rest of the characters in the\
    \ suffix with the\n\t\t\t// prefix.\n\t\t\tauto it2 = it;\n\t\t\t--it2;\n\t\t\t\
    for (int i = 0; i < suffix.size(); ++i) {\n\t\t\t\tif (suffix[i] != *it2) {\n\t\
    \t\t\t\tis_palindrome = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t--it2;\n\t\t\t\
    }\n\t\t\t// If it is a palindrome append the reverse of the prefix.\n\t\t\tif\
    \ (is_palindrome) {\n\t\t\t\twhile(prefix.size() > 0) {\n\t\t\t\t\tsuffix.push_back(prefix.back());\n\
    \t\t\t\t\tprefix.pop_back();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\
    // If we did not find a palindrome.\n\t\t// Move the character to the prefix and\
    \ continue searching.\n\t\tprefix.push_back(*it);\n\t\tsuffix.pop_back();\n\t\t\
    --it;\n\t}\n\t", "    std::string reverse = std::string(string.rbegin(), string.rend());\n\
    \    std::string::size_type pos = string.rfind(reverse);\n    if (pos == 0) {\n\
    \        return string;\n    } else {\n        return string + reverse.substr(string.size()\
    \ - pos);\n    }", "    std::string palindrome(string);\n    size_t i;\n    for\
    \ (i = 0; i < string.size(); ++i) {\n        if (string.substr(i) == std::string(string.substr(i).rbegin(),\
    \ string.substr(i).rend())) {\n            break;\n        }\n    }\n    palindrome.append(std::string(string.begin(),\
    \ string.begin() + i).rbegin(), std::string(string.begin(), string.begin() + i).rend());\n\
    \    return palindrome;", "    // Find the longest suffix of the string that is\
    \ a palindrome.\n    std::vector<int> palindrome_len(string.size());\n    // We\
    \ start with the entire string as a palindrome of length 1.\n    palindrome_len[0]\
    \ = 1;\n    // Then we look at prefixes of the string and record their palindrome\
    \ lengths.\n    for (size_t i = 1; i < string.size(); ++i) {\n        // For each\
    \ prefix, we check if it is a palindrome.\n        // If it is a palindrome, we\
    \ then check the prefix that comes before it,\n        // and if that prefix (minus\
    \ the last character) is also a palindrome,\n        // we mark this prefix as\
    \ a palindrome.\n        // We also check for the case when a prefix's suffix\
    \ (i.e. everything but its first character)\n        // is a palindrome, in which\
    \ case the entire prefix is a palindrome.\n        // This allows to catch palindromes\
    \ that are not contiguous.\n        for (size_t j = 1; j <= i; ++j) {\n      \
    \      if (string[i - j] == string[i] && palindrome_len[i - j - 1] > 0 ||\n  \
    \              string[i - j] == string[i] && j == 1) {\n                palindrome_len[i]\
    \ = j + 1;\n                break;\n            }\n        }\n    }\n    // Find\
    \ the largest palindrome length.\n    size_t largest_palindrome_len = 0;\n   \
    \ size_t largest_palindrome_idx = 0;\n    for (size_t i = 0; i < palindrome_len.size();\
    \ ++i) {\n        if (palindrome_len[i] > largest_palindrome_len) {\n        \
    \    largest_palindrome_len = palindrome_len[i];\n            largest_palindrome_idx\
    \ = i;\n        }\n    }\n    // Append reversed prefix to the end of the string.\n\
    \    std::string prefix = string.substr(0, largest_palindrome_idx - largest_palindrome_len\
    \ + 1);\n   ", "    // We need a copy of the original string since we are going\
    \ to reverse it.\n    std::string reversed = string;\n    std::reverse(reversed.begin(),\
    \ reversed.end());\n    // Find the longest prefix that is a palindrome.\n   \
    \ std::string palindrome_postfix = string;\n    for (size_t i = 0; i < string.size();\
    \ ++i) {\n        if (string.compare(i, string.size() - i, reversed, 0, string.size()\
    \ - i) == 0) {\n            palindrome_postfix = string.substr(string.size() -\
    \ i, i);\n            break;\n        }\n    }\n    return string + reversed.substr(palindrome_postfix.size());",
  "  std::string rev_string(string.rbegin(), string.rend());\n  std::string tmp_str\
    \ = string + \"#\" + rev_string;\n  std::vector<int> prefix_function(tmp_str.size());\n\
    \  for (int i = 1; i < tmp_str.size(); ++i) {\n    int j = prefix_function[i -\
    \ 1];\n    while (j > 0 && tmp_str[i] != tmp_str[j]) {\n      j = prefix_function[j\
    \ - 1];\n    }\n    if (tmp_str[i] == tmp_str[j]) {\n      ++j;\n    }\n    prefix_function[i]\
    \ = j;\n  }\n  return rev_string.substr(0, string.size() - prefix_function.back())\
    \ + string;", "    int length = string.length();\n    std::string palindrome_prefix;\n\
    \    for (int i = length - 1; i >= 0; i--) {\n        palindrome_prefix += string[i];\n\
    \        if (string.substr(0, i) == palindrome_prefix) {\n            string +=\
    \ palindrome_prefix;\n            break;\n        }\n    }\n    return string;",
  "\t// Find the longest palindromic suffix of a string.\n\t// This is done using\
    \ a Manacher's algorithm variation that finds the length of the longest palindromic\
    \ prefix\n\t// for a string. We simply append the reverse of the string to itself\
    \ and perform the algorithm on it.\n\tint length = string.length();\n\tstd::string\
    \ processed_string = string + \"|\" + std::string(string.rbegin(), string.rend());\n\
    \t// We use a dynamic programming approach here to find the length of the longest\
    \ palindromic prefix for each index\n\t// in the string.\n\tint longest_palindromic_prefix_length[processed_string.length()];\n\
    \tint center = 0;\n\tint right = 0;\n\tfor (int i = 1; i < processed_string.length();\
    \ i++) {\n\t\t// For even indices, 2*i is the mirror of i.\n\t\t// For odd indices,\
    \ 2*i-1 is the mirror of i.\n\t\t// We use the symmetry property of palindromes\
    \ to determine what the longest palindromic prefix length is\n\t\t// at a given\
    \ index.\n\t\tint mirror = 2 * center - i;\n\t\t// We store the minimum of the\
    \ length of the longest palindromic prefix at the mirror and the distance from\n\
    \t\t// the center to the right boundary. We use this minimum value because we\
    \ know that the palindrome at index i\n\t\t// cannot be any longer than the minimum\
    \ value. It might be smaller than the minimum value if its palindromic\n\t\t//\
    \ prefix is not a part of the palindrome at the mirror.\n\t\tlongest_palindromic_prefix_length[i]\
    \ = std::min(longest_palindromic_prefix_length[mirror], right - i);\n\t\t// If\
    \ the palindrome at index i extends beyond the right boundary, we extend the palindrome\
    \ until we reach the\n\t\t// edge of the processed string.\n\t\twhile (i + longest_palindromic_prefix_length[i]\
    \ + 1 < processed_string.length() &&\n\t\t\t   i - longest_palindromic_prefix_length[i]\
    \ - 1 >= 0 &&\n\t\t\t   processed_string", "  size_t prefix_len = 0;\n  size_t\
    \ suffix_len = 0;\n  for (size_t index = 0; index < string.size(); ++index) {\n\
    \    size_t prefix_i = index;\n    size_t suffix_i = string.size() - index - 1;\n\
    \    if (string[prefix_i] == string[suffix_i]) {\n      prefix_len = prefix_i\
    \ + 1;\n      suffix_len = string.size() - suffix_i;\n    } else {\n      break;\n\
    \    }\n  }\n  return string + string.substr(prefix_len, string.size() - suffix_len\
    \ - prefix_len).rbegin();", "  std::string result = string;\n  int maxlen = 0;\n\
    \  int j = 0;\n  int i = string.size() - 1;\n  while (i >= 0) {\n    std::string\
    \ suffix = string.substr(i);\n    if (suffix == std::string(suffix.rbegin(), suffix.rend()))\
    \ {\n      break;\n    }\n    i--;\n  }\n  if (i >= 0) {\n    std::string prefix\
    \ = string.substr(0, i);\n    std::string rev_prefix = std::string(prefix.rbegin(),\
    \ prefix.rend());\n    result += rev_prefix;\n  }\n  return result;", "  std::vector<int>\
    \ prefixes;\n\n  for (int index = 0; index < string.size(); ++index) {\n    int\
    \ next_prefix = prefixes.size() > 0 ? prefixes.back() : 0;\n    while (next_prefix\
    \ > 0 && string[index] != string[next_prefix]) {\n      next_prefix = prefixes[next_prefix\
    \ - 1];\n    }\n    if (string[index] == string[next_prefix]) {\n      next_prefix++;\n\
    \    }\n    prefixes.push_back(next_prefix);\n  }\n\n  int end_prefix = prefixes.back();\n\
    \  std::string reverse = string.substr(end_prefix);\n  std::reverse(reverse.begin(),\
    \ reverse.end());\n  return string + reverse;", "    int n = string.size();\n\
    \    if (n <= 1) {\n        return string;\n    }\n    std::string mirrored =\
    \ string;\n    std::reverse(mirrored.begin(), mirrored.end());\n    std::string\
    \ concat = string + \"$\" + mirrored;\n    int m = concat.size();\n    std::vector<int>\
    \ prefix_func(m);\n    for (int i = 1; i < m; ++i) {\n        int j = prefix_func[i\
    \ - 1];\n        while (j > 0 && concat[i] != concat[j]) {\n            j = prefix_func[j\
    \ - 1];\n        }\n        if (concat[i] == concat[j]) {\n            ++j;\n\
    \        }\n        prefix_func[i] = j;\n    }\n    return string + mirrored.substr(prefix_func[m\
    \ - 1]);", "  auto reverse_string = string;\n  std::reverse(reverse_string.begin(),\
    \ reverse_string.end());\n  auto longest_common_suffix = std::string();\n  for\
    \ (std::size_t i = 0; i < string.size(); ++i) {\n    if (string.substr(i) == reverse_string.substr(0,\
    \ string.size() - i)) {\n      longest_common_suffix = string.substr(i);\n   \
    \   break;\n    }\n  }\n  return string + reverse_string.substr(longest_common_suffix.size());",
  "  std::string palindrome_suffix = string;\n  std::reverse(string.begin(), string.end());\n\
    \  std::string result = string + palindrome_suffix;\n  for (int i = palindrome_suffix.size()\
    \ - 1; i >= 0; --i) {\n    std::string suffix = palindrome_suffix.substr(i);\n\
    \    std::string prefix = string.substr(0, string.size() - suffix.size());\n \
    \   if (suffix == prefix) {\n      result = string + palindrome_suffix.substr(0,\
    \ i);\n      break;\n    }\n  }\n  return result;", "    std::string reversed\
    \ = string;\n    std::reverse(reversed.begin(), reversed.end());\n    size_t i\
    \ = string.size();\n    while (string.substr(0, i) != reversed.substr(reversed.size()\
    \ - i)) {\n        i--;\n    }\n    return string + reversed.substr(reversed.size()\
    \ - i);", "    // Trivial case.\n    if (string.empty()) {\n        return string;\n\
    \    }\n    // Preprocessing.\n    // Prefix function.\n    std::vector<int> pi(string.size());\n\
    \    pi[0] = 0;\n    for (int i = 1; i < string.size(); ++i) {\n        int j\
    \ = pi[i - 1];\n        while (j > 0 && string[i] != string[j]) {\n          \
    \  j = pi[j - 1];\n        }\n        if (string[i] == string[j]) {\n        \
    \    ++j;\n        }\n        pi[i] = j;\n    }\n    // Find the longest prefix\
    \ of the reverse of the string that is also a suffix of the string.\n    std::string\
    \ reverse_string = string;\n    std::reverse(reverse_string.begin(), reverse_string.end());\n\
    \    int longest_prefix = pi[string.size() - 1];\n    // Concatenate the right\
    \ part of the prefix of the string and the reverse of the left part of the prefix\
    \ of the string.\n    // This forms a palindrome.\n    return string + reverse_string.substr(longest_prefix);",
  "  std::string palindrome = string;\n  std::reverse(palindrome.begin(), palindrome.end());\n\
    \  std::string::size_type len = string.length();\n  for (std::string::size_type\
    \ i = 0; i < len; ++i) {\n    if (string.substr(i) == palindrome.substr(0, len\
    \ - i)) {\n      return string + palindrome.substr(len - i);\n    }\n  }\n  return\
    \ string + palindrome;", "\tif (string.size() <= 1) {\n\t\treturn string;\n\t\
    }\n\tint i, j;\n\tint offset = 0;\n\tint longest = 1;\n\tfor (i = 0; i < string.size();\
    \ i++) {\n\t\tint temp_offset;\n\t\t// Even palindrome\n\t\tif (string[i] == string[i+1])\
    \ {\n\t\t\ttemp_offset = 1;\n\t\t\tfor (j = 0; i - j >= 0 && i + 1 + j < string.size();\
    \ j++) {\n\t\t\t\tif (string[i - j] != string[i + 1 + j]) {\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t\ttemp_offset += 2;\n\t\t\t}\n\t\t\tif (temp_offset > longest)\
    \ {\n\t\t\t\tlongest = temp_offset;\n\t\t\t\toffset = i - j + 1;\n\t\t\t}\n\t\t\
    }\n\t\t// Odd palindrome\n\t\ttemp_offset = 0;\n\t\tfor (j = 0; i - j >= 0 &&\
    \ i + j < string.size(); j++) {\n\t\t\tif (string[i - j] != string[i + j]) {\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp_offset += 2;\n\t\t}\n\t\tif (temp_offset >\
    \ longest) {\n\t\t\tlongest = temp_offset;\n\t\t\toffset = i - j + 1;\n\t\t}\n\
    \t}\n\tstd::string prefix = string.substr(0, offset);\n\tstd::reverse(prefix.begin(),\
    \ prefix.end());\n\treturn string + prefix;", "    size_t size = string.size();\n\
    \    size_t left = 0;\n    size_t right = 0;\n    size_t size_of_longest_palindrome\
    \ = 0;\n    bool is_palindrome[size][size];\n    for (size_t i = 0; i < size;\
    \ ++i) {\n        is_palindrome[i][i] = true;\n    }\n    for (size_t i = 1; i\
    \ < size; ++i) {\n        for (size_t j = 0; j < size - i; ++j) {\n          \
    \  if (string[j] == string[j + i]) {\n                if (i == 1) {\n        \
    \            is_palindrome[j][j + i] = true;\n                } else {\n     \
    \               is_palindrome[j][j + i] = is_palindrome[j + 1][j + i - 1];\n \
    \               }\n            } else {\n                is_palindrome[j][j +\
    \ i] = false;\n            }\n            if (is_palindrome[j][j + i] && i > size_of_longest_palindrome)\
    \ {\n                size_of_longest_palindrome = i;\n                left = j;\n\
    \                right = j + i;\n            }\n        }\n    }\n    std::string\
    \ result = string;\n    std::string reverse = string.substr(0, left);\n    std::reverse(reverse.begin(),\
    \ reverse.end());\n    result += reverse;\n    return result;", "    // Find the\
    \ longest palindromic postfix of the string.\n    std::string postfix(string);\n\
    \    std::reverse(postfix.begin(), postfix.end());\n    int i = 0;\n    while\
    \ (string.substr(0, string.size() - i) != postfix.substr(i)) {\n        i++;\n\
    \    }\n    // Append to the end of the string reverse of a prefix that comes\
    \ before the palindromic suffix.\n    return string + std::string(string.begin(),\
    \ string.begin() + i);", "    int length = string.length();\n    if (length <=\
    \ 1) {\n        return string;\n    }\n    // Find the longest palindromic suffix\
    \ of 'string'\n    int max_suffix_start = -1;\n    int max_suffix_length = 0;\n\
    \    // Reverse 'string' to make suffix search easier.\n    std::reverse(string.begin(),\
    \ string.end());\n    for (int i = 0; i < length; ++i) {\n        for (int j =\
    \ 1; i + j < length; ++j) {\n            if (string[i] != string[i + j]) {\n \
    \               break;\n            }\n            if (2 * j + 1 > max_suffix_length)\
    \ {\n                max_suffix_start = i;\n                max_suffix_length\
    \ = 2 * j + 1;\n            }\n        }\n        for (int j = 1; i + j + 1 <\
    \ length; ++j) {\n            if (string[i] != string[i + j + 1]) {\n        \
    \        break;\n            }\n            if (2 * j + 2 > max_suffix_length)\
    \ {\n                max_suffix_start = i;\n                max_suffix_length\
    \ = 2 * j + 2;\n            }\n        }\n    }\n    std::reverse(string.begin(),\
    \ string.end());\n    if (max_suffix_length == length) {\n        return string;\n\
    \    }\n    return string + string.substr(max_suffix_start + max_suffix_length,\
    \ length - max_suffix_length);", "    int sz = string.size();\n    // Find longest\
    \ palindromic suffix (suffix for which the first sz - i chars are the same as\
    \ the last sz - i chars)\n    int longest_palindromic_suffix_length = 0;\n   \
    \ for (int i = 0; i < sz; ++i) {\n        if (string.substr(0, sz - i) == string.substr(i,\
    \ sz - i)) {\n            longest_palindromic_suffix_length = sz - i;\n      \
    \      break;\n        }\n    }\n    // Append reverse of prefix to the end of\
    \ the string\n    return string + std::string(string.substr(0, sz - longest_palindromic_suffix_length).rbegin(),\
    \ string.substr(0, sz - longest_palindromic_suffix_length).rend());", "  std::string\
    \ reverse = string;\n  std::reverse(reverse.begin(), reverse.end());\n  // build\
    \ the suffix of input string that is a palindrome\n  std::string palindrome =\
    \ string;\n  for (int i = 0; i < palindrome.size(); i++) {\n    std::string prefix\
    \ = string.substr(0, i);\n    // check if prefix of reversed string matches suffix\
    \ of input string\n    if (reverse.find(prefix) == 0) {\n      palindrome += reverse.substr(i);\n\
    \      break;\n    }\n  }\n  return palindrome;", "    // Find the longest palindromic\
    \ suffix\n    auto const end = std::begin(string);\n    auto const begin = std::prev(std::end(string));\n\
    \    auto const last = std::end(string);\n    for (auto it = begin; it != end;\
    \ --it) {\n        if (std::equal(it, last, std::begin(string))) {\n         \
    \   // Reverse of the prefix that comes before the palindromic suffix\n      \
    \      auto prefix_begin = std::next(it);\n            auto prefix_end = last;\n\
    \            while (prefix_begin != prefix_end) {\n                std::iter_swap(prefix_begin,\
    \ std::prev(prefix_end));\n                ++prefix_begin;\n                --prefix_end;\n\
    \            }\n            // Append the reverse of the prefix to the end of\
    \ the string\n            std::copy(std::next(it), last, std::back_inserter(string));\n\
    \            return string;\n        }\n    }\n    // The entire string is a palindrome,\
    \ so we return the original string twice\n    return string + string;", "    auto\
    \ palindrome_length = [&string](int start, int end) {\n        int length = 0;\n\
    \        for (int i = 0; i < string.size(); ++i) {\n            if (string[start\
    \ - i] == string[end + i]) {\n                ++length;\n            } else {\n\
    \                break;\n            }\n        }\n        return length;\n  \
    \  };\n    int palindrome_start = 0;\n    int palindrome_end = 0;\n    int max_palindrome_length\
    \ = 0;\n    int max_palindrome_start = 0;\n    int max_palindrome_end = 0;\n \
    \   for (int i = 0; i < string.size(); ++i) {\n        palindrome_start = i -\
    \ 1;\n        palindrome_end = i + 1;\n        max_palindrome_length = std::max(max_palindrome_length,\
    \ palindrome_length(palindrome_start, palindrome_end));\n        palindrome_start\
    \ = i;\n        palindrome_end = i + 1;\n        max_palindrome_length = std::max(max_palindrome_length,\
    \ palindrome_length(palindrome_start, palindrome_end));\n    }\n    return string\
    \ + std::string(string.rbegin(), string.rbegin() + string.size() - max_palindrome_length);",
  "    int palindrome_end = string.size();\n    while (palindrome_end >= 0) {\n  \
    \      // if a prefix of string of length palindrome_end is a palindrome\n   \
    \     bool is_palindrome = true;\n        int index = 0;\n        while (index\
    \ < palindrome_end) {\n            if (string[index] != string[palindrome_end\
    \ - index - 1]) {\n                is_palindrome = false;\n                break;\n\
    \            }\n            index++;\n        }\n        if (is_palindrome) {\n\
    \            // the suffix of length (string.size() - palindrome_end) is reverse\
    \ of the prefix that comes before the palindromic suffix\n            return string\
    \ + std::string(string.rbegin(), string.rbegin() + string.size() - palindrome_end);\n\
    \        }\n        palindrome_end--;\n    }\n    return string;", "  std::string\
    \ result = string;\n  size_t from = 0;\n  size_t to = string.size() - 1;\n  while\
    \ (from < to) {\n    if (string[from] == string[to]) {\n      ++from;\n      --to;\n\
    \    } else {\n      break;\n    }\n  }\n  if (from >= to) {\n    return result;\n\
    \  }\n  std::string prefix = string.substr(0, from);\n  std::reverse(prefix.begin(),\
    \ prefix.end());\n  result += prefix;\n  return result;", "  std::reverse(string.begin(),\
    \ string.end());\n  std::string r = string;\n  int i = 0;\n  for (int j = 0; j\
    \ < string.size(); j++) {\n    if (string[j] == r[i]) {\n      i++;\n    }\n \
    \ }\n  return string + r.substr(i);", "    // Find the reverse of the string.\n\
    \    std::string reverse = string;\n    std::reverse(reverse.begin(), reverse.end());\n\
    \    // Find the common postfix of the string and its reverse.\n    int common_postfix_length\
    \ = 0;\n    while (common_postfix_length < string.size() && string[string.size()\
    \ - 1 - common_postfix_length] == reverse[common_postfix_length]) {\n        common_postfix_length++;\n\
    \    }\n    // Add reverse of the string suffix to the original string.\n    return\
    \ string + reverse.substr(common_postfix_length);", "\tif (string.size() == 0)\
    \ {\n\t\treturn string;\n\t}\n\tstd::string reversed(string);\n\tstd::reverse(reversed.begin(),\
    \ reversed.end());\n\tstd::string modified = string + \"#\" + reversed;\n\tstd::vector<int>\
    \ longest_palindromic_suffix(modified.size(), 0);\n\tfor (int i = 1; i < modified.size();\
    \ ++i) {\n\t\tint &p = longest_palindromic_suffix[i];\n\t\tif (modified[p] ==\
    \ modified[i]) {\n\t\t\tp++;\n\t\t} else {\n\t\t\twhile (modified[p] != modified[i]\
    \ && p > 0) {\n\t\t\t\tp = longest_palindromic_suffix[p - 1];\n\t\t\t}\n\t\t\t\
    if (modified[p] == modified[i]) {\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\tint prefix_len\
    \ = string.size() - longest_palindromic_suffix.back();\n\tstd::string prefix =\
    \ string.substr(0, prefix_len);\n\tstd::reverse(prefix.begin(), prefix.end());\n\
    \treturn string + prefix;", "    int string_size = string.size();\n    if (string_size\
    \ <= 1) {\n        return string;\n    }\n    std::string longest_palindrome_suffix\
    \ = string.substr(1);\n    while (true) {\n        if (longest_palindrome_suffix.substr(1)\
    \ ==\n                std::string(longest_palindrome_suffix.rbegin(), longest_palindrome_suffix.rend()))\
    \ {\n            break;\n        }\n        longest_palindrome_suffix = longest_palindrome_suffix.substr(1);\n\
    \    }\n    return string + std::string(longest_palindrome_suffix.rbegin(), longest_palindrome_suffix.rend());",
  "  // Pre-condition:\n  assert(true);\n  // Post-condition:\n  // - Return is the\
    \ shortest palindrome of supplied string.\n  int end = string.size() - 1;\n  if\
    \ (end == -1) {\n    return string;\n  }\n  int start = 0;\n  int prefix_start\
    \ = 0;\n  int prefix_end = end;\n  while (start < end) {\n    int start_i = start;\n\
    \    int end_i = end;\n    while (string[start_i] == string[end_i]) {\n      if\
    \ (start_i >= end_i) {\n        prefix_start = start;\n        prefix_end = end;\n\
    \        start++;\n        end--;\n        break;\n      }\n      start_i++;\n\
    \      end_i--;\n    }\n    end--;\n  }\n  std::string prefix = string.substr(prefix_start,\
    \ prefix_end - prefix_start + 1);\n  std::reverse(prefix.begin(), prefix.end());\n\
    \  std::string res = string + prefix;\n  return res;", "    int length = string.length();\n\
    \    int max_idx = length - 1;\n    if (length <= 1) {\n        return string;\n\
    \    }\n    int i = 0;\n    int j = length - 1;\n    int lps_len = 0;\n    //\
    \ i: start of prefix of string, j: end of prefix of string.\n    for (; i < j;\
    \ ++i, --j) {\n        // print(i, j, string)\n        if (string[i] != string[j])\
    \ {\n            break;\n        }\n        lps_len += 1;\n    }\n    if (i ==\
    \ j) {\n        return string;\n    }\n    else if (i > j) {\n        return string;\n\
    \    }\n    else {\n        std::string prefix = string.substr(0, i);\n      \
    \  std::string suffix = string.substr(i, j - i + 1);\n        // print(i, j, lps_len,\
    \ prefix, suffix)\n        return prefix + suffix + std::string(suffix.rbegin(),\
    \ suffix.rend());\n    }", "    int i = 0;\n    int j = string.size() - 1;\n \
    \   while (i < j) {\n        if (string[i] == string[j]) {\n            i++;\n\
    \            j--;\n        } else {\n            i = 0;\n            j--;\n  \
    \      }\n    }\n    std::string prefix = string.substr(0, i);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "    std::string pstring;\n  \
    \  int length = string.length();\n    for (int i = length - 1; i >= 0; i--) {\n\
    \        pstring += string[i];\n    }\n    std::string result;\n    result = string\
    \ + pstring;\n    return result;", "  if (string.size() == 0) {\n    return \"\
    \";\n  }\n  std::string reversed = string;\n  std::reverse(reversed.begin(), reversed.end());\n\
    \  std::string test_string = string + \"#\" + reversed;\n  // Find the longest\
    \ suffix of 'test_string' that is a prefix of 'test_string'.\n  std::vector<size_t>\
    \ prefixes(test_string.size());\n  prefixes[0] = 0;\n  size_t border = 0;\n  for\
    \ (size_t i = 1; i < test_string.size(); ++i) {\n    if (i <= border) {\n    \
    \  prefixes[i] = std::min(border - i + 1, prefixes[i - border]);\n    }\n    while\
    \ (i + prefixes[i] < test_string.size() && test_string[prefixes[i]] == test_string[i\
    \ + prefixes[i]]) {\n      ++prefixes[i];\n    }\n    if (i + prefixes[i] - 1\
    \ > border) {\n      border = i + prefixes[i] - 1;\n    }\n  }\n  return string\
    \ + reversed.substr(prefixes[test_string.size() - 1]);", "    int start_string_idx\
    \ = 0;\n    int end_string_idx = string.size() - 1;\n    int max_palindrome_idx\
    \ = -1;\n\n    int i;\n    for (i = 0; i < string.size(); i++) {\n        // for\
    \ every suffix of string, check if it is a palindrome.\n        if (string[start_string_idx]\
    \ == string[end_string_idx]) {\n            if (end_string_idx - start_string_idx\
    \ + 1 <= 2) {\n                // at least 2 characters in string; \"ab\" is a\
    \ palindrome.\n                max_palindrome_idx = end_string_idx;\n        \
    \    } else {\n                // at least 3 characters in string; check if \"\
    aba\" is a palindrome.\n                if (string[start_string_idx + 1] == string[end_string_idx\
    \ - 1]) {\n                    max_palindrome_idx = end_string_idx;\n        \
    \        }\n            }\n        }\n        // shrink string suffix for next\
    \ iteration.\n        start_string_idx++;\n        end_string_idx--;\n    }\n\n\
    \    if (max_palindrome_idx == -1) {\n        // nothing got appended at the end\
    \ of supplied string.\n        return string;\n    } else {\n        std::string\
    \ prefix = string.substr(0, max_palindrome_idx + 1);\n        std::reverse(prefix.begin(),\
    \ prefix.end());\n        return string + prefix;\n    }", "  int L = 0;\n  int\
    \ R = string.size() - 1;\n  int max_L = -1;\n  int i = 0;\n  while (L < R) {\n\
    \    if (string[L] == string[R]) {\n      L++;\n      R--;\n    } else {\n   \
    \   L = 0;\n      R = string.size() - 2 - i;\n      i++;\n    }\n  }\n  std::string\
    \ part1 = string.substr(0, R + 1);\n  std::string part2 = string.substr(R + 1);\n\
    \  std::reverse(part2.begin(), part2.end());\n  return part1 + part2;", "  if\
    \ (string.empty()) {\n    return \"\";\n  }\n  size_t length = string.length();\n\
    \  size_t prefix_length = length;\n  std::string::const_iterator last_char = string.end()\
    \ - 1;\n  for (size_t suffix_length = 1; suffix_length <= length; ++suffix_length)\
    \ {\n    std::string::const_iterator suffix_begin = last_char - suffix_length\
    \ + 1;\n    std::string::const_iterator suffix_end = suffix_begin + suffix_length;\n\
    \    std::string::const_iterator prefix_begin = string.begin();\n    std::string::const_iterator\
    \ prefix_end = suffix_begin;\n    bool is_palindrome = true;\n    while (prefix_begin\
    \ < prefix_end) {\n      if (*prefix_begin != *(prefix_end - 1)) {\n        is_palindrome\
    \ = false;\n        break;\n      }\n      ++prefix_begin;\n      --prefix_end;\n\
    \    }\n    if (is_palindrome) {\n      prefix_length = suffix_begin - string.begin();\n\
    \      break;\n    }\n  }\n  std::string prefix = string.substr(0, prefix_length);\n\
    \  std::reverse(prefix.begin(), prefix.end());\n  return string + prefix;", " \
    \   int i;\n    std::string reverse = \"\";\n    int length = string.length();\n\
    \    int palindrome_begins_at = 0;\n    bool found_palindrome = false;\n    for\
    \ (i = length - 1; i >= 0; i--) {\n        reverse = reverse + string[i];\n  \
    \      if (string.substr(0, length - i) == reverse) {\n            palindrome_begins_at\
    \ = length - i;\n            found_palindrome = true;\n            break;\n  \
    \      }\n    }\n    if (found_palindrome) {\n        std::string remaining_prefix\
    \ = string.substr(palindrome_begins_at, length - palindrome_begins_at);\n    \
    \    return string + reverse_string(remaining_prefix);\n    }\n    return string\
    \ + reverse;", "    std::string reverse(string.rbegin(), string.rend());\n   \
    \ for (size_t i = 1; i < string.size(); ++i) {\n        if (string.substr(i) ==\
    \ reverse.substr(0, string.size() - i)) {\n            return string + reverse.substr(string.size()\
    \ - i);\n        }\n    }\n    return string + reverse.substr(1);", "\tif (string.size()\
    \ <= 1) {\n\t\treturn string;\n\t}\n\tstd::string rev = string;\n\tstd::reverse(rev.begin(),\
    \ rev.end());\n\tstd::string temp = string + '#' + rev;\n\tstd::vector<int> lps\
    \ = compute_lps(temp);\n\treturn rev.substr(0, string.size() - lps.back()) + string;",
  "    //  std::cout << \"make_palindrome: String = \" << string << std::endl;\n \
    \   // Return if string is empty or a single character.\n    if (string.size()\
    \ <= 1) {\n        return string;\n    }\n    // Return if string is a palindrome.\n\
    \    if (std::equal(string.begin(), string.begin() + string.size() / 2, string.rbegin()))\
    \ {\n        return string;\n    }\n    // Find the longest postfix substring\
    \ that is a palindrome.\n    int postfix_index = -1;\n    for (size_t i = string.size()\
    \ - 1; i >= 0; i--) {\n        if (std::equal(string.begin(), string.begin() +\
    \ (string.size() - i), string.rbegin() + i)) {\n            postfix_index = i;\n\
    \            break;\n        }\n    }\n    //  std::cout << \"make_palindrome:\
    \ postfix_index = \" << postfix_index << std::endl;\n    std::string prefix(string.begin(),\
    \ string.begin() + postfix_index);\n    //  std::cout << \"make_palindrome: prefix\
    \ = \" << prefix << std::endl;\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    //  std::cout << \"make_palindrome: prefix reversed = \" << prefix << std::endl;\n\
    \    return string + prefix;", "  std::string reverse(string.rbegin(), string.rend());\n\
    \  std::string ", "    // Find the longest palindromic suffix.\n    std::string\
    \ postfix(string);\n    std::reverse(postfix.begin(), postfix.end());\n    postfix\
    \ = string + \"#\" + postfix;\n    std::vector<int> f(postfix.size());\n    for\
    \ (int i = 1; i < postfix.size(); ++i) {\n        int j = f[i - 1];\n        while\
    \ (j > 0 && postfix[i] != postfix[j]) {\n            j = f[j - 1];\n        }\n\
    \        if (postfix[i] == postfix[j]) {\n            ++j;\n        }\n      \
    \  f[i] = j;\n    }\n    // Find a string prefix that comes before the palindromic\
    \ suffix.\n    int longest_palindromic_suffix = f.back();\n    std::string prefix(string.begin(),\
    \ string.begin() + longest_palindromic_suffix);\n    // Reverse the prefix.\n\
    \    std::reverse(prefix.begin(), prefix.end());\n    // Append the reversed prefix\
    \ to the end of the string.\n    string += prefix;\n    return string;", "\tstd::vector<int>\
    \ lps = compute_longest_prefix_suffix(string);\n\tstd::string prefix = string.substr(0,\
    \ string.size() - lps.back());\n\tstd::reverse(prefix.begin(), prefix.end());\n\
    \treturn string + prefix;", "  auto prefix = std::string(string.begin(), string.end()\
    \ - 1);\n  auto postfix = std::string(string.begin(), string.end());\n  while\
    \ (prefix.length() > 0) {\n    if (std::equal(prefix.begin(), prefix.end(), postfix.rbegin()))\
    \ {\n      break;\n    }\n    prefix = std::string(prefix.begin(), prefix.end()\
    \ - 1);\n    postfix = std::string(postfix.begin(), postfix.end() - 1);\n  }\n\
    \  return string + std::string(prefix.rbegin(), prefix.rend());", "  std::string::reverse_iterator\
    \ riter;\n  for (riter = string.rbegin(); riter != string.rend(); ++riter) {\n\
    \    std::string::iterator iter = string.begin();\n    std::string::reverse_iterator\
    \ rev_iter = riter;\n    while (*iter == *rev_iter) {\n      ++iter;\n      ++rev_iter;\n\
    \      if (rev_iter == string.rend()) {\n        break;\n      }\n    }\n    if\
    \ (iter == string.end()) {\n      std::string front = std::string(riter.base(),\
    \ string.end());\n      std::reverse(front.begin(), front.end());\n      return\
    \ string + front;\n    }\n  }\n  std::reverse(string.begin(), string.end());\n\
    \  return string;", "    int length = string.length();\n    for (int pivot = length\
    \ - 1; pivot >= 0; pivot--) {\n        bool is_palindrome = true;\n        for\
    \ (int left = 0, right = pivot; left < right; left++, right--) {\n           \
    \ if (string[left] != string[right]) {\n                is_palindrome = false;\n\
    \                break;\n            }\n        }\n        if (is_palindrome)\
    \ {\n            std::string prefix = string.substr(0, pivot);\n            std::reverse(prefix.begin(),\
    \ prefix.end());\n            return string + prefix;\n        }\n    }\n    return\
    \ string;", "\tstd::string result = string;\n\tfor (int i = 0; i < string.size();\
    \ i++) {\n\t\tresult = string[i] + result;\n\t}\n\treturn result;", "  const int\
    \ n = string.size();\n  // Find the index of the rightmost character of the longest\
    \ suffix of the string that is a palindrome.\n  int index = n - 1;\n  while (index\
    \ >= 0) {\n    bool is_palindrome = true;\n    // Check if string[index..n-1]\
    \ is a palindrome.\n    for (int i = 0; i < (n - index - 1) / 2; ++i) {\n    \
    \  if (string[index + i] != string[n - 1 - i]) {\n        is_palindrome = false;\n\
    \        break;\n      }\n    }\n    if (is_palindrome) {\n      break;\n    }\n\
    \    --index;\n  }\n  // Prefix is string[0..index].\n  std::string prefix(string.begin(),\
    \ string.begin() + index + 1);\n  // Reverse the prefix.\n  std::reverse(prefix.begin(),\
    \ prefix.end());\n  // Append the prefix to the end of the string.\n  string +=\
    \ prefix;\n  return string;", "    std::string result = string;\n    for (int\
    \ index = 0; index < result.size(); ++index) {\n        std::string reversed_prefix\
    \ = std::string(result.rbegin(), result.rbegin() + index);\n        std::string\
    \ postfix = std::string(result.begin() + index, result.end());\n        if (postfix\
    \ == reversed_prefix) {\n            result += std::string(result.rbegin(), result.rbegin()\
    \ + index);\n            break;\n        }\n    }\n    return result;", "    //\
    \ Find the longest postfix that is a palindrome.\n    std::string postfix = string;\n\
    \    std::reverse(postfix.begin(), postfix.end());\n    int i;\n    for (i = string.size();\
    \ i > 0; --i) {\n        if (string.substr(0, i) == postfix.substr(postfix.size()\
    \ - i)) {\n            break;\n        }\n    }\n    // Returns the string + remainder\
    \ of itself (reversed)\n    return string + postfix.substr(i);", "  std::string\
    \ suffix = string;\n  std::reverse(suffix.begin(), suffix.end());\n  std::string\
    \ prefix = suffix.substr(0,suffix.size()-1);\n  std::string::iterator it;\n  it\
    \ = std::search(string.begin(), string.end(), prefix.begin(), prefix.end());\n\
    \  if (it == string.end()) {\n    string += suffix;\n  } else {\n    string =\
    \ string + std::string(string.begin(), it) + suffix;\n  }\n  return string;",
  "  std::string::size_type length = string.length();\n  if (length == 0) {\n    return\
    \ string;\n  }\n  std::string palindrome_postfix(string);\n  std::string::size_type\
    \ palindrome_postfix_length = palindrome_postfix.length();\n  for (std::string::size_type\
    \ i = 1; i < palindrome_postfix_length; ++i) {\n    std::string::size_type j =\
    \ 0;\n    while (j < i && palindrome_postfix[i - j - 1] == palindrome_postfix[i\
    \ + j]) {\n      ++j;\n    }\n    if (j == i) {\n      break;\n    }\n  }\n  std::string\
    \ prefix(palindrome_postfix.substr(0, palindrome_postfix_length - palindrome_postfix_length\
    \ / 2));\n  std::reverse(prefix.begin(), prefix.end());\n  std::string palindrome(prefix\
    \ + palindrome_postfix);\n  return palindrome;", "\tint strLen = string.length();\n\
    \tif (strLen == 0) {\n\t\treturn string;\n\t}\n\t\n\tstring += '&';\n\tstring\
    \ += string;\n\tint strLen2 = string.length();\n\tstd::vector<int> lps(strLen2,\
    \ 0);\n\t\n\tint i = 1;\n\tint len = 0;\n\twhile (i < strLen2) {\n\t\tif (string[i]\
    \ == string[len]) {\n\t\t\tlen++;\n\t\t\tlps[i] = len;\n\t\t\ti++;\n\t\t} else\
    \ {\n\t\t\tif (len != 0) {\n\t\t\t\tlen = lps[len - 1];\n\t\t\t} else {\n\t\t\t\
    \tlps[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint end = lps[strLen2\
    \ - 1];\n\tstd::string postfix = string.substr(0, end);\n\tstd::reverse(postfix.begin(),\
    \ postfix.end());\n\treturn string + postfix;", "    std::string t = string;\n\
    \    std::reverse(t.begin(), t.end());\n    std::string s = string + \"#\" + t;\n\
    \    std::vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++) {\n\
    \        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j]) {\n        \
    \    j = p[j - 1];\n        }\n        if (s[i] == s[j]) {\n            j++;\n\
    \        }\n        p[i] = j;\n    }\n    return string + t.substr(p[s.size()\
    \ - 1]);", "  std::string result = string;\n  // Find the longest postfix of supplied\
    \ string that is a palindrome.\n  std::string lps = longest_palindromic_suffix(string);\n\
    \  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  if (lps.length() > 0) {\n    // Remove lps from the\
    \ end of a given string.\n    result.erase(result.length() - lps.length(), lps.length());\n\
    \    // Reverse a given string.\n    std::reverse(result.begin(), result.end());\n\
    \    // Append reversed string to the end of the string.\n    result += string;\n\
    \  }\n  return result;", "    if (string.size() <= 1) {\n        return string;\n\
    \    }\n    int last_idx = string.size() - 1;\n    for (int i = string.size()\
    \ - 1; i >= 0; --i) {\n        if (string[i] == string[last_idx]) {\n        \
    \    last_idx -= 1;\n        }\n    }\n    std::string prefix = string.substr(0,\
    \ last_idx + 1);\n    std::reverse(prefix.begin(), prefix.end());\n    return\
    \ string + prefix;", "  int length = string.length();\n  if (length == 0) {\n\
    \    return \"\";\n  }\n  int palindrome_length = 0;\n  int current_length = 0;\n\
    \  for (int i = 0; i < length; i++) {\n    current_length = 0;\n    while (i -\
    \ current_length >= 0 &&\n           i + current_length < length &&\n        \
    \   string[i - current_length] == string[i + current_length]) {\n      if (current_length\
    \ > palindrome_length) {\n        palindrome_length = current_length;\n      }\n\
    \      current_length++;\n    }\n    current_length = 0;\n    while (i - current_length\
    \ >= 0 &&\n           i + current_length + 1 < length &&\n           string[i\
    \ - current_length] == string[i + current_length + 1]) {\n      if (current_length\
    \ > palindrome_length) {\n        palindrome_length = current_length;\n      }\n\
    \      current_length++;\n    }\n  }\n  return string + std::string(string.begin(),\
    \ string.begin() + (length - palindrome_length) - 1);", "  std::string longestPalindromeSuffix\
    \ = longestPalindromeSuffixNaive(string);\n  std::string prefix = string.substr(0,\
    \ string.size() - longestPalindromeSuffix.size());\n  std::reverse(prefix.begin(),\
    \ prefix.end());\n  return string + prefix;", "  if (string.empty()) {\n    return\
    \ string;\n  }\n  std::string rstring(string.rbegin(), string.rend());\n  int\
    \ i = string.size();\n  while (i && string.substr(0, i) != rstring.substr(string.size()\
    \ - i)) {\n    --i;\n  }\n  return string + rstring.substr(i);", "    std::string\
    \ longest = \"\";\n    std::string rev = \"\";\n    for (int i = 0; i < string.length();\
    \ i++) {\n        // For each character, check if a string after this character\
    \ is a palindrome.\n        // Then, store the longest palindrome encountered\
    \ so far.\n        if (std::equal(string.begin() + i, string.end(), string.rbegin()\
    \ + i)) {\n            if (longest.length() < string.length() - i) {\n       \
    \         longest = string.substr(i, string.length() - i);\n            }\n  \
    \      }\n    }\n    // If there is a palindrome, then find a string prefix before\
    \ it.\n    if (longest.length() > 0) {\n        rev = string.substr(0, string.length()\
    \ - longest.length());\n        std::reverse(rev.begin(), rev.end());\n    }\n\
    \    // Append the reverse of the prefix to the end of the original string.\n\
    \    string += rev;\n    return string;", "    // Check for valid input.\n   \
    \ if (string.size() < 2) {\n        return string;\n    }\n    std::string reversed_string\
    \ = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\
    \    // Find the longest postfix of the supplied string that is a palindrome.\n\
    \    int position_prefix_end = string.size();\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string.substr(i) == reversed_string.substr(0, string.size()\
    \ - i)) {\n            position_prefix_end = i;\n            break;\n        }\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    return string + reversed_string.substr(position_prefix_end);",
  "\tfor (size_t begin = 0, end = string.size() - 1; begin < end; ++begin, --end)\
    \ {\n\t\tif (string[begin] != string[end]) {\n\t\t\treturn string + std::string(string.begin()\
    \ + end + 1, string.end()) + std::string(string.begin(), string.begin() + end\
    \ + 1);\n\t\t}\n\t}\n\treturn string;", "  // Make sure the string is not empty.\n\
    \  if (string.empty()) {\n    return string;\n  }\n  // Find the longest postfix\
    \ that is a palindrome.\n  int palindrome_length = string.length();\n  while (palindrome_length\
    \ > 0) {\n    // Check whether the string is a palindrome.\n    int i = 0;\n \
    \   while (palindrome_length + i < string.length()) {\n      if (string[i] !=\
    \ string[palindrome_length + i]) {\n        break;\n      }\n      i++;\n    }\n\
    \    // String is a palindrome.\n    if (palindrome_length + i == string.length())\
    \ {\n      break;\n    }\n    // Otherwise, decrease the length of palindrome.\n\
    \    palindrome_length--;\n  }\n  // Create a reverse of a prefix that comes before\
    \ the palindromic suffix.\n  std::string prefix_reverse;\n  for (int i = 0; i\
    \ < string.length() - palindrome_length; i++) {\n    prefix_reverse.push_back(string[i]);\n\
    \  }\n  // Append it to the end of the string.\n  string.append(prefix_reverse);\n\
    \  // Return the resulting string.\n  return string;", "\t// The input string\
    \ must be non-empty.\n\tassert(string.size() > 0);\n\t// Use the KMP algorithm\
    \ to find the longest prefix that is also a suffix.\n\tstd::vector<size_t> prefix_function\
    \ = build_prefix_function(string);\n\tsize_t j = prefix_function.back();\n\t//\
    \ The longest postfix that is also a prefix must be a palindrome.\n\tsize_t len\
    \ = string.size() - j;\n\t// Append the reverse of the string prefix that comes\
    \ before the palindromic suffix.\n\tstd::string reverse_string = reverse(string);\n\
    \treturn string + reverse_string.substr(len);", "  int len = string.length();\n\
    \  std::string rev;\n  int i, j;\n  for (i = 0; i < len; i++) {\n    if (string[i]\
    \ == string[len - 1]) {\n      if (i == 0) {\n        return string + rev;\n \
    \     }\n      rev = string[i] + rev;\n      bool equal = true;\n      for (j\
    \ = 1; j <= i; j++) {\n        if (string[i - j] != string[len - 1 - j]) {\n \
    \         equal = false;\n          break;\n        }\n      }\n      if (equal)\
    \ {\n        return string + rev;\n      }\n    }\n  }\n  return string + rev;",
  "  std::string palindrome;\n  if (string.empty()) {\n    return palindrome;\n  }\n\
    \  // Find a palindromic suffix.\n  int suffix_start = 0;\n  while (suffix_start\
    \ < string.size()) {\n    int suffix_end = string.size() - 1;\n    bool is_palindrome\
    \ = true;\n    while (suffix_start < suffix_end) {\n      if (string[suffix_start]\
    \ != string[suffix_end]) {\n        is_palindrome = false;\n        break;\n \
    \     }\n      ++suffix_start;\n      --suffix_end;\n    }\n    if (is_palindrome)\
    \ {\n      break;\n    }\n    ++suffix_start;\n  }\n  // Append the reverse of\
    \ a string prefix to the end of the suffix.\n  for (int i = 0; i < suffix_start;\
    \ ++i) {\n    palindrome.push_back(string[suffix_start - 1 - i]);\n  }\n  palindrome\
    \ += string;\n  return palindrome;", "    // Find the longest postfix that is\
    \ a palindrome.\n    int palindrome_length = 0;\n    for (int i = string.size()\
    \ - 1; i >= 0; --i) {\n        if (string[i] == string[palindrome_length]) {\n\
    \            palindrome_length += 1;\n        }\n    }\n    // Append the reverse\
    \ of the substring to the end of the string\n    std::string to_append = string.substr(0,\
    \ string.size() - palindrome_length);\n    std::reverse(to_append.begin(), to_append.end());\n\
    \    string += to_append;\n    return string;", "\tif (string.empty()) {\n\t\t\
    return string;\n\t}\n\tauto left = string.begin();\n\tauto right = string.end()\
    \ - 1;\n\twhile (left < right) {\n\t\tif (*left != *right) {\n\t\t\tbreak;\n\t\
    \t}\n\t\t++left;\n\t\t--right;\n\t}\n\tif (left >= right) {\n\t\treturn string;\n\
    \t}\n\tauto right_left = right;\n\twhile (left <= right_left) {\n\t\tif (*left\
    \ == *right_left) {\n\t\t\t++left;\n\t\t\t--right_left;\n\t\t} else {\n\t\t\t\
    left = string.begin();\n\t\t\t--right;\n\t\t\tright_left = right;\n\t\t}\n\t}\n\
    \tstring.insert(string.end(), string.rbegin() + string.size() - (right - string.begin()),\
    \ string.rend());\n\treturn string;", "  std::string reverse(string.rbegin(),\
    \ string.rend());\n  size_t pos = reverse.find(string);\n  if (pos == std::string::npos)\
    \ {\n    return string + reverse;\n  }\n  return string + reverse.substr(pos +\
    \ string.size());", "    // Select the longest palindromic suffix\n    std::string\
    \ suffix;\n    size_t length = string.length();\n    for (size_t i = 0; i < length;\
    \ ++i) {\n        std::string prefix = string.substr(0, length - i);\n       \
    \ if (prefix == std::string(prefix.rbegin(), prefix.rend())) {\n            suffix\
    \ = string.substr(length - i);\n            break;\n        }\n    }\n    // Reverse\
    \ the suffix and append to string\n    std::string rev_suffix = std::string(suffix.rbegin(),\
    \ suffix.rend());\n    return string + rev_suffix;", "  std::string temp(string);\n\
    \  std::reverse(temp.begin(), temp.end());\n  auto length = 0;\n  for (auto i\
    \ = 0; i < string.size(); ++i) {\n    if (string.substr(i) == temp.substr(0, string.size()\
    \ - i)) {\n      length = i;\n      break;\n    }\n  }\n  return string + temp.substr(length);",
  "  assert(!string.empty());\n  size_t start_index = 0;\n  size_t max_length = 0;\n\
    \  for (size_t i = 0; i < string.size(); ++i) {\n    if (i - max_length - 1 >=\
    \ 0 && string[i - max_length - 1] == string[i]) {\n      start_index = i - max_length\
    \ - 1;\n      max_length += 2;\n    } else if (i - max_length >= 0 && string[i\
    \ - max_length] == string[i]) {\n      start_index = i - max_length;\n      max_length\
    \ += 1;\n    }\n  }\n  std::string prefix(string.begin(), string.begin() + start_index);\n\
    \  std::reverse(prefix.begin(), prefix.end());\n  return string + prefix;", " \
    \   assert(string.size() < 100000);\n    auto rev_string = string;\n    std::reverse(rev_string.begin(),\
    \ rev_string.end());\n    for (int i = 0; i < string.size(); ++i) {\n        if\
    \ (rev_string.substr(i) == string.substr(0, string.size() - i)) {\n          \
    \  return string + rev_string.substr(i);\n        }\n    }\n    return string;",
  "    int longest_postfix_palindrome_len = 0;\n    int size = string.size();\n  \
    \  std::vector<int> postfix_palindrome_length(size);\n    postfix_palindrome_length[0]\
    \ = 0;\n    for (int i = 1; i < size; ++i) {\n        int j = postfix_palindrome_length[i\
    \ - 1];\n        while (j > 0 && string[i] != string[j]) {\n            j = postfix_palindrome_length[j\
    \ - 1];\n        }\n        if (string[i] == string[j]) {\n            ++j;\n\
    \        }\n        postfix_palindrome_length[i] = j;\n        if (j > longest_postfix_palindrome_len)\
    \ {\n            longest_postfix_palindrome_len = j;\n        }\n    }\n    std::string\
    \ prefix = string.substr(0, size - longest_postfix_palindrome_len);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "\tif (string.size() < 2) {\n\t\
    \treturn string;\n\t}\n\tstd::string reverse_string(string.rbegin(), string.rend());\n\
    \tfor (int length = string.size(); length > 0; --length) {\n\t\tif (string.substr(0,\
    \ length) == reverse_string.substr(string.size() - length)) {\n\t\t\treturn string\
    \ + reverse_string.substr(length);\n\t\t}\n\t}\n\treturn string;", "\tstd::string\
    \ reverses_string = string;\n\tstd::reverse(reverses_string.begin(), reverses_string.end());\n\
    \tsize_t pos = string.find(reverses_string);\n\tif (pos + reverses_string.size()\
    \ == string.size()) {\n\t\treturn string;\n\t}\n\tstd::string sub1 = string.substr(0,\
    \ pos);\n\tstd::string sub2 = string.substr(pos);\n\tstd::string res = sub2 +\
    \ make_palindrome(sub1) + sub2;\n\treturn res;", "    // this vector will store\
    \ palindromic substrings of string.\n    std::vector<std::string> palindromes(string.size());\n\
    \    // this will be the final palindrome we build.\n    std::string palindrome\
    \ = \"\";\n    // last_substring will store the current longest palindromic substring.\n\
    \    std::string last_substring = \"\";\n    // length of last_substring.\n  \
    \  size_t length = 0;\n    // iterate through all substrings of string.\n    for\
    \ (size_t i = 0; i < string.size(); i++) {\n        // if the substring is odd-length,\
    \ then it has character at 'i' as its center.\n        if (string[i] == string[i\
    \ + 1]) {\n            palindromes[i] = string[i] + string[i + 1];\n         \
    \   length = 2;\n        } else {\n            palindromes[i] = string[i];\n \
    \           length = 1;\n        }\n        // expand the palindrome at 'i' if\
    \ possible.\n        while (i - length >= 0 && i + length < string.size() && string[i\
    \ - length] == string[i + length]) {\n            palindromes[i] = string[i -\
    \ length] + palindromes[i] + string[i + length];\n            length++;\n    \
    \    }\n        // if we found a longer palindrome, then update last_substring.\n\
    \        if (palindromes[i].size() > last_substring.size()) {\n            last_substring\
    \ = palindromes[i];\n        }\n    }\n    // now we will append to palindrome\
    \ the part of the string that comes before the palindromic suffix.\n    // since\
    \ string[last_substring.size()] will equal string[0], we can just iterate backwards\
    \ until we reach\n    // the last palindromic character.\n    for (size_t i =\
    \ string.size() - 1; i > last_substring.size(); i--) {\n        palindrome +=\
    \ string[i];\n    }\n    palindrome += string;\n    return palindrome;", "   \
    \ int len = string.length();\n    for (int i = len - 1; i >= 0; i--) {\n     \
    \   if (string[0] == string[i]) {\n            int j = 0;\n            while (j\
    \ < i) {\n                if (string[j] != string[i]) {\n                    break;\n\
    \                }\n                j++;\n                i--;\n            }\n\
    \            if (j >= i) {\n                int prefix = len - j - 1;\n      \
    \          for (int k = prefix - 1; k >= 0; k--) {\n                    string\
    \ += string[k];\n                }\n                return string;\n         \
    \   }\n        }\n    }\n    return string;", "    std::string suffix = string;\n\
    \    std::reverse(suffix.begin(), suffix.end());\n    std::string prefix = string.substr(0,\
    \ string.size() - suffix.size());\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    return string + prefix;", "  std::string rev = string;\n  std::reverse(rev.begin(),\
    \ rev.end());\n  std::string both = string + rev;\n  const size_t length = both.length();\n\
    \  std::vector<size_t> match_lengths(length);\n  size_t max_match_length = 0;\n\
    \  for (size_t i = 1; i < length; ++i) {\n    if (both[i] == both[max_match_length])\
    \ {\n      max_match_length++;\n      match_lengths[i] = max_match_length;\n \
    \   } else {\n      size_t j = match_lengths[max_match_length - 1];\n      while\
    \ (j > 0 && both[i] != both[j]) {\n        j = match_lengths[j - 1];\n      }\n\
    \      if (both[i] == both[j]) {\n        j++;\n      }\n      max_match_length\
    \ = j;\n      match_lengths[i] = max_match_length;\n    }\n  }\n  size_t palindrome_length\
    \ = match_lengths[length - 1];\n  return string + rev.substr(palindrome_length);",
  "    if (string.size() == 0) {\n        return string;\n    }\n    std::string rev_string(string.rbegin(),\
    \ string.rend());\n    std::string longest_palindrome;\n    std::string shortest_palindrome;\n\
    \    int length = string.size();\n    for (int i = length; i > 0; i--) {\n   \
    \     std::string postfix = string.substr(length - i, i);\n        std::string\
    \ rev_postfix = rev_string.substr(0, i);\n        if (postfix == rev_postfix)\
    \ {\n            longest_palindrome = postfix;\n            break;\n        }\n\
    \    }\n    std::string suffix = string.substr(0, length - longest_palindrome.size());\n\
    \    shortest_palindrome = string + rev_string.substr(longest_palindrome.size());\n\
    \    return shortest_palindrome;", "    std::string prefix;\n    std::string postfix;\n\
    \    std::string result;\n    std::string current_palindrome;\n    int i;\n  \
    \  int j;\n    for (i = 0; i < string.length(); i++) {\n        prefix = string.substr(0,\
    \ i);\n        std::reverse(prefix.begin(), prefix.end());\n        postfix =\
    \ string.substr(i, string.length() - i);\n        current_palindrome = prefix\
    \ + postfix;\n        std::reverse(current_palindrome.begin(), current_palindrome.end());\n\
    \        if (current_palindrome == postfix) {\n            std::reverse(prefix.begin(),\
    \ prefix.end());\n            result = postfix + prefix;\n            break;\n\
    \        }\n    }\n    if (result.length() == 0) {\n        std::reverse(string.begin(),\
    \ string.end());\n        result = string + string;\n    }\n    return result;",
  "    // Find the longest palindromic suffix.\n    std::string palindromic_suffix;\n\
    \    for (int i = string.size() - 1; i >= 0; --i) {\n        if (string[i] ==\
    \ string[0]) {\n            palindromic_suffix = string.substr(i);\n         \
    \   if (std::equal(palindromic_suffix.begin(), palindromic_suffix.end(), palindromic_suffix.rbegin()))\
    \ {\n                break;\n            }\n        }\n    }\n    // Append reverse\
    \ of the prefix of the string that comes before palindromic suffix.\n    std::string\
    \ prefix = string.substr(0, string.size() - palindromic_suffix.size());\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "    std::string palindrome;\n\
    \    std::string reverse;\n    reverse = string;\n    std::reverse(reverse.begin(),\
    \ reverse.end());\n    palindrome = string + reverse;\n    return palindrome;",
  "    std::string rev = string;\n    std::reverse(rev.begin(), rev.end());\n    std::string\
    \ combined = string + rev;\n    // Find longest palindromic suffix of combined.\n\
    \    std::vector<int> z(combined.size());\n    z[0] = 0;\n    int left = 0;\n\
    \    int right = 0;\n    for (int i = 1; i < combined.size(); ++i) {\n       \
    \ if (i <= right) {\n            z[i] = std::min(right - i + 1, z[i - left]);\n\
    \        }\n        while (i + z[i] < combined.size() && combined[z[i]] == combined[i\
    \ + z[i]]) {\n            ++z[i];\n        }\n        if (i + z[i] - 1 > right)\
    \ {\n            left = i;\n            right = i + z[i] - 1;\n        }\n   \
    \ }\n    int longest_palindromic_suffix = 0;\n    for (int i = 0; i < z.size();\
    \ ++i) {\n        if (z[i] == i + 1) {\n            longest_palindromic_suffix\
    \ = i + 1;\n        }\n    }\n    std::string prefix = string.substr(0, string.size()\
    \ - longest_palindromic_suffix);\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    return string + prefix;", "    std::string::iterator front = string.begin();\n\
    \    std::string::iterator back = string.end() - 1;\n    bool is_already_palindrome\
    \ = true;\n    while (front < back) {\n        if (*front != *back) {\n      \
    \      is_already_palindrome = false;\n            break;\n        }\n       \
    \ ++front;\n        --back;\n    }\n    if (is_already_palindrome) {\n       \
    \ return string;\n    }\n    size_t palindrome_tail_length = 0;\n    front = string.begin();\n\
    \    back = string.end() - 1;\n    while (front < back) {\n        std::string::iterator\
    \ front_copy = front;\n        std::string::iterator back_copy = back;\n     \
    \   while (front_copy < back_copy) {\n            if (*front_copy != *back_copy)\
    \ {\n                break;\n            }\n            ++front_copy;\n      \
    \      --back_copy;\n        }\n        if (front_copy >= back_copy) {\n     \
    \       palindrome_tail_length = back - front + 1;\n            break;\n     \
    \   }\n        ++front;\n        --back;\n    }\n    std::string palindrome_tail(string.begin(),\
    \ string.begin() + palindrome_tail_length);\n    std::string palindrome_head(string.rbegin(),\
    \ string.rend() - palindrome_tail_length);\n    return palindrome_head + palindrome_tail;",
  "    std::string suffix(string);\n    std::reverse(suffix.begin(), suffix.end());\n\
    \    std::string::size_type position = string.find(suffix);\n    if (position\
    \ != std::string::npos) {\n        std::string prefix(string.substr(0, position));\n\
    \        std::reverse(prefix.begin(), prefix.end());\n        return string +\
    \ prefix;\n    }\n    return string + suffix;", "  for (size_t i = string.size();\
    \ i > 0; i--) {\n    if (std::equal(string.begin(), string.begin() + i, string.rbegin()))\
    \ {\n      return string + std::string(string.begin(), string.begin() + i - 1);\n\
    \    }\n  }\n  return string;", "  std::string ret = string;\n  std::string::iterator\
    \ i = string.begin();\n  std::string::iterator j = string.end() - 1;\n  while\
    \ (i <= j) {\n    if (*i == *j) {\n      i++;\n      j--;\n    } else {\n    \
    \  i = string.begin();\n      j--;\n      ret = std::string(string.begin(), j\
    \ + 1);\n      std::reverse(ret.begin(), ret.end());\n      ret += string;\n \
    \   }\n  }\n  return ret;", "    int length = string.length();\n    for (int i\
    \ = length - 1; i >= 0; i--) {\n        if (string[0] == string[i]) {\n      \
    \      bool is_palindrome = true;\n            for (int j = 0; j < i; j++) {\n\
    \                if (string[j] != string[i - j]) {\n                    is_palindrome\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if (is_palindrome) {\n                std::string result = string;\n\
    \                for (int j = length - 1; j >= i; j--) {\n                   \
    \ result += string[j];\n                }\n                return result;\n  \
    \          }\n        }\n    }\n    return string;", "    // First find the longest\
    \ palindromic postfix (suffix).\n    std::string::size_type max_palindrome_length\
    \ = 0;\n    for (std::string::size_type length = 1; length <= string.size(); ++length)\
    \ {\n        std::string::size_type begin = string.size() - length;\n        if\
    \ (string[begin] == string[begin + length - 1]) {\n            max_palindrome_length\
    \ = length;\n        }\n    }\n    // If longest postfix is the whole string,\
    \ return the string.\n    if (max_palindrome_length == string.size()) {\n    \
    \    return string;\n    }\n    // Otherwise, append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    std::string::size_type\
    \ palindrome_begin = string.size() - max_palindrome_length;\n    std::string::size_type\
    \ palindrome_end = string.size();\n    std::string string_prefix = string.substr(0,\
    \ palindrome_begin);\n    std::reverse(string_prefix.begin(), string_prefix.end());\n\
    \    return string + string_prefix;", "    if (string.empty()) {\n        return\
    \ string;\n    }\n    std::string result;\n    int len = string.length();\n  \
    \  for (int i = len; i >= 0; --i) {\n        if (std::equal(string.begin(), string.begin()\
    \ + i, string.rbegin())) {\n            std::string prefix = string.substr(i,\
    \ len - i);\n            std::reverse(prefix.begin(), prefix.end());\n       \
    \     result = string + prefix;\n            break;\n        }\n    }\n    return\
    \ result;", "  assert(!string.empty());\n  std::string::iterator first_non_palindrome_letter\
    \ = string.begin();\n  for (auto it = string.begin(); it != string.end(); ++it)\
    \ {\n    if (*it != *first_non_palindrome_letter) {\n      first_non_palindrome_letter\
    \ = it;\n    }\n  }\n  auto new_string = string;\n  std::reverse(new_string.begin(),\
    \ first_non_palindrome_letter);\n  new_string += string;\n  return new_string;",
  "  std::string reverse;\n  reverse.resize(string.size());\n  std::reverse_copy(string.begin(),\
    \ string.end(), reverse.begin());\n  // We have 2 choices where to cut the string\
    \ to 2 parts (prefix and postfix):\n  // 1. len / 2\n  // 2. len / 2 + 1\n  for\
    \ (size_t cut = string.size() / 2; cut > 0; --cut) {\n    if (string.compare(cut,\
    \ string.size() - cut, reverse, 0, string.size() - cut) == 0) {\n      return\
    \ string + reverse.substr(string.size() - cut);\n    }\n  }\n  return string +\
    \ reverse.substr(1);", "    int max_palindrome_length = 0;\n    int start_of_palindrome\
    \ = 0;\n    // We will create a 2D array where rows will be string positions,\n\
    \    // and columns will be string lengths.\n    // An item at (row, column) will\
    \ be a boolean indicating if a substring\n    // at [row, row + column] is a palindrome.\n\
    \    // Such an array will be symmetric.\n    // We will only need half of it\
    \ and we will create it dynamically.\n    int length = string.length();\n    bool\
    \ **palindrome_substrings = new bool*[length];\n    for (int row = 0; row < length;\
    \ row++) {\n        palindrome_substrings[row] = new bool[length - row];\n   \
    \     // Initially all substrings of length 1 are palindromes.\n        palindrome_substrings[row][0]\
    \ = true;\n    }\n    // Build the palindrome_substrings array.\n    for (int\
    \ column = 1; column < length; column++) {\n        for (int row = 0; row < length\
    \ - column; row++) {\n            // Palindrome substring can be made from two\
    \ substrings one character smaller\n            // or two substrings that differ\
    \ in two characters.\n            if (string[row] == string[row + column] && (\n\
    \                (column == 1) || palindrome_substrings[row + 1][column - 2]))\
    \ {\n                palindrome_substrings[row][column] = true;\n            \
    \    // We are interested in the longest palindrome.\n                if (column\
    \ + 1 > max_palindrome_length) {\n                    max_palindrome_length =\
    \ column + 1;\n                    start_of_palindrome = row;\n              \
    \  }\n            } else {\n                palindrome_substrings[row][column]\
    \ = false;\n            }\n        }\n    }\n    // The palindrome substrings\
    \ array is not needed any more.\n    for (int row = 0; row < length; row++) {\n\
    \        delete [] palindrome_substrings[row];\n    }\n    delete [] palindrome_substrings;\n\
    \    // Return the palindrome.\n    return string +", "    std::string suffix,\
    \ suffix_copy;\n    bool is_palindrome = false;\n    //go through all substring\
    \ of the string\n    for (int i = 0; i < string.size(); i++) {\n        suffix.push_back(string[i]);\n\
    \        std::reverse_copy(suffix.begin(), suffix.end(), std::back_inserter(suffix_copy));\n\
    \        if (suffix == suffix_copy) {\n            is_palindrome = true;\n   \
    \         break;\n        }\n    }\n    if (is_palindrome) {\n        //appends\
    \ the reverse of the string prefix that comes before the palindromic suffix\n\
    \        string.append(suffix_copy.substr(0, suffix_copy.size() - suffix.size()));\n\
    \    }\n    return string;", "  // KMP prefix table:\n  // - At index i the value\
    \ is the length of the longest proper prefix that is also a proper suffix,\n \
    \ //   where proper means not inlcuding the whole string.\n  std::vector<int>\
    \ prefix_table(string.size() + 1);\n  prefix_table[0] = -1;\n  int k = -1;\n \
    \ for (int i = 1; i <= string.size(); ++i) {\n    while (k >= 0 && string[k] !=\
    \ string[i - 1]) {\n      k = prefix_table[k];\n    }\n    ++k;\n    prefix_table[i]\
    \ = k;\n  }\n  std::string result = string;\n  for (int i = prefix_table[string.size()];\
    \ i < string.size(); ++i) {\n    result += string[string.size() - i - 1];\n  }\n\
    \  return result;", "  assert(string.size() != 0);\n  // Find longest postfix\
    \ which is a palindrome.\n  int start = string.size() - 1;\n  while (start >=\
    \ 0) {\n    int i = 0;\n    int j = start;\n    bool ok = true;\n    while (i\
    \ < j) {\n      if (string[i] != string[j]) {\n        ok = false;\n        break;\n\
    \      }\n      i++;\n      j--;\n    }\n    if (ok) break;\n    start--;\n  }\n\
    \  // Build the palindrome by appending the reverse of the prefix.\n  for (int\
    \ i = 0; i < start; i++) {\n    string.push_back(string[start - i - 1]);\n  }\n\
    \  return string;", "    int n = string.size();\n    std::vector<int> p(n);\n\
    \    int c = 0, r = 0;\n    for (int i = 1; i < n; ++i) {\n        int m = (r\
    \ > i) ? std::min(r - i, p[2 * c - i]) : 0;\n        while (i + m + 1 < n && i\
    \ - m - 1 >= 0 && string[i + m + 1] == string[i - m - 1]) ++m;\n        p[i] =\
    \ m;\n        if (i + m > r) {\n            c = i;\n            r = i + m;\n \
    \       }\n    }\n    int center = std::max_element(p.begin(), p.end()) - p.begin();\n\
    \    std::string prefix = string.substr(0, center - p[center] + 1);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "    // Reversing the string.\n\
    \    std::string reversed = string;\n    std::reverse(reversed.begin(), reversed.end());\n\
    \    // KMP lps array.\n    // Suppose we want to find lps array for a string\
    \ `aabaa`.\n    // The next algorithm will go like this:\n    //      i: 0 1 2\
    \ 3 4 5 6 7 8 9 10 11 12 13 14 15\n    // String: a a b a a a a b a a b a a a\
    \ a b a a\n    // lps   : 0 1 0 1 2 3 4 5 4 3 2 1 2 3 4 5 6 7\n    // `i` goes\
    \ from `0` to `lps.size() - 1`\n    // `lps[i]` will be `0` for `i == 0` as there\
    \ are no prefixes that are also suffixes.\n    // At `i == 1` we consider a prefix\
    \ of length `1` which is `a` and the suffix of length `1` which is also `a` and\n\
    \    // since they are equal we set `lps[1]` to `1`.\n    // At `i == 2` we consider\
    \ a prefix of length `2` which is `aa` and the suffix of length `1` which is `a`\
    \ and since\n    // they aren't equal we set `lps[2]` to `0`.\n    // At `i ==\
    \ 3` we consider a prefix of length `3` which is `aab` and the suffix of length\
    \ `1` which is `b` and since\n    // they aren't equal we set `lps[3]` to `0`.\n\
    \    // At `i == 4` we consider a prefix of length `4` which is `aaba` and the\
    \ suffix of length `1` which is `a` and since\n    // they aren't equal we set\
    \ `lps[4]` to `0`.\n    // At `i == 5` we consider a prefix of length `5` which\
    \ is `aabaa` and the suffix of length `1` which is `a` and since\n    // they\
    \ are equal we set `lps[5]` to `1`.\n    // At `i == 6` we consider a prefix of\
    \ length `6` which is `a", "    size_t length = string.length();\n    // Trivial\
    \ case\n    if (length <= 1) return string;\n    // Find the longest suffix that\
    \ is a palindrome\n    // All prefixes of the string are palindromes as well,\
    \ so iterate from -1 to see if the prefix is a palindrome\n    size_t found_suffix_length\
    \ = 0;\n    for (int i = -1; i < (int)length; i++) {\n        if (string[length\
    \ + i] == string[length - 1 - i]) {\n            found_suffix_length++;\n    \
    \    } else {\n            break;\n        }\n    }\n    // Append a reverse of\
    \ the prefix that comes before the suffix\n    std::string prefix = string.substr(0,\
    \ length - found_suffix_length);\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    return string + prefix;", "  std::vector<int> z_values = Z(string);\n  int\
    \ first_position = 0;\n  for (int i = 1; i < z_values.size(); ++i) {\n    if (z_values[i]\
    \ + i == z_values.size()) {\n      first_position = i;\n      break;\n    }\n\
    \  }\n  std::string reversed = Reverse(string.substr(0, first_position));\n  return\
    \ string + reversed;", "    std::vector<std::vector<int>> table(string.size(),\
    \ std::vector<int>(string.size(), 0));\n    int max_substring_index = 0;\n   \
    \ int max_substring_length = 1;\n    for (int i = 0; i < string.size(); i++) {\n\
    \        table[i][i] = 1;\n    }\n    for (int i = 0; i < string.size() - 1; i++)\
    \ {\n        if (string[i] == string[i + 1]) {\n            table[i][i + 1] =\
    \ 1;\n            max_substring_index = i;\n            max_substring_length =\
    \ 2;\n        }\n    }\n    for (int len = 3; len <= string.size(); len++) {\n\
    \        for (int i = 0; i < string.size() - len + 1; i++) {\n            int\
    \ j = i + len - 1;\n            if (string[i] == string[j] && table[i + 1][j -\
    \ 1]) {\n                table[i][j] = 1;\n                max_substring_index\
    \ = i;\n                max_substring_length = len;\n            }\n        }\n\
    \    }\n    std::string prefix = string.substr(0, max_substring_index);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    std::string result = string + prefix;\n    return result;",
  "  if (string.size() == 0) {\n    return string;\n  }\n  auto start = string.begin();\n\
    \  auto end = string.end() - 1;\n  while(end >= start) {\n    if (*start == *end)\
    \ {\n      ++start;\n      --end;\n    } else {\n      --end;\n    }\n  }\n  ++end;\n\
    \  std::reverse(string.begin(), end);\n  return string + std::string(end, string.end());",
  "  std::string palindrome = string;\n  size_t i;\n  size_t max_length = 0;\n  size_t\
    \ palindrome_begin_position = 0;\n  size_t string_size = string.size();\n  bool\
    \ palindrome_map[string_size][string_size];\n  // Initialise 2D table.\n  for\
    \ (i = 0; i < string_size; i++) {\n    for (size_t j = 0; j < string_size; j++)\
    \ {\n      palindrome_map[i][j] = false;\n    }\n  }\n  // Check for substrings\
    \ with 1 character.\n  for (i = 0; i < string_size; i++) {\n    palindrome_map[i][i]\
    \ = true;\n  }\n  // Check for substrings with 2 characters.\n  for (i = 0; i\
    \ < string_size - 1; i++) {\n    if (string[i] == string[i + 1]) {\n      palindrome_map[i][i\
    \ + 1] = true;\n      palindrome_begin_position = i;\n      max_length = 2;\n\
    \    }\n  }\n  // Check for substrings with 3 or more characters.\n  for (size_t\
    \ k = 3; k <= string_size; k++) {\n    for (i = 0; i < string_size - k + 1; i++)\
    \ {\n      size_t j = i + k - 1;\n      if (palindrome_map[i + 1][j - 1] && string[i]\
    \ == string[j]) {\n        palindrome_map[i][j] = true;\n        if (k > max_length)\
    \ {\n          palindrome_begin_position = i;\n          max_length = k;\n   \
    \     }\n      }\n    }\n  }\n  // Append reverse of prefix to the end of the\
    \ string.\n  palindrome.append(palindrome.substr(0, string_size - max_length));\n\
    \  return palindrome;", "    auto is_palindrome = [](const std::string& string)\
    \ {\n        if (string.size() <= 1) {\n            return true;\n        }\n\
    \        for (std::size_t i = 0; i < string.size() / 2; ++i) {\n            if\
    \ (string[i] != string[string.size() - i - 1]) {\n                return false;\n\
    \            }\n        }\n        return true;\n    };\n    for (int i = string.size()\
    \ - 1; i >= 0; --i) {\n        if (is_palindrome(string.substr(i))) {\n      \
    \      std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(),\
    \ prefix.end());\n            return string + prefix;\n        }\n    }\n    return\
    \ \"\";", "  int string_length = string.length();\n  if (string_length == 0) {\n\
    \    return string;\n  }\n  std::string new_string = string;\n  int longest_postfix_length\
    \ = 0;\n  // Determine the longest postfix that is a palindrome.\n  for (int i\
    \ = 0; i < string_length; ++i) {\n    if (string[i] == string[string_length -\
    \ 1]) {\n      bool is_palindrome = true;\n      for (int j = 0; j < string_length\
    \ - i; ++j) {\n        if (string[i + j] != string[string_length - 1 - j]) {\n\
    \          is_palindrome = false;\n          break;\n        }\n      }\n    \
    \  if (is_palindrome) {\n        longest_postfix_length = string_length - i;\n\
    \        break;\n      }\n    }\n  }\n  // Append reverse of a string prefix that\
    \ comes before the palindromic suffix.\n  for (int i = 0; i < string_length -\
    \ longest_postfix_length; ++i) {\n    new_string += string[string_length - 1 -\
    \ i];\n  }\n  return new_string;", "  std::string reverse(string.rbegin(), string.rend());\n\
    \  // Initialize string with the original reversed string.\n  std::string palindrome\
    \ = reverse;\n  // Find the longest suffix that is also a prefix of the reversed\
    \ string.\n  for (size_t i = 0; i < string.size(); ++i) {\n    if (string.substr(0,\
    \ string.size() - i) == reverse.substr(i)) {\n      // If a match is found,\n\
    \      // reverse the remaining prefix.\n      palindrome += string.substr(string.size()\
    \ - i);\n      return palindrome;\n    }\n  }\n  // If no match is found, the\
    \ original string is a palindrome.\n  return string;", "    int n = string.size();\n\
    \    assert(n);\n    std::vector<int> p(n);\n    p[0] = 0;\n    int k = 0;\n \
    \   for (int i = 1; i < n; ++i) {\n        while (k > 0 && string[k] != string[i])\
    \ {\n            k = p[k - 1];\n        }\n        if (string[k] == string[i])\
    \ {\n            ++k;\n        }\n        p[i] = k;\n    }\n    int size = p[n\
    \ - 1];\n    std::string prefix = string.substr(0, size);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "    if (string.empty()) {\n \
    \       return string;\n    }\n    std::string palindrome = string;\n    for (int\
    \ i = 0; i < string.size(); ++i) {\n        if (string.substr(i) == std::string(string.substr(i).rbegin(),\
    \ string.substr(i).rend())) {\n            palindrome = string.substr(0, i) +\
    \ std::string(string.substr(i).rbegin(), string.substr(i).rend());\n         \
    \   break;\n        }\n    }\n    return palindrome;", "  if (string.size() ==\
    \ 0) {\n    return string;\n  }\n  std::string str_rev(string.rbegin(), string.rend());\n\
    \  std::string str_dbl = string + '#' + str_rev;\n  std::vector<int> pi(str_dbl.size(),\
    \ 0);\n  // We may need to substract 1 from size, because there is a separator.\n\
    \  std::string result = str_dbl.substr(string.size() + 1, str_dbl.size() - string.size()\
    \ - pi.back() - 1);\n  std::reverse(result.begin(), result.end());\n  return string\
    \ + result;", "    int n = string.size();\n    std::vector<std::vector<bool>>\
    \ palindrome(n + 1, std::vector<bool>(n + 1, false));\n    // By definition empty\
    \ string is a palindrome.\n    palindrome[0][0] = true;\n    for (int i = 1; i\
    \ <= n; ++i) {\n        // All prefixes of length 1 are palindromes.\n       \
    \ palindrome[i][1] = true;\n        // All prefixes of length 2 are palindromes\
    \ iff they consist of the same character.\n        palindrome[i][2] = string[i\
    \ - 1] == string[i - 2];\n        for (int j = 3; j <= i; ++j) {\n           \
    \ // A string is a palindrome iff\n            // - its first character is the\
    \ same as the last character and\n            // - the substring that excludes\
    \ first and last characters is a palindrome.\n            palindrome[i][j] = (string[i\
    \ - 1] == string[i - j]) && palindrome[i - 1][j - 2];\n        }\n    }\n    //\
    \ The longest palindromic postfix is simply the shortest prefix that is a palindrome.\n\
    \    int length = n;\n    while (!palindrome[n][length]) {\n        --length;\n\
    \    }\n    std::string prefix = string.substr(0, n - length);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;", "    string.erase(std::remove(string.begin(),\
    \ string.end(), ' '), string.end());\n    std::string str = string;\n    std::reverse(str.begin(),\
    \ str.end());\n    std::string result = string + str;\n    int n = string.length();\n\
    \    int i = 0;\n    while (i < n) {\n        int j = n - 1;\n        while (j\
    \ >= i) {\n            if (string[i] == string[j]) {\n                --j;\n \
    \               ++i;\n            } else {\n                break;\n         \
    \   }\n        }\n        if (j < i) {\n            break;\n        }\n      \
    \  j = n - 1;\n        i = 0;\n    }\n    std::string sub = str.substr(0, n -\
    \ i);\n    result = sub + string + str.substr(n - i);\n    return result;", "\t\
    int length = string.length();\n\tstd::string result = string;\n\tfor (int i =\
    \ length - 1; i >= 0; i--) {\n\t\tstd::string substring = string.substr(i, length\
    \ - i);\n\t\tstd::string reverse = substring;\n\t\tstd::reverse(reverse.begin(),\
    \ reverse.end());\n\t\tif (substring == reverse) {\n\t\t\tresult.append(string.substr(0,\
    \ i));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;", "    std::string string_reversed(string);\n\
    \    std::reverse(string_reversed.begin(), string_reversed.end());\n    // Substring\
    \ of first argument that is at most second argument characters from the end is\
    \ concatenated\n    // to the end of the second argument to produce a palindrome.\n\
    \    return string + string_reversed.substr(string.size() - string_reversed.find(string));",
  "\tint size = string.size();\n\tint longest_palindrome_suffix = size;\n\tfor (int\
    \ j = 0; j < size; j++) {\n\t\tif (string[j] == string[size - 1 - j]) {\n\t\t\t\
    longest_palindrome_suffix = size - 1 - j;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\
    \t}\n\t// std::string prefix_string = string.substr(0, longest_palindrome_suffix);\n\
    \t// std::string reversed_prefix_string = prefix_string;\n\t// std::reverse(reversed_prefix_string.begin(),\
    \ reversed_prefix_string.end());\n\t// string += reversed_prefix_string;\n\t//\
    \ return string;\n\tstd::string result = string + string.substr(0, longest_palindrome_suffix);\n\
    \tstd::reverse(result.begin(), result.end());\n\treturn result;", "    std::string\
    \ palindrome = string;\n    std::string reversed_prefix = std::string(string.rbegin(),\
    \ string.rend());\n    std::string::size_type position = string.find(reversed_prefix);\n\
    \    palindrome += reversed_prefix.substr(position + 1);\n    return palindrome;",
  "    if (string.size() == 0) return string;\n    // If string is already a palindrome,\
    \ there is nothing to do\n    bool is_palindrome = true;\n    for (std::size_t\
    \ i = 0; i < string.size() / 2; ++i) {\n        if (string[i] != string[string.size()\
    \ - i - 1]) {\n            is_palindrome = false;\n            break;\n      \
    \  }\n    }\n    if (is_palindrome) return string;\n    // Find the longest postfix\
    \ that is a palindrome\n    std::size_t longest_palindrome_size = 0;\n    for\
    \ (std::size_t i = 0; i < string.size(); ++i) {\n        bool is_palindrome =\
    \ true;\n        for (std::size_t j = 0; j < i; ++j) {\n            if (string[string.size()\
    \ - i + j] != string[j]) {\n                is_palindrome = false;\n         \
    \       break;\n            }\n        }\n        if (is_palindrome) {\n     \
    \       longest_palindrome_size = i;\n        }\n    }\n    // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix\n\
    \    std::string palindrome = string;\n    for (std::size_t i = 0; i < string.size()\
    \ - longest_palindrome_size; ++i) {\n        palindrome += string[string.size()\
    \ - i - 1];\n    }\n    return palindrome;", "  int length = string.length();\n\
    \  for (int pos = 0; pos < length; ++pos) {\n    int left = pos;\n    int right\
    \ = pos;\n    while (left >= 0 && right < length && string[left] == string[right])\
    \ {\n      --left;\n      ++right;\n    }\n    if (left < 0) {\n      std::string\
    \ palindrome = string;\n      std::reverse(string.begin(), string.begin() + pos\
    \ + 1);\n      palindrome += string;\n      return palindrome;\n    }\n    left\
    \ = pos;\n    right = pos + 1;\n    while (left >= 0 && right < length && string[left]\
    \ == string[right]) {\n      --left;\n      ++right;\n    }\n    if (left < 0)\
    \ {\n      std::string palindrome = string;\n      std::reverse(string.begin(),\
    \ string.begin() + pos + 1);\n      palindrome += string;\n      return palindrome;\n\
    \    }\n  }\n  return string;", "\tstd::string palindrome(string);\n\tstd::string\
    \ reversed(string);\n\tstd::reverse(reversed.begin(), reversed.end());\n\tint\
    \ offset = 0;\n\t// Find the longest substring postfix that is a palindrome.\n\
    \twhile (string.substr(offset, string.size() - offset) != reversed.substr(0, string.size()\
    \ - offset)) {\n\t\toffset++;\n\t}\n\tpalindrome += reversed.substr(offset, string.size()\
    \ - offset);\n\treturn palindrome;", "  std::string reverse = string;\n  std::reverse(reverse.begin(),\
    \ reverse.end());\n  std::vector<int> prefix = build_prefix_function(string +\
    \ '$' + reverse);\n  return string + reverse.substr(prefix.back());", "    //\
    \ Find the longest palindromic suffix of the supplied string.\n    size_t i =\
    \ 0;\n    for (size_t j = string.size() - 1; j > 0; --j) {\n        size_t k =\
    \ i;\n        size_t l = j;\n        while (k < l && string[k] == string[l]) {\n\
    \            ++k;\n            --l;\n        }\n        if (k >= l) {\n      \
    \      i = j;\n            break;\n        }\n    }\n    // Make string palindromic\
    \ by adding the prefix to the end of the string.\n    if (i > 0) {\n        for\
    \ (size_t j = 0; j < i; ++j) {\n            string.push_back(string[i - j - 1]);\n\
    \        }\n    }\n    return string;", "    std::string reversed_prefix = string;\n\
    \    std::reverse(reversed_prefix.begin(), reversed_prefix.end());\n    std::string\
    \ concatenated_strings = string + reversed_prefix;\n    std::vector<size_t> prefix_function\
    \ = compute_prefix_function(concatenated_strings);\n    size_t palindrome_length\
    \ = string.size() - prefix_function.back();\n    return string + reversed_prefix.substr(palindrome_length);",
  "  assert(std::is_sorted(string.begin(), string.end()));\n  std::string mirror =\
    \ string;\n  std::reverse(mirror.begin(), mirror.end());\n  std::string longest_palindrome_suffix\
    \ =\n      *std::max_element(string.begin(), string.end(),\n        [&string,\
    \ &mirror](char a, char b) {\n        return string.substr(a).compare(mirror.substr(b))\
    \ < 0;\n        });\n  return string + mirror.substr(longest_palindrome_suffix);",
  "    if (string.empty()) {\n        return string;\n    }\n    std::string reverse_string\
    \ = string;\n    std::reverse(reverse_string.begin(), reverse_string.end());\n\
    \    int length = string.length();\n    for (int i = length; i >= 0; --i) {\n\
    \        if (string.substr(0, i) == reverse_string.substr(length - i)) {\n   \
    \         return string + reverse_string.substr(length - i);\n        }\n    }\n\
    \    return \"\";", "  if (string.empty()) {\n    return string;\n  }\n  std::string\
    \ end_string;\n  auto it = string.begin();\n  while (it != string.end()) {\n \
    \   std::string prefix_string = std::string(string.begin(), it);\n    if (prefix_string\
    \ == std::string(prefix_string.rbegin(), prefix_string.rend())) {\n      end_string\
    \ = std::string(prefix_string.rbegin(), prefix_string.rend());\n      break;\n\
    \    }\n    ++it;\n  }\n  return string + end_string;", "  std::string rev(string.rbegin(),\
    \ string.rend());\n  std::string palindrome(string);\n  palindrome.append(rev.substr(rev.find(string)));\n\
    \  return palindrome;", "  int length = string.length();\n  std::string reverse(string);\n\
    \  std::reverse(reverse.begin(), reverse.end());\n  int start = 0;\n  int end\
    \ = length - 1;\n  int palindrome_suffix_length = 0;\n  while (start < end) {\n\
    \    if (string[start] == reverse[end]) {\n      palindrome_suffix_length++;\n\
    \    } else {\n      palindrome_suffix_length = 0;\n    }\n    start++;\n    end--;\n\
    \  }\n  std::string prefix(string.begin(), string.begin() + length - palindrome_suffix_length);\n\
    \  std::reverse(prefix.begin(), prefix.end());\n  return string + prefix;", " \
    \   size_t n = string.size();\n    size_t k = 0;\n    while (k < n && string[k]\
    \ == string[n - 1 - k])\n        ++k;\n    if (k == n)\n        return string;\n\
    \    std::string tmp = string.substr(k);\n    std::reverse(tmp.begin(), tmp.end());\n\
    \    return string + tmp;", "  // First, let's find the longest palindromic postfix.\n\
    \  std::vector<size_t> kmp_table(string.size(), 0);\n  size_t i = 1;\n  size_t\
    \ j = 0;\n  while (i < string.size()) {\n    // If the ith character matches jth\
    \ character, increment j.\n    if (string[i] == string[j]) {\n      j++;\n   \
    \   kmp_table[i] = j;\n      i++;\n    } else {\n      // If the jth character\
    \ does not match ith character, take jth character to the farthest\n      // position\
    \ we know that it matches something.\n      if (j != 0) {\n        j = kmp_table[j\
    \ - 1];\n      } else {\n        // If the jth character does not match ith character\
    \ and j is 0, move on with i.\n        kmp_table[i] = 0;\n        i++;\n     \
    \ }\n    }\n  }\n  size_t palindrome_length = kmp_table.back();\n  // Now that\
    \ we know the length of the palindromic suffix of the string, we can append the\n\
    \  // reverse of the prefix of that string that comes before the palindromic suffix.\n\
    \  std::string prefix = string.substr(0, string.size() - palindrome_length);\n\
    \  return string + std::string(prefix.rbegin(), prefix.rend());", "  std::string\
    \ newString = string;\n  std::reverse(newString.begin(), newString.end());\n \
    \ string = string + newString;\n  // get suffix which is palindrome\n  std::string\
    \ temp = string;\n  std::reverse(temp.begin(), temp.end());\n  // get prefix to\
    \ reverse\n  std::string::size_type pos = string.find(temp);\n  std::string prefix\
    \ = string.substr(0, pos);\n  std::reverse(prefix.begin(), prefix.end());\n  //\
    \ append prefix to palindrome\n  return string + prefix;", "    size_t found =\
    \ string.find_last_of(string[0]);\n    while (found != std::string::npos) {\n\
    \        if (string.substr(0, found) == std::string(string.substr(found).rbegin(),\
    \ string.substr(found).rend())) {\n            break;\n        }\n        found\
    \ = string.find_last_of(string[0], found - 1);\n    }\n    return string + std::string(string.substr(found).rbegin(),\
    \ string.substr(found).rend());", "  assert(string.length() > 0);\n  std::string\
    \ string_reverse = string;\n  std::reverse(string_reverse.begin(), string_reverse.end());\n\
    \  std::string string_double = string + '\\0' + string_reverse;\n  int length\
    \ = string_double.length();\n  std::vector<int> prefix_function(length);\n  int\
    \ position = 0;\n  for (int index = 1; index < length; ++index) {\n    while (position\
    \ > 0 && string_double[position] != string_double[index]) {\n      position =\
    \ prefix_function[position - 1];\n    }\n    if (string_double[position] == string_double[index])\
    \ {\n      ++position;\n    }\n    prefix_function[index] = position;\n  }\n \
    \ int longest_palindrome_postfix_length = prefix_function[length - 1];\n  return\
    \ string + string_reverse.substr(longest_palindrome_postfix_length);", "    std::string\
    \ result = string;\n    size_t index = 0;\n    for (size_t i = 1; i < string.size();\
    \ ++i) {\n        if (string[i] == string[index]) {\n            ++index;\n  \
    \      } else {\n            index = 0;\n        }\n    }\n    for (size_t i =\
    \ index; i < string.size(); ++i) {\n        result += string[string.size() - i\
    \ - 1];\n    }\n    return result;", "    std::string rev_string = string;\n \
    \   std::reverse(rev_string.begin(), rev_string.end());\n    std::string lcp =\
    \ longest_common_postfix(string, rev_string);\n    if (lcp.length() == string.length())\
    \ {\n        return string;\n    }\n    std::string head = string.substr(0, string.length()\
    \ - lcp.length());\n    std::reverse(head.begin(), head.end());\n    return string\
    \ + head;", "  std::string result = string;\n  int n = string.size();\n  int i\
    \ = 0;\n  int j = n - 1;\n  while (i < j) {\n    if (string[i] != string[j]) {\n\
    \      break;\n    }\n    i++;\n    j--;\n  }\n  for (int x = i; x < n; x++) {\n\
    \    result += string[n - x - 1];\n  }\n  return result;", "    std::string reverse_string\
    \ = string;\n    std::reverse(reverse_string.begin(), reverse_string.end());\n\
    \    std::string temp = string + reverse_string;\n    std::vector<int> prefix_fn(temp.size());\n\
    \    prefix_fn[0] = 0;\n    int border = 0;\n    for (int i = 1; i < temp.size();\
    \ ++i) {\n        while (border > 0 && temp[i] != temp[border]) {\n          \
    \  border = prefix_fn[border - 1];\n        }\n        if (temp[i] == temp[border])\
    \ {\n            ++border;\n        } else {\n            border = 0;\n      \
    \  }\n        prefix_fn[i] = border;\n    }\n    return string + reverse_string.substr(prefix_fn[temp.size()\
    \ - 1]);", "  std::string result;\n  for (size_t i = string.size(); i != 0; --i)\
    \ {\n    if (std::equal(string.begin(), string.begin() + i, string.end() - i))\
    \ {\n      result = string + std::string(string.begin(), string.begin() + i);\n\
    \      break;\n    }\n  }\n  return result;", "  std::string rev(string.rbegin(),\
    \ string.rend());\n  std::string s = string + '#' + rev;\n  std::vector<int> f(s.size(),\
    \ 0);\n  for (size_t i = 1; i < s.size(); ++i) {\n    int j = f[i - 1];\n    while\
    \ (j > 0 && s[i] != s[j]) {\n      j = f[j - 1];\n    }\n    if (s[i] == s[j])\
    \ {\n      ++j;\n    }\n    f[i] = j;\n  }\n  return rev.substr(0, string.size()\
    \ - f[s.size() - 1]) + string;", "    int k = 0;\n    for (int i = 1; i < string.size();\
    \ ++i) {\n        int j = i;\n        while (j > 0 && string[j] == string[i -\
    \ j]) --j;\n        if (i - j > k) k = i - j;\n    }\n    return string + std::string(string.rbegin(),\
    \ string.rbegin() + k);", "    int j = 0;\n    std::vector<int> d(string.size());\n\
    \    d[0] = 0;\n    for (int i = 1; i < string.size(); i++) {\n        while (j\
    \ > 0 && string[i] != string[j]) {\n            j = d[j - 1];\n        }\n   \
    \     if (string[i] == string[j]) {\n            j++;\n        }\n        d[i]\
    \ = j;\n    }\n    return string + std::string(string.begin(), string.begin()\
    \ + d[string.size() - 1]);", "\tstd::string reversed = string;\n\tstd::reverse(reversed.begin(),\
    \ reversed.end());\n\tstd::string result = string + \"#\" + reversed;\n\tstd::vector<int>\
    \ prefix(result.size());\n\tfor (int i = 1; i < result.size(); ++i) {\n\t\tint\
    \ j = prefix[i - 1];\n\t\twhile (j > 0 && result[i] != result[j]) {\n\t\t\tj =\
    \ prefix[j - 1];\n\t\t}\n\t\tif (result[i] == result[j]) {\n\t\t\t++j;\n\t\t}\n\
    \t\tprefix[i] = j;\n\t}\n\treturn string + reversed.substr(prefix.back());", " \
    \ std::string tmp_string = string;\n  std::reverse(string.begin(), string.end());\n\
    \  std::string::size_type position = tmp_string.find(string);\n  if (position\
    \ != 0) {\n    std::string new_string = tmp_string.substr(0, position);\n    std::reverse(new_string.begin(),\
    \ new_string.end());\n    tmp_string.append(new_string);\n  }\n  return tmp_string;",
  "  std::string palindrome = string;\n  size_t size = string.size();\n  for (size_t\
    \ i = 0; i < size; ++i) {\n    if (std::equal(palindrome.begin(), palindrome.begin()\
    \ + size - i,\n                   palindrome.rbegin())) {\n      palindrome +=\
    \ std::string(palindrome.begin(), palindrome.begin() + i);\n      break;\n   \
    \ }\n  }\n  return palindrome;", "  if (string.empty()) return string;\n  int\
    \ length = string.length();\n  std::string result;\n  int j = 0;\n  for (int i\
    \ = length - 1; i >= 0; --i) {\n    if (string[i] == string[j]) ++j;\n  }\n  if\
    \ (j == length) return string;\n  std::string suffix = string.substr(j);\n  std::reverse(suffix.begin(),\
    \ suffix.end());\n  return suffix + make_palindrome(string.substr(0, j)) + string.substr(j);",
  "  // find the longest palindromic suffix of the supplied string\n  int longest_palindromic_suffix_length\
    \ = longest_palindromic_suffix(string);\n  // find reverse of the string prefix\
    \ that comes before the palindromic suffix\n  std::string prefix =\n      string.substr(0,\
    \ string.size() - longest_palindromic_suffix_length);\n  std::reverse(prefix.begin(),\
    \ prefix.end());\n  // return the concatenation of above two strings\n  return\
    \ string + prefix;", "    std::size_t number_of_characters = string.size();\n\
    \    std::size_t longest_palindrome_start_position = 0;\n    std::size_t longest_palindrome_size\
    \ = 0;\n    std::size_t start_position = 0;\n    std::size_t size = 0;\n    for\
    \ (std::size_t i = 0; i < number_of_characters; ++i) {\n        std::size_t j\
    \ = i;\n        while (j < number_of_characters && string[i] == string[j]) {\n\
    \            ++j;\n        }\n        std::size_t current_palindrome_start_position\
    \ = i;\n        std::size_t current_palindrome_size = j - i;\n        while (current_palindrome_start_position\
    \ > 0 && j < number_of_characters && string[current_palindrome_start_position\
    \ - 1] == string[j]) {\n            --current_palindrome_start_position;\n   \
    \         ++j;\n            ++current_palindrome_size;\n        }\n        if\
    \ (current_palindrome_size > longest_palindrome_size) {\n            longest_palindrome_start_position\
    \ = current_palindrome_start_position;\n            longest_palindrome_size =\
    \ current_palindrome_size;\n        }\n        i = j - 1;\n    }\n    std::string\
    \ prefix(string.begin(), string.begin() + longest_palindrome_start_position);\n\
    \    std::reverse(prefix.begin(), prefix.end());\n    return string + prefix;",
  "    std::string rev = string;\n    std::reverse(rev.begin(), rev.end());\n    int\
    \ n = string.size();\n    int i = n;\n    while (i > 0) {\n        if (string.substr(0,\
    \ i) == rev.substr(n - i))\n            break;\n        i--;\n    }\n    std::string\
    \ str = string + rev.substr(n - i);\n    return str;", "  auto len_string = string.length();\n\
    \  assert(len_string >= 0);\n  if (len_string == 0) {\n    return string;\n  }\n\
    \  auto len_palindrome = len_string;\n  for (int ii = len_string - 1; ii >= 0;\
    \ --ii) {\n    if (string[0] == string[ii]) {\n      auto left = 0;\n      auto\
    \ right = ii;\n      while (left < right && string[left] == string[right]) {\n\
    \        ++left;\n        --right;\n      }\n      if (left >= right) {\n    \
    \    len_palindrome = ii;\n        break;\n      }\n    }\n  }\n  std::string\
    \ result;\n  result.reserve(len_string);\n  result.append(string.begin(), string.begin()\
    \ + len_palindrome);\n  std::reverse(string.begin(), string.begin() + len_palindrome);\n\
    \  result.append(string.begin(), string.begin() + len_palindrome);\n  return result;",
  "  // If the string is empty, an empty string is also the shortest palindrome we\
    \ can find.\n  if (string.empty()) {\n    return string;\n  }\n  // Find the longest\
    \ palindromic postfix in the string.\n  size_t postfix_length = 0;\n  for (size_t\
    \ i = 0; i < string.size(); ++i) {\n    // Length of a postfix is one greater\
    \ than number of characters we check.\n    size_t postfix_length_to_check = i\
    \ + 1;\n    // We check odd lengths only.\n    if (postfix_length_to_check % 2\
    \ == 0) {\n      continue;\n    }\n    // Check if a postfix of given length is\
    \ a palindrome.\n    // If it is, remember the length of the palindromic postfix.\n\
    \    bool is_palindrome = true;\n    for (size_t j = 0; j < postfix_length_to_check\
    \ / 2; ++j) {\n      if (string[string.size() - postfix_length_to_check + j] !=\
    \ string[string.size() - postfix_length_to_check / 2 + j]) {\n        is_palindrome\
    \ = false;\n        break;\n      }\n    }\n    if (is_palindrome) {\n      postfix_length\
    \ = postfix_length_to_check;\n    }\n  }\n  // Reverse the prefix of the string\
    \ that comes before the palindromic postfix and append it to the string.\n  for\
    \ (size_t i = 0; i < string.size() - postfix_length; ++i) {\n    string.push_back(string[string.size()\
    \ - postfix_length - i - 1]);\n  }\n  return string;"]
stop_tokens:
- "\n}"
