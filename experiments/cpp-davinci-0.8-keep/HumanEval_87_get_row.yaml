name: HumanEval_87_get_row
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional\
  \ data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n\
  // each row may contain a different number of columns.\n// Given lst, and integer\
  \ x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with\
  \ 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates\
  \ of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n\
  // [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5),\
  \ (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2,\
  \ 2)]\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>>\
  \ lst, long x) {\n"
tests: "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 1, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 1})})), (1)) == (std::vector<std::tuple<long, long>>({std::make_tuple(0,\
  \ 0), std::make_tuple(1, 4), std::make_tuple(1, 0), std::make_tuple(2, 5), std::make_tuple(2,\
  \ 0)})));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6})})), (2)) == (std::vector<std::tuple<long,\
  \ long>>({std::make_tuple(0, 1), std::make_tuple(1, 1), std::make_tuple(2, 1), std::make_tuple(3,\
  \ 1), std::make_tuple(4, 1), std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6}), std::vector<long>({1,\
  \ 1, 3, 4, 5, 6}), std::vector<long>({1, 2, 1, 4, 5, 6}), std::vector<long>({1,\
  \ 2, 3, 1, 5, 6}), std::vector<long>({1, 2, 3, 4, 1, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 1})})), (1)) == (std::vector<std::tuple<long, long>>({std::make_tuple(0,\
  \ 0), std::make_tuple(1, 0), std::make_tuple(2, 1), std::make_tuple(2, 0), std::make_tuple(3,\
  \ 2), std::make_tuple(3, 0), std::make_tuple(4, 3), std::make_tuple(4, 0), std::make_tuple(5,\
  \ 4), std::make_tuple(5, 0), std::make_tuple(6, 5), std::make_tuple(6, 0)})));\n\
  \    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long,\
  \ long>>()));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1})})),\
  \ (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>(),\
  \ std::vector<long>({1}), std::vector<long>({1, 2, 3})})), (3)) == (std::vector<std::tuple<long,\
  \ long>>({std::make_tuple(2, 2)})));\n}\n"
completions: ["    std::vector<std::tuple<long, long>> res;\n    for (int i = 0; i\
    \ < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n  \
    \          if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        if (std::get<0>(a)\
    \ == std::get<0>(b)) {\n            return std::get<1>(a) > std::get<1>(b);\n\
    \        }\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (int i = 0; i\
    \ < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n  \
    \          if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    sort(res.begin(), res.end());\n \
    \   return res;", "  std::vector<std::tuple<long, long>> ret;\n  for (long i =\
    \ 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n\
    \      if (lst[i][j] == x) {\n        ret.push_back(std::make_tuple(i, j));\n\
    \      }\n    }\n  }\n  std::sort(ret.begin(), ret.end(), [](std::tuple<long,\
    \ long>& a, std::tuple<long, long>& b) {\n    return std::get<0>(a) < std::get<0>(b);\n\
    \  });\n  std::sort(ret.begin(), ret.end(), [](std::tuple<long, long>& a, std::tuple<long,\
    \ long>& b) {\n    return std::get<1>(a) > std::get<1>(b);\n  });\n  return ret;",
  "  std::vector<std::tuple<long, long>> res;\n  for (long i = 0; i < lst.size();\
    \ i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j]\
    \ == x) {\n        res.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n\
    \  std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a)\
    \ > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n\
    \  return res;", "    std::vector<std::tuple<long, long>> result;\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++)\
    \ {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    for (int i = 0; i < result.size(); i++) {\n\
    \        for (int j = 0; j < result.size() - 1; j++) {\n            if (std::get<0>(result[j])\
    \ == std::get<0>(result[j + 1])) {\n                if (std::get<1>(result[j])\
    \ < std::get<1>(result[j + 1])) {\n                    std::swap(result[j], result[j\
    \ + 1]);\n                }\n            }\n        }\n    }\n    return result;",
  "    std::vector<std::tuple<long, long>> result;\n    // Your code here\n    for(int\
    \ i = 0; i < lst.size(); i++) {\n        for(int j = 0; j < lst[i].size(); j++)\
    \ {\n            if(lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    // 0 sort\n    std::sort(result.begin(),\
    \ result.end(),\n              [](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) {\n                  if(std::get<0>(a) == std::get<0>(b)) {\n    \
    \                  return std::get<1>(a) > std::get<1>(b);\n                 \
    \ }\n                  return std::get<0>(a) < std::get<0>(b);\n             \
    \ });\n    return result;", "    std::vector<std::tuple<long, long>> result;\n\
    \    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\n\
    \              [](std::tuple<long, long> a, std::tuple<long, long> b) {\n    \
    \              return (std::get<0>(a) < std::get<0>(b));\n              });\n\
    \    for (long i = 0; i < result.size(); i++) {\n        for (long j = 0; j <\
    \ result.size() - 1; j++) {\n            if (std::get<0>(result[j]) == std::get<0>(result[j\
    \ + 1])) {\n                if (std::get<1>(result[j]) < std::get<1>(result[j\
    \ + 1])) {\n                    std::swap(result[j], result[j + 1]);\n       \
    \         }\n            }\n        }\n    }\n    return result;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    auto it = std::find(lst[i].begin(),\
    \ lst[i].end(), x);\n    if (it != lst[i].end()) {\n      result.push_back(std::make_tuple(i,\
    \ std::distance(lst[i].begin(), it)));\n    }\n  }\n  // sort row in ascending\
    \ order\n  std::sort(result.begin(), result.end(),\n            [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n    return std::get<0>(a) < std::get<0>(b);\n\
    \  });\n  // sort column in descending order\n  std::sort(result.begin(), result.end(),\n\
    \            [](std::tuple<long, long> a, std::tuple<long, long> b) {\n    return\
    \ std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b);\n  });\n\
    \  return result;", "\tstd::vector<std::tuple<long, long>> ans;\n\tfor (long i\
    \ = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size(); j++) {\n\
    \t\t\tif (lst[i][j] == x) {\n\t\t\t\tans.push_back(std::make_tuple(i, j));\n\t\
    \t\t}\n\t\t}\n\t}\n\tstd::sort(ans.begin(), ans.end(), [](std::tuple<long, long>\
    \ const & a, std::tuple<long, long> const & b) {\n\t\tif (std::get<0>(a) == std::get<0>(b))\
    \ {\n\t\t\treturn std::get<1>(a) > std::get<1>(b);\n\t\t}\n\t\treturn std::get<0>(a)\
    \ < std::get<0>(b);\n\t});\n\treturn ans;", "\tstd::vector<std::tuple<long, long>>\
    \ rows;\n\tif(lst.size() == 0)\n\t\treturn rows;\n\telse if(lst.size() == 1) {\n\
    \t\tif(lst[0].size() == 0)\n\t\t\treturn rows;\n\t\telse {\n\t\t\tstd::tuple<long,\
    \ long> row;\n\t\t\trow = std::make_tuple(0, 0);\n\t\t\trows.push_back(row);\n\
    \t\t\treturn rows;\n\t\t}\n\t}\n\telse {\n\t\tfor(long i = 0; i < lst.size();\
    \ i++) {\n\t\t\tfor(long j = 0; j < lst[i].size(); j++) {\n\t\t\t\tif(lst[i][j]\
    \ == x) {\n\t\t\t\t\tstd::tuple<long, long> row;\n\t\t\t\t\trow = std::make_tuple(i,\
    \ j);\n\t\t\t\t\trows.push_back(row);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn rows;\n\
    \t}", "    std::vector<std::tuple<long, long>> res;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                res.push_back(std::make_tuple(i, j));\n           \
    \ }\n        }\n    }\n    std::sort(res.begin(), res.end(),\n        [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n            return\
    \ std::get<0>(a) < std::get<0>(b);\n        });\n    for (int i = 0; i < res.size();\
    \ i++) {\n        int count = 0;\n        while (i + 1 < res.size() && std::get<0>(res[i])\
    \ == std::get<0>(res[i + 1])) {\n            if (std::get<1>(res[i]) < std::get<1>(res[i\
    \ + 1])) {\n                std::swap(res[i], res[i + 1]);\n            }\n  \
    \          i++;\n            count++;\n        }\n        i -= count;\n    }\n\
    \    return res;", "    std::vector<std::tuple<long, long>> result;\n    std::sort(lst.begin(),\
    \ lst.end(), [](std::vector<long> v1, std::vector<long> v2) {\n        return\
    \ v1.size() < v2.size();\n    });\n    for (size_t i = 0; i < lst.size(); i++)\
    \ {\n        std::vector<long>::iterator it = std::find(lst[i].begin(), lst[i].end(),\
    \ x);\n        if (it != lst[i].end()) {\n            result.push_back(std::make_tuple(i,\
    \ std::distance(lst[i].begin(), it)));\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> t1, std::tuple<long, long> t2) {\n \
    \       return std::get<0>(t1) < std::get<0>(t2);\n    });\n    std::vector<std::tuple<long,\
    \ long>> final_result;\n    for (size_t i = 0; i < result.size(); i++) {\n   \
    \     if (std::get<0>(result[i]) != std::get<0>(result[i - 1])) {\n          \
    \  std::sort(result.begin() + i, result.end(), [](std::tuple<long, long> t1, std::tuple<long,\
    \ long> t2) {\n                return std::get<1>(t1) > std::get<1>(t2);\n   \
    \         });\n        }\n    }\n    return result;", "  std::vector<std::tuple<long,\
    \ long>> ret;\n  if(lst.size()==0) return ret;\n  for(int i=0;i<lst.size();i++){\n\
    \    for(int j=0;j<lst[i].size();j++){\n      if(lst[i][j]==x) ret.push_back(std::make_tuple(i,j));\n\
    \    }\n  }\n  std::sort(ret.begin(),ret.end());\n  std::reverse(ret.begin(),ret.end());\n\
    \  std::sort(ret.begin(),ret.end(),[](std::tuple<long, long> a, std::tuple<long,\
    \ long> b){\n    return std::get<0>(a)<std::get<0>(b);\n  });\n  return ret;",
  "  std::vector<std::tuple<long, long>> result;\n  // your code here\n  return result;",
  "    std::vector<std::tuple<long, long>> result;\n    if(lst.size()==0) {\n    \
    \    return result;\n    }\n    for(long i=0; i<lst.size(); i++) {\n        for(long\
    \ j=0; j<lst[i].size(); j++) {\n            if(lst[i][j]==x) {\n             \
    \   result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n\
    \    std::sort(result.begin(), result.end(), [&](std::tuple<long, long> &a, std::tuple<long,\
    \ long> &b) {\n        if(std::get<0>(a)==std::get<0>(b)) {\n            return\
    \ std::get<1>(a)>std::get<1>(b);\n        }\n        return std::get<0>(a)<std::get<0>(b);\n\
    \    });\n    return result;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for (size_t i = 0; i < lst.size(); i++) {\n        for (size_t j = 0; j <\
    \ lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](std::tuple<long, long> &a, std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    for (size_t i = 0; i < res.size(); i++) {\n\
    \        for (size_t j = i + 1; j < res.size(); j++) {\n            if (std::get<0>(res[i])\
    \ == std::get<0>(res[j])) {\n                if (std::get<1>(res[i]) < std::get<1>(res[j]))\
    \ {\n                    std::swap(res[i], res[j]);\n                }\n     \
    \       }\n        }\n    }\n    return res;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    for (long j =\
    \ 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  return result;", "  // your code goes here\n  std::vector<std::tuple<long,\
    \ long>> found;\n  if (lst.size() == 0) {\n    return found;\n  }\n  for (long\
    \ i = 0; i < lst.size(); i++) {\n    if (lst[i].size() == 0) {\n      continue;\n\
    \    }\n    long j = 0;\n    while (j < lst[i].size()) {\n      if (lst[i][j]\
    \ == x) {\n        found.push_back(std::make_tuple(i, j));\n      }\n      j++;\n\
    \    }\n  }\n  std::sort(found.begin(), found.end(), [](const std::tuple<long,\
    \ long> &lhs, const std::tuple<long, long> &rhs) {\n    if (std::get<0>(lhs) !=\
    \ std::get<0>(rhs)) {\n      return std::get<0>(lhs) < std::get<0>(rhs);\n   \
    \ }\n    else {\n      return std::get<1>(lhs) > std::get<1>(rhs);\n    }\n  });\n\
    \  return found;", "  // your code here\n  std::vector<std::tuple<long, long>>\
    \ ans;\n  for (int i = 0; i < lst.size(); i++) {\n    std::vector<long> row =\
    \ lst[i];\n    for (int j = 0; j < row.size(); j++) {\n      if (row[j] == x)\
    \ {\n        ans.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  return\
    \ ans;", "    std::vector<std::tuple<long, long>> ret;\n    std::vector<std::tuple<long,\
    \ long>> tmp;\n    for (auto i = 0; i < lst.size(); i++) {\n        for (auto\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          ret.push_back(std::make_tuple(i, j));\n            }\n        }\n \
    \   }\n    std::sort(ret.begin(), ret.end());\n    for (auto i = 0; i < ret.size();\
    \ i++) {\n        tmp.push_back(std::make_tuple(ret[i].first, -ret[i].second));\n\
    \    }\n    std::sort(tmp.begin(), tmp.end());\n    for (auto i = 0; i < tmp.size();\
    \ i++) {\n        ret[i] = std::make_tuple(tmp[i].first, -tmp[i].second);\n  \
    \  }\n    return ret;", "\tstd::vector<std::tuple<long, long>> result;\n\tlong\
    \ i = 0;\n\tlong j = 0;\n\tlong size = lst.size();\n\twhile (i < size) {\n\t\t\
    j = 0;\n\t\twhile (j < lst[i].size()) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\t\
    result.push_back(std::make_tuple(i, j));\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\
    \t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n\t\tif (std::get<0>(a) == std::get<0>(b)) {\n\t\t\treturn std::get<1>(a)\
    \ > std::get<1>(b);\n\t\t}\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\t});\n\
    \treturn result;", "\t// your code here\n\tstd::vector<std::tuple<long, long>>\
    \ temp;\n\tfor (auto i = 0; i < lst.size(); i++) {\n\t\tfor (auto j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\ttemp.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(temp.begin(), temp.end(), [] (std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n\t\tif (std::get<0>(a) == std::get<0>(b))\
    \ {\n\t\t\treturn std::get<1>(a) > std::get<1>(b);\n\t\t}\n\t\treturn std::get<0>(a)\
    \ < std::get<0>(b);\n\t});\n\treturn temp;", "\tstd::vector<std::tuple<long, long>>\
    \ sorted_lst;\n\tstd::vector<std::tuple<long, long>> result;\n\tfor (long i =\
    \ 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size(); j++) {\n\t\
    \t\tif (lst[i][j] == x) {\n\t\t\t\tsorted_lst.push_back(std::make_tuple(i, j));\n\
    \t\t\t}\n\t\t}\n\t}\n\tsort(sorted_lst.begin(), sorted_lst.end());\n\tfor (long\
    \ i = 0; i < sorted_lst.size(); i++) {\n\t\tif (std::get<0>(sorted_lst[i]) ==\
    \ std::get<0>(sorted_lst[i - 1])) {\n\t\t\tresult.push_back(sorted_lst[i]);\n\t\
    \t}\n\t}\n\tfor (long i = 0; i < result.size(); i++) {\n\t\tfor (long j = 0; j\
    \ < result.size() - 1; j++) {\n\t\t\tif (std::get<1>(result[j]) < std::get<1>(result[j\
    \ + 1])) {\n\t\t\t\tstd::tuple<long, long> temp = result[j];\n\t\t\t\tresult[j]\
    \ = result[j + 1];\n\t\t\t\tresult[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;", "    std::vector<std::tuple<long, long>> temp;\n    for (int i = 0;\
    \ i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n\
    \            if (lst[i][j] == x) {\n                temp.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n\
    \    return temp;", "    // count number of x in the list\n    int number_of_x\
    \ = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0;\
    \ j < lst[i].size(); j++) {\n            if (lst[i][j] == x)\n               \
    \ number_of_x++;\n        }\n    }\n    // each x is stored in a tuple\n    //\
    \ std::vector<std::tuple<long, long>> result;\n    std::vector<std::tuple<long,\
    \ long>> result(number_of_x);\n    int k = 0;\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                result[k] = std::make_tuple(i, j);\n              \
    \  k++;\n            }\n        }\n    }\n    std::sort(result.begin(), result.end());\n\
    \    std::sort(result.begin(), result.end(),\n              [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n                  return std::get<1>(a)\
    \ > std::get<1>(b);\n              });\n    return result;", "    vector<tuple<long,\
    \ long>> ans;\n    //cout << lst.size() << endl;\n    for(int i = 0; i < lst.size();\
    \ i++) {\n        for(int j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j]\
    \ == x)\n                ans.push_back(make_tuple(i, j));\n        }\n    }\n\
    \    sort(ans.begin(), ans.end());\n    for(int i = 0; i < ans.size(); i++) {\n\
    \        for(int j = i+1; j < ans.size(); j++) {\n            if(get<0>(ans[i])\
    \ == get<0>(ans[j])) {\n                if(get<1>(ans[i]) < get<1>(ans[j])) {\n\
    \                    tuple<long, long> tmp = ans[i];\n                    ans[i]\
    \ = ans[j];\n                    ans[j] = tmp;\n                }\n          \
    \  }\n        }\n    }\n    return ans;", "  std::vector<std::tuple<long, long>>\
    \ result;\n  for (auto i = 0; i < lst.size(); i++) {\n    for (auto j = 0; j <\
    \ lst[i].size(); j++) {\n      if (lst[i][j] == x)\n        result.push_back(std::make_tuple(i,\
    \ j));\n    }\n  }\n  std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n    if (std::get<0>(a) == std::get<0>(b))\
    \ {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a)\
    \ < std::get<0>(b);\n  });\n  return result;", "    std::vector<std::tuple<long,\
    \ long>> ret;\n    if (lst.size() > 0) {\n        for (long i = 0; i < lst.size();\
    \ i++) {\n            if (lst[i].size() > 0) {\n                std::vector<long>::iterator\
    \ itr = std::find(lst[i].begin(), lst[i].end(), x);\n                if (itr !=\
    \ lst[i].end()) {\n                    for (long j = 0; j < lst[i].size(); j++)\
    \ {\n                        if (lst[i][j] == x) {\n                         \
    \   ret.push_back(std::make_tuple(i, j));\n                        }\n       \
    \             }\n                }\n            }\n        }\n    }\n    std::sort(ret.begin(),\
    \ ret.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n      \
    \  if (std::get<0>(a) == std::get<0>(b)) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        }\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    return ret;", "    std::vector<std::tuple<long, long>> final_vector;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        auto current_vector = lst[i];\n\
    \        std::vector<long> current_vector_index;\n        for (int j = 0; j <\
    \ current_vector.size(); j++) {\n            if (current_vector[j] == x) {\n \
    \               current_vector_index.push_back(j);\n            }\n        }\n\
    \        for (int k = 0; k < current_vector_index.size(); k++) {\n           \
    \ std::tuple<long, long> current_tuple = std::make_tuple(i, current_vector_index[k]);\n\
    \            final_vector.push_back(current_tuple);\n        }\n    }\n    std::sort(final_vector.begin(),\
    \ final_vector.end(), [](std::tuple<long, long> left, std::tuple<long, long> right)\
    \ {\n        long first_left = std::get<0>(left);\n        long first_right =\
    \ std::get<0>(right);\n        long second_left = std::get<1>(left);\n       \
    \ long second_right = std::get<1>(right);\n        if (first_left != first_right)\
    \ {\n            return first_left < first_right;\n        } else {\n        \
    \    return second_left > second_right;\n        }\n    });\n    return final_vector;",
  "\tstd::vector<std::tuple<long, long>> res;\n\tlong i, j;\n\tfor (i = 0; i < lst.size();\
    \ i++) {\n\t\tfor (j = 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x)\
    \ {\n\t\t\t\tres.push_back(std::make_tuple(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(res.begin(),\
    \ res.end());\n\treturn res;", "  std::vector<std::tuple<long, long>> ans;\n \
    \ for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        ans.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(ans.begin(), ans.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n    return std::get<0>(a) < std::get<0>(b);\n\
    \  });\n  for (int i = 0; i < ans.size(); i++) {\n    int cur = std::get<0>(ans[i]);\n\
    \    int j = i + 1;\n    while (j < ans.size() && std::get<0>(ans[j]) == cur)\
    \ {\n      j++;\n    }\n    std::sort(ans.begin() + i, ans.begin() + j, [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n      return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    i = j - 1;\n  }\n  return ans;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  if (lst.empty()) {\n    return result;\n  }\n  long row_size\
    \ = lst.size();\n  for (long i = 0; i < row_size; i++) {\n    long column_size\
    \ = lst[i].size();\n    for (long j = 0; j < column_size; j++) {\n      if (lst[i][j]\
    \ == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n\
    \  }\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>\
    \ &t1, const std::tuple<long, long> &t2) {\n    if (std::get<0>(t1) != std::get<0>(t2))\
    \ {\n      return std::get<0>(t1) < std::get<0>(t2);\n    } else {\n      return\
    \ std::get<1>(t1) > std::get<1>(t2);\n    }\n  });\n  return result;", "\tstd::vector<std::tuple<long,\
    \ long>> result;\n\tlong sum = 0;\n\tlong cnt = 0;\n\tfor (auto& l : lst) {\n\t\
    \tsum += l.size();\n\t\tauto it = std::find(l.begin(), l.end(), x);\n\t\twhile\
    \ (it != l.end()) {\n\t\t\tresult.push_back(std::make_tuple(cnt, sum - l.size()\
    \ + std::distance(l.begin(), it)));\n\t\t\tit = std::find(it + 1, l.end(), x);\n\
    \t\t}\n\t\tcnt++;\n\t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n\t\treturn std::get<0>(t1) < std::get<0>(t2);\n\
    \t});\n\tfor (auto& t : result) {\n\t\tstd::cout << std::get<0>(t) << \" \" <<\
    \ std::get<1>(t) << std::endl;\n\t}\n\treturn result;", "\tlong row = 0;\n\tlong\
    \ column = 0;\n\tlong count = 0;\n\tstd::vector<std::tuple<long, long>> co_ordinate;\n\
    \tfor (auto i = lst.begin(); i != lst.end(); i++) {\n\t\tfor (auto j = i->begin();\
    \ j != i->end(); j++) {\n\t\t\tif (*j == x) {\n\t\t\t\tcount++;\n\t\t\t\tco_ordinate.push_back(std::make_tuple(row,\
    \ column));\n\t\t\t}\n\t\t\tcolumn++;\n\t\t}\n\t\tcolumn = 0;\n\t\trow++;\n\t\
    }\n\t// std::cout << std::get<0>(co_ordinate[0]) << std::endl;\n\t// std::cout\
    \ << std::get<1>(co_ordinate[0]) << std::endl;\n\tstd::sort(co_ordinate.begin(),\
    \ co_ordinate.end(),\n\t\t\t  [](std::tuple<long, long> &a, std::tuple<long, long>\
    \ &b) {\n\t\t\t\t  return std::get<0>(a) < std::get<0>(b);\n\t\t\t  });\n\t//\
    \ std::cout << std::get<0>(co_ordinate[0]) << std::endl;\n\t// std::cout << std::get<1>(co_ordinate[0])\
    \ << std::endl;\n\trow = 0;\n\twhile (row < count) {\n\t\tlong prev_row = std::get<0>(co_ordinate[row]);\n\
    \t\tlong prev_column = std::get<1>(co_ordinate[row]);\n\t\tlong next_row = prev_row;\n\
    \t\twhile (next_row == prev_row) {\n\t\t\tlong next_column = std::get<1>(co_ordinate[row]);\n\
    \t\t\tif (next_column < prev_column) {\n\t\t\t\tstd::swap(co_ordinate[row], co_ordinate[row\
    \ - 1]);\n\t\t\t\tprev_column = next_column;\n\t\t\t}\n\t\t\tnext_row = std::get<0>(",
  "    std::vector<std::tuple<long, long>> r;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x)\n                r.push_back(std::make_tuple(i, j));\n        }\n    }\n\
    \    std::sort(r.begin(), r.end(),\n        [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) {\n            return std::get<0>(a) < std::get<0>(b);\n\
    \        });\n    std::sort(r.begin(), r.end(),\n        [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        });\n    return r;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          result.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(result.begin(), result.end(), [](const\
    \ std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return\
    \ std::get<1>(a) > std::get<1>(b);\n    });\n    return result;", "    std::vector<std::tuple<long,\
    \ long>> answer;\n    for (long row = 0; row < lst.size(); row++) {\n        for\
    \ (long col = 0; col < lst[row].size(); col++) {\n            if (lst[row][col]\
    \ == x) {\n                answer.push_back(std::make_tuple(row, col));\n    \
    \        }\n        }\n    }\n    std::sort(answer.begin(), answer.end(), [](auto\
    \ t1, auto t2) {\n        return (std::get<0>(t1) < std::get<0>(t2)) || (std::get<0>(t1)\
    \ == std::get<0>(t2) && std::get<1>(t1) > std::get<1>(t2));\n    });\n    return\
    \ answer;", "    int row = lst.size();\n    int column;\n    std::vector<std::tuple<long,\
    \ long>> res;\n    for (int i = 0; i < row; i++) {\n        column = lst[i].size();\n\
    \        for (int j = 0; j < column; j++) {\n            if (lst[i][j] == x) {\n\
    \                res.push_back(std::make_tuple(i, j));\n            }\n      \
    \  }\n    }\n    std::sort(res.begin(), res.end());\n    int tupSize = res.size();\n\
    \    for (int i = 0; i < tupSize; i++) {\n        for (int j = 0; j < tupSize;\
    \ j++) {\n            if (std::get<0>(res[i]) == std::get<0>(res[j])) {\n    \
    \            if (std::get<1>(res[i]) < std::get<1>(res[j])) {\n              \
    \      std::swap(res[i], res[j]);\n                }\n            }\n        }\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> result;\n \
    \   int cnt = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          result.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long, long>\
    \ x, std::tuple<long, long> y) {\n        if (std::get<0>(x) == std::get<0>(y))\
    \ {\n            return std::get<1>(x) > std::get<1>(y);\n        }\n        return\
    \ std::get<0>(x) < std::get<0>(y);\n    });\n    return result;", "    int n =\
    \ lst.size();\n    std::vector<std::tuple<long, long>> result;\n    for (int i\
    \ = 0; i < n; i++) {\n        std::vector<long> temp = lst[i];\n        int m\
    \ = temp.size();\n        for (int j = 0; j < m; j++) {\n            if (temp[j]\
    \ == x) {\n                result.push_back(std::make_tuple(i, j));\n        \
    \    }\n        }\n    }\n    if (result.size() == 0) {\n        return result;\n\
    \    }\n    std::sort(result.begin(), result.end());\n    int last = std::get<0>(result[0]);\n\
    \    for (int i = 1; i < result.size(); i++) {\n        if (last == std::get<0>(result[i]))\
    \ {\n            std::tuple<long, long> a = result[i];\n            std::tuple<long,\
    \ long> b = result[i - 1];\n            if (std::get<1>(a) > std::get<1>(b)) {\n\
    \                result[i] = b;\n                result[i - 1] = a;\n        \
    \    }\n        }\n        last = std::get<0>(result[i]);\n    }\n    return result;",
  "\tstd::vector<std::tuple<long, long>> toReturn;\n\tfor (long i = 0; i < lst.size();\
    \ i++) {\n\t\tfor (long j = 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j]\
    \ == x) {\n\t\t\t\ttoReturn.push_back(std::make_tuple(i, j));\n\t\t\t}\n\t\t}\n\
    \t}\n\tsort(toReturn.begin(), toReturn.end());\n\tfor (long i = 0; i < toReturn.size();\
    \ i++) {\n\t\tlong row = std::get<0>(toReturn[i]);\n\t\tlong col = std::get<1>(toReturn[i]);\n\
    \t\tfor (long j = i + 1; j < toReturn.size(); j++) {\n\t\t\tlong row1 = std::get<0>(toReturn[j]);\n\
    \t\t\tlong col1 = std::get<1>(toReturn[j]);\n\t\t\tif (row == row1) {\n\t\t\t\t\
    if (col < col1) {\n\t\t\t\t\tstd::swap(toReturn[i], toReturn[j]);\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn toReturn;", "  //your code here\n  std::vector<std::tuple<long,\
    \ long>> ans;\n  long index = 0;\n  for (auto i : lst) {\n    long position =\
    \ 0;\n    for (auto j : i) {\n      if (j == x) {\n        ans.push_back(std::make_tuple(index,\
    \ position));\n      }\n      position++;\n    }\n    index++;\n  }\n  std::sort(ans.begin(),\
    \ ans.end());\n  long index1 = 0;\n  long index2 = 0;\n  long row_index = 0;\n\
    \  for (auto i : ans) {\n    if (index1 == 0) {\n      row_index = std::get<0>(i);\n\
    \    }\n    if (std::get<0>(i) != row_index) {\n      std::reverse(ans.begin()\
    \ + index2, ans.begin() + index1);\n      index2 = index1;\n      row_index =\
    \ std::get<0>(i);\n    }\n    index1++;\n  }\n  std::reverse(ans.begin() + index2,\
    \ ans.end());\n  return ans;", "  std::vector<std::tuple<long, long>> result;\n\
    \  if (lst.empty()) {\n    return result;\n  }\n  for (int i = 0; i < lst.size();\
    \ i++) {\n    for (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] ==\
    \ x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n\
    \  // TODO:: Write the function body\n  return result;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (unsigned long i = 0; i < lst.size(); i++) {\n     \
    \   for (unsigned long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x)\n                result.push_back(std::make_tuple(i, j));\n        }\n\
    \    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b) {\n        if (std::get<0>(a) == std::get<0>(b))\n\
    \            return std::get<1>(a) > std::get<1>(b);\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    return result;", "    std::vector<std::tuple<long,\
    \ long>> points;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          points.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    std::sort(points.begin(), points.end(), [](std::tuple<long, long>\
    \ t1, std::tuple<long, long> t2) {\n        long i1 = std::get<0>(t1);\n     \
    \   long i2 = std::get<0>(t2);\n        long j1 = std::get<1>(t1);\n        long\
    \ j2 = std::get<1>(t2);\n        if (i1 < i2) {\n            return true;\n  \
    \      } else if (i1 == i2) {\n            return j1 > j2;\n        } else {\n\
    \            return false;\n        }\n    });\n    return points;", "    std::vector<std::tuple<long,\
    \ long>>  res;\n    std::vector<std::vector<long>>::iterator it ;\n    for(it\
    \ = lst.begin(); it != lst.end(); it++) {\n        for(int i = 0; i < (*it).size();\
    \ i++) {\n            if((*it)[i] == x) {\n                res.push_back(std::make_tuple(it\
    \ - lst.begin(), i));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> x, std::tuple<long, long> y) {\n      \
    \  if(std::get<0>(x) != std::get<0>(y)) {\n            return std::get<0>(x) <\
    \ std::get<0>(y);\n        }\n        return std::get<1>(x) > std::get<1>(y);\n\
    \    });\n    return res;", "  std::vector<std::tuple<long, long>> result;\n \
    \ int row_size = lst.size();\n  for (int i = 0; i < row_size; i++) {\n    std::vector<long>\
    \ inside_array = lst[i];\n    int col_size = inside_array.size();\n    for (int\
    \ j = 0; j < col_size; j++) {\n      if (inside_array[j] == x) {\n        std::tuple<long,\
    \ long> tpl = std::make_tuple(i, j);\n        result.push_back(tpl);\n      }\n\
    \    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", " \
    \ // TODO: Implement Me\n  return {};", "\tstd::vector<std::tuple<long, long>>\
    \ ans;\n\tfor (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tans.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(ans.begin(), ans.end(),\n\t\t[](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n\t\tif (std::get<0>(a)\
    \ < std::get<0>(b)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (std::get<0>(a)\
    \ == std::get<0>(b)) {\n\t\t\treturn std::get<1>(a) > std::get<1>(b);\n\t\t}\n\
    \t\telse {\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn ans;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (long row = 0; row < lst.size(); row++) {\n        for\
    \ (long col = 0; col < lst[row].size(); col++) {\n            if (lst[row][col]\
    \ == x) {\n                result.push_back(std::make_tuple(row, col));\n    \
    \        }\n        }\n    }\n    std::sort(result.begin(), result.end(),\n  \
    \            [](std::tuple<long, long> &t1, std::tuple<long, long> &t2) {\n  \
    \                if (std::get<0>(t1) == std::get<0>(t2)) {\n                 \
    \     return std::get<1>(t1) > std::get<1>(t2);\n                  }\n       \
    \           return std::get<0>(t1) < std::get<0>(t2);\n              });\n   \
    \ return result;", "    std::vector<std::tuple<long, long>> ret;\n    for (long\
    \ i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++)\
    \ {\n            if (lst[i][j] == x) {\n                ret.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(ret.begin(), ret.end(),\
    \ [](const std::tuple<long, long>& lhs, const std::tuple<long, long>& rhs) {\n\
    \        if (std::get<0>(lhs) == std::get<0>(rhs)) {\n            return std::get<1>(lhs)\
    \ > std::get<1>(rhs);\n        }\n        return std::get<0>(lhs) < std::get<0>(rhs);\n\
    \    });\n    return ret;", "\tstd::vector<std::tuple<long, long>> result;\n\t\
    for (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n\t\tif (std::get<0>(a) < std::get<0>(b))\
    \ {\n\t\t\treturn true;\n\t\t}\n\t\telse if (std::get<0>(a) == std::get<0>(b))\
    \ {\n\t\t\treturn std::get<1>(a) > std::get<1>(b);\n\t\t}\n\t\telse {\n\t\t\t\
    return false;\n\t\t}\n\t});\n\treturn result;", "    std::vector<std::tuple<long,\
    \ long>> ans;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j\
    \ = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n        \
    \        ans.push_back(std::make_tuple(i, j));\n            }\n        }\n   \
    \ }\n    return ans;", "\tif (lst.empty()) return {};\n\tstd::vector<std::tuple<long,\
    \ long>> ret;\n\tfor (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0;\
    \ j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x) ret.push_back(std::make_tuple(i,\
    \ j));\n\t\t}\n\t}\n\tstd::sort(ret.begin(), ret.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n\t\tif (std::get<0>(a) < std::get<0>(b))\
    \ return true;\n\t\tif (std::get<0>(a) > std::get<0>(b)) return false;\n\t\treturn\
    \ std::get<1>(a) > std::get<1>(b);\n\t});\n\treturn ret;", "    // your code here\n\
    \    std::vector<std::tuple<long, long>> ans;\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        for(long j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j]\
    \ == x) {\n                ans.push_back(std::make_tuple(i, j));\n           \
    \ }\n        }\n    }\n    std::sort(ans.begin(), ans.end());\n    for(long i\
    \ = 0; i < ans.size(); i++) {\n        std::get<1>(ans[i]) = -std::get<1>(ans[i]);\n\
    \    }\n    std::sort(ans.begin(), ans.end());\n    for(long i = 0; i < ans.size();\
    \ i++) {\n        std::get<1>(ans[i]) = -std::get<1>(ans[i]);\n    }\n    return\
    \ ans;", "    std::vector<std::tuple<long, long>> res;\n    long long rlen = lst.size();\n\
    \    long long clen;\n    for (long long i = 0; i < rlen; i++) {\n        clen\
    \ = lst[i].size();\n        for (long long j = 0; j < clen; j++) {\n         \
    \   if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i, j));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n        return std::get<0>(t1) < std::get<0>(t2);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> t1,\
    \ std::tuple<long, long> t2) {\n        return std::get<1>(t1) > std::get<1>(t2);\n\
    \    });\n    return res;", "  std::vector<std::tuple<long, long>> res;\n  for\
    \ (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j < lst[i].size(); j++)\
    \ {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i, j));\n\
    \      }\n    }\n  }\n  std::sort(res.begin(), res.end(), [](auto t1, auto t2)\
    \ {\n    if (std::get<0>(t1) < std::get<0>(t2)) {\n      return true;\n    } else\
    \ if (std::get<0>(t1) == std::get<0>(t2)) {\n      return std::get<1>(t1) > std::get<1>(t2);\n\
    \    }\n    return false;\n  });\n  return res;", "    std::vector<std::tuple<long,\
    \ long>> row;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j\
    \ = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n        \
    \        row.push_back(std::make_tuple(i, j));\n            }\n        }\n   \
    \ }\n    sort(row.begin(), row.end());\n    for (int i = 0; i < row.size(); i++)\
    \ {\n        for (int j = i; j < row.size(); j++) {\n            if (std::get<0>(row[i])\
    \ == std::get<0>(row[j])) {\n                if (std::get<1>(row[i]) < std::get<1>(row[j]))\
    \ {\n                    std::swap(row[i], row[j]);\n                }\n     \
    \       }\n        }\n    }\n    return row;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x)\n        \
    \        result.push_back(std::make_tuple(i, j));\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::stable_sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \     return std::get<1>(a) > std::get<1>(b);\n    });\n    return result;", "\t\
    std::vector<std::tuple<long, long>> answer;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tfor (int j = 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] ==\
    \ x)\n\t\t\t\tanswer.push_back(std::make_tuple(i, j));\n\t\t}\n\t}\n\tstd::sort(answer.begin(),\
    \ answer.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n\t\t\
    return std::get<0>(a) < std::get<0>(b);\n\t});\n\tstd::sort(answer.begin(), answer.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n\t\treturn std::get<1>(a)\
    \ > std::get<1>(b);\n\t});\n\treturn answer;", "  std::vector<std::tuple<long,\
    \ long>> output;\n  std::vector<std::tuple<long, long>> temp;\n  std::vector<std::tuple<long,\
    \ long>>::iterator it;\n  for (long i = 0; i < lst.size(); i++) {\n    for (long\
    \ j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        temp.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  sort(temp.begin(), temp.end());\n  for (it = temp.begin();\
    \ it != temp.end(); it++) {\n    output.push_back(std::make_tuple(std::get<0>(*it),\
    \ std::get<1>(*it)));\n  }\n  return output;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0;\
    \ j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  // Sort tuples inside vector by first element (row)\n\
    \  std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  // Now sort\
    \ by second element (column)\n  std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n    return std::get<1>(a) > std::get<1>(b);\n\
    \  });\n  return result;", "\tstd::vector<std::tuple<long, long>> res;\n\tfor\
    \ (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tres.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\
    \t});\n\tstd::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) {\n\t\treturn std::get<0>(a) == std::get<0>(b)\
    \ ? std::get<1>(a) > std::get<1>(b) : true;\n\t});\n\treturn res;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (long row = 0; row < lst.size(); row++) {\n        for\
    \ (long col = 0; col < lst[row].size(); col++) {\n            if (lst[row][col]\
    \ == x) {\n                result.push_back(std::make_tuple(row, col));\n    \
    \        }\n        }\n    }\n    // for (auto t : result) {\n    //     std::cout\
    \ << \"(\" << std::get<0>(t) << \", \" << std::get<1>(t) << \") \";\n    // }\n\
    \    // std::cout << std::endl;\n    std::sort(result.begin(), result.end(), [](auto\
    \ const &t1, auto const &t2) {\n        if (std::get<0>(t1) == std::get<0>(t2))\
    \ {\n            return std::get<1>(t1) > std::get<1>(t2);\n        }\n      \
    \  return std::get<0>(t1) < std::get<0>(t2);\n    });\n    return result;", " \
    \   std::vector<std::tuple<long, long>> res;\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x)\n                res.push_back(std::make_tuple(i, j));\n        }\n  \
    \  }\n    std::sort(res.begin(), res.end(), [&](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [&](std::tuple<long, long> a, std::tuple<long, long> b) {\n     \
    \   return std::get<0>(a) == std::get<0>(b) ? std::get<1>(a) > std::get<1>(b)\
    \ : false;\n    });\n    return res;", "    // your code here\n    std::vector<std::tuple<long,\
    \ long>> result;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          result.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    auto comp = [](const std::tuple<long, long>& a, const std::tuple<long,\
    \ long>& b) {\n        if (std::get<0>(a) < std::get<0>(b)) {\n            return\
    \ true;\n        } else if (std::get<0>(a) == std::get<0>(b)) {\n            return\
    \ std::get<1>(a) > std::get<1>(b);\n        } else {\n            return false;\n\
    \        }\n    };\n    std::sort(result.begin(), result.end(), comp);\n    return\
    \ result;", "\tstd::vector<std::tuple<long, long>> result;\n\tfor (long i = 0;\
    \ i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size(); j++) {\n\t\t\
    \tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i, j));\n\t\t\
    \t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long>& t1, std::tuple<long, long>& t2) {\n\t\tif (std::get<0>(t1) < std::get<0>(t2))\
    \ return true;\n\t\tif (std::get<0>(t1) > std::get<0>(t2)) return false;\n\t\t\
    if (std::get<1>(t1) > std::get<1>(t2)) return true;\n\t\treturn false;\n\t});\n\
    \treturn result;", "  std::vector<std::tuple<long, long>> ret;\n  for (int i =\
    \ 0; i < lst.size(); i++) {\n    for (int j = 0; j < lst[i].size(); j++) {\n \
    \     if (lst[i][j] == x) {\n        ret.push_back(std::make_tuple(i, j));\n \
    \     }\n    }\n  }\n  std::sort(ret.begin(), ret.end(), [] (std::tuple<long,\
    \ long>& a, std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b))\
    \ {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a)\
    \ < std::get<0>(b);\n  });\n  return ret;", "  std::vector<std::tuple<long, long>>\
    \ result;\n  for (long row = 0; row < lst.size(); row++) {\n    for (long col\
    \ = 0; col < lst[row].size(); col++) {\n      if (lst[row][col] == x) {\n    \
    \    result.push_back(std::make_tuple(row, col));\n      }\n    }\n  }\n  // Sort\
    \ by rows ascending\n  std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> lhs, std::tuple<long, long> rhs) {\n    if (std::get<0>(lhs) < std::get<0>(rhs))\
    \ {\n      return true;\n    } else if (std::get<0>(lhs) == std::get<0>(rhs))\
    \ {\n      return std::get<1>(lhs) > std::get<1>(rhs);\n    } else {\n      return\
    \ false;\n    }\n  });\n  return result;", "    std::vector<std::tuple<long, long>>\
    \ result;\n    int count = 0;\n    for (int i = 0; i < lst.size(); i++) {\n  \
    \      for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ x) {\n                result.push_back(std::make_tuple(i, j));\n           \
    \ }\n        }\n    }\n    return result;", "\tstd::vector<std::tuple<long, long>>\
    \ result;\n\tlong numRows = lst.size();\n\tfor (long i = 0; i < numRows; i++)\
    \ {\n\t\tlong numColumns = lst[i].size();\n\t\tfor (long j = 0; j < numColumns;\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tstd::tuple<long, long> temp(i,\
    \ j);\n\t\t\t\tresult.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\tsort(result.begin(),\
    \ result.end());\n\tfor (long i = 0; i < result.size(); i++) {\n\t\tstd::cout\
    \ << std::get<0>(result[i]) << \" \" << std::get<1>(result[i]) << std::endl;\n\
    \t}\n\treturn result;", "    std::vector<std::tuple<long, long>> v(lst.size()*10);\n\
    \    auto k = 0;\n    for(auto i = 0; i < lst.size(); i++) {\n        for(auto\
    \ j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j] == x) {\n       \
    \         v[k++] = std::make_tuple(i, j);\n            }\n        }\n    }\n \
    \   v.resize(k);\n    std::sort(v.begin(), v.end(), [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    for(auto i = 0; i < v.size(); i++) {\n        for(auto j = i+1;\
    \ j < v.size(); j++) {\n            if(std::get<0>(v[i]) == std::get<0>(v[j]))\
    \ {\n                if(std::get<1>(v[i]) < std::get<1>(v[j])) {\n           \
    \         std::swap(v[i], v[j]);\n                }\n            }\n        }\n\
    \    }\n    return v;", "    int i, j, n = lst.size();\n    std::vector<std::tuple<long,\
    \ long>> v;\n    for(i = 0; i < n; i++) {\n        for(j = 0; j < lst[i].size();\
    \ j++) {\n            if(lst[i][j] == x) {\n                v.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return\
    \ v;", '    //put your code here', "  std::vector<std::tuple<long, long>> myVec;\n\
    \  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        myVec.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(myVec.begin(), myVec.end());\n  std::reverse(myVec.begin(),\
    \ myVec.end());\n  return myVec;", "\t// this is a classic two pass algorithm.\n\
    \t// first you index row,col of all x's in the 2d matrix.\n\t// then you sort\
    \ the index by row, and then by col\n\t// this is O(m*n)\n\t// you could do it\
    \ with a third pass and binary search on row,\n\t// but it is better to do the\
    \ two pass because it is O(1) space.\n\tstd::vector<std::tuple<long, long>> rowcol;\n\
    \tfor (size_t i = 0; i < lst.size(); i++) {\n\t\tfor (size_t j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x)\n\t\t\t\trowcol.push_back(std::make_tuple(i,\
    \ j));\n\t\t}\n\t}\n\tstd::sort(rowcol.begin(), rowcol.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n\t\tif (std::get<0>(a) == std::get<0>(b))\n\
    \t\t\treturn std::get<1>(a) > std::get<1>(b);\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\
    \t});\n\treturn rowcol;", "        std::vector<std::tuple<long, long>> res;\n\
    \        for (long i = 0; i < lst.size(); i++) {\n                for (long j\
    \ = 0; j < lst[i].size(); j++) {\n                        if (lst[i][j] == x)\
    \ {\n                                res.push_back(std::make_tuple(i, j));\n \
    \                       }\n                }\n        }\n        std::sort(res.begin(),\
    \ res.end(), [&](std::tuple<long, long> a, std::tuple<long, long> b) {\n     \
    \           if (std::get<0>(a) == std::get<0>(b)) {\n                        return\
    \ std::get<1>(a) > std::get<1>(b);\n                }\n                return\
    \ std::get<0>(a) < std::get<0>(b);\n        });\n        return res;", "    std::vector<std::tuple<long,\
    \ long>> ans;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          ans.push_back(std::make_tuple(i, j));\n            }\n        }\n \
    \   }\n    std::sort(ans.begin(), ans.end(),\n    [](std::tuple<long, long> a,\
    \ std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(ans.begin(), ans.end(),\n    [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return ans;", "    long n=lst.size();\n    if(n==0)\n        return\
    \ {};\n    std::vector<std::tuple<long, long>> result;\n    for(long i=0;i<n;i++)\n\
    \    {\n        auto it=std::find(lst[i].begin(),lst[i].end(),x);\n        if(it!=lst[i].end())\n\
    \        {\n            result.push_back(std::make_tuple(i,std::distance(lst[i].begin(),it)));\n\
    \        }\n    }\n    if(result.size()==0)\n        return {};\n    sort(result.begin(),result.end());\n\
    \    auto it=result.begin();\n    while(it!=result.end())\n    {\n        auto\
    \ tmp=it;\n        long count=0;\n        while(tmp!=result.end() && std::get<0>(*tmp)==std::get<0>(*it))\n\
    \        {\n            count++;\n            tmp++;\n        }\n        sort(it,tmp,[](std::tuple<long,\
    \ long> a,std::tuple<long, long> b){return std::get<1>(a)>std::get<1>(b);});\n\
    \        it=tmp;\n    }\n    return result;", "  std::vector<std::tuple<long,\
    \ long>> out;\n  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j\
    \ < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        out.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(out.begin(), out.end(), [&](std::tuple<long,\
    \ long> &a, std::tuple<long, long> &b) {\n    long x = std::get<0>(a);\n    long\
    \ y = std::get<0>(b);\n    if (x == y) {\n      x = std::get<1>(a);\n      y =\
    \ std::get<1>(b);\n      return x > y;\n    }\n    return x < y;\n  });\n  return\
    \ out;", "  std::vector<std::tuple<long, long>> result;\n  for (int row = 0; row\
    \ < lst.size(); row++) {\n    for (int col = 0; col < lst[row].size(); col++)\
    \ {\n      if (lst[row][col] == x) {\n        result.push_back(std::make_tuple(row,\
    \ col));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n    if (std::get<0>(t1) < std::get<0>(t2))\
    \ {\n      return true;\n    } else if (std::get<0>(t1) == std::get<0>(t2)) {\n\
    \      return std::get<1>(t1) > std::get<1>(t2);\n    } else {\n      return false;\n\
    \    }\n  });\n  return result;", "    std::vector<std::tuple<long, long>> result;\n\
    \    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\
    \ [](std::tuple<long, long> left, std::tuple<long, long> right) {\n        return\
    \ std::get<0>(left) < std::get<0>(right);\n    });\n    std::sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> left, std::tuple<long, long> right)\
    \ {\n        return std::get<1>(left) > std::get<1>(right);\n    });\n    return\
    \ result;", "    std::vector<std::tuple<long, long>> result;\n    long rows =\
    \ lst.size();\n    for (long i = 0; i < rows; i++) {\n        long columns = lst[i].size();\n\
    \        for (long j = 0; j < columns; j++) {\n            if (lst[i][j] == x)\
    \ {\n                result.push_back(std::make_tuple(i, j));\n            }\n\
    \        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> lhs, std::tuple<long, long> rhs) {\n        return std::get<0>(lhs) <\
    \ std::get<0>(rhs);\n    });\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> lhs, std::tuple<long, long> rhs) {\n        return std::get<1>(lhs) >\
    \ std::get<1>(rhs);\n    });\n    return result;", "\tstd::vector<std::tuple<long,\
    \ long>> result;\n\tstd::vector<long> xCoord;\n\tstd::vector<long> yCoord;\n\t\
    for (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\txCoord.push_back(i);\n\t\t\t\t\
    yCoord.push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < xCoord.size();\
    \ i++) {\n\t\tresult.push_back(std::make_tuple(xCoord[i], yCoord[i]));\n\t}\n\t\
    std::sort(result.begin(), result.end());\n\tstd::stable_sort(result.begin(), result.end(),\
    \ [](std::tuple<long, long>& a, std::tuple<long, long>& b) {\n\t\treturn std::get<0>(a)\
    \ < std::get<0>(b);\n\t});\n\treturn result;", "  std::vector<std::tuple<long,\
    \ long>> output;\n  if (lst.size() == 0) {\n    return output;\n  }\n  long row_size\
    \ = lst.size();\n  long col_size = lst[0].size();\n  std::tuple<long, long> temp;\n\
    \  for (long i = 0; i < row_size; i++) {\n    for (long j = 0; j < col_size; j++)\
    \ {\n      if (lst[i][j] == x) {\n        std::get<0>(temp) = i;\n        std::get<1>(temp)\
    \ = j;\n        output.push_back(temp);\n      }\n    }\n  }\n  std::sort(output.begin(),\
    \ output.end());\n  for (auto i = output.begin(); i != output.end(); i++) {\n\
    \    std::tuple<long, long> t = *i;\n    std::tuple<long, long> temp;\n    temp\
    \ = std::make_tuple(std::get<0>(t), std::get<1>(t));\n    *i = temp;\n  }\n  std::sort(output.begin(),\
    \ output.end(), sortBySecDesc);\n  return output;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x)\n        \
    \        result.push_back(std::make_tuple(i, j));\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        if (std::get<0>(a) == std::get<0>(b)) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        }\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    return result;", "    // First, let's create a vector of vectors,\
    \ where every inner vector\n    // contains the indexes in which x is found in\
    \ the outer vector.\n    std::vector<std::vector<long>> x_idxs;\n    for (long\
    \ i = 0; i < lst.size(); i++) {\n        std::vector<long> sub_x_idxs;\n     \
    \   for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x)\
    \ {\n                sub_x_idxs.push_back(j);\n            }\n        }\n    \
    \    x_idxs.push_back(sub_x_idxs);\n    }\n    // Now, let's create a vector of\
    \ tuples, that contains all the\n    // indexes where x is found in the outer\
    \ vector.\n    std::vector<std::tuple<long, long>> x_tuples;\n    for (long i\
    \ = 0; i < x_idxs.size(); i++) {\n        if (x_idxs[i].size() > 0) {\n      \
    \      for (long j = 0; j < x_idxs[i].size(); j++) {\n                x_tuples.push_back(std::make_tuple(i,\
    \ x_idxs[i][j]));\n            }\n        }\n    }\n    // Finally, let's sort\
    \ the tuples first by their first index (which\n    // represents the row index),\
    \ and then by their second index (which\n    // represents the column index).\n\
    \    std::sort(x_tuples.begin(), x_tuples.end(),\n        [](const std::tuple<long,\
    \ long> &left, const std::tuple<long, long> &right) {\n            return (std::get<0>(left)\
    \ < std::get<0>(right)\n                || (std::get<0>(left) == std::get<0>(right)\n\
    \                && std::get<1>(left) > std::get<1>(right)));\n        });\n \
    \   return x_tuples;", "    int i, j, k;\n    std::vector<std::tuple<long, long>>\
    \ vect;\n    std::tuple<long, long> tup;\n    for(i = 0; i < lst.size(); i++)\
    \ {\n        for(j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j] ==\
    \ x) {\n                vect.push_back(std::make_tuple(i, j));\n            }\n\
    \        }\n    }\n    std::sort(vect.begin(), vect.end());\n    for(i = 0; i\
    \ < vect.size(); i++) {\n        for(j = i+1; j < vect.size(); j++) {\n      \
    \      if(std::get<0>(vect[i]) == std::get<0>(vect[j])) {\n                tup\
    \ = vect[i];\n                vect[i] = vect[j];\n                vect[j] = tup;\n\
    \            }\n        }\n    }\n    return vect;", "  std::vector<std::tuple<long,\
    \ long>> ans;\n  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j\
    \ < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        ans.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(ans.begin(), ans.end(),\n           \
    \ [](const std::tuple<long, long>& t1, const std::tuple<long, long>& t2) {\n \
    \             if (std::get<0>(t1) < std::get<0>(t2)) {\n                return\
    \ true;\n              } else if (std::get<0>(t1) == std::get<0>(t2)) {\n    \
    \            return std::get<1>(t1) > std::get<1>(t2);\n              } else {\n\
    \                return false;\n              }\n            });\n  return ans;",
  "\tstd::vector<std::tuple<long, long>> result;\n\tfor (size_t i = 0; i < lst.size();\
    \ i++) {\n\t\tstd::vector<long> row = lst[i];\n\t\tfor (size_t j = 0; j < row.size();\
    \ j++) {\n\t\t\tif (row[j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long>& a, std::tuple<long, long>& b) {\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\
    \t});\n\tstd::stable_sort(result.begin(), result.end(), [](std::tuple<long, long>&\
    \ a, std::tuple<long, long>& b) {\n\t\treturn std::get<0>(a) == std::get<0>(b)\
    \ && std::get<1>(a) > std::get<1>(b);\n\t});\n\treturn result;", "    // Your\
    \ code here:\n    std::vector<std::tuple<long, long>> ans;\n    for (int i = 0;\
    \ i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n\
    \            if (lst[i][j] == x) {\n                ans.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(ans.begin(), ans.end());\n\
    \    for (int i = 0; i < ans.size(); i++) {\n        std::get<0>(ans[i]) = i;\n\
    \    }\n    return ans;", "\t", "\tstd::vector<std::tuple<long, long>> ret;\n\t\
    for (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tret.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(ret.begin(), ret.end(),\n\t\t[](const\
    \ std::tuple<long, long> & a, const std::tuple<long, long> & b) {\n\t\t\treturn\
    \ (std::get<0>(a) < std::get<0>(b)) ||\n\t\t\t\t((std::get<0>(a) == std::get<0>(b))\
    \ && (std::get<1>(a) > std::get<1>(b)));\n\t\t});\n\treturn ret;", "    std::vector<std::tuple<long,\
    \ long>> answer;\n    std::vector<std::vector<long>>::iterator it = lst.begin();\n\
    \    while (it != lst.end()) {\n        std::vector<long> lst_element = *it;\n\
    \        std::vector<long>::iterator itr = lst_element.begin();\n        long\
    \ i = 0;\n        while (itr != lst_element.end()) {\n            if (*itr ==\
    \ x) {\n                long distance = std::distance(lst.begin(), it);\n    \
    \            answer.push_back(std::make_tuple(distance, i));\n            }\n\
    \            i++;\n            itr++;\n        }\n        it++;\n    }\n    return\
    \ answer;", "    // your code here\n    std::vector<std::tuple<long, long>> newlst;\n\
    \    for(int i = 0; i < lst.size(); i++){\n        for(int j = 0; j < lst[i].size();\
    \ j++){\n            if(lst[i][j] == x){\n                newlst.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(newlst.begin(), newlst.end());\n\
    \    std::sort(newlst.begin(), newlst.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b){\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ newlst;", "    std::vector<std::tuple<long, long>> result;\n    for (int i =\
    \ 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n\
    \            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\
    \ [](std::tuple<long, long> t1, std::tuple<long, long> t2) {\n        if (std::get<0>(t1)\
    \ < std::get<0>(t2)) {\n            return true;\n        } else if (std::get<0>(t1)\
    \ == std::get<0>(t2)) {\n            return std::get<1>(t1) > std::get<1>(t2);\n\
    \        } else {\n            return false;\n        }\n    });\n    return result;",
  "    std::vector<std::tuple<long, long>> res;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                res.push_back(std::make_tuple(i, j));\n           \
    \ }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> result;\n    std::tuple<long,\
    \ long> temp(0, 0);\n    bool test = false;\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                test = true;\n                std::get<0>(temp) = i;\n\
    \                std::get<1>(temp) = j;\n                result.push_back(temp);\n\
    \            }\n        }\n    }\n    if (test == false) {\n        return result;\n\
    \    }\n    else {\n        std::sort(result.begin(), result.end());\n       \
    \ return result;\n    }", "    std::vector<std::tuple<long, long>> result;\n \
    \   for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    return result;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          result.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    std::sort(result.begin(), result.end(), [](auto& lhs, auto& rhs) {\n\
    \            if (std::get<0>(lhs) == std::get<0>(rhs)) {\n                return\
    \ std::get<1>(lhs) > std::get<1>(rhs);\n            }\n            return std::get<0>(lhs)\
    \ < std::get<0>(rhs);\n            });\n    return result;", "  // TODO: replace\
    \ with your solution\n  std::vector<std::tuple<long, long>> result;\n  if (lst.size()\
    \ > 0) {\n    for (long index = 0; index < lst.size(); index++) {\n      std::vector<long>\
    \ v = lst[index];\n      if (v.size() > 0) {\n        for (long second_index =\
    \ 0; second_index < v.size(); second_index++) {\n          if (v[second_index]\
    \ == x) {\n            result.push_back(std::make_tuple(index, second_index));\n\
    \          }\n        }\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(),\
    \ [](std::tuple<long, long> & a, std::tuple<long, long> & b) {\n    if (std::get<0>(a)\
    \ < std::get<0>(b)) {\n      return true;\n    } else if (std::get<0>(a) == std::get<0>(b))\
    \ {\n      return std::get<1>(a) > std::get<1>(b);\n    } else {\n      return\
    \ false;\n    }\n  });\n  return result;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    std::vector<std::tuple<long, long>> res1;\n    for (long i = 0; i\
    \ < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n \
    \           if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end());\n\
    \    res1.push_back(res[0]);\n    for (long i = 1; i < res.size(); i++) {\n  \
    \      if (std::get<0>(res[i]) != std::get<0>(res[i - 1])) {\n            res1.push_back(res[i]);\n\
    \        }\n    }\n    std::sort(res1.begin(), res1.end(), [&lst](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        if (std::get<0>(a) == std::get<0>(b))\
    \ {\n            return std::get<1>(a) > std::get<1>(b);\n        }\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    return res1;", "  std::vector<std::tuple<long,\
    \ long>> ans;\n  for (size_t i = 0; i < lst.size(); i++) {\n    for (size_t j\
    \ = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        ans.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  // first sort by row number and then by column\n\
    \  std::sort(ans.begin(), ans.end(), [](std::tuple<long, long>a, std::tuple<long,\
    \ long>b) -> bool {\n    if (std::get<0>(a) < std::get<0>(b)) {\n      return\
    \ true;\n    } else if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a)\
    \ > std::get<1>(b);\n    } else {\n      return false;\n    }\n  });\n  return\
    \ ans;", "  std::vector<std::tuple<long, long>> res;\n  long row_len = lst.size();\n\
    \  long col_len = 0;\n  if (row_len > 0) {\n    col_len = lst[0].size();\n  }\n\
    \  for (long i = 0; i < row_len; i++) {\n    for (long j = 0; j < col_len; j++)\
    \ {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i, j));\n\
    \      }\n    }\n  }\n  // Sort initially by rows in ascending order.\n  // Also,\
    \ sort coordinates of the row by columns in descending order.\n  std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> &a, std::tuple<long, long> &b) {\n    if\
    \ (std::get<0>(a) != std::get<0>(b)) {\n      return std::get<0>(a) < std::get<0>(b);\n\
    \    } else {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n  });\n \
    \ return res;", "  std::vector<std::tuple<long, long>> res;\n  for (long i = 0;\
    \ i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n   \
    \   if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i, j));\n   \
    \   }\n    }\n  }\n  std::sort(res.begin(), res.end(), [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n\
    \      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a)\
    \ < std::get<0>(b);\n  });\n  return res;", "    std::vector<std::tuple<long,\
    \ long>> ret;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          ret.push_back(std::make_tuple(i, j));\n            }\n        }\n \
    \   }\n    return ret;", "  std::vector<std::tuple<long, long>> result;\n  //\
    \ your code here\n  if(lst.size() == 0) return result;\n  int row = lst.size();\n\
    \  int j = 0;\n  for(int i = 0; i < row; i++){\n    if(lst[i].size() == 0) continue;\n\
    \    for(j = 0; j < lst[i].size(); j++){\n      if(lst[i][j] == x){\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b){\n    if(std::get<0>(a)\
    \ < std::get<0>(b)) return true;\n    else if(std::get<0>(a) == std::get<0>(b)){\n\
    \      if(std::get<1>(a) > std::get<1>(b)) return true;\n      else return false;\n\
    \    }\n    else return false;\n  });\n  return result;", "    vector<pair<long,\
    \ long>>v;\n    vector<tuple<long, long>>ans;\n    long i, j;\n    for(i = 0;\
    \ i < lst.size(); i++) {\n        for(j = 0; j < lst[i].size(); j++) {\n     \
    \       if(lst[i][j] == x)\n                v.push_back(make_pair(i, j));\n  \
    \      }\n    }\n    sort(v.begin(), v.end());\n    for(i = 0; i < v.size(); i++)\
    \ {\n        ans.push_back(make_tuple(v[i].first, v[i].second));\n    }\n    for(i\
    \ = 0; i < ans.size(); i++) {\n        cout << get<0>(ans[i]) << \" \" << get<1>(ans[i])\
    \ << endl;\n    }\n    return ans;", "    std::vector<std::tuple<long, long>>\
    \ result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j =\
    \ 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x)\n            \
    \    result.push_back(std::make_tuple(i, j));\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) {\n        if (std::get<0>(a) == std::get<0>(b)) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        }\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    return result;", "  std::vector<std::tuple<long, long>> res;\n \
    \ for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(res.begin(), res.end(), [](auto const\
    \ &a, auto const &b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return\
    \ std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n\
    \  });\n  return res;", "    std::vector<std::tuple<long, long>> result;\n   \
    \ std::vector<long>::iterator it;\n    for (int i = 0; i < lst.size(); i++) {\n\
    \        it = std::find(lst[i].begin(), lst[i].end(), x);\n        while (it !=\
    \ lst[i].end()) {\n            result.push_back(std::make_tuple(i, std::distance(lst[i].begin(),\
    \ it)));\n            it = std::find(it + 1, lst[i].end(), x);\n        }\n  \
    \  }\n    std::sort(result.begin(), result.end(),\n            [](std::tuple<long,\
    \ long>&a, std::tuple<long, long>&b) {\n                return std::get<0>(a)\
    \ < std::get<0>(b);\n            });\n    for (int i = 0; i < result.size(); i++)\
    \ {\n        int j = i + 1;\n        for (; j < result.size(); j++) {\n      \
    \      if (std::get<0>(result[i]) != std::get<0>(result[j])) {\n             \
    \   break;\n            }\n        }\n        std::sort(result.begin() + i, result.begin()\
    \ + j,\n                [](std::tuple<long, long>&a, std::tuple<long, long>&b)\
    \ {\n                    return std::get<1>(a) > std::get<1>(b);\n           \
    \     });\n        i = j - 1;\n    }\n    return result;", "\tstd::vector<std::tuple<long,\
    \ long>> result;\n\tfor (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j =\
    \ 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x)\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n\t\tif (std::get<0>(a) < std::get<0>(b))\n\
    \t\t\treturn true;\n\t\telse if (std::get<0>(a) == std::get<0>(b))\n\t\t\treturn\
    \ std::get<1>(a) > std::get<1>(b);\n\t\telse\n\t\t\treturn false;\n\t});\n\treturn\
    \ result;", "\tstd::vector<std::tuple<long, long>> v;\n\tfor (int i = 0; i < lst.size();\
    \ i++) {\n\t\tfor (int j = 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] ==\
    \ x) {\n\t\t\t\tv.push_back(std::make_tuple(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(v.begin(),\
    \ v.end());\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = i; j < v.size();\
    \ j++) {\n\t\t\tif (std::get<0>(v[i]) == std::get<0>(v[j])) {\n\t\t\t\tif (std::get<1>(v[i])\
    \ < std::get<1>(v[j])) {\n\t\t\t\t\tstd::swap(v[i], v[j]);\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn v;", "    std::vector<std::tuple<long, long>> result;\n\
    \    if(lst.size() == 0) return result;\n    for(size_t i = 0; i < lst.size();\
    \ i++) {\n        for(size_t j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j]\
    \ == x) {\n                result.push_back(std::make_tuple(i, j));\n        \
    \    }\n        }\n    }\n    // sort rows in ascending order\n    // then sort\
    \ columns in descending order for each row\n    std::sort(result.begin(), result.end(),\n\
    \              [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n                  if(std::get<0>(a) < std::get<0>(b)) return true;\n\
    \                  if(std::get<0>(a) > std::get<0>(b)) return false;\n       \
    \           return std::get<1>(a) > std::get<1>(b);\n              });\n    return\
    \ result;", "    std::vector<std::tuple<long, long>> result;\n    for (size_t\
    \ i = 0; i < lst.size(); i++) {\n        for (size_t j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x)\n                result.push_back(std::make_tuple(i,\
    \ j));\n        }\n    }\n    std::sort(result.begin(), result.end(),\n      \
    \        [](std::tuple<long, long> &a, std::tuple<long, long> &b) -> bool {\n\
    \                  return (std::get<0>(a) < std::get<0>(b));\n              });\n\
    \    std::sort(result.begin(), result.end(),\n              [](std::tuple<long,\
    \ long> &a, std::tuple<long, long> &b) -> bool {\n                  return (std::get<0>(a)\
    \ == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n              });\n\
    \    return result;", "    std::vector<std::tuple<long, long>> res;\n    std::vector<std::vector<long>>::iterator\
    \ it;\n    std::vector<long>::iterator itt;\n    long i = 0, j = 0;\n    // Iterate\
    \ through the list\n    for (it = lst.begin(); it != lst.end(); it++) {\n    \
    \    for (itt = it->begin(); itt != it->end(); itt++) {\n            if (*itt\
    \ == x) {\n                res.push_back(std::make_tuple(i, j));\n           \
    \ }\n            j++;\n        }\n        j = 0;\n        i++;\n    }\n    //\
    \ Sort the result on the basis of first element of tuple\n    std::sort(res.begin(),\
    \ res.end());\n    // Sort the result on the basis of second element of tuple\n\
    \    std::sort(res.begin(), res.end(),\n              [](std::tuple<long, long>\
    \ const &t1, std::tuple<long, long> const &t2) {\n                  return std::get<1>(t1)\
    \ > std::get<1>(t2);\n              });\n    return res;", "    // your code here\n\
    \    long i,j,size=lst.size();\n    std::vector<std::tuple<long, long>> get_row;\n\
    \    for(i=0;i<size;i++)\n    {\n      long sub_size=lst[i].size();\n      for(j=0;j<sub_size;j++)\n\
    \      {\n        if(lst[i][j]==x)\n        {\n          get_row.push_back(std::make_tuple(i,j));\n\
    \        }\n      }\n    }\n    std::sort(get_row.begin(),get_row.end());\n  \
    \  std::reverse(get_row.begin(),get_row.end());\n    return get_row;", "\tstd::vector<std::tuple<long,\
    \ long>> result;\n\tif(lst.size() == 0) return result;\n\tfor(long i = 0; i <\
    \ lst.size(); i++) {\n\t\tstd::vector<long> tmp_row = lst[i];\n\t\tfor(long j\
    \ = 0; j < tmp_row.size(); j++) {\n\t\t\tif(tmp_row[j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), \n\t\t\
    [](const std::tuple<long, long> &lhs, const std::tuple<long, long> &rhs) {\n\t\
    \t\treturn std::get<0>(lhs) < std::get<0>(rhs);\n\t\t});\n\tstd::sort(result.begin(),\
    \ result.end(), \n\t\t[](const std::tuple<long, long> &lhs, const std::tuple<long,\
    \ long> &rhs) {\n\t\t\treturn std::get<1>(lhs) > std::get<1>(rhs);\n\t\t});\n\t\
    return result;", "  std::vector<std::tuple<long, long>> res;\n  for (long i =\
    \ 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n\
    \      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i, j));\n\
    \      }\n    }\n  }\n  std::sort(res.begin(), res.end(), [](auto a, auto b) {\n\
    \    return std::get<0>(a) < std::get<0>(b);\n  });\n  for (long i = 0; i < res.size();\
    \ i++) {\n    auto row = std::get<0>(res[i]);\n    for (long j = i + 1; j < res.size();\
    \ j++) {\n      if (std::get<0>(res[j]) == row) {\n        if (std::get<1>(res[i])\
    \ < std::get<1>(res[j])) {\n          std::swap(res[i], res[j]);\n        }\n\
    \      }\n    }\n  }\n  return res;", "  // edge cases\n  if (lst.size() == 0)\
    \ return {};\n  int row_index = 0;\n  std::vector<std::tuple<long, long>> output;\n\
    \  for (auto list: lst) {\n    int col_index = 0;\n    for (auto i: list) {\n\
    \      if (i == x) {\n        output.push_back(std::make_tuple(row_index, col_index));\n\
    \      }\n      col_index++;\n    }\n    row_index++;\n  }\n  // sort the list\
    \ ascendingly based on column index and then row index\n  std::sort(output.begin(),\
    \ output.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \ if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n\
    \    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  return output;",
  "  std::vector<std::tuple<long, long>> res;\n  for (long i = 0; i < lst.size();\
    \ i++) {\n    auto& row = lst[i];\n    long j = 0;\n    while (j < row.size())\
    \ {\n      if (row[j] == x) {\n        res.push_back(std::make_tuple(i, j));\n\
    \      }\n      j++;\n    }\n  }\n  std::sort(res.begin(), res.end(), [](auto\
    \ a, auto b) {\n    auto [a_row, a_col] = a;\n    auto [b_row, b_col] = b;\n \
    \   if (a_row != b_row) {\n      return a_row < b_row;\n    }\n    return a_col\
    \ > b_col;\n  });\n  return res;", "  std::vector<std::tuple<long, long>> coordinates;\n\
    \  // std::vector<std::vector<long>> lst = v;\n  std::vector<long>::iterator it;\n\
    \  for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        coordinates.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  sort(coordinates.begin(), coordinates.end());\n\
    \  return coordinates;", "    std::vector<std::tuple<long, long>> v;\n    std::vector<std::tuple<long,\
    \ long>> tmp;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j\
    \ = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n        \
    \        tmp.push_back(std::make_tuple(i, j));\n            }\n        }\n   \
    \ }\n    std::sort(tmp.begin(), tmp.end());\n    for (int i = 0; i < tmp.size();\
    \ i++) {\n        for (int j = 0; j < i; j++) {\n            if (std::get<0>(tmp[i])\
    \ == std::get<0>(tmp[j])) {\n                v.push_back(tmp[i]);\n          \
    \      tmp.erase(tmp.begin() + i);\n                i--;\n                break;\n\
    \            }\n        }\n    }\n    for (int i = 0; i < tmp.size(); i++) {\n\
    \        for (int j = 0; j < i; j++) {\n            if (std::get<0>(tmp[i]) ==\
    \ std::get<0>(tmp[j])) {\n                std::tuple<long, long> temp = tmp[i];\n\
    \                tmp[i] = tmp[j];\n                tmp[j] = temp;\n          \
    \  }\n        }\n    }\n    v.insert(v.end(), tmp.begin(), tmp.end());\n    return\
    \ v;", "  std::vector<std::tuple<long, long>> res;\n  for (int i = 0; i < lst.size();\
    \ i++) {\n    for (int j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] ==\
    \ x) {\n        res.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n \
    \ if (res.size() == 0) {\n    return res;\n  }\n  // now sort by row\n  for (int\
    \ i = 0; i < res.size(); i++) {\n    for (int j = i + 1; j < res.size(); j++)\
    \ {\n      if (std::get<0>(res[i]) > std::get<0>(res[j])) {\n        auto temp\
    \ = res[i];\n        res[i] = res[j];\n        res[j] = temp;\n      }\n    }\n\
    \  }\n  // now sort by column\n  for (int i = 0; i < res.size(); i++) {\n    for\
    \ (int j = i + 1; j < res.size(); j++) {\n      if (std::get<0>(res[i]) == std::get<0>(res[j]))\
    \ {\n        if (std::get<1>(res[i]) < std::get<1>(res[j])) {\n          auto\
    \ temp = res[i];\n          res[i] = res[j];\n          res[j] = temp;\n     \
    \   }\n      }\n    }\n  }\n  return res;", "  std::vector<std::tuple<long, long>>\
    \ res;\n  if(lst.size()==0)\n    return res;\n  for(int i=0;i<lst.size();i++)\n\
    \  {\n    for(int j=0;j<lst[i].size();j++)\n    {\n      if(lst[i][j]==x)\n  \
    \    {\n        res.push_back(std::make_tuple(i,j));\n      }\n    }\n  }\n  sort(res.begin(),res.end());\n\
    \  for(int i=0;i<res.size();i++)\n  {\n    for(int j=i+1;j<res.size();j++)\n \
    \   {\n      if(std::get<0>(res[i])==std::get<0>(res[j]))\n      {\n        if(std::get<1>(res[i])<std::get<1>(res[j]))\n\
    \        {\n          std::tuple<long, long> temp=res[i];\n          res[i]=res[j];\n\
    \          res[j]=temp;\n        }\n      }\n    }\n  }\n  return res;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  if (lst.empty()) {\n    return result;\n  }\n  for (unsigned\
    \ int i = 0; i < lst.size(); i++) {\n    for (unsigned int j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long>& a, std::tuple<long, long>& b) {\n    if (std::get<0>(a) != std::get<0>(b))\
    \ {\n      return std::get<0>(a) < std::get<0>(b);\n    }\n    return std::get<1>(a)\
    \ > std::get<1>(b);\n  });\n  return result;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          res.push_back(std::make_tuple(i, j));\n            }\n        }\n \
    \   }\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    for\
    \ (long i = 0; i < res.size(); i++) {\n        for (long j = i + 1; j < res.size();\
    \ j++) {\n            if (std::get<0>(res[i]) == std::get<0>(res[j])) {\n    \
    \            std::swap(res[i + 1], res[j]);\n                i++;\n          \
    \  }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j =\
    \ 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n          \
    \      result.push_back(std::make_tuple(i, j));\n            }\n        }\n  \
    \  }\n    std::sort(result.begin(), result.end(), [](std::tuple<long, long> x,\
    \ std::tuple<long, long> y) {\n        if (std::get<0>(x) < std::get<0>(y)) {\n\
    \            return true;\n        } else if (std::get<0>(x) == std::get<0>(y))\
    \ {\n            return std::get<1>(x) > std::get<1>(y);\n        } else {\n \
    \           return false;\n        }\n    });\n    return result;", "\tstd::vector<std::tuple<long,\
    \ long>> list;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = 0;\
    \ j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tlist.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(list.begin(), list.end(), [](std::tuple<long,\
    \ long> first, std::tuple<long, long> second) -> bool {\n\t\tif (std::get<0>(first)\
    \ != std::get<0>(second)) {\n\t\t\treturn std::get<0>(first) < std::get<0>(second);\n\
    \t\t}\n\t\telse {\n\t\t\treturn std::get<1>(first) > std::get<1>(second);\n\t\t\
    }\n\t});\n\treturn list;", "\tstd::vector<std::tuple<long, long>> res;\n\tfor\
    \ (size_t i = 0; i < lst.size(); i++) {\n\t\tlong row = lst[i].size();\n\t\tfor\
    \ (size_t j = 0; j < row; j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tres.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n\t\tif (std::get<0>(a) == std::get<0>(b))\
    \ {\n\t\t\treturn std::get<1>(a) > std::get<1>(b);\n\t\t}\n\t\treturn std::get<0>(a)\
    \ < std::get<0>(b);\n\t});\n\treturn res;", "  std::vector<std::tuple<long, long>>\
    \ result;\n  for (size_t i = 0; i < lst.size(); i++) {\n    for (size_t j = 0;\
    \ j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(),\n     \
    \       [](std::tuple<long, long> a, std::tuple<long, long> b) {\n           \
    \   if (std::get<0>(a) == std::get<0>(b)) {\n                return std::get<1>(a)\
    \ > std::get<1>(b);\n              }\n              return std::get<0>(a) < std::get<0>(b);\n\
    \            });\n  return result;", "  std::vector<std::tuple<long, long>> res;\n\
    \  for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(res.begin(), res.end(), [&](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n    if (std::get<0>(t1) != std::get<0>(t2))\
    \ {\n      return std::get<0>(t1) < std::get<0>(t2);\n    } else {\n      return\
    \ std::get<1>(t1) > std::get<1>(t2);\n    }\n  });\n  return res;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  std::vector<long> newResult;\n  std::vector<long> element;\n\
    \  if (lst.size() > 0) {\n    for (int i = 0; i < lst.size(); i++) {\n      element\
    \ = lst[i];\n      std::vector<long>::iterator it;\n      it = std::find(element.begin(),\
    \ element.end(), x);\n      if (it != element.end()) {\n        newResult.push_back(i);\n\
    \        newResult.push_back(std::distance(element.begin(), it));\n      }\n \
    \   }\n    // sort(newResult.begin(), newResult.end());\n    for (int i = 0; i\
    \ < newResult.size(); i += 2) {\n      std::tuple<long, long> a = std::make_tuple(newResult[i],\
    \ newResult[i + 1]);\n      result.push_back(a);\n    }\n  }\n  return result;",
  "  std::vector<std::tuple<long, long>> res;\n  for (long row = 0; row < lst.size();\
    \ row++) {\n    for (long col = 0; col < lst[row].size(); col++) {\n      if (lst[row][col]\
    \ == x) {\n        res.push_back(std::make_tuple(row, col));\n      }\n    }\n\
    \  }\n  std::sort(res.begin(), res.end(), [](auto& a, auto& b) {\n    return (std::get<0>(a)\
    \ < std::get<0>(b) ||\n            (std::get<0>(a) == std::get<0>(b) && std::get<1>(a)\
    \ > std::get<1>(b)));\n  });\n  return res;", "    // write your code here\n \
    \   std::vector<std::tuple<long, long>> result;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                result.push_back(std::make_tuple(i, j));\n        \
    \    }\n        }\n    }\n    // sort the final result by row.\n    sort(result.begin(),\
    \ result.end());\n    return result;", "  std::vector<std::tuple<long, long>>\
    \ out;\n  for (auto row = 0; row < lst.size(); ++row) {\n    for (auto col = 0;\
    \ col < lst[row].size(); ++col) {\n      if (lst[row][col] == x) {\n        out.push_back(std::make_tuple(row,\
    \ col));\n      }\n    }\n  }\n  std::sort(out.begin(), out.end(), [](std::tuple<long,\
    \ long>& a, std::tuple<long, long>& b) {\n    return (std::get<0>(a) < std::get<0>(b))\
    \ ||\n    (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n\
    \  });\n  return out;", "    std::vector<std::tuple<long, long>> result;\n   \
    \ for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x)\n                result.push_back(std::make_tuple(i,\
    \ j));\n        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n        if (std::get<0>(t1) != std::get<0>(t2))\n\
    \            return std::get<0>(t1) < std::get<0>(t2);\n        else\n       \
    \     return std::get<1>(t1) > std::get<1>(t2);\n    });\n    return result;",
  "    std::vector<std::tuple<long, long>> result;\n    std::vector<std::vector<long>>\
    \ coordinates;\n    // merge all rows into one\n    for (size_t i = 0; i < lst.size();\
    \ i++) {\n        std::vector<long> curr;\n        for (size_t j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                std::vector<long>\
    \ lst_;\n                lst_.push_back(i);\n                lst_.push_back(j);\n\
    \                coordinates.push_back(lst_);\n            }\n        }\n    }\n\
    \    // sort coordinates according to the problem\n    std::sort(coordinates.begin(),\
    \ coordinates.end());\n    std::vector<std::vector<long>> unique_;\n    unique_.push_back(coordinates[0]);\n\
    \    for (size_t i = 1; i < coordinates.size(); i++) {\n        if (coordinates[i][0]\
    \ == coordinates[i - 1][0]) {\n            if (coordinates[i][1] > coordinates[i\
    \ - 1][1]) {\n                unique_.push_back(coordinates[i]);\n           \
    \ }\n        } else {\n            unique_.push_back(coordinates[i]);\n      \
    \  }\n    }\n    // format output\n    for (size_t i = 0; i < unique_.size();\
    \ i++) {\n        std::tuple<long, long> curr(unique_[i][0], unique_[i][1]);\n\
    \        result.push_back(curr);\n    }\n    return result;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0;\
    \ j < lst[i].size(); j++) {\n      if (lst[i][j] == x)\n        result.push_back(std::make_tuple(i,\
    \ j));\n    }\n  }\n  return result;", "\tstd::vector<std::tuple<long, long>>\
    \ result;\n\tfor (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j <\
    \ lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(),\n\t\t[](const\
    \ std::tuple<long, long> &left, const std::tuple<long, long> &right) {\n\t\tif\
    \ (std::get<0>(left) == std::get<0>(right)) {\n\t\t\treturn std::get<1>(left)\
    \ > std::get<1>(right);\n\t\t}\n\t\treturn std::get<0>(left) < std::get<0>(right);\n\
    \t});\n\treturn result;", "\tstd::vector<std::tuple<long, long>> tuple_list;\n\
    \tfor (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\ttuple_list.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tsort(tuple_list.begin(), tuple_list.end());\n\t\
    return tuple_list;", "    std::vector<std::tuple<long, long>> res;\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++)\
    \ {\n            if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\n\
    \              [](std::tuple<long, long> a, std::tuple<long, long> b) {\n    \
    \              if (std::get<0>(a) == std::get<0>(b)) {\n                     \
    \ return std::get<1>(a) > std::get<1>(b);\n                  }\n             \
    \     return std::get<0>(a) < std::get<0>(b);\n              });\n    return res;",
  "  // your code here\n  return {};", "    std::vector<std::tuple<long, long>> res;\n\
    \    if (lst.empty()) return res;\n    std::vector<long> rows;\n    std::vector<long>\
    \ cols;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j\
    \ < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n               \
    \ rows.push_back(i);\n                cols.push_back(j);\n            }\n    \
    \    }\n    }\n    for (int i = 0; i < rows.size(); i++) {\n        res.push_back(std::make_tuple(rows[i],\
    \ cols[i]));\n    }\n    std::sort(res.begin(), res.end());\n    for (int i =\
    \ 0; i < res.size(); i++) {\n        for (int j = 0; j < res.size() - 1; j++)\
    \ {\n            if (std::get<0>(res[j]) == std::get<0>(res[j + 1])) {\n     \
    \           if (std::get<1>(res[j]) < std::get<1>(res[j + 1])) {\n           \
    \         std::tuple<long, long> temp = res[j];\n                    res[j] =\
    \ res[j + 1];\n                    res[j + 1] = temp;\n                }\n   \
    \         }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> l;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j\
    \ = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n        \
    \        l.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n\
    \    std::sort(l.begin(), l.end());\n    for (long i = 0; i < l.size(); i++) {\n\
    \        if (i + 1 < l.size() && std::get<0>(l[i]) == std::get<0>(l[i + 1])) {\n\
    \            std::get<1>(l[i]) *= -1;\n            std::get<1>(l[i + 1]) *= -1;\n\
    \        }\n    }\n    std::sort(l.begin(), l.end());\n    for (long i = 0; i\
    \ < l.size(); i++) {\n        if (std::get<1>(l[i]) < 0) {\n            std::get<1>(l[i])\
    \ *= -1;\n        }\n    }\n    return l;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j\
    \ = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x)\n          \
    \      res.push_back(std::make_tuple(i, j));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n      \
    \  if (std::get<0>(a) < std::get<0>(b))\n            return true;\n        else\
    \ if (std::get<0>(a) == std::get<0>(b))\n            return std::get<1>(a) > std::get<1>(b);\n\
    \        else\n            return false;\n    });\n    return res;", "  \n  std::vector<std::tuple<long,\
    \ long>> v;\n  for(int i = 0; i < lst.size(); i++) {\n    std::vector<long> ::\
    \ iterator it = std::find(lst[i].begin(), lst[i].end(), x);\n    while(it != lst[i].end())\
    \ {\n      std::tuple<long, long> t (i, it - lst[i].begin());\n      v.push_back(t);\n\
    \      it = std::find(it + 1, lst[i].end(), x);\n    }\n  }\n  std::sort(v.begin(),\
    \ v.end());\n  for(int i = 0; i < v.size(); i++) {\n    long x, y;\n    std::tie(x,\
    \ y) = v[i];\n    v[i] = std::make_tuple(x, -y);\n  }\n  std::sort(v.begin(),\
    \ v.end());\n  for(int i = 0; i < v.size(); i++) {\n    long x, y;\n    std::tie(x,\
    \ y) = v[i];\n    v[i] = std::make_tuple(x, -y);\n  }\n  return v;", "    // write\
    \ your code here\n    std::vector<std::tuple<long, long>> output;\n    long count\
    \ = 0;\n    for(long i = 0; i < lst.size(); i++) {\n        if(std::find(lst[i].begin(),\
    \ lst[i].end(), x) != lst[i].end()) {\n            output.push_back(std::make_tuple(i,\
    \ std::distance(lst[i].begin(), std::find(lst[i].begin(), lst[i].end(), x))));\n\
    \        }\n    }\n    std::sort(output.begin(), output.end());\n    std::sort(output.begin(),\
    \ output.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \     if(std::get<0>(a) == std::get<0>(b)) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        }\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    return output;", "    std::vector<std::tuple<long, long>> result;\n\
    \    long rows = lst.size();\n    for (long i = 0; i < rows; i++) {\n        for\
    \ (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n\
    \                result.push_back(std::make_tuple(i, j));\n            }\n   \
    \     }\n    }\n    std::sort(result.begin(), result.end(),\n              [](const\
    \ std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return\
    \ std::get<0>(a) == std::get<0>(b) ? std::get<1>(a) > std::get<1>(b) : std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    return result;", "  std::vector<std::tuple<long,\
    \ long>> result;\n  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0;\
    \ j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](auto\
    \ &left, auto &right) {\n    return std::get<0>(left) < std::get<0>(right);\n\
    \  });\n  std::sort(result.begin(), result.end(), [](auto &left, auto &right)\
    \ {\n    return std::get<1>(left) > std::get<1>(right);\n  });\n  return result;",
  "    std::vector<std::tuple<long, long>> result;\n    long row = 0;\n    for (auto\
    \ y : lst) {\n        long col = 0;\n        for (auto z : y) {\n            if\
    \ (z == x) {\n                result.push_back(std::make_tuple(row, col));\n \
    \           }\n            col++;\n        }\n        row++;\n    }\n    // sort\
    \ the row element in descending order\n    std::sort(result.begin(), result.end(),\
    \ [](auto &e1, auto &e2) {\n        return std::get<1>(e1) > std::get<1>(e2);\n\
    \    });\n    // sort the row element in ascending order\n    std::sort(result.begin(),\
    \ result.end(), [](auto &e1, auto &e2) {\n        return std::get<0>(e1) < std::get<0>(e2);\n\
    \    });\n    return result;", "\tstd::vector<std::tuple<long, long>> res;\n\t\
    for (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tres.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> lhs, std::tuple<long, long> rhs) {\n\t\tif (std::get<0>(lhs) < std::get<0>(rhs))\
    \ {\n\t\t\treturn true;\n\t\t}\n\t\telse if (std::get<0>(lhs) == std::get<0>(rhs))\
    \ {\n\t\t\treturn std::get<1>(lhs) > std::get<1>(rhs);\n\t\t}\n\t\telse {\n\t\t\
    \treturn false;\n\t\t}\n\t});\n\treturn res;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    std::vector<std::tuple<long, long>> result_v;\n    std::tuple<long,\
    \ long> add_tuple;\n    if (lst.size() == 0)\n        return result;\n    // read\
    \ row by row\n    for (size_t i = 0; i < lst.size(); i++) {\n        // read by\
    \ col\n        for (size_t j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                std::get<0>(add_tuple) = i;\n                std::get<1>(add_tuple)\
    \ = j;\n                result.push_back(add_tuple);\n            }\n        }\n\
    \    }\n    // Sort result in descending order, compare by row first, then by\
    \ col\n    std::sort(result.begin(), result.end(),\n              [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n                  return (std::get<0>(a)\
    \ < std::get<0>(b) ||\n                          (std::get<0>(a) == std::get<0>(b)\
    \ && std::get<1>(a) > std::get<1>(b)));\n              });\n    return result;",
  "  std::vector<std::tuple<long, long>> res;\n  for (long i = 0; i < lst.size();\
    \ i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j]\
    \ == x) {\n        res.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n\
    \  std::sort(res.begin(), res.end(),\n            [](std::tuple<long, long> a,\
    \ std::tuple<long, long> b) {\n              if (std::get<0>(a) == std::get<0>(b))\
    \ {\n                return std::get<1>(a) > std::get<1>(b);\n              }\n\
    \              return std::get<0>(a) < std::get<0>(b);\n            });\n  return\
    \ res;", "    std::vector<std::tuple<long, long>> listOfTuples;\n    long counter\
    \ = 0;\n    long row = 0;\n    for (auto i = lst.begin(); i != lst.end(); i++)\
    \ {\n        long column = 0;\n        for (auto j = i->begin(); j != i->end();\
    \ j++) {\n            if (*j == x) {\n                listOfTuples.push_back(std::make_tuple(row,\
    \ column));\n            }\n            column++;\n        }\n        row++;\n\
    \    }\n    std::sort(listOfTuples.begin(), listOfTuples.end());\n    return listOfTuples;",
  "\tstd::vector<std::tuple<long, long>> ans;\n\tstd::map<long, std::vector<long>>\
    \ m;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tm[i].push_back(j);\n\t\t\t}\n\t\
    \t}\n\t}\n\tfor (auto it = m.begin(); it != m.end(); it++) {\n\t\tstd::sort(it->second.begin(),\
    \ it->second.end(), std::greater<long>());\n\t\tfor (int i = 0; i < it->second.size();\
    \ i++) {\n\t\t\tans.push_back(std::make_tuple(it->first, it->second[i]));\n\t\t\
    }\n\t}\n\treturn ans;", "\tstd::vector<std::tuple<long, long>> result;\n\tfor\
    \ (long i = 0; i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n\t\treturn (std::get<0>(t1) < std::get<0>(t2)\
    \ || std::get<0>(t1) == std::get<0>(t2) && std::get<1>(t1) > std::get<1>(t2));\n\
    \t});\n\treturn result;", "\tstd::vector<std::tuple<long, long>> result;\n\tif(lst.size()\
    \ == 0)\n\t\treturn result;\n\tfor(size_t i = 0; i < lst.size(); i++) {\n\t\t\
    for(size_t j = 0; j < lst[i].size(); j++) {\n\t\t\tif(lst[i][j] == x) {\n\t\t\t\
    \tstd::tuple<long, long> temp(i, j);\n\t\t\t\tresult.push_back(temp);\n\t\t\t\
    }\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end());\n\tlong count = 0;\n\
    \twhile(count < result.size() - 1) {\n\t\tstd::tuple<long, long> temp = result[count];\n\
    \t\tif(std::get<0>(temp) == std::get<0>(result[count + 1])) {\n\t\t\tstd::tuple<long,\
    \ long> temp1 = result[count + 1];\n\t\t\tstd::tuple<long, long> temp2 = result[count];\n\
    \t\t\tif(std::get<1>(temp1) > std::get<1>(temp2)) {\n\t\t\t\tresult[count] = temp1;\n\
    \t\t\t\tresult[count + 1] = temp2;\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t}\n\treturn\
    \ result;", "\tstd::vector<std::tuple<long, long>> result;\n\tfor (long i = 0;\
    \ i < lst.size(); i++) {\n\t\tfor (long j = 0; j < lst[i].size(); j++) {\n\t\t\
    \tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i, j));\n\t\t\
    \t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](const std::tuple<long,\
    \ long> &lhs, const std::tuple<long, long> &rhs) {\n\t\tif (std::get<0>(lhs) <\
    \ std::get<0>(rhs)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (std::get<0>(lhs)\
    \ == std::get<0>(rhs)) {\n\t\t\treturn std::get<1>(lhs) > std::get<1>(rhs);\n\t\
    \t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn result;", "     \
    \   if (lst.empty()) return {};\n        long r = 0;\n        long c = 0;\n  \
    \      std::vector<std::tuple<long, long>> result;\n        for (auto l : lst)\
    \ {\n                for (auto i : l) {\n                        if (i == x) result.push_back(std::make_tuple(r,\
    \ c));\n                        c++;\n                }\n                c = 0;\n\
    \                r++;\n        }\n        std::sort(result.begin(), result.end());\n\
    \        return result;", "  std::vector<std::tuple<long, long>> res;\n  if (lst.empty())\
    \ return res;\n  std::vector<std::vector<long>>::iterator row_iter = lst.begin();\n\
    \  long row_num = 0;\n  while (row_iter != lst.end()) {\n    std::vector<long>::iterator\
    \ col_iter = (*row_iter).begin();\n    long col_num = 0;\n    while (col_iter\
    \ != (*row_iter).end()) {\n      if (*col_iter == x) {\n        res.push_back(std::make_tuple(row_num,\
    \ col_num));\n      }\n      col_num++;\n      col_iter++;\n    }\n    row_num++;\n\
    \    row_iter++;\n  }\n  // sort coordinates by rows and then by columns\n  sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long>a, std::tuple<long, long>b) {\n    if (std::get<0>(a)\
    \ < std::get<0>(b)) {\n      return true;\n    } else if (std::get<0>(a) == std::get<0>(b))\
    \ {\n      return std::get<1>(a) > std::get<1>(b);\n    } else {\n      return\
    \ false;\n    }\n  });\n  return res;", "\tstd::vector<std::tuple<long, long>>\
    \ result;\n\tif (lst.size() == 0) {\n\t\treturn result;\n\t}\n\tfor (unsigned\
    \ long i = 0; i < lst.size(); i++) {\n\t\tfor (unsigned long j = 0; j < lst[i].size();\
    \ j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long>& a, std::tuple<long, long>& b) {\n\t\tif (std::get<0>(a) != std::get<0>(b))\
    \ {\n\t\t\treturn std::get<0>(a) < std::get<0>(b);\n\t\t}\n\t\treturn std::get<1>(a)\
    \ > std::get<1>(b);\n\t});\n\treturn result;", "\tif (lst.empty()) return {};\n\
    \tvector<tuple<long, long>> res;\n\tfor (long i = 0; i < lst.size(); i++) {\n\t\
    \tauto &v = lst[i];\n\t\tauto it = find(v.begin(), v.end(), x);\n\t\tif (it !=\
    \ v.end()) {\n\t\t\tfor (; it != v.end(); it = find(++it, v.end(), x)) {\n\t\t\
    \t\tres.push_back(make_tuple(i, it - v.begin()));\n\t\t\t}\n\t\t}\n\t}\n\tsort(res.begin(),\
    \ res.end(), [](tuple<long, long> &t1, tuple<long, long> &t2) {\n\t\tif (get<0>(t1)\
    \ == get<0>(t2)) {\n\t\t\treturn get<1>(t1) > get<1>(t2);\n\t\t}\n\t\treturn get<0>(t1)\
    \ < get<0>(t2);\n\t});\n\treturn res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0;\
    \ j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n             \
    \   res.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n \
    \   std::sort(res.begin(), res.end(),\n    [&](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        long x1 = std::get<0>(a);\n        long y1 = std::get<1>(a);\n\
    \        long x2 = std::get<0>(b);\n        long y2 = std::get<1>(b);\n      \
    \  if (x1 == x2) return y1 > y2;\n        return x1 < x2;\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> result;\n    if(lst.size() ==\
    \ 0) return result;\n    for(long i = 0; i < lst.size(); i++) {\n        for(long\
    \ j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j] == x) {\n       \
    \         result.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long,\
    \ long>& lhs, const std::tuple<long, long>& rhs) {\n        return std::get<0>(lhs)\
    \ < std::get<0>(rhs);\n    });\n    long start = 0;\n    long end = 0;\n    while(start\
    \ < result.size()) {\n        end = start;\n        while(end < result.size()\
    \ && std::get<0>(result[start]) == std::get<0>(result[end])) {\n            end++;\n\
    \        }\n        std::sort(result.begin() + start, result.begin() + end, [](const\
    \ std::tuple<long, long>& lhs, const std::tuple<long, long>& rhs) {\n        \
    \    return std::get<1>(lhs) > std::get<1>(rhs);\n        });\n        start =\
    \ end;\n    }\n    return result;", "  int index = 0;\n  std::vector<std::tuple<long,\
    \ long>> result;\n  for (std::vector<long> x : lst) {\n    for (int y = 0; y <\
    \ x.size(); y++) {\n      if (x[y] == x) {\n        result.push_back(std::make_tuple(index,\
    \ y));\n      }\n    }\n    index++;\n  }\n  std::sort(result.begin(), result.end());\n\
    \  std::sort(result.begin(), result.end(),\n            [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b))\
    \ {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a)\
    \ < std::get<0>(b);\n  });\n  return result;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    long row_idx = 0;\n    for (auto row : lst) {\n        auto\
    \ it = std::find(row.begin(), row.end(), x);\n        while (it != row.end())\
    \ {\n            res.push_back(std::make_tuple(row_idx, std::distance(row.begin(),\
    \ it)));\n            it = std::find(it + 1, row.end(), x);\n        }\n     \
    \   row_idx++;\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> t1, std::tuple<long, long> t2) {\n        return (std::get<0>(t1) < std::get<0>(t2))\
    \ ||\n               (std::get<0>(t1) == std::get<0>(t2) && std::get<1>(t1) >\
    \ std::get<1>(t2));\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    if (lst.empty()) return res;\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                res.push_back(std::make_tuple(i, j));\n           \
    \ }\n        }\n    }\n    std::sort(res.begin(), res.end(),\n              [](std::tuple<long,\
    \ long> &lhs, std::tuple<long, long> &rhs) {\n                  return std::get<0>(lhs)\
    \ < std::get<0>(rhs);\n              });\n    for (long i = 0; i < res.size();\
    \ i++) {\n        for (long j = i + 1; j < res.size(); j++) {\n            if\
    \ (std::get<0>(res[i]) == std::get<0>(res[j])) {\n                if (std::get<1>(res[i])\
    \ < std::get<1>(res[j])) {\n                    std::swap(res[i], res[j]);\n \
    \               }\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> ret;\n    std::tuple<long, long> temp;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                std::get<0>(temp) = i;\n                std::get<1>(temp)\
    \ = j;\n                ret.push_back(temp);\n            }\n        }\n    }\n\
    \    std::sort(ret.begin(), ret.end());\n    return ret;", "  std::vector<std::tuple<long,\
    \ long>> res;\n  long cnt = 0;\n  for (long i = 0; i < lst.size(); i++) {\n  \
    \  for (long j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n \
    \       res.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  return res;",
  "\tstd::vector<std::tuple<long, long>> ret;\n\tfor (auto i = 0; i < lst.size();\
    \ i++) {\n\t\tauto found = std::find(lst[i].begin(), lst[i].end(), x);\n\t\tif\
    \ (found != lst[i].end()) {\n\t\t\tret.push_back(std::make_tuple(i, found - lst[i].begin()));\n\
    \t\t}\n\t}\n\treturn ret;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](std::tuple<long, long> t1, std::tuple<long, long> t2) {\n        return std::get<0>(t1)\
    \ == std::get<0>(t2) ? std::get<1>(t1) > std::get<1>(t2) : std::get<0>(t1) < std::get<0>(t2);\n\
    \    });\n    return res;", "  std::vector<std::tuple<long, long>> result;\n \
    \ for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        std::tuple<long, long> coordinate(i,\
    \ j);\n        result.push_back(coordinate);\n      }\n    }\n  }\n  std::sort(result.begin(),\
    \ result.end());\n  for (int i = 0; i < result.size(); i++) {\n    for (int j\
    \ = 0; j < result.size() - 1; j++) {\n      if (std::get<0>(result[j]) == std::get<0>(result[j\
    \ + 1])) {\n        if (std::get<1>(result[j]) < std::get<1>(result[j + 1])) {\n\
    \          std::swap(result[j], result[j + 1]);\n        }\n      }\n    }\n \
    \ }\n  return result;", "    // Your code here\n    // You may use tuples to return\
    \ values\n    std::vector<std::tuple<long, long>> ans;\n    std::vector<std::vector<long>>::iterator\
    \ it_outer,it_inner;\n    for(it_outer=lst.begin();it_outer!=lst.end();it_outer++)\n\
    \    {\n        for(it_inner=(*it_outer).begin();it_inner!=(*it_outer).end();it_inner++)\n\
    \        {\n            if(*it_inner==x)\n            {\n                std::tuple<long,long>\
    \ temp((it_outer-lst.begin()),(it_inner-(*it_outer).begin()));\n             \
    \   ans.push_back(temp);\n            }\n        }\n    }\n    sort(ans.begin(),ans.end());\n\
    \    return ans;", "    std::vector<std::tuple<long, long>> ret{};\n    int row\
    \ = 0;\n    std::for_each(lst.begin(), lst.end(), [&](auto v) {\n        long\
    \ i = 0;\n        std::vector<long> indexes{};\n        for (auto j : v) {\n \
    \           if (j == x) {\n                indexes.push_back(i);\n           \
    \ }\n            i++;\n        }\n        std::for_each(indexes.begin(), indexes.end(),\
    \ [&](auto index) {\n            ret.push_back(std::make_tuple(row, index));\n\
    \        });\n        row++;\n    });\n    std::sort(ret.begin(), ret.end(), [](auto\
    \ lhs, auto rhs) {\n        if (std::get<0>(lhs) != std::get<0>(rhs)) {\n    \
    \        return std::get<0>(lhs) < std::get<0>(rhs);\n        } else {\n     \
    \       return std::get<1>(lhs) > std::get<1>(rhs);\n        }\n    });\n    return\
    \ ret;", "    std::vector<std::tuple<long, long>> result;\n    for (long i = 0;\
    \ i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n\
    \            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\n\
    \    [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n\
    \        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(result.begin(),\
    \ result.end(),\n    [](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ result;", "    std::vector<std::tuple<long, long>> result;\n    for (int i =\
    \ 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n\
    \            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\
    \ [](auto& a, auto& b) {\n        if (std::get<0>(a) == std::get<0>(b)) {\n  \
    \          return std::get<1>(a) > std::get<1>(b);\n        }\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    return result;", "  // std::vector<std::vector<long>>\
    \ result;\n  std::vector<std::tuple<long, long>> coordinates;\n  for (unsigned\
    \ int i = 0; i < lst.size(); i++) {\n    for (unsigned int j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        coordinates.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  return coordinates;", "    std::vector<std::tuple<long,\
    \ long>> ans;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          ans.push_back(std::make_tuple(i, j));\n            }\n        }\n \
    \   }\n    std::sort(ans.begin(), ans.end(), [](std::tuple<long, long>& x, std::tuple<long,\
    \ long>& y) {\n        if (std::get<0>(x) < std::get<0>(y)) {\n            return\
    \ true;\n        } else if (std::get<0>(x) == std::get<0>(y)) {\n            return\
    \ std::get<1>(x) > std::get<1>(y);\n        } else {\n            return false;\n\
    \        }\n    });\n    return ans;", "    std::vector<std::tuple<long, long>>\
    \ result;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0;\
    \ j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n             \
    \   result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n\
    \    std::sort(result.begin(), result.end(),\n            [](const std::tuple<long,\
    \ long> &lhs, const std::tuple<long, long> &rhs) {\n                return std::get<0>(lhs)\
    \ < std::get<0>(rhs);\n            });\n    for (int i = 0; i < result.size();\
    \ i++) {\n        std::reverse(result.begin(), result.end());\n    }\n    return\
    \ result;", '    // your code here', "  std::vector<std::tuple<long, long>> res;\n\
    \  for (int i = 0; i < lst.size(); i++) {\n    for (int j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(res.begin(), res.end(), [&lst](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n    if (std::get<0>(a) == std::get<0>(b))\
    \ {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a)\
    \ < std::get<0>(b);\n  });\n  return res;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int\
    \ j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n      \
    \          result.push_back(std::make_tuple(i, j));\n            }\n        }\n\
    \    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b) {\n            return std::get<0>(a) < std::get<0>(b);\n\
    \            });\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n            return std::get<1>(a) > std::get<1>(b);\n\
    \            });\n    return result;", "    long i, j, k, r=lst.size(), c;\n \
    \   bool found;\n    std::vector<std::tuple<long, long>> res;\n    for(i=0; i<r;\
    \ i++) {\n        c=lst[i].size();\n        for(j=0; j<c; j++) {\n           \
    \ if(lst[i][j]==x) {\n                found=false;\n                for(k=0; k<res.size();\
    \ k++) {\n                    if(std::get<0>(res[k])==i) {\n                 \
    \       found=true;\n                        break;\n                    }\n \
    \               }\n                if(found) {\n                    std::tuple<long,\
    \ long> temp=res[k];\n                    res.erase(res.begin()+k);\n        \
    \            res.push_back(std::make_tuple(i, j));\n                    res.push_back(temp);\n\
    \                }\n                else {\n                    res.push_back(std::make_tuple(i,\
    \ j));\n                }\n            }\n        }\n    }\n    return res;",
  "    std::vector<std::tuple<long, long>> res;\n    for (int i = 0; i < lst.size();\
    \ i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                res.push_back(std::make_tuple(i, j));\n           \
    \ }\n        }\n    }\n    std::sort(res.begin(), res.end(),\n        [](const\
    \ std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n            if\
    \ (std::get<0>(a) == std::get<0>(b)) {\n                return std::get<1>(a)\
    \ > std::get<1>(b);\n            }\n            return std::get<0>(a) < std::get<0>(b);\n\
    \        });\n    return res;", "\t// TODO: Write - Your - Code\n\tstd::vector<std::tuple<long,\
    \ long>> res;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = 0; j\
    \ < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tres.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\
    \t});\n\tfor (int i = 0; i < res.size(); i++) {\n\t\tif (i + 1 < res.size() &&\
    \ std::get<0>(res[i]) == std::get<0>(res[i + 1])) {\n\t\t\tstd::tuple<long, long>\
    \ temp = res[i];\n\t\t\tfor (int j = i; j < res.size(); j++) {\n\t\t\t\tif (std::get<0>(res[j])\
    \ == std::get<0>(temp)) {\n\t\t\t\t\tif (std::get<1>(res[j]) > std::get<1>(temp))\
    \ {\n\t\t\t\t\t\ttemp = res[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int\
    \ j = i; j < res.size(); j++) {\n\t\t\t\tif (std::get<0>(res[j]) == std::get<0>(temp))\
    \ {\n\t\t\t\t\tres[j] = temp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\tfor (int i = 0; i < res.size(); i++) {\n\t\tif (i + 1 < res.size() && std::get<0>(res[i])\
    \ == std::get<0>(res[i + 1])) {\n\t\t\t", "  std::vector<std::tuple<long, long>>\
    \ result;\n  for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j <\
    \ lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i,\
    \ j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(),\n     \
    \       [](std::tuple<long, long> a, std::tuple<long, long> b) {\n           \
    \   if (std::get<0>(a) < std::get<0>(b))\n                return true;\n     \
    \         else if (std::get<0>(a) == std::get<0>(b))\n                return std::get<1>(a)\
    \ > std::get<1>(b);\n              else\n                return false;\n     \
    \       });\n  return result;", "  std::vector<std::tuple<long, long>> result;\n\
    \  for (long row = 0; row < lst.size(); row++) {\n    auto& r = lst[row];\n  \
    \  auto it = std::find(r.begin(), r.end(), x);\n    while (it != r.end()) {\n\
    \      result.push_back(std::make_tuple(row, it - r.begin()));\n      it = std::find(it\
    \ + 1, r.end(), x);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](auto\
    \ a, auto b) {\n    auto r1 = std::get<0>(a);\n    auto r2 = std::get<0>(b);\n\
    \    auto c1 = std::get<1>(a);\n    auto c2 = std::get<1>(b);\n    if (r1 == r2)\
    \ {\n      return c1 > c2;\n    }\n    return r1 < r2;\n  });\n  return result;",
  "\t// Your code here\n\tstd::vector<std::tuple<long, long>> ans;\n\tfor (int i =\
    \ 0; i < lst.size(); i++) {\n\t\tfor (int j = 0; j < lst[i].size(); j++) {\n\t\
    \t\tif (lst[i][j] == x)\n\t\t\t\tans.push_back(std::make_tuple(i, j));\n\t\t}\n\
    \t}\n\tstd::sort(ans.begin(), ans.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n\t\tif (std::get<0>(a) != std::get<0>(b))\n\t\t\treturn std::get<0>(a)\
    \ < std::get<0>(b);\n\t\telse\n\t\t\treturn std::get<1>(a) > std::get<1>(b);\n\
    \t});\n\treturn ans;", "    std::vector<std::tuple<long, long>> res;\n    long\
    \ row = 0;\n    for (auto &a : lst) {\n        long col = 0;\n        for (auto\
    \ &b : a) {\n            if (b == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n            col++;\n        }\n        row++;\n    }\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) {\n        if (std::get<0>(a)\
    \ == std::get<0>(b)) {\n            return std::get<1>(a) > std::get<1>(b);\n\
    \        }\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> result;\n    if (lst.empty())\
    \ {\n        return result;\n    }\n    std::vector<std::vector<std::tuple<long,\
    \ long>>> sorted_rows;\n    std::vector<std::tuple<long, long>> temp;\n    for\
    \ (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                temp.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n        sorted_rows.push_back(temp);\n     \
    \   temp.clear();\n    }\n    for (int i = 0; i < sorted_rows.size(); i++) {\n\
    \        std::sort(sorted_rows[i].begin(), sorted_rows[i].end(), [](std::tuple<long,\
    \ long> const &a, std::tuple<long, long> const &b) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        });\n    }\n    std::sort(sorted_rows.begin(), sorted_rows.end(),\
    \ [](std::vector<std::tuple<long, long>> const &a, std::vector<std::tuple<long,\
    \ long>> const &b) {\n        return std::get<0>(a[0]) < std::get<0>(b[0]);\n\
    \    });\n    for (int i = 0; i < sorted_rows.size(); i++) {\n        for (int\
    \ j = 0; j < sorted_rows[i].size(); j++) {\n            result.push_back(sorted_rows[i][j]);\n\
    \        }\n    }\n    return result;", "    std::vector<std::tuple<long, long>>\
    \ ret;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j\
    \ < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n               \
    \ ret.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n   \
    \ std::sort(ret.begin(), ret.end(), [](std::tuple<long, long> &lhs, std::tuple<long,\
    \ long> &rhs) {\n        return (std::get<0>(lhs) < std::get<0>(rhs) ||\n    \
    \            (std::get<0>(lhs) == std::get<0>(rhs) && std::get<1>(lhs) > std::get<1>(rhs)));\n\
    \    });\n    return ret;", "  std::vector<std::tuple<long, long>> ans;\n  for\
    \ (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x)\n        ans.push_back(std::make_tuple(i,\
    \ j));\n    }\n  }\n  std::sort(ans.begin(), ans.end(),\n            [](const\
    \ std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n            \
    \  return std::get<0>(a) < std::get<0>(b);\n            });\n  for (long i = 0;\
    \ i < ans.size(); i++) {\n    if (i + 1 < ans.size() && std::get<0>(ans[i]) ==\
    \ std::get<0>(ans[i + 1])) {\n      for (long j = i + 1; j < ans.size(); j++)\
    \ {\n        if (std::get<0>(ans[i]) != std::get<0>(ans[j]))\n          break;\n\
    \        for (long k = i; k < j; k++) {\n          if (std::get<1>(ans[k]) < std::get<1>(ans[j]))\
    \ {\n            std::swap(ans[k], ans[j]);\n          }\n        }\n      }\n\
    \    }\n  }\n  return ans;", "    std::vector<std::tuple<long, long>> result;\n\
    \    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    sort(result.begin(), result.end());\n\
    \    for (auto it = result.begin(); it != result.end(); ++it) {\n        std::sort(it\
    \ + 1, result.end(),\n                  [it](std::tuple<long, long>& a, std::tuple<long,\
    \ long>& b) {\n                      return std::get<0>(a) == std::get<0>(*it)\
    \ && std::get<1>(a) > std::get<1>(*it);\n                  });\n    }\n    return\
    \ result;", "\tstd::vector<std::tuple<long, long>> coords;\n\tfor (size_t i =\
    \ 0; i < lst.size(); i++) {\n\t\tfor (size_t j = 0; j < lst[i].size(); j++) {\n\
    \t\t\tif (lst[i][j] == x) {\n\t\t\t\tcoords.push_back(std::make_tuple(i, j));\n\
    \t\t\t}\n\t\t}\n\t}\n\tstd::sort(coords.begin(), coords.end(),\n\t\t[](std::tuple<long,\
    \ long> coord1, std::tuple<long, long> coord2) {\n\t\t\tif (std::get<0>(coord1)\
    \ == std::get<0>(coord2)) {\n\t\t\t\treturn std::get<1>(coord1) > std::get<1>(coord2);\n\
    \t\t\t}\n\t\t\treturn std::get<0>(coord1) < std::get<0>(coord2);\n\t\t});\n\t\
    return coords;", "\t// TODO: implement get_row function\n\tstd::vector<std::tuple<long,\
    \ long>> res;\n\tlong i = 0;\n\tfor (auto r : lst) {\n\t\tlong j = 0;\n\t\tfor\
    \ (auto c : r) {\n\t\t\tif (c == x) {\n\t\t\t\tres.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\tstd::sort(res.begin(), res.end(),\
    \ [](auto a, auto b) {\n\t\tif (std::get<0>(a) == std::get<0>(b))\n\t\t\treturn\
    \ std::get<1>(a) > std::get<1>(b);\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\
    \t});\n\treturn res;", "  std::vector<std::tuple<long, long>> res;\n  for (long\
    \ i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++)\
    \ {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i, j));\n\
    \      }\n    }\n  }\n  // std::cout << \"Size of res \" << res.size() << std::endl;\n\
    \  std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  // std::cout\
    \ << \"Sorted\" << std::endl;\n  for (long i = 0; i < res.size(); i++) {\n   \
    \ long j = i;\n    while (j > 0 && std::get<0>(res[j]) == std::get<0>(res[j -\
    \ 1])) {\n      if (std::get<1>(res[j]) > std::get<1>(res[j - 1])) {\n       \
    \ std::swap(res[j], res[j - 1]);\n      }\n      j--;\n    }\n  }\n  return res;",
  "    long length = lst.size();\n    std::vector<std::tuple<long, long>> out;\n \
    \   for (long i = 0; i < length; i++) {\n        std::vector<long> row = lst[i];\n\
    \        long width = row.size();\n        for (long j = 0; j < width; j++) {\n\
    \            if (row[j] == x) {\n                out.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    std::sort(out.begin(), out.end());\n\
    \    return out;", "\tstd::vector<std::tuple<long, long>> result;\n\tint i, j;\n\
    \tfor (i = 0; i < lst.size(); i++) {\n\t\tfor (j = 0; j < lst[i].size(); j++)\
    \ {\n\t\t\tif (lst[i][j] == x) {\n\t\t\t\tresult.push_back(std::make_tuple(i,\
    \ j));\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(result.begin(), result.end(), [](const\
    \ std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n\t\treturn std::get<0>(a)\
    \ < std::get<0>(b);\n\t});\n\tfor (i = 0; i < result.size(); i++) {\n\t\tfor (j\
    \ = i + 1; j < result.size(); j++) {\n\t\t\tif (std::get<0>(result[i]) == std::get<0>(result[j]))\
    \ {\n\t\t\t\tif (std::get<1>(result[i]) < std::get<1>(result[j])) {\n\t\t\t\t\t\
    std::swap(result[i], result[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;",
  "    // Sort the rows:\n    std::sort(lst.begin(), lst.end(), [](std::vector<long>\
    \ lhs, std::vector<long> rhs) {\n        return lhs.size() < rhs.size();\n   \
    \ });\n    // Transpose and re-sort:\n    long max_length = 0;\n    for (long\
    \ i = 0; i < lst.size(); i++) {\n        max_length = std::max(max_length, long(lst[i].size()));\n\
    \    }\n    std::vector<std::vector<long>> transposed(max_length, std::vector<long>(lst.size()));\n\
    \    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size();\
    \ j++) {\n            transposed[j][i] = lst[i][j];\n        }\n    }\n    for\
    \ (long i = 0; i < transposed.size(); i++) {\n        std::sort(transposed[i].begin(),\
    \ transposed[i].end(), [](long lhs, long rhs) {\n            return lhs > rhs;\n\
    \        });\n    }\n    // Recover from the transpose:\n    std::vector<std::vector<long>>\
    \ recovered(lst.size(), std::vector<long>(max_length));\n    for (long i = 0;\
    \ i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n\
    \            recovered[i][j] = transposed[j][i];\n        }\n    }\n    // Finally,\
    \ collect the indices:\n    std::vector<std::tuple<long, long>> result;\n    for\
    \ (long i = 0; i < recovered.size(); i++) {\n        for (long j = 0; j < recovered[i].size();\
    \ j++) {\n            if (recovered[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    return result;"]
stop_tokens:
- "\n}"
