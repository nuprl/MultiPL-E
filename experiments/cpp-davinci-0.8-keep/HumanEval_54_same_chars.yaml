name: HumanEval_54_same_chars
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the\
  \ same characters.\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// True\n\
  // >>> same_chars('abcd', 'dddddddabc')\n// True\n// >>> same_chars('dddddddabc',\
  \ 'abcd')\n// True\n// >>> same_chars('eabcd', 'dddddddabc')\n// False\n// >>> same_chars('abcd',\
  \ 'dddddddabce')\n// False\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n\
  // False\nbool same_chars(std::string s0, std::string s1) {\n"
tests: "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"\
  eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"\
  ), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\"\
  )) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n\
  \    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"\
  eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"\
  ), (\"aaccc\")) == (false));\n}\n"
completions: ["\tif (s0.length() != s1.length()) return false;\n\tfor (int i = 0;\
    \ i < s0.length(); i++) {\n\t\tif (s0[i] != s1[i]) return false;\n\t}\n\treturn\
    \ true;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\
    \    return s0 == s1;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "  int len0 = s0.length();\n  int len1 =\
    \ s1.length();\n  if (len0 != len1) return false;\n  int arr[256] = {0};\n  for\
    \ (int i = 0; i < len0; i++) {\n    arr[s0[i]]++;\n    arr[s1[i]]--;\n  }\n  for\
    \ (int i = 0; i < 256; i++) {\n    if (arr[i] != 0) {\n      return false;\n \
    \   }\n  }\n  return true;", "    int dict[256] = {0};\n    int len0 = s0.length();\n\
    \    int len1 = s1.length();\n    for (int i = 0; i < len0; i++) {\n        dict[s0[i]]\
    \ += 1;\n    }\n    for (int i = 0; i < len1; i++) {\n        dict[s1[i]] -= 1;\n\
    \    }\n    for (int i = 0; i < 256; i++) {\n        if (dict[i] != 0) {\n   \
    \         return false;\n        }\n    }\n    return true;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n \
    \   return s0 == s1;", "    // Write your code here.\n    std::map<char, int>\
    \ mp1;\n    std::map<char, int> mp2;\n    for(int i = 0; i < s0.length(); i++)\n\
    \    {\n        if(mp1.find(s0[i]) == mp1.end())\n        {\n            mp1[s0[i]]\
    \ = 1;\n        }\n        else\n        {\n            mp1[s0[i]]++;\n      \
    \  }\n    }\n    for(int i = 0; i < s1.length(); i++)\n    {\n        if(mp2.find(s1[i])\
    \ == mp2.end())\n        {\n            mp2[s1[i]] = 1;\n        }\n        else\n\
    \        {\n            mp2[s1[i]]++;\n        }\n    }\n    for(auto it = mp1.begin();\
    \ it != mp1.end(); it++)\n    {\n        if(mp2.find(it->first) == mp2.end())\n\
    \        {\n            return false;\n        }\n        else\n        {\n  \
    \          if(mp2[it->first] < it->second)\n            {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;", "  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "    //\
    \ Your code goes here\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0==s1;", "   if(s0.length() != s1.length()) return false;\n\
    \   std::map<char, int> m;\n   for(int i = 0; i < s0.length(); i++) {\n      \
    \ m[s0[i]]++;\n   }\n   for(int i = 0; i < s1.length(); i++) {\n       m[s1[i]]--;\n\
    \   }\n   for(auto e : m) {\n       if(e.second != 0) return false;\n   }\n  \
    \ return true;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "\tstd::map<char, int> freq;\n\tfor (auto\
    \ ch : s0) {\n\t\tfreq[ch]++;\n\t}\n\tfor (auto ch : s1) {\n\t\tfreq[ch]--;\n\t\
    }\n\tfor (auto val : freq) {\n\t\tif (val.second != 0) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;", "\tstd::map<char, int> cnt;\n\tfor (auto c : s0)\n\
    \t\tcnt[c]++;\n\tfor (auto c : s1)\n\t\tcnt[c]--;\n\tfor (auto p : cnt)\n\t\t\
    if (p.second != 0)\n\t\t\treturn false;\n\treturn true;", "  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "    int\
    \ sz0 = s0.size();\n    int sz1 = s1.size();\n    if (sz0 != sz1) {\n        return\
    \ false;\n    }\n    std::unordered_map<char, int> mp;\n    for (int i = 0; i\
    \ < sz0; i++) {\n        if (mp.find(s0[i]) == mp.end()) {\n            mp[s0[i]]\
    \ = 1;\n        } else {\n            mp[s0[i]] += 1;\n        }\n    }\n    for\
    \ (int i = 0; i < sz1; i++) {\n        if (mp.find(s1[i]) == mp.end()) {\n   \
    \         return false;\n        } else {\n            mp[s1[i]] -= 1;\n     \
    \   }\n    }\n    std::unordered_map<char, int>::iterator it;\n    for (it = mp.begin();\
    \ it != mp.end(); it++) {\n        if (it->second != 0) {\n            return\
    \ false;\n        }\n    }\n    return true;", "    assert(s0.size() > 0);\n \
    \   assert(s1.size() > 0);\n    if (s0.size() == s1.size())\n        return s0\
    \ == s1;\n    if (s0.size() > s1.size())\n        return same_chars(s1, s0);\n\
    \    std::unordered_map<char, int> s0_map;\n    for (char c : s0) {\n        if\
    \ (s0_map.find(c) == s0_map.end())\n            s0_map[c] = 1;\n        else\n\
    \            s0_map[c]++;\n    }\n    std::unordered_map<char, int> s1_map;\n\
    \    for (char c : s1) {\n        if (s1_map.find(c) == s1_map.end())\n      \
    \      s1_map[c] = 1;\n        else\n            s1_map[c]++;\n    }\n    std::unordered_map<char,\
    \ int>::iterator it0 = s0_map.begin();\n    while (it0 != s0_map.end()) {\n  \
    \      if (s1_map.find(it0->first) == s1_map.end())\n            return false;\n\
    \        if (s1_map[it0->first] < it0->second)\n            return false;\n  \
    \      it0++;\n    }\n    return true;", "  int i;\n  std::sort(s0.begin(), s0.end());\n\
    \  std::sort(s1.begin(), s1.end());\n  // cout << s0 << ' ' << s1 << endl;\n \
    \ return s0 == s1;", "    std::map<char, int> m1;\n    std::map<char, int> m2;\n\
    \    for (auto i : s0)\n        m1[i]++;\n    for (auto i : s1)\n        m2[i]++;\n\
    \    return m1 == m2;", "    if (s0.size() != s1.size()) {\n        return false;\n\
    \    }\n    if (s0.size() == 0 && s1.size() == 0) {\n        return true;\n  \
    \  }\n    auto *counter_0 = new int[255];\n    auto *counter_1 = new int[255];\n\
    \    for (int i = 0; i < 255; i++) {\n        counter_0[i] = 0;\n        counter_1[i]\
    \ = 0;\n    }\n    for (char c : s0) {\n        counter_0[c] += 1;\n    }\n  \
    \  for (char c : s1) {\n        counter_1[c] += 1;\n    }\n    for (int i = 0;\
    \ i < 255; i++) {\n        if (counter_0[i] != counter_1[i]) {\n            return\
    \ false;\n        }\n    }\n    return true;", '    return false;', "  std::unordered_map<char,\
    \ size_t> map;\n  std::unordered_map<char, size_t> map1;\n  for (char i : s0)\
    \ {\n    if (map.find(i) == map.end()) {\n      map[i] = 1;\n    } else {\n  \
    \    map[i] += 1;\n    }\n  }\n  for (char i : s1) {\n    if (map1.find(i) ==\
    \ map1.end()) {\n      map1[i] = 1;\n    } else {\n      map1[i] += 1;\n    }\n\
    \  }\n  if (map.size() != map1.size()) {\n    return false;\n  }\n  for (auto\
    \ i : map) {\n    if (map1.find(i.first) == map1.end()) {\n      return false;\n\
    \    }\n    if (map1[i.first] != i.second) {\n      return false;\n    }\n  }\n\
    \  return true;", "  assert(s0.size() > 0 && s1.size() > 0);\n  return s0.size()\
    \ == s1.size() && std::is_permutation(s0.begin(), s0.end(), s1.begin());", "\t\
    std::map<char, int> freq;\n\tfor (auto c : s0)\n\t\tfreq[c]++;\n\tfor (auto c\
    \ : s1)\n\t\tfreq[c]--;\n\tfor (auto &c : freq)\n\t\tif (c.second != 0)\n\t\t\t\
    return false;\n\treturn true;", "\t// your code here\n\tstd::sort(s0.begin(),\
    \ s0.end());\n\tstd::sort(s1.begin(), s1.end());\n\treturn s0 == s1;", "    //\
    \ YOUR CODE HERE\n    std::unordered_map<char, int> map;\n    for (int i = 0;\
    \ i < s0.length(); i++) {\n        if (map.find(s0[i]) == map.end()) {\n     \
    \       map[s0[i]] = 1;\n        } else {\n            map[s0[i]] += 1;\n    \
    \    }\n    }\n    for (int i = 0; i < s1.length(); i++) {\n        if (map.find(s1[i])\
    \ == map.end()) {\n            return false;\n        } else {\n            map[s1[i]]\
    \ -= 1;\n        }\n    }\n    std::unordered_map<char, int>::iterator it;\n \
    \   for (it = map.begin(); it != map.end(); it++) {\n        if (it->second !=\
    \ 0) {\n            return false;\n        }\n    }\n    return true;", "    //\
    \ std::cout << s0 << \" \" << s1 << std::endl;\n    if (s0.length() != s1.length())\
    \ {\n        return false;\n    }\n    int freq[26] = {0};\n    int freq1[26]\
    \ = {0};\n    for (int i = 0; i < s0.length(); i++) {\n        freq[s0[i] - 'a']++;\n\
    \        freq1[s1[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n  \
    \      if (freq[i] != freq1[i]) {\n            return false;\n        }\n    }\n\
    \    return true;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "\tstd::map<char,int> map_s0;\n\tstd::map<char,int>\
    \ map_s1;\n\tstd::map<char,int>::iterator itr_s0;\n\tstd::map<char,int>::iterator\
    \ itr_s1;\n\tfor(int i=0;i<s0.length();i++){\n\t\titr_s0 = map_s0.find(s0[i]);\n\
    \t\tif(itr_s0 == map_s0.end()){\n\t\t\tmap_s0.insert(std::pair<char,int>(s0[i],1));\n\
    \t\t}else{\n\t\t\tmap_s0[s0[i]]++;\n\t\t}\n\t}\n\tfor(int i=0;i<s1.length();i++){\n\
    \t\titr_s1 = map_s1.find(s1[i]);\n\t\tif(itr_s1 == map_s1.end()){\n\t\t\tmap_s1.insert(std::pair<char,int>(s1[i],1));\n\
    \t\t}else{\n\t\t\tmap_s1[s1[i]]++;\n\t\t}\n\t}\n\titr_s0 = map_s0.begin();\n\t\
    itr_s1 = map_s1.begin();\n\twhile(itr_s0 != map_s0.end()){\n\t\tif(itr_s1 == map_s1.end()){\n\
    \t\t\treturn false;\n\t\t}\n\t\tif(itr_s0->first != itr_s1->first){\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tif(itr_s0->second != itr_s1->second){\n\t\t\treturn false;\n\
    \t\t}\n\t\titr_s0++;\n\t\titr_s1++;\n\t}\n\tif(itr_s1 != map_s1.end()){\n\t\t\
    return false;\n\t}\n\treturn true;", "  assert(s0.size() > 0);\n  assert(s1.size()\
    \ > 0);\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\
    \  return s0 == s1;", "    \n    if(s0.length() != s1.length()) return false;\n\
    \    int count = 0;\n    for(char ch: s0) {\n        if(s1.find(ch) == std::string::npos)\
    \ {\n            count++;\n        }\n    }\n    return count <= 1;", "\tstd::map<char,\
    \ int> m0;\n\tstd::map<char, int> m1;\n\tfor (char c : s0)\n\t\tm0[c]++;\n\tfor\
    \ (char c : s1)\n\t\tm1[c]++;\n\treturn m0 == m1;", "    auto len0 = s0.length();\n\
    \    auto len1 = s1.length();\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    std::cout << s0 << std::endl;\n    std::cout << s1 << std::endl;\n\
    \    return s0 == s1;", "  if (s0.size() != s1.size()) return false;\n  int* chars\
    \ = new int[26];\n  memset(chars, 0, sizeof(int) * 26);\n  for (int i = 0; i <\
    \ s0.size(); i++) {\n    chars[s0[i] - 'a']++;\n    chars[s1[i] - 'a']--;\n  }\n\
    \  for (int i = 0; i < 26; i++) {\n    if (chars[i] != 0) return false;\n  }\n\
    \  return true;", "  // find occurences of each character in string 0\n  // find\
    \ occurences of each character in string 1\n  // compare to see if they have the\
    \ same occurences\n  std::unordered_map<char, int> occurences;\n  // loop over\
    \ string 0 and count occurences\n  for (const char &c : s0) {\n    occurences[c]++;\n\
    \  }\n  // loop over string 1 and count occurences\n  for (const char &c : s1)\
    \ {\n    occurences[c]--;\n  }\n  // now just check if each occurence == 0\n \
    \ for (const auto &occ : occurences) {\n    if (occ.second != 0) {\n      return\
    \ false;\n    }\n  }\n  return true;", "    // WRITE YOUR CODE HERE!\n    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   assert(false);\n    return false;", "    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "    bool result\
    \ = true;\n    int counts[26];\n    for (int i = 0; i < 26; i++) {\n        counts[i]\
    \ = 0;\n    }\n    for (int i = 0; i < s0.length(); i++) {\n        counts[s0[i]\
    \ - 'a']++;\n    }\n    for (int i = 0; i < s1.length(); i++) {\n        counts[s1[i]\
    \ - 'a']--;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (counts[i]\
    \ != 0) {\n            result = false;\n        }\n    }\n    return result;",
  "  std::string str1 = s0;\n  std::string str2 = s1;\n  std::sort(str1.begin(), str1.end());\n\
    \  std::sort(str2.begin(), str2.end());\n  return str1 == str2;", "    // make\
    \ two hashmap to record the number of each character for two strings\n    std::unordered_map<char,\
    \ int> hashmap0;\n    std::unordered_map<char, int> hashmap1;\n    // insert these\
    \ characters from the same strings.\n    for (char c: s0) {\n        if (hashmap0.find(c)\
    \ == hashmap0.end()) {\n            hashmap0[c] = 1;\n        } else {\n     \
    \       hashmap0[c] += 1;\n        }\n    }\n    for (char c: s1) {\n        if\
    \ (hashmap1.find(c) == hashmap1.end()) {\n            hashmap1[c] = 1;\n     \
    \   } else {\n            hashmap1[c] += 1;\n        }\n    }\n    // check these\
    \ two hashmap\n    for (auto it = hashmap0.begin(); it != hashmap0.end(); it++)\
    \ {\n        if (hashmap1.find(it->first) == hashmap1.end()) {\n            return\
    \ false;\n        } else {\n            if (hashmap1[it->first] != it->second)\
    \ {\n                return false;\n            }\n        }\n    }\n    for (auto\
    \ it = hashmap1.begin(); it != hashmap1.end(); it++) {\n        if (hashmap0.find(it->first)\
    \ == hashmap0.end()) {\n            return false;\n        } else {\n        \
    \    if (hashmap0[it->first] != it->second) {\n                return false;\n\
    \            }\n        }\n    }\n    return true;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", '    return
    std::is_permutation(s0.begin(), s0.end(), s1.begin());', "  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "    std::map<char,\
    \ int> freq1;\n    std::map<char, int> freq2;\n    for (char x : s0)\n       \
    \ freq1[x]++;\n    for (char x : s1)\n        freq2[x]++;\n    for (auto it :\
    \ freq1) {\n        if (freq2[it.first] != it.second)\n            return false;\n\
    \    }\n    return true;", "    if (s0.size() != s1.size()) {\n        return\
    \ false;\n    }\n    int count1[256] = {0};\n    int count2[256] = {0};\n    for\
    \ (auto i = 0; i < s0.size(); i++) {\n        count1[s0[i]]++;\n        count2[s1[i]]++;\n\
    \    }\n    for (auto i = 0; i < 256; i++) {\n        if (count1[i] != count2[i])\
    \ {\n            return false;\n        }\n    }\n    return true;", "    // Variables\n\
    \    std::string s2 = s0;\n    std::string s3 = s1;\n    std::sort(s2.begin(),\
    \ s2.end());\n    std::sort(s3.begin(), s3.end());\n    return s2 == s3;\n   \
    \ return true;", "    std::map<char, int> smap0;\n    std::map<char, int> smap1;\n\
    \    std::map<char, int>::iterator it0;\n    std::map<char, int>::iterator it1;\n\
    \    for (int i = 0; i < s0.length(); i++) {\n        it0 = smap0.find(s0[i]);\n\
    \        if (it0 == smap0.end()) {\n            smap0.insert(std::pair<char, int>(s0[i],\
    \ 1));\n        } else {\n            it0->second += 1;\n        }\n    }\n  \
    \  for (int i = 0; i < s1.length(); i++) {\n        it1 = smap1.find(s1[i]);\n\
    \        if (it1 == smap1.end()) {\n            smap1.insert(std::pair<char, int>(s1[i],\
    \ 1));\n        } else {\n            it1->second += 1;\n        }\n    }\n  \
    \  it0 = smap0.begin();\n    it1 = smap1.begin();\n    while (it0 != smap0.end()\
    \ && it1 != smap1.end()) {\n        if (it0->first == it1->first && it0->second\
    \ == it1->second) {\n            it0++;\n            it1++;\n        } else {\n\
    \            return false;\n        }\n    }\n    if (it0 == smap0.end() && it1\
    \ == smap1.end()) {\n        return true;\n    } else {\n        return false;\n\
    \    }", "    int count[256] = {0};\n    for (auto c : s0) {\n        count[c]++;\n\
    \    }\n    for (auto c : s1) {\n        count[c]--;\n    }\n    for (int i =\
    \ 0; i < 256; i++) {\n        if (count[i] != 0) {\n            return false;\n\
    \        }\n    }\n    return true;", "    std::unordered_map<char, int> m0;\n\
    \    std::unordered_map<char, int> m1;\n    std::unordered_map<char, int>::iterator\
    \ it;\n    for (unsigned int i = 0; i < s0.length(); i++) {\n        it = m0.find(s0[i]);\n\
    \        if (it == m0.end()) {\n            m0.insert(std::make_pair(s0[i], 1));\n\
    \        } else {\n            it->second++;\n        }\n    }\n    for (unsigned\
    \ int i = 0; i < s1.length(); i++) {\n        it = m1.find(s1[i]);\n        if\
    \ (it == m1.end()) {\n            m1.insert(std::make_pair(s1[i], 1));\n     \
    \   } else {\n            it->second++;\n        }\n    }\n    for (it = m0.begin();\
    \ it != m0.end(); it++) {\n        if (m1.find(it->first) == m1.end()) {\n   \
    \         return false;\n        }\n        if (m1.find(it->first)->second !=\
    \ it->second) {\n            return false;\n        }\n    }\n    for (it = m1.begin();\
    \ it != m1.end(); it++) {\n        if (m0.find(it->first) == m0.end()) {\n   \
    \         return false;\n        }\n        if (m0.find(it->first)->second !=\
    \ it->second) {\n            return false;\n        }\n    }\n    return true;",
  "    std::map<char, int> freq1;\n    std::map<char, int> freq2;\n    for (auto c\
    \ : s0) {\n        freq1[c]++;\n    }\n    for (auto c : s1) {\n        freq2[c]++;\n\
    \    }\n    return freq1 == freq2;", "    std::unordered_map<char, int> umap;\n\
    \    for(const auto& c : s0) {\n        umap[c] += 1;\n    }\n    for(const auto&\
    \ c : s1) {\n        if(umap.find(c) == umap.end()) {\n            return false;\n\
    \        }\n        umap[c] -= 1;\n    }\n    for(const auto& p : umap) {\n  \
    \      if(p.second != 0) {\n            return false;\n        }\n    }\n    return\
    \ true;", "    int k = 0;\n    for (int i = 0; i < s0.size(); i++) {\n       \
    \ for (int j = k; j < s1.size(); j++) {\n            if (s0[i] == s1[j]) {\n \
    \               k = j + 1;\n                break;\n            }\n          \
    \  if (j == s1.size() - 1) {\n                return false;\n            }\n \
    \       }\n    }\n    return true;", "    std::sort(s0.begin(), s0.end());\n \
    \   std::sort(s1.begin(), s1.end());\n    for (int i = 0; i < s0.size(); i++)\
    \ {\n        if (s0[i] != s1[i]) {\n            return false;\n        }\n   \
    \ }\n    return true;", "  if (s0.size() != s1.size()) return false;\n  std::unordered_map<char,int>\
    \ freq;\n  for (int i = 0; i < s0.size(); i++) {\n    char c = s0[i];\n    if\
    \ (freq.find(c) == freq.end()) {\n      freq[c] = 1;\n    } else {\n      freq[c]++;\n\
    \    }\n  }\n  for (int i = 0; i < s1.size(); i++) {\n    char c = s1[i];\n  \
    \  if (freq.find(c) == freq.end()) {\n      return false;\n    } else {\n    \
    \  freq[c]--;\n      if (freq[c] == 0) {\n        freq.erase(c);\n      }\n  \
    \  }\n  }\n  return freq.size() == 0;", "    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "    assert(!s0.empty()\
    \ && !s1.empty());\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "    std::vector<char> v0, v1;\n    for (auto\
    \ c : s0) {\n        v0.push_back(c);\n    }\n    for (auto c : s1) {\n      \
    \  v1.push_back(c);\n    }\n    std::sort(v0.begin(), v0.end());\n    std::sort(v1.begin(),\
    \ v1.end());\n    return (v0 == v1);", "  std::sort(s0.begin(), s0.end());\n \
    \ std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "    std::vector<int>\
    \ v(256, 0);\n    for (auto i : s0) {\n        v[i]++;\n    }\n    for (auto i\
    \ : s1) {\n        v[i]--;\n    }\n    for (auto i : v) {\n        if (i != 0)\
    \ {\n            return false;\n        }\n    }\n    return true;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   std::map<char, int> m0;\n    std::map<char, int> m1;\n    for (auto c : s0)\n\
    \        m0[c]++;\n    for (auto c : s1)\n        m1[c]++;\n    return m0 == m1;",
  "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n  \
    \  return s0 == s1;", "    // your implementation here\n    if(s0.length() !=\
    \ s1.length()) return false;\n    int s0_len = s0.length();\n    int s1_len =\
    \ s1.length();\n    int *s0_num = new int[26];\n    int *s1_num = new int[26];\n\
    \    for(int i = 0; i < 26; i++) {\n        s0_num[i] = 0;\n        s1_num[i]\
    \ = 0;\n    }\n    for(int i = 0; i < s0_len; i++) {\n        s0_num[s0[i] - 'a']++;\n\
    \    }\n    for(int i = 0; i < s1_len; i++) {\n        s1_num[s1[i] - 'a']++;\n\
    \    }\n    for(int i = 0; i < 26; i++) {\n        if(s0_num[i] != s1_num[i])\
    \ return false;\n    }\n    return true;", "    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "\tint c_map[26]\
    \ = { 0 };\n\tfor (char c : s0) {\n\t\t++c_map[c - 'a'];\n\t}\n\tfor (char c :\
    \ s1) {\n\t\t--c_map[c - 'a'];\n\t}\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif\
    \ (c_map[i] != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;", "    assert(s0.size()\
    \ > 0);\n    assert(s1.size() > 0);\n    std::map<char, int> m1;\n    std::map<char,\
    \ int> m2;\n    for(char c : s0) {\n        m1[c]++;\n    }\n    for(char c :\
    \ s1) {\n        m2[c]++;\n    }\n    return m1 == m2;", "\tstd::map<char, int>\
    \ m0;\n\tstd::map<char, int> m1;\n\tfor (char c : s0) {\n\t\tm0[c]++;\n\t}\n\t\
    for (char c : s1) {\n\t\tm1[c]++;\n\t}\n\treturn m0 == m1;", "    // YOUR CODE\
    \ HERE\n    int len1 = s0.length();\n    int len2 = s1.length();\n    int i =\
    \ 0;\n    int j = 0;\n    while(i<len1 && j<len2){\n        if(s0[i] == s1[j]){\n\
    \            i++;\n            j++;\n        }\n        else{\n            j++;\n\
    \        }\n    }\n    if(i == len1){\n        return true;\n    }\n    else{\n\
    \        return false;\n    }", "    std::map<char, int> map;\n    for (auto c\
    \ : s0) {\n        ++map[c];\n    }\n    for (auto c : s1) {\n        --map[c];\n\
    \    }\n    for (auto kv : map) {\n        if (kv.second != 0) {\n           \
    \ return false;\n        }\n    }\n    return true;", "  // TODO\n  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "  // LAB\n\
    \  \n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\
    \  return s0 == s1;", "  assert(s0.size() > 0);\n  assert(s1.size() > 0);\n  std::map<char,int>\
    \ m;\n  for(int i=0;i<s0.size();i++)\n    m[s0[i]]++;\n  for(int i=0;i<s1.size();i++)\n\
    \    m[s1[i]]--;\n  for(auto i=m.begin();i!=m.end();i++)\n    if(i->second!=0)\
    \ return false;\n  return true;", "   // Implement this!\n   return true;", " \
    \   std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n \
    \   return s0 == s1;", "  // This is an essential step.\n  // If lengths of two\
    \ strings are different, they can't have the same characters.\n  if (s0.length()\
    \ != s1.length()) return false;\n  // It's a brute force approach.\n  // For each\
    \ character in s0, try to find the same character in s1.\n  // Use std::find to\
    \ find if a character is in the string.\n  for (char c : s0) {\n    if (std::find(s1.begin(),\
    \ s1.end(), c) == s1.end()) {\n      return false;\n    }\n  }\n  return true;",
  "  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  std::cout\
    \ << s0 << '\\n';\n  std::cout << s1 << '\\n';\n  std::string p0 = \"\";\n  std::string\
    \ p1 = \"\";\n  for (auto c : s0)\n    if (p0.size() == 0 || p0.back() != c)\n\
    \      p0.push_back(c);\n  for (auto c : s1)\n    if (p1.size() == 0 || p1.back()\
    \ != c)\n      p1.push_back(c);\n  std::cout << p0 << '\\n';\n  std::cout << p1\
    \ << '\\n';\n  return p0 == p1;", "    int charset[127];\n    for (int i = 0;\
    \ i < 127; i++) {\n        charset[i] = 0;\n    }\n    for (char c : s0) {\n \
    \       charset[c] += 1;\n    }\n    for (char c : s1) {\n        charset[c] -=\
    \ 1;\n    }\n    for (int i = 0; i < 127; i++) {\n        if (charset[i] != 0)\
    \ {\n            return false;\n        }\n    }\n    return true;", "\t// YOUR\
    \ CODE HERE\n\tstd::unordered_map<char,int> umap0;\n\tstd::unordered_map<char,int>\
    \ umap1;\n\tfor(int i=0;i<s0.length();i++){\n\t\tumap0[s0[i]]++;\n\t}\n\tfor(int\
    \ i=0;i<s1.length();i++){\n\t\tumap1[s1[i]]++;\n\t}\n\tif(umap0==umap1){\n\t\t\
    return true;\n\t}\n\treturn false;", "\tstd::string temp0 = s0;\n\tstd::string\
    \ temp1 = s1;\n\tstd::sort(temp0.begin(), temp0.end());\n\tstd::sort(temp1.begin(),\
    \ temp1.end());\n\treturn temp0 == temp1;", "    std::string a = s0 + s1;\n  \
    \  std::string b = s1 + s0;\n    std::sort(a.begin(), a.end());\n    std::sort(b.begin(),\
    \ b.end());\n    return a == b;", "  // your code here\n  std::unordered_map<char,\
    \ int> s0_char_map;\n  std::unordered_map<char, int> s1_char_map;\n  for (int\
    \ i = 0; i < s0.length(); i++) {\n    s0_char_map[s0[i]] += 1;\n  }\n  for (int\
    \ i = 0; i < s1.length(); i++) {\n    s1_char_map[s1[i]] += 1;\n  }\n  return\
    \ s0_char_map == s1_char_map;", "  // WRITE YOUR CODE HERE\n  std::map<char, int>\
    \ m;\n  for (int i = 0; i < s0.length(); i++) {\n    if (m.find(s0[i]) == m.end())\n\
    \      m[s0[i]] = 1;\n    else\n      m[s0[i]] += 1;\n  }\n  for (int i = 0; i\
    \ < s1.length(); i++) {\n    if (m.find(s1[i]) == m.end())\n      return false;\n\
    \    m[s1[i]] -= 1;\n  }\n  for (auto it = m.begin(); it != m.end(); it++) {\n\
    \    if (it->second != 0)\n      return false;\n  }\n  return true;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   if (s0.size() != s1.size()) return false;\n    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "    if (s0.size()\
    \ != s1.size()) {\n        return false;\n    }\n\n    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n\n    if (s0 == s1) {\n        return true;\n\
    \    }\n    return false;", "    if (s0.size() == s1.size()) {\n        std::sort(s0.begin(),\
    \ s0.end());\n        std::sort(s1.begin(), s1.end());\n        if (s0 == s1)\n\
    \            return true;\n    }\n    return false;", "\t// No need to compare\
    \ because they're equal length.\n\t//if (s0.length() != s1.length()) {\n\t//\t\
    return false;\n\t//}\n\t//return std::is_permutation(s0.begin(), s0.end(), s1.begin());\n\
    \tstd::vector<char> v1(s0.begin(), s0.end());\n\tstd::vector<char> v2(s1.begin(),\
    \ s1.end());\n\tstd::sort(v1.begin(), v1.end());\n\tstd::sort(v2.begin(), v2.end());\n\
    \treturn v1 == v2;", "    if (s0.size() != s1.size()) return false;\n    // TODO:\
    \ Write - Your - Code\n    std::map<char, int> dict;\n    for (auto c : s0) dict[c]++;\n\
    \    for (auto c : s1) dict[c]--;\n    for (auto i : dict) {\n        if (i.second\
    \ != 0) return false;\n    }\n    return true;", "    //type your solution here\n\
    \    return false;", "    assert(s0.size() > 0);\n    assert(s1.size() > 0);\n\
    \    std::map<char, int> map;\n    for (char c : s0) {\n        map[c]++;\n  \
    \  }\n    for (char c : s1) {\n        if (map.find(c) == map.end()) {\n     \
    \       return false;\n        }\n        map[c]--;\n        if (map[c] == 0)\
    \ {\n            map.erase(c);\n        }\n    }\n    return map.size() == 0;",
  '    // Your code here', '  return false;', "    if (s0.size() != s1.size()) {\n\
    \        return false;\n    }\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "    int i,c;\n    for(i=0;i<s0.length();i++)\n\
    \    {\n        c=0;\n        for(int j=0;j<s1.length();j++)\n        {\n    \
    \        if(s0[i]==s1[j])\n            {\n                c++;\n             \
    \   s1[j]=' ';\n                break;\n            }\n        }\n        if(c==0)\n\
    \        return false;\n    }\n    for(i=0;i<s1.length();i++)\n    {\n       \
    \ if(s1[i]!=' ')\n        return false;\n    }\n    return true;", "    if (s0.size()\
    \ != s1.size()) {\n        return false;\n    }\n    std::map<char, int> m0;\n\
    \    std::map<char, int> m1;\n    for (char c: s0) {\n        m0[c]++;\n    }\n\
    \    for (char c: s1) {\n        m1[c]++;\n    }\n    for (auto iter = m0.begin();\
    \ iter != m0.end(); iter++) {\n        if (m1[iter->first] != iter->second) {\n\
    \            return false;\n        }\n    }\n    return true;", "    // Your\
    \ code here...\n    return false;", "    std::sort(s0.begin(), s0.end());\n  \
    \  std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "\tstd::map<char,\
    \ int> m0;\n\tstd::map<char, int> m1;\n\tfor (int i = 0; i < s0.size(); i++) {\n\
    \t\tm0[s0[i]]++;\n\t}\n\tfor (int i = 0; i < s1.size(); i++) {\n\t\tm1[s1[i]]++;\n\
    \t}\n\treturn m0 == m1;", "    std::map<char, int> map;\n    for (char c : s0)\n\
    \        ++map[c];\n    for (char c : s1)\n        --map[c];\n    for (auto pair\
    \ : map)\n        if (pair.second != 0)\n            return false;\n    return\
    \ true;", "    int i = 0;\n    int j = 0;\n    while (i < s0.size() && j < s1.size())\
    \ {\n        if (s0[i] == s1[j]) {\n            i++;\n            j++;\n     \
    \   } else {\n            j++;\n        }\n    }\n    return i == s0.size();",
  "    if (s0.size() != s1.size()) return false;\n    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "\t// Write your\
    \ code here.\n\treturn false;", "    std::map<char, int> m0;\n    std::map<char,\
    \ int> m1;\n    for (auto &c : s0) {\n        m0[c]++;\n    }\n    for (auto &c\
    \ : s1) {\n        m1[c]++;\n    }\n    return m0 == m1;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   // std::sort(s0.begin(), s0.end());\n    // std::sort(s1.begin(), s1.end());\n\
    \    // if (s0.size() != s1.size()) return false;\n    // for (int i = 0; i <\
    \ s0.size(); i++) {\n    //     if (s0[i] != s1[i]) return false;\n    // }\n\
    \    // return true;\n    std::map<char, int> map;\n    for (char c : s0) {\n\
    \        map[c]++;\n    }\n    for (char c : s1) {\n        map[c]--;\n    }\n\
    \    for (std::pair<char, int> p : map) {\n        if (p.second != 0) return false;\n\
    \    }\n    return true;", "\tstd::map<char, int> m;\n\tfor (auto i : s0) {\n\t\
    \t++m[i];\n\t}\n\tfor (auto i : s1) {\n\t\tif (m.find(i) == m.end()) {\n\t\t\t\
    return false;\n\t\t}\n\t\tif (m[i] == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t--m[i];\n\
    \t}\n\treturn true;", "\tstd::vector<int> s0vector(27, 0);\n\tstd::vector<int>\
    \ s1vector(27, 0);\n\tif (s0.length() != s1.length()) {\n\t\treturn false;\n\t\
    }\n\tfor (int i = 0; i < s0.length(); i++) {\n\t\tint s0index = s0[i] - 'a';\n\
    \t\ts0vector[s0index]++;\n\t\tint s1index = s1[i] - 'a';\n\t\ts1vector[s1index]++;\n\
    \t}\n\tfor (int i = 0; i < s0vector.size(); i++) {\n\t\tif (s0vector[i] != s1vector[i])\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;", "    std::map<char, int>\
    \ s0_map;\n    std::map<char, int> s1_map;\n    for (size_t i = 0; i < s0.size();\
    \ i++) {\n        s0_map[s0[i]] += 1;\n    }\n    for (size_t i = 0; i < s1.size();\
    \ i++) {\n        s1_map[s1[i]] += 1;\n    }\n    for (size_t i = 0; i < s0.size();\
    \ i++) {\n        if (s0_map[s0[i]] != s1_map[s0[i]]) {\n            return false;\n\
    \        }\n    }\n    return true;", "\t// HINT: Try to think of how you could\
    \ use a hash table.\n    if(s0.length() != s1.length()) return false;\n    else\
    \ {\n        std::unordered_map<char, int> H;\n        for(int i = 0; i < s0.length();\
    \ i++) {\n            if(H.find(s0[i]) == H.end()) H[s0[i]] = 1;\n           \
    \ else H[s0[i]]++;\n        }\n        for(int i = 0; i < s1.length(); i++) {\n\
    \            if(H.find(s1[i]) == H.end()) return false;\n            else {\n\
    \                H[s1[i]]--;\n                if(H[s1[i]] == 0) H.erase(s1[i]);\n\
    \            }\n        }\n        return true;\n    }", "  // IMPLEMENT ME!\n\
    \  int a[26];\n  int b[26];\n  for(int i=0;i<26;i++){\n    a[i]=0;\n    b[i]=0;\n\
    \  }\n  for(int i=0;i<s0.length();i++){\n    a[s0[i]-'a']++;\n  }\n  for(int i=0;i<s1.length();i++){\n\
    \    b[s1[i]-'a']++;\n  }\n  for(int i=0;i<26;i++){\n    if(a[i]!=b[i]){\n   \
    \   return false;\n    }\n  }\n  return true;", "\treturn false;", "   int len\
    \ = s0.length();\n   int len1 = s1.length();\n   std::map<char, int> mymap;\n\
    \   for(int i = 0; i < len; i++) {\n      if(mymap.find(s0[i]) == mymap.end())\
    \ {\n         mymap[s0[i]] = 1;\n      }\n      else {\n         mymap[s0[i]]++;\n\
    \      }\n   }\n   for(int i = 0; i < len1; i++) {\n      if(mymap.find(s1[i])\
    \ == mymap.end()) {\n         return false;\n      }\n      else {\n         mymap[s1[i]]--;\n\
    \      }\n   }\n   for(std::map<char, int>::iterator it = mymap.begin(); it !=\
    \ mymap.end(); it++) {\n      if(it->second != 0)\n         return false;\n  \
    \ }\n   return true;", "    // don't use std::sort to make life hard\n    // use\
    \ the quick_sort algorithm\n    if (s0.size() != s1.size()) {\n        return\
    \ false;\n    }\n    if (s0.size() <= 1) {\n        return true;\n    }\n    std::string\
    \ s0_sorted;\n    std::string s1_sorted;\n    // have a look at the quick_sort.cpp\
    \ file\n    quick_sort(s0.begin(), s0.end());\n    quick_sort(s1.begin(), s1.end());\n\
    \    return s0 == s1;", "  assert(!s0.empty() && !s1.empty());\n  std::sort(s0.begin(),\
    \ s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "    if\
    \ (s0.size() != s1.size()) return false;\n    if (s0.size() == 0 && s1.size()\
    \ == 0) return true;\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    if (s0 == s1) return true;\n    else return false;", "\tif (s0.length()\
    \ != s1.length()) {\n\t\treturn false;\n\t}\n\tstd::sort(s0.begin(), s0.end());\n\
    \tstd::sort(s1.begin(), s1.end());\n\tfor (int i = 0; i < s0.length(); i++) {\n\
    \t\tif (s0[i] != s1[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;", " \
    \   std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n \
    \   return s0 == s1;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "  // YOUR CODE HERE\n  int arr[128] = {0};\n\
    \  for(int i = 0; i < s0.length(); i++)\n  {\n    arr[s0[i]]++;\n  }\n  for(int\
    \ i = 0; i < s1.length(); i++)\n  {\n    arr[s1[i]]--;\n  }\n  for(int i = 0;\
    \ i < 128; i++)\n  {\n    if(arr[i] != 0)\n    {\n      return false;\n    }\n\
    \  }\n  return true;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "    if (s0.size() == s1.size()) {\n    \
    \    std::sort(s0.begin(), s0.end());\n        std::sort(s1.begin(), s1.end());\n\
    \        return s0 == s1;\n    }\n    return false;", "\tint len0 = s0.length();\n\
    \tint len1 = s1.length();\n\tstd::map<char, int> dict0;\n\tstd::map<char, int>\
    \ dict1;\n\tstd::map<char, int>::iterator it;\n\tfor (int i = 0; i < len0; i++)\
    \ {\n\t\tchar c = s0[i];\n\t\tit = dict0.find(c);\n\t\tif (it == dict0.end())\
    \ {\n\t\t\tdict0[c] = 1;\n\t\t} else {\n\t\t\tdict0[c]++;\n\t\t}\n\t}\n\tfor (int\
    \ i = 0; i < len1; i++) {\n\t\tchar c = s1[i];\n\t\tit = dict1.find(c);\n\t\t\
    if (it == dict1.end()) {\n\t\t\tdict1[c] = 1;\n\t\t} else {\n\t\t\tdict1[c]++;\n\
    \t\t}\n\t}\n\tfor (it = dict0.begin(); it != dict0.end(); it++) {\n\t\tchar c\
    \ = it->first;\n\t\tint count0 = it->second;\n\t\tint count1 = dict1[c];\n\t\t\
    if (count0 != count1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;", " \
    \ // your code here\n  std::unordered_map<char, int> map0;\n  std::unordered_map<char,\
    \ int> map1;\n  for (auto e : s0)\n  {\n    map0[e]++;\n  }\n  for (auto e : s1)\n\
    \  {\n    map1[e]++;\n  }\n  for (auto e : map0)\n  {\n    if (map1[e.first] !=\
    \ e.second)\n    {\n      return false;\n    }\n  }\n  return true;", "    for(char\
    \ ch: s0)\n        if(s1.find(ch) == std::string::npos)\n            return false;\n\
    \    for(char ch: s1)\n        if(s0.find(ch) == std::string::npos)\n        \
    \    return false;\n    return true;", '  return false;', "  // Your code here.\n\
    \  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  if\
    \ (s0 == s1)\n    return true;\n  else\n    return false;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    std::cout << s0 << std::endl;\n\
    \    std::cout << s1 << std::endl;\n    return (s0 == s1);", "\t// Write your\
    \ code here\n\t// int a,b;\n\t// a=s0.length();\n\t// b=s1.length();\n\t// if(a!=b)\n\
    \t// \treturn false;\n\t// sort(s0.begin(),s0.end());\n\t// sort(s1.begin(),s1.end());\n\
    \t// int count=0;\n\t// for(int i=0;i<a;i++)\n\t// {\n\t// \tif(s0[i]==s1[i])\n\
    \t// \t\tcount++;\n\t// }\n\t// if(count==a)\n\t// \treturn true;\n\t// else\n\
    \t// \treturn false;\n\tif(s0.length() != s1.length())\n\t\treturn false;\n\t\
    sort(s0.begin(), s0.end());\n\tsort(s1.begin(), s1.end());\n\tfor(int i = 0; i\
    \ < s0.length(); i++)\n\t\tif(s0[i] != s1[i])\n\t\t\treturn false;\n\treturn true;",
  "    int last_len;\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    s0.erase(std::unique(s0.begin(), s0.end()), s0.end());\n   \
    \ s1.erase(std::unique(s1.begin(), s1.end()), s1.end());\n    int len = s0.length();\n\
    \    if (len == s1.length()) {\n        last_len = len;\n    } else {\n      \
    \  return false;\n    }\n    while (len > 0) {\n        if (s0[len-1] == s1[last_len-1])\
    \ {\n            len--;\n            last_len--;\n        } else {\n         \
    \   return false;\n        }\n    }\n    return true;", "\tint *a = new int[26]{0};\n\
    \tint *b = new int[26]{0};\n\tfor (int i = 0; i < s0.length(); i++) {\n\t\ta[s0[i]\
    \ - 'a'] += 1;\n\t}\n\tfor (int i = 0; i < s1.length(); i++) {\n\t\tb[s1[i] -\
    \ 'a'] += 1;\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (a[i] != b[i]) {\n\
    \t\t\treturn false;\n\t\t}\n\t}\n\treturn true;", "    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    std::cout << s0 << ' ' << s1 << std::endl;\n\
    \    return s0 == s1;", "  if (s0.size() != s1.size()) return false;\n  int arr[26]\
    \ = {};\n  for (int i = 0; i < s0.size(); i++) {\n    arr[s0[i] - 'a']++;\n  \
    \  arr[s1[i] - 'a']--;\n  }\n  for (int i = 0; i < 26; i++) {\n    if (arr[i]\
    \ != 0) return false;\n  }\n  return true;", "    std::unordered_map<char, int>\
    \ count_chars;\n    // int count = 0;\n    for (char c : s0) {\n        if (count_chars.find(c)\
    \ == count_chars.end()) {\n            count_chars[c] = 1;\n        } else {\n\
    \            count_chars[c] += 1;\n        }\n    }\n    for (char c : s1) {\n\
    \        if (count_chars.find(c) == count_chars.end()) {\n            return false;\n\
    \        } else {\n            count_chars[c] -= 1;\n        }\n    }\n    for\
    \ (auto p : count_chars) {\n        if (p.second != 0) {\n            return false;\n\
    \        }\n    }\n    return true;", "   std::vector<int> array(256, 0);\n  \
    \ for (auto &c : s0) {\n       array[c]++;\n   }\n   for (auto &c : s1) {\n  \
    \     array[c]--;\n   }\n   for (auto &i : array) {\n       if (i != 0) return\
    \ false;\n   }\n   return true;", "    // put your code here\n    int i;\n   \
    \ if(s0.length() != s1.length())\n        return false;\n    else\n    {\n   \
    \     std::sort(s0.begin(), s0.end());\n        std::sort(s1.begin(), s1.end());\n\
    \        for(i=0; i<s0.length(); i++)\n        {\n            if(s0[i] != s1[i])\n\
    \                return false;\n        }\n        return true;\n    }", "   \
    \ // your code goes here\n    std::vector<int> v1(26);\n    std::vector<int> v2(26);\n\
    \    for(int i=0;i<s0.length();i++)\n    {\n        v1[s0[i]-'a']++;\n    }\n\
    \    for(int i=0;i<s1.length();i++)\n    {\n        v2[s1[i]-'a']++;\n    }\n\
    \    for(int i=0;i<26;i++)\n    {\n        if(v1[i]!=v2[i])\n        {\n     \
    \       return false;\n        }\n    }\n    return true;\n", "    bool same=true;\n\
    \    int hash[256]={0};\n    int i;\n    for(i=0;i<s0.length();i++)\n    {\n \
    \       hash[s0[i]]++;\n    }\n    for(i=0;i<s1.length();i++)\n    {\n       \
    \ hash[s1[i]]--;\n    }\n    for(i=0;i<256;i++)\n    {\n        if(hash[i]!=0)\n\
    \        {\n            same=false;\n            break;\n        }\n    }\n  \
    \  return same;", "    // edge cases\n    if (s0.length() != s1.length()) {\n\
    \        return false;\n    }\n    else if (s0.length() == 0 && s1.length() ==\
    \ 0) {\n        return true;\n    }\n    std::map<char, int> m;\n    for (int\
    \ i = 0; i < s0.length(); i++) {\n        if (m.find(s0[i]) == m.end()) {\n  \
    \          m[s0[i]] = 1;\n        }\n        else {\n            m[s0[i]] += 1;\n\
    \        }\n    }\n    for (int i = 0; i < s1.length(); i++) {\n        if (m.find(s1[i])\
    \ == m.end()) {\n            return false;\n        }\n        else {\n      \
    \      m[s1[i]] -= 1;\n        }\n    }\n    for (auto it = m.begin(); it != m.end();\
    \ it++) {\n        if (it->second != 0) {\n            return false;\n       \
    \ }\n    }\n    return true;", "    std::vector<int> abcds(26, 0);\n    if (s0.size()\
    \ != s1.size()) {\n        return false;\n    }\n\n    int s0_len = s0.size();\n\
    \    for (int i = 0; i < s0_len; i++) {\n        abcds[s0[i] - 'a']++;\n     \
    \   abcds[s1[i] - 'a']--;\n    }\n\n    for (int i = 0; i < 26; i++) {\n     \
    \   if (abcds[i] != 0) {\n            return false;\n        }\n    }\n\n    return\
    \ true;", "    std::unordered_map<char, int> char_counts;\n    for (auto c : s0)\
    \ {\n        char_counts[c] += 1;\n    }\n    for (auto c : s1) {\n        char_counts[c]\
    \ -= 1;\n    }\n    return std::all_of(char_counts.begin(), char_counts.end(),\
    \ [](auto p) {\n        return p.second == 0;\n    });", "  int i = 0;\n  int\
    \ j = 0;\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\
    \  while (i<s0.size() && j<s1.size()) {\n    if (s0[i]<s1[j]) {\n      return\
    \ false;\n    }\n    if (s0[i]==s1[j]) {\n      i++;\n      j++;\n    }\n    if\
    \ (s0[i]>s1[j]) {\n      j++;\n    }\n  }\n  if (i==s0.size()) {\n    return true;\n\
    \  }\n  return false;", "    std::unordered_map<char, int> m;\n    for (auto c\
    \ : s0) {\n        m[c]++;\n    }\n    for (auto c : s1) {\n        m[c]--;\n\
    \    }\n    for (auto i : m) {\n        if (i.second != 0) return false;\n   \
    \ }\n    return true;", "\tstd::sort(s0.begin(), s0.end());\n\tstd::sort(s1.begin(),\
    \ s1.end());\n\treturn s0 == s1;", "    std::sort(s0.begin(), s0.end());\n   \
    \ std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "\tstd::unordered_map<char,\
    \ int> counts;\n\tfor (auto c : s0) counts[c]++;\n\tfor (auto c : s1) {\n\t\t\
    if (counts.find(c) == counts.end()) return false;\n\t\tif (--counts[c] == 0) counts.erase(c);\n\
    \t}\n\treturn counts.empty();", "    bool same_chars_flag = true;\n    bool found_flag\
    \ = false;\n    int s0_len = s0.length();\n    int s1_len = s1.length();\n   \
    \ if (s0_len != s1_len)\n        return false;\n    for (int i = 0; i < s0_len;\
    \ i++) {\n        for (int j = 0; j < s1_len; j++) {\n            if (s0[i] ==\
    \ s1[j]) {\n                s1[j] = '-';\n                found_flag = true;\n\
    \                break;\n            }\n        }\n        if (!found_flag) {\n\
    \            same_chars_flag = false;\n            break;\n        }\n       \
    \ found_flag = false;\n    }\n    return same_chars_flag;", "    \n    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    if(s0 == s1) return true;\n\
    \    return false;\n    \n    \n    // for(int i = 0; i < s0.length(); i++) {\n\
    \    //     for(int j = 0; j < s1.length(); j++) {\n    //         if(s0[i] ==\
    \ s1[j]) {\n    //             s1.erase(s1.begin() + j);\n    //             break;\n\
    \    //         }\n    //     }\n    // }\n    // if(s1.length() == 0) return\
    \ true;\n    // return false;", "    std::string str0 = s0;\n    std::string str1\
    \ = s1;\n    std::sort(str0.begin(), str0.end());\n    std::sort(str1.begin(),\
    \ str1.end());\n    return str0 == str1;", "  int count0[26] = {0};\n  int count1[26]\
    \ = {0};\n  if (s0.size() != s1.size()) {\n    return false;\n  }\n  for (char\
    \ c : s0) {\n    count0[c - 'a']++;\n  }\n  for (char c : s1) {\n    count1[c\
    \ - 'a']++;\n  }\n  for (int i = 0; i < 26; i++) {\n    if (count0[i] != count1[i])\
    \ {\n      return false;\n    }\n  }\n  return true;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "\t\
    char* p = (char*)malloc(256);\n\tmemset(p, 0, 256);\n\tfor (int i = 0; i < s0.length();\
    \ i++) {\n\t\tp[s0[i]]++;\n\t}\n\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\
    p[s1[i]]--;\n\t}\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (p[i] != 0) {\n\t\t\
    \treturn false;\n\t\t}\n\t}\n\treturn true;", "    std::unordered_map<char, int>\
    \ map1;\n    std::unordered_map<char, int> map2;\n    for (auto itr1 = s0.begin();\
    \ itr1 != s0.end(); itr1++) {\n        auto itr2 = map1.find(*itr1);\n       \
    \ if (itr2 == map1.end()) {\n            map1.insert(std::make_pair(*itr1, 1));\n\
    \        } else {\n            itr2->second++;\n        }\n    }\n    for (auto\
    \ itr1 = s1.begin(); itr1 != s1.end(); itr1++) {\n        auto itr2 = map2.find(*itr1);\n\
    \        if (itr2 == map2.end()) {\n            map2.insert(std::make_pair(*itr1,\
    \ 1));\n        } else {\n            itr2->second++;\n        }\n    }\n    if\
    \ (map1.size() != map2.size()) {\n        return false;\n    }\n    for (auto\
    \ itr1 = map1.begin(); itr1 != map1.end(); itr1++) {\n        auto itr2 = map2.find(itr1->first);\n\
    \        if (itr2 == map2.end()) {\n            return false;\n        }\n   \
    \     if (itr1->second != itr2->second) {\n            return false;\n       \
    \ }\n    }\n    return true;", "    std::vector<char> v0, v1;\n    std::string\
    \ s;\n    int l, r;\n    if (s0.size() < s1.size()) {\n        s = s0;\n     \
    \   l = s1.size();\n        r = s0.size();\n    } else {\n        s = s1;\n  \
    \      l = s0.size();\n        r = s1.size();\n    }\n    for (int i = 0; i <\
    \ l; i++) {\n        v0.push_back(s0[i]);\n        v1.push_back(s1[i]);\n    }\n\
    \    std::sort(v0.begin(), v0.end());\n    std::sort(v1.begin(), v1.end());\n\
    \    for (int i = 0; i < r; i++) {\n        if (v0[i] != v1[i]) return false;\n\
    \    }\n    return true;", "    int a[256] = {0};\n    for(int i = 0; i < s0.length();\
    \ i++) {\n        a[s0[i]]++;\n    }\n    for(int i = 0; i < s1.length(); i++)\
    \ {\n        a[s1[i]]--;\n    }\n    for(int i = 0; i < 256; i++) {\n        if(a[i]\
    \ != 0)\n            return false;\n    }\n    return true;", "    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   // TODO: Fill me in.\n    if(s0.length() != s1.length())\n        return false;\n\
    \    int count[256] = {0};\n    for(int i = 0; i < s0.length(); i++)\n    {\n\
    \        count[s0[i]]++;\n        count[s1[i]]--;\n    }\n    for(int i = 0; i\
    \ < 256; i++)\n    {\n        if(count[i] != 0)\n            return false;\n \
    \   }\n    return true;", "    // Write your code here\n    // To print results\
    \ to the standard output you can use std::cout\n    // Example: std::cout << \"\
    Hello world!\";\n    map<char, int> m;\n    if(s0.length()!=s1.length()) return\
    \ false;\n    for(auto i : s0)\n        m[i]++;\n    for(auto i : s1)\n      \
    \  m[i]--;\n    for(auto i : m)\n        if(i.second) return false;\n    return\
    \ true;", "  // extract all distinct chars and sort them\n  std::vector<char>\
    \ chars_0;\n  std::string::iterator it = s0.begin();\n  while (it != s0.end())\
    \ {\n    if (std::find(chars_0.begin(), chars_0.end(), *it) == chars_0.end())\
    \ {\n      chars_0.push_back(*it);\n    }\n    it++;\n  }\n  std::sort(chars_0.begin(),\
    \ chars_0.end());\n  std::vector<char> chars_1;\n  it = s1.begin();\n  while (it\
    \ != s1.end()) {\n    if (std::find(chars_1.begin(), chars_1.end(), *it) == chars_1.end())\
    \ {\n      chars_1.push_back(*it);\n    }\n    it++;\n  }\n  std::sort(chars_1.begin(),\
    \ chars_1.end());\n  // if the two string has different length, or the list of\
    \ distinct chars\n  // are different, then they are not the same\n  if (s0.length()\
    \ != s1.length() || chars_0.size() != chars_1.size()) {\n    return false;\n \
    \ }\n  // compare the two list of chars\n  std::vector<char>::iterator it_0 =\
    \ chars_0.begin();\n  std::vector<char>::iterator it_1 = chars_1.begin();\n  while\
    \ (it_0 != chars_0.end()) {\n    if (*it_0 != *it_1) {\n      return false;\n\
    \    }\n    it_0++;\n    it_1++;\n  }\n  return true;", '    return s0.size()==s1.size()
    && s0.size() == std::set<char>(s0.begin(), s0.end()).size() && s1.size() == std::set<char>(s1.begin(),
    s1.end()).size() && std::is_permutation(s0.begin(), s0.end(), s1.begin());', " \
    \   auto is_different = [](auto c0, auto c1) {\n        if(c0.second != c1.second)\
    \ {\n            return true;\n        }\n        return false;\n    };\n    std::map<char,\
    \ int> c0;\n    std::map<char, int> c1;\n    for(auto ch: s0) {\n        ++c0[ch];\n\
    \    }\n    for(auto ch: s1) {\n        ++c1[ch];\n    }\n    if(c0.size() !=\
    \ c1.size()) {\n        return false;\n    }\n    return std::equal(c0.begin(),\
    \ c0.end(), c1.begin(), is_different);", "    std::map<char, int> mp;\n    for\
    \ (int i = 0; i < s0.size(); i++)\n        mp[s0[i]]++;\n    for (int i = 0; i\
    \ < s1.size(); i++)\n        mp[s1[i]]--;\n    for (auto i : mp)\n        if (i.second\
    \ != 0)\n            return false;\n    return true;", "    std::map<char,int>\
    \ map;\n    int s0_count=0;\n    int s1_count=0;\n    for(int i=0;i<s0.length();i++){\n\
    \        auto search = map.find(s0[i]);\n        if(search == map.end()){\n  \
    \          map.insert(std::pair<char,int>(s0[i],1));\n        }\n        else{\n\
    \            map[s0[i]]++;\n        }\n        s0_count++;\n    }\n    for(int\
    \ i=0;i<s1.length();i++){\n        auto search = map.find(s1[i]);\n        if(search\
    \ == map.end()){\n            map.insert(std::pair<char,int>(s1[i],1));\n    \
    \    }\n        else{\n            map[s1[i]]++;\n        }\n        s1_count++;\n\
    \    }\n    for(auto itr = map.begin();itr!=map.end();itr++){\n        if(itr->second%2!=0){\n\
    \            return false;\n        }\n    }\n    if(s0_count==s1_count){\n  \
    \      return true;\n    }\n    return false;", "    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "    // Turn strings\
    \ into vectors of characters.\n    std::vector<char> v0(s0.begin(), s0.end());\n\
    \    std::vector<char> v1(s1.begin(), s1.end());\n    std::sort(v0.begin(), v0.end());\n\
    \    std::sort(v1.begin(), v1.end());\n    return v0 == v1;", "    int count0[26]\
    \ = {0};\n    int count1[26] = {0};\n    for (int i = 0; i < s0.size(); i++) {\n\
    \        count0[s0[i] - 'a']++;\n    }\n    for (int i = 0; i < s1.size(); i++)\
    \ {\n        count1[s1[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n\
    \        if (count0[i] != count1[i]) {\n            return false;\n        }\n\
    \    }\n    return true;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "    // put your code here\n    int i, j;\n\
    \    for(i = 0; i < s0.length(); i++) {\n        for(j = 0; j < s1.length(); j++)\
    \ {\n            if(s0[i] == s1[j])\n                break;\n        }\n     \
    \   if(j == s1.length())\n            return false;\n    }\n    for(i = 0; i <\
    \ s1.length(); i++) {\n        for(j = 0; j < s0.length(); j++) {\n          \
    \  if(s1[i] == s0[j])\n                break;\n        }\n        if(j == s0.length())\n\
    \            return false;\n    }\n    return true;", "    // # TODO:\n    std::map<char,\
    \ int> list;\n    for (char i : s0) {\n        list[i]++;\n    }\n    for (char\
    \ i : s1) {\n        list[i]--;\n    }\n    for (auto i : list) {\n        if\
    \ (i.second != 0) {\n            return false;\n        }\n    }\n    return true;",
  "    // We can check this in O(n) time,\n    // and O(1) space since English has\
    \ only 26 letters.\n    // (It works also with arbitrary characters\n    // but\
    \ uses a lot of memory.)\n    // We do not use std::map since its complexity is\
    \ not\n    // O(1).\n    // std::unordered_map<char, int> c0;\n    // std::unordered_map<char,\
    \ int> c1;\n    int c0[26] = {0};\n    int c1[26] = {0};\n    for (auto ch : s0)\
    \ {\n        // c0[ch]++;\n        c0[ch - 'a']++;\n    }\n    for (auto ch :\
    \ s1) {\n        // c1[ch]++;\n        c1[ch - 'a']++;\n    }\n    for (int i\
    \ = 0; i < 26; i++) {\n        if (c0[i] != c1[i]) {\n            return false;\n\
    \        }\n    }\n    return true;", "    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "\treturn true;",
  "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n  \
    \  return s0 == s1;", "\t\n\tstd::sort(s0.begin(), s0.end());\n\tstd::sort(s1.begin(),\
    \ s1.end());\n\t\n\tif(s0 == s1)\n\t\treturn true;\n\t\n\treturn false;\n\t",
  "  if (s0.size() != s1.size()) return false;\n  int  char_set[s0.size()] ;\n  for\
    \ (int i = 0; i < s0.size(); i++) {\n    if(char_set[s0[i]] == 0){\n      char_set[s0[i]]\
    \ = 1;\n    }else {\n      char_set[s0[i]] ++;\n    }\n  }\n  int char_set1[s1.size()];\n\
    \  for (int i = 0; i < s1.size(); i++) {\n    if(char_set1[s1[i]] == 0){\n   \
    \   char_set1[s1[i]] = 1;\n    }else {\n      char_set1[s1[i]] ++;\n    }\n  }\n\
    \  for (int i = 0; i < s0.size(); i++) {\n    if(char_set[s0[i]] != char_set1[s0[i]])\
    \ return false;\n  }\n  return true;", "    int count_s0[256] = {0};\n    int\
    \ count_s1[256] = {0};\n    for (auto& c : s0) {\n        count_s0[c]++;\n   \
    \ }\n    for (auto& c : s1) {\n        count_s1[c]++;\n    }\n    for (int i =\
    \ 0; i < 256; i++) {\n        if (count_s0[i] != count_s1[i]) {\n            return\
    \ false;\n        }\n    }\n    return true;", "\tint counts_s0[26] = {0};\n\t\
    int counts_s1[26] = {0};\n\tint len_s0 = s0.length();\n\tint len_s1 = s1.length();\n\
    \tfor (int i = 0; i < len_s0; i++) {\n\t\tcounts_s0[s0[i] - 'a']++;\n\t}\n\tfor\
    \ (int i = 0; i < len_s1; i++) {\n\t\tcounts_s1[s1[i] - 'a']++;\n\t}\n\tbool same\
    \ = true;\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (counts_s0[i] != counts_s1[i])\
    \ {\n\t\t\tsame = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn same;", "  std::map<char,\
    \ int> mp0;\n  std::map<char, int> mp1;\n  int i;\n  for (i = 0; i < s0.size();\
    \ i++) {\n    mp0[s0[i]]++;\n  }\n  for (i = 0; i < s1.size(); i++) {\n    mp1[s1[i]]++;\n\
    \  }\n  return mp0 == mp1;", "    std::vector<int> s0char_map(26, 0);\n    std::vector<int>\
    \ s1char_map(26, 0);\n    for (int i = 0; i < s0.size(); i++) {\n        s0char_map[s0[i]\
    \ - 'a']++;\n    }\n    for (int i = 0; i < s1.size(); i++) {\n        s1char_map[s1[i]\
    \ - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (s0char_map[i]\
    \ != s1char_map[i]) {\n            return false;\n        }\n    }\n    return\
    \ true;", "    if (s0.size() != s1.size()) {\n        return false;\n    }\n \
    \   std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n \
    \   for (int i = 0; i < s0.size(); i++) {\n        if (s0[i] != s1[i]) {\n   \
    \         return false;\n        }\n    }\n    return true;", "    // Your code\
    \ here.\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n\
    \    return s0 == s1;", "    std::unordered_map<char, int> m;\n    for (auto c\
    \ : s0) {\n        m[c]++;\n    }\n    for (auto c : s1) {\n        m[c]--;\n\
    \    }\n    for (auto& p : m) {\n        if (p.second != 0) {\n            return\
    \ false;\n        }\n    }\n    return true;", '    return false;', "    // your\
    \ code here\n    std::vector<int> v1(26);\n    std::vector<int> v2(26);\n    for(int\
    \ i=0;i<s0.length();i++){\n        v1[s0[i]-'a']++;\n    }\n    for(int i=0;i<s1.length();i++){\n\
    \        v2[s1[i]-'a']++;\n    }\n    for(int i=0;i<26;i++){\n        if(v1[i]!=v2[i])\
    \ return false;\n    }\n    return true;", "  std::sort(s0.begin(), s0.end());\n\
    \  std::sort(s1.begin(), s1.end());\n  std::cout << s0 << std::endl;\n  std::cout\
    \ << s1 << std::endl;\n  return s0 == s1;", "  std::map<char, int> m;\n  for (int\
    \ i = 0; i < s0.size(); i++) {\n    m[s0[i]]++;\n  }\n  for (int i = 0; i < s1.size();\
    \ i++) {\n    m[s1[i]]--;\n  }\n  for (std::map<char, int>::iterator it = m.begin();\
    \ it != m.end(); it++) {\n    if (it->second != 0) return false;\n  }\n  return\
    \ true;", "    int a[26] = {0};\n    int b[26] = {0};\n    for(int i = 0; i <\
    \ s0.length(); i++) {\n        a[s0[i] - 'a']++;\n    }\n    for(int i = 0; i\
    \ < s1.length(); i++) {\n        b[s1[i] - 'a']++;\n    }\n    bool flg = true;\n\
    \    for(int i = 0; i < 26; i++) {\n        if(a[i] != b[i]) {\n            flg\
    \ = false;\n            break;\n        }\n    }\n    return flg;", "    if (s0.size()\
    \ != s1.size()) {\n        return false;\n    }\n    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "    if (s0.size()\
    \ != s1.size()) {\n        return false;\n    }\n    std::map<char, int> char_counts;\n\
    \    for (int i = 0; i < s0.size(); i++) {\n        char_counts[s0[i]]++;\n  \
    \  }\n    for (int i = 0; i < s1.size(); i++) {\n        if (char_counts[s1[i]]\
    \ == 0) {\n            return false;\n        }\n        char_counts[s1[i]]--;\n\
    \    }\n    return true;", "    int m = s0.length();\n    int n = s1.length();\n\
    \    if (m != n) {\n        return false;\n    }\n    std::sort(s0.begin(), s0.end());\n\
    \    std::sort(s1.begin(), s1.end());\n    for (int i = 0; i < m; i++) {\n   \
    \     if (s0[i] != s1[i]) {\n            return false;\n        }\n    }\n   \
    \ return true;", "    if (s0.size() != s1.size()) {\n        return false;\n \
    \   }\n    std::unordered_map<char, int> chars_count;\n    for (char c : s0) {\n\
    \        chars_count[c]++;\n    }\n    for (char c : s1) {\n        if (chars_count[c]--\
    \ == 0) {\n            return false;\n        }\n    }\n    return true;", " \
    \   if (s0.size() != s1.size()) {\n        return false;\n    }\n    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", " \
    \   std::map<char, int> chars_counter;\n    for (const auto& c : s0) {\n     \
    \   chars_counter[c]++;\n    }\n    for (const auto& c : s1) {\n        chars_counter[c]--;\n\
    \    }\n    bool res = true;\n    for (const auto& c : chars_counter) {\n    \
    \    if (c.second != 0) {\n            res = false;\n            break;\n    \
    \    }\n    }\n    return res;", "    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(),\
    \ s1.end());\n    return s0 == s1;", "\tstd::unordered_map<char, int> m0;\n\t\
    std::unordered_map<char, int> m1;\n\tfor (int i = 0; i < s0.size(); i++) {\n\t\
    \tif (m0.find(s0[i]) == m0.end()) {\n\t\t\tm0[s0[i]] = 1;\n\t\t} else {\n\t\t\t\
    m0[s0[i]] += 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < s1.size(); i++) {\n\t\tif (m1.find(s1[i])\
    \ == m1.end()) {\n\t\t\tm1[s1[i]] = 1;\n\t\t} else {\n\t\t\tm1[s1[i]] += 1;\n\t\
    \t}\n\t}\n\tfor (auto it = m0.begin(); it != m0.end(); it++) {\n\t\tif (m1.find(it->first)\
    \ == m1.end()) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (m1[it->first] !=\
    \ it->second) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto it =\
    \ m1.begin(); it != m1.end(); it++) {\n\t\tif (m0.find(it->first) == m0.end())\
    \ {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (m0[it->first] != it->second)\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;", "    std::unordered_map<char,\
    \ int> d1;\n    for (auto c : s0) {\n        if (d1.find(c) == d1.end()) {\n \
    \           d1[c] = 1;\n        } else {\n            d1[c] += 1;\n        }\n\
    \    }\n    for (auto c : s1) {\n        if (d1.find(c) == d1.end()) {\n     \
    \       return false;\n        } else {\n            d1[c] -= 1;\n        }\n\
    \    }\n    for (auto x : d1) {\n        if (x.second != 0) {\n            return\
    \ false;\n        }\n    }\n    return true;", "  int len0 = s0.length();\n  int\
    \ len1 = s1.length();\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(),\
    \ s1.end());\n  if (len0 != len1) {\n    return false;\n  } else {\n    for (int\
    \ i = 0; i < len0; i++) {\n      if (s0[i] != s1[i]) {\n        return false;\n\
    \      }\n    }\n  }\n  return true;", "    int i;\n    std::sort(s0.begin(),\
    \ s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0==s1;"]
stop_tokens:
- "\n}"
