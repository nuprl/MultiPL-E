language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = 0;\n    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n  \
    \  while(i < word.length()){\n        if(std::find(std::begin(vowels), std::end(vowels),\
    \ word[i]) != std::end(vowels)){\n            break;\n        }\n        i++;\n\
    \    }\n    while(i < word.length() - 1){\n        if(std::find(std::begin(vowels),\
    \ std::end(vowels), word[i + 1]) != std::end(vowels)){\n            i++;\n   \
    \     }else{\n            break;\n        }\n    }\n    if(i == word.length()\
    \ - 1){\n        return \"\";\n    }\n    return std::string(1, word[i]);\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgnn1p5id: /tmp/tmpgnn1p5id.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint clen = word.length();\n\tstd::string vowels = \"aeiou\";\n\t\
    for (int i = clen - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) == std::string::npos)\
    \ {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (vowels.find(word[j])\
    \ != std::string::npos) {\n\t\t\t\t\treturn word.substr(j, 1);\n\t\t\t\t}\n\t\t\
    \t}\n\t\t\treturn \"\";\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp43dbw0zv: /tmp/tmp43dbw0zv.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // set up vowel hash set\n    std::unordered_set<char> vowel_set\
    \ = {'a', 'e', 'i', 'o', 'u'};\n    // set up vowel pointer\n    char *front =\
    \ &word[0];\n    char *back = &word[word.size() - 1];\n    // for edge case of\
    \ word.size() == 1\n    if (word.size() == 1) {\n        if (vowel_set.find(*front)\
    \ != vowel_set.end()) {\n            return *front;\n        } else {\n      \
    \      return \"\";\n        }\n    }\n    // set up boolean hash set\n    bool\
    \ first_vowel = true;\n    // while front is not at back of word\n    while (front\
    \ != back) {\n        // if current char is vowel\n        if (vowel_set.find(*front)\
    \ != vowel_set.end()) {\n            // if found first vowel\n            if (first_vowel)\
    \ {\n                // if vowel is at end of word, return \"\"\n            \
    \    if (front == back - 1) {\n                    return \"\";\n            \
    \    }\n                // set boolean to false\n                first_vowel =\
    \ false;\n            } else {\n                // return vowel if next char is\
    \ consonant\n                if (vowel_set.find(*(front + 1)) == vowel_set.end())\
    \ {\n                    return *front;\n                }\n            }\n  \
    \      }\n        front++;\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgpv42pqh.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpgpv42pqh.cpp:22:20: error: could not convert \u2018* front\u2019 from\
    \ \u2018char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   22 |             return *front;\n      |                    ^~~~~~\n   \
    \   |                    |\n      |                    char\n/tmp/tmpgpv42pqh.cpp:44:28:\
    \ error: could not convert \u2018* front\u2019 from \u2018char\u2019 to \u2018\
    std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   44 |\
    \                     return *front;\n      |                            ^~~~~~\n\
    \      |                            |\n      |                            char\n"
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string res;\n  std::string vowels(\"aeiou\");\n  std::regex\
    \ reg(\"[a-zA-Z]+\");\n  if (!std::regex_match(word, reg)) {\n    return res;\n\
    \  }\n  int vow_pos = -1;\n  int count = 0;\n  bool is_consonant = false;\n  std::string::iterator\
    \ iter = word.end() - 1;\n  while (iter != word.begin()) {\n    if (vowels.find(*iter)\
    \ != std::string::npos) {\n      vow_pos = (int)(iter - word.begin());\n     \
    \ break;\n    }\n    --iter;\n  }\n  if (vow_pos == -1) {\n    return res;\n \
    \ }\n  for (auto iter = word.begin() + vow_pos; iter != word.end(); ++iter) {\n\
    \    if (vowels.find(*iter) != std::string::npos) {\n      continue;\n    }\n\
    \    ++count;\n    if (count == 2) {\n      return std::string(1, *(iter - 1));\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqkvuy_1n: /tmp/tmpqkvuy_1n.cpp:47: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    int maxDistance\
    \ = 100;\n    char result;\n    int distance;\n    char nextChar;\n    bool flag\
    \ = false;\n    for (int i = 0; i < word.length(); i++) {\n        nextChar =\
    \ word[i];\n        for (int j = 0; j < 5; j++) {\n            if (nextChar ==\
    \ vowels[j]) {\n                flag = true;\n                distance = i;\n\
    \                if (distance < maxDistance) {\n                    maxDistance\
    \ = distance;\n                    result = nextChar;\n                }\n   \
    \         }\n        }\n    }\n    if (flag)\n        return std::string(1, result);\n\
    \    else\n        return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmgmtwlg2: /tmp/tmpmgmtwlg2.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowel = \"aeiouAEIOU\";\n\tint size = word.size();\n\t\
    if (size < 3) return \"\";\n\tint index = size - 1;\n\twhile (index >= 0) {\n\t\
    \tif (vowel.find(word[index]) != std::string::npos) {\n\t\t\tif (index + 1 < size)\
    \ {\n\t\t\t\tif (vowel.find(word[index + 1]) == std::string::npos) {\n\t\t\t\t\
    \tif (index - 1 >= 0) {\n\t\t\t\t\t\tif (vowel.find(word[index - 1]) == std::string::npos)\
    \ {\n\t\t\t\t\t\t\treturn word.substr(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindex--;\n\t}\n\treturn \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  //your code here\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpa991fcms: /tmp/tmpa991fcms.cpp:19: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    std::vector<std::string>\
    \ temp;\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            std::string s = word.substr(i,1);\n   \
    \         temp.push_back(s);\n        }\n    }\n    if (temp.size() < 2) {\n \
    \       return \"\";\n    }\n    std::reverse(temp.begin(), temp.end());\n   \
    \ std::string s = temp[0];\n    for (int i = 1; i < temp.size(); i++) {\n    \
    \    if (vowels.find(temp[i-1]) != std::string::npos) {\n            break;\n\
    \        }\n        if (vowels.find(temp[i]) != std::string::npos) {\n       \
    \     if (vowels.find(temp[i-1]) == std::string::npos) {\n                s =\
    \ temp[i];\n                break;\n            }\n        }\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzl10jhc_: /tmp/tmpzl10jhc_.cpp:43: int main(): Assertion `candidate(("full"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // your code here\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgjdqz6_x: /tmp/tmpgjdqz6_x.cpp:19: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n  bool flag = false;\n  char\
    \ res;\n  for(int i = word.size()-1; i >= 0; i--) {\n    if(consonants.find(word[i])\
    \ != std::string::npos && vowels.find(word[i-1]) != std::string::npos) {\n   \
    \   res = word[i-1];\n      flag = true;\n      break;\n    }\n  }\n  return flag\
    \ ? std::string(1, res) : \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbxambocq: /tmp/tmpbxambocq.cpp:31: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    static const std::string vowels = \"aeiou\";\n    bool is_consonant\
    \ = true;\n    std::string closest_vowel = \"\";\n    for (size_t i = word.size()\
    \ - 1; i >= 0; --i) {\n        if (is_consonant) {\n            if (vowels.find(word[i])\
    \ != std::string::npos) {\n                closest_vowel = word[i];\n        \
    \        is_consonant = false;\n            }\n        } else {\n            if\
    \ (vowels.find(word[i]) == std::string::npos) {\n                return closest_vowel;\n\
    \            }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpr6jzc64s: /tmp/tmpr6jzc64s.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string result = \"\";\n    bool hasVowel = false;\n    int\
    \ count = 0;\n    int vowelIndex = -1;\n    int countIndex = -1;\n    for (int\
    \ i = word.length() - 1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ||\n          \
    \  word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U') {\n            if (count == 0) {\n                vowelIndex = i;\n\
    \                hasVowel = true;\n            }\n            else {\n       \
    \         countIndex = i;\n                break;\n            }\n        }\n\
    \        else {\n            count++;\n        }\n    }\n    if (hasVowel && countIndex\
    \ != -1) {\n        result = word[vowelIndex];\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_5ruv030: /tmp/tmp_5ruv030.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    if (word.size() == 1)\
    \ return \"\";\n    bool prev = false;\n    bool curr = false;\n    bool next\
    \ = false;\n    int res = -1;\n    for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n        prev = curr;\n        curr = next;\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            next = true;\n            if (prev && curr)\
    \ {\n                res = i;\n                break;\n            }\n       \
    \ } else {\n            next = false;\n        }\n    }\n    if (res == -1) return\
    \ \"\";\n    return word.substr(res, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5a81q11u: /tmp/tmp5a81q11u.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    bool flag=false;\n    bool flag2=false;\n    int len = word.length();\n\
    \    int pos = 0;\n    int arr[len];\n    for(int i=0;i<len;i++){\n        if(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u'||word[i]=='A'||word[i]=='E'||word[i]=='I'||word[i]=='O'||word[i]=='U'){\n\
    \            flag=true;\n            arr[pos++]=i;\n        }\n    }\n    if(flag){\n\
    \        if(arr[0]!=0&&arr[pos-1]!=len-1){\n            if(word[arr[0]-1]!='a'&&word[arr[0]-1]!='e'&&word[arr[0]-1]!='i'&&word[arr[0]-1]!='o'&&word[arr[0]-1]!='u'&&word[arr[0]-1]!='A'&&word[arr[0]-1]!='E'&&word[arr[0]-1]!='I'&&word[arr[0]-1]!='O'&&word[arr[0]-1]!='U'){\n\
    \                flag2=true;\n                for(int i=0;i<pos;i++){\n      \
    \              if(word[arr[i]+1]!='a'&&word[arr[i]+1]!='e'&&word[arr[i]+1]!='i'&&word[arr[i]+1]!='o'&&word[arr[i]+1]!='u'&&word[arr[i]+1]!='A'&&word[arr[i]+1]!='E'&&word[arr[i]+1]!='I'&&word[arr[i]+1]!='O'&&word[arr[i]+1]!='U'){\n\
    \                        std::string s=\"\";\n                        s += word[arr[i]];\n\
    \                        return\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpja_9vzfi.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpja_9vzfi.cpp:34:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   34 | }\n      | ^\n/tmp/tmpja_9vzfi.cpp:33:31: error: expected\
    \ \u2018;\u2019 before \u2018}\u2019 token\n   33 |                         return\n\
    \      |                               ^\n      |                            \
    \   ;\n   34 | }\n      | ~                              \n/tmp/tmpja_9vzfi.cpp:35:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   35 | int main() {\n      |            ^\n/tmp/tmpja_9vzfi.cpp:50:1: error:\
    \ expected \u2018}\u2019 at end of input\n   50 | }\n      | ^\n/tmp/tmpja_9vzfi.cpp:29:39:\
    \ note: to match this \u2018{\u2019\n   29 |                 for(int i=0;i<pos;i++){\n\
    \      |                                       ^\n/tmp/tmpja_9vzfi.cpp:50:1: error:\
    \ expected \u2018}\u2019 at end of input\n   50 | }\n      | ^\n/tmp/tmpja_9vzfi.cpp:27:225:\
    \ note: to match this \u2018{\u2019\n   27 |             if(word[arr[0]-1]!='a'&&word[arr[0]-1]!='e'&&word[arr[0]-1]!='i'&&word[arr[0]-1]!='o'&&word[arr[0]-1]!='u'&&word[arr[0]-1]!='A'&&word[arr[0]-1]!='E'&&word[arr[0]-1]!='I'&&word[arr[0]-1]!='O'&&word[arr[0]-1]!='U'){\n\
    \      |                                                                     \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpja_9vzfi.cpp:50:1: error: expected \u2018}\u2019 at end of input\n\
    \   50 | }\n      | ^\n/tmp/tmpja_9vzfi.cpp:26:41: note: to match this \u2018\
    {\u2019\n   26 |         if(arr[0]!=0&&arr[pos-1]!=len-1){\n      |          \
    \                               ^\n/tmp/tmpja_9vzfi.cpp:50:1: error: expected\
    \ \u2018}\u2019 at end of input\n   50 | }\n      | ^\n/tmp/tmpja_9vzfi.cpp:25:13:\
    \ note: to match this \u2018{\u2019\n   25 |     if(flag){\n      |          \
    \   ^\n/tmp/tmpja_9vzfi.cpp:50:1: error: expected \u2018}\u2019 at end of input\n\
    \   50 | }\n      | ^\n/tmp/tmpja_9vzfi.cpp:13:49: note: to match this \u2018\
    {\u2019\n   13 | std::string get_closest_vowel(std::string word)"
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    word = word;\n    auto vowels = std::string(\"aeiou\");\n    auto\
    \ pos = word.rfind('q');\n    if (pos != std::string::npos) {\n        auto npos\
    \ = word.find('u', pos + 1);\n        if (npos != std::string::npos) {\n     \
    \       return \"u\";\n        }\n    }\n    for (int i = word.size() - 1; i >=\
    \ 0; i--) {\n        auto pos = vowels.find(word[i]);\n        if (pos != std::string::npos)\
    \ {\n            if (i != 0 && i != word.size() - 1) {\n                if (vowels.find(word[i\
    \ - 1]) == std::string::npos && vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                    return word.substr(i, 1);\n                }\n      \
    \      }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpk5laf89v: /tmp/tmpk5laf89v.cpp:46: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::vector<char> all_vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E',\
    \ 'I', 'O', 'U'};\n\tfor (int i = word.size() - 1; i >= 0; i--) {\n\t\tfor (int\
    \ j = 0; j < all_vowels.size(); j++) {\n\t\t\tif (word[i] == all_vowels[j]) {\n\
    \t\t\t\tfor (int k = i - 1; k >= 0; k--) {\n\t\t\t\t\tfor (int l = 0; l < all_vowels.size();\
    \ l++) {\n\t\t\t\t\t\tif (word[k] == all_vowels[l]) {\n\t\t\t\t\t\t\treturn word.substr(k\
    \ + 1, i - k - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpuug0h0y6: /tmp/tmpuug0h0y6.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if(word.length() == 0) return \"\";\n    for(int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            if(i == word.length()\
    \ - 1) continue;\n            if(word[i + 1] == 'a' || word[i + 1] == 'e' || word[i\
    \ + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u') continue;\n       \
    \     else return word.substr(i, 1);\n        }\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcj1_1bjx: /tmp/tmpcj1_1bjx.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    for (int i = 0; i < word.size();\
    \ i++) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int j = i + 1;\n            for (; j < word.size(); j++) {\n             \
    \   if (vowels.find(word[j]) != std::string::npos) {\n                    return\
    \ word.substr(i, 1);\n                }\n            }\n            return word.substr(i,\
    \ 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpke90tdxw: /tmp/tmpke90tdxw.cpp:30: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tif (word.length() == 0) return \"\";\n\tif (word.length() == 1) return\
    \ \"\";\n\tbool first_consonant = true;\n\tint closest_vowel_pos = -1;\n\tfor\
    \ (int i = word.length() - 1; i >= 0; i--) {\n\t\tif (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A'\
    \ || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n\
    \t\t\tif (first_consonant) {\n\t\t\t\tclosest_vowel_pos = i;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\tclosest_vowel_pos = i;\n\t\t\t\tfirst_consonant\
    \ = true;\n\t\t\t}\n\t\t}\n\t\telse first_consonant = false;\n\t}\n\tif (closest_vowel_pos\
    \ == -1) return \"\";\n\treturn std::string(1, word[closest_vowel_pos]);\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpliw6u6os: /tmp/tmpliw6u6os.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tfor (int i = word.size()\
    \ - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\
    \t\treturn word[i];\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpecnr1bki.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpecnr1bki.cpp:17:17: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   17 |    return word[i];\n      |                 ^\n      |            \
    \     |\n      |                 __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string res=\"\";\n  std::string vowels = \"aeiou\";\n  bool\
    \ is_found = false;\n  int len = word.length();\n  for(int i=len-1;i>=0;i--){\n\
    \    if(!is_found){\n      for(int j=0;j<vowels.length();j++){\n        if(word[i]==vowels[j]){\n\
    \          is_found = true;\n          res = word[i];\n          break;\n    \
    \    }\n      }\n    }\n    else{\n      for(int j=0;j<vowels.length();j++){\n\
    \        if(word[i]==vowels[j]){\n          is_found = false;\n          res=\"\
    \";\n          break;\n        }\n      }\n    }\n  }\n  return res;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph3etdnkc: /tmp/tmph3etdnkc.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  \n  std::string vowel = \"aeiou\";\n  int pos = word.size() - 1;\n\
    \  char ans = ' ';\n  int min = 100;\n  bool b = false;\n  int i = 0;\n  while(i\
    \ < word.size() && !b) {\n    int idx = vowel.find(word[i]);\n    if(idx != std::string::npos)\
    \ {\n      if(i < pos) {\n        b = true;\n        pos = i;\n        ans = word[i];\n\
    \      }\n    }\n    i++;\n  }\n  if(b)\n    return std::string(1, ans);\n  return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptt9ujavg: /tmp/tmptt9ujavg.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::vector<std::string> all_vowels = {\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"};\n  std::vector<char> vowels = {'a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::string closest_vowel =\
    \ \"\";\n  int vowel_count = 0;\n  std::size_t found;\n  std::vector<int> all_vowel_pos;\n\
    \  for(int i = 0; i < all_vowels.size(); i++) {\n    if(word.find(all_vowels[i])\
    \ != std::string::npos) {\n      found = word.find(all_vowels[i]);\n      all_vowel_pos.push_back(found);\n\
    \      vowel_count++;\n    }\n  }\n  if(vowel_count == 0) {\n    return \"\";\n\
    \  }\n  std::sort(all_vowel_pos.begin(), all_vowel_pos.end());\n  if(all_vowel_pos[0]\
    \ == 0) {\n    return \"\";\n  }\n  int minimum_right_consonant_distance = 0;\n\
    \  int right_consonant_distance = 0;\n  for(int i = 0; i < all_vowel_pos.size();\
    \ i++) {\n    for(int j = all_vowel_pos[i]; j < word.length(); j++) {\n      if(std::find(vowels.begin(),\
    \ vowels.end(), word[j]) == vowels.end()) {\n        right_consonant_distance++;\n\
    \      }\n      else {\n        break;\n      }\n    }\n    if(i == 0) {\n   \
    \   minimum_right_consonant_distance = right_consonant_distance;\n      closest_vowel\
    \ = all_vowels[i];\n    }\n    else {\n      if(right_consonant_distance < minimum_right_consonant_distance)\
    \ {\n\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn8f1avqg.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpn8f1avqg.cpp:53:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   53 | int main() {\n      |            ^\n/tmp/tmpn8f1avqg.cpp:68:1:\
    \ error: expected \u2018}\u2019 at end of input\n   68 | }\n      | ^\n/tmp/tmpn8f1avqg.cpp:49:10:\
    \ note: to match this \u2018{\u2019\n   49 |     else {\n      |          ^\n\
    /tmp/tmpn8f1avqg.cpp:68:1: error: expected \u2018}\u2019 at end of input\n   68\
    \ | }\n      | ^\n/tmp/tmpn8f1avqg.cpp:36:49: note: to match this \u2018{\u2019\
    \n   36 |   for(int i = 0; i < all_vowel_pos.size(); i++) {\n      |         \
    \                                        ^\n/tmp/tmpn8f1avqg.cpp:68:1: error:\
    \ expected \u2018}\u2019 at end of input\n   68 | }\n      | ^\n/tmp/tmpn8f1avqg.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpn8f1avqg.cpp:68:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   68 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int count = 0;\n  std::string s;\n  for(int i = word.length()-1;\
    \ i >= 0; i--) {\n    if(!count && !(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' ||\n       word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i]\
    \ == 'E' ||\n       word[i] == 'I' || word[i] == 'O' || word[i] == 'U')) {\n \
    \     count++;\n    } else if(count && !(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' ||\n       word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i]\
    \ == 'E' ||\n       word[i] == 'I' || word[i] == 'O' || word[i] == 'U')) {\n \
    \     break;\n    } else if(count && (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' ||\n       word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i]\
    \ == 'E' ||\n       word[i] == 'I' || word[i] == 'O' || word[i] == 'U')) {\n \
    \     s = word[i];\n      break;\n    }\n  }\n  return s;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzgtii7xx: /tmp/tmpzgtii7xx.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string out = \"\";\n  std::string vowels = \"AEIOUaeiou\";\n\
    \  for (int i = word.length() - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      if (i != word.length() - 1 && vowels.find(word[i\
    \ + 1]) == std::string::npos) {\n        return std::string(1, word[i]);\n   \
    \   }\n    }\n  }\n  return out;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpfl1q39qs: /tmp/tmpfl1q39qs.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  bool firstVowel = false;\n  std::string vowels(\"aeiouAEIOU\");\n\
    \  std::string found(\"\");\n  for (int i = 0; i < word.length(); i++) {\n   \
    \ if (vowels.find(word[i]) == std::string::npos) {\n      if (firstVowel) {\n\
    \        found = \"\";\n        firstVowel = false;\n      }\n    } else {\n \
    \     if (found == \"\") {\n        found = word[i];\n        firstVowel = true;\n\
    \      }\n    }\n  }\n  return found;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmo_4h0tf: /tmp/tmpmo_4h0tf.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    bool\
    \ flag = false;\n    int vowel_index = -1;\n    int vowel_pos = -1;\n    for(int\
    \ i = 0; i < word.size(); i++) {\n        for(int j = 0; j < vowels.size(); j++)\
    \ {\n            if(word[i] == vowels[j]) {\n                vowel_index = j;\n\
    \                vowel_pos = i;\n                break;\n            }\n     \
    \   }\n        if(vowel_index != -1) {\n            break;\n        }\n    }\n\
    \    if(vowel_index == -1) {\n        return \"\";\n    }\n    for(int i = word.size()\
    \ - 1; i >= 0; i--) {\n        for(int j = 0; j < vowels.size(); j++) {\n    \
    \        if(word[i] == vowels[j]) {\n                flag = true;\n          \
    \      break;\n            }\n        }\n        if(flag) {\n            break;\n\
    \        }\n        vowel_pos = i;\n    }\n    return std::string(1, word[vowel_pos]);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcw0pabui: /tmp/tmpcw0pabui.cpp:49: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if(word.size() == 0)\n        return \"\";\n    if(word.size()\
    \ == 1)\n        return \"\";\n    if(word.size() == 2)\n        return \"\";\n\
    \    if(word.size() == 3)\n        return \"\";\n    if(word.size() == 4)\n  \
    \      return \"\";\n    if(word.size() == 5)\n        return \"\";\n    if(word.size()\
    \ == 6)\n        return \"\";\n    if(word.size() == 7)\n        return \"\";\n\
    \    if(word.size() == 8)\n        return \"\";\n    if(word.size() == 9)\n  \
    \      return \"\";\n    if(word.size() == 10)\n        return \"\";\n    if(word.size()\
    \ == 11)\n        return \"\";\n    if(word.size() == 12)\n        return \"\"\
    ;\n    if(word.size() == 13)\n        return \"\";\n    if(word.size() == 14)\n\
    \        return \"\";\n    if(word.size() == 15)\n        return \"\";\n    if(word.size()\
    \ == 16)\n        return \"\";\n    if(word.size() == 17)\n        return \"\"\
    ;\n    if(word.size() == 18)\n        return \"\";\n    if(word.size() == 19)\n\
    \        return \"\";\n    if(word.size() == 20)\n        return \"\";\n    return\
    \ word;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo_pnnce0: /tmp/tmpo_pnnce0.cpp:60: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int count = 0;\n    int ci = 0;\n\
    \    std::string str = \"\";\n    for(int i = len-1; i >= 0; i--) {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U') {\n            count++;\n            ci = i;\n        }\n        if(count\
    \ == 2) {\n            str = word[ci];\n            break;\n        }\n    }\n\
    \    return str;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmfuy4an9: /tmp/tmpmfuy4an9.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here!\n    // Iterate over the word, adding vowels\
    \ to a vector and consonants to a stack\n    // Keep track of the last character\n\
    \    // Keep track of the last vowel\n    // If the last character was a vowel\
    \ and the current character is a consonant,\n    // pop off the last vowel and\
    \ return it\n    // Else, keep iterating\n    // If the end is reached, then return\
    \ an empty string\n    std::vector<char> vowels;\n    std::stack<char> consonants;\n\
    \    char last_character = ' ';\n    char last_vowel = ' ';\n    for (int i =\
    \ 0; i < word.length(); i++) {\n        if (word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n          \
    \  vowels.push_back(word[i]);\n            last_vowel = word[i];\n        } else\
    \ {\n            consonants.push(word[i]);\n        }\n        last_character\
    \ = word[i];\n    }\n    if (last_character == 'a' || last_character == 'e' ||\
    \ last_character == 'i' || last_character == 'o' || last_character == 'u' || last_character\
    \ == 'A' || last_character == 'E' || last_character == 'I' || last_character ==\
    \ 'O' || last_character == 'U') {\n        return \"\";\n    }\n    if (vowels.size()\
    \ == 0) {\n        return \"\";\n    }\n    return last_vowel;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpejxkqfmi.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpejxkqfmi.cpp:41:12: error: could not convert \u2018last_vowel\u2019\
    \ from \u2018char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   41 |     return last_vowel;\n      |            ^~~~~~~~~~\n      |    \
    \        |\n      |            char\n"
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string v = \"aeiouAEIOU\";\n    std::string consonants = \"\
    bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    size_t c1,c2,v1,v2;\n    v1\
    \ = v2 = c1 = c2 = 0;\n    for(size_t i = word.size()-1; i != std::string::npos;\
    \ i--){\n        if(i == 0){\n            return \"\";\n        }\n        if(consonants.find(word[i])\
    \ != std::string::npos){\n            c1 = i;\n            break;\n        }\n\
    \    }\n    for(size_t i = c1; i != std::string::npos; i--){\n        if(i ==\
    \ 0){\n            return \"\";\n        }\n        if(consonants.find(word[i])\
    \ != std::string::npos){\n            c2 = i;\n            break;\n        }\n\
    \    }\n    for(size_t i = c1; i != std::string::npos; i--){\n        if(i ==\
    \ 0){\n            return \"\";\n        }\n        if(v.find(word[i]) != std::string::npos){\n\
    \            v1 = i;\n            break;\n        }\n    }\n    for(size_t i =\
    \ c2; i != std::string::npos; i--){\n        if(i == 0){\n            return \"\
    \";\n        }\n        if(v.find(word[i]) != std::string::npos){\n          \
    \  v2 = i;\n            break;\n        }\n    }\n    if(c1-v1 > v2-c2){\n   \
    \     return word.substr(v2,1);\n    }\n    else{\n        return word.substr(v1,1);\n\
    \    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprpdwmlfw: /tmp/tmprpdwmlfw.cpp:65: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// Your code here\n\tstd::string result = \"\";\n\tstd::string vowels\
    \ = \"aeiou\";\n\tstd::string temp = \"\";\n\tbool first = true;\n\tfor (int i\
    \ = word.length() - 1; i >= 0; i--) {\n\t\ttemp += word[i];\n\t\tfor (int j =\
    \ 0; j < vowels.length(); j++) {\n\t\t\tif (vowels[j] == word[i]) {\n\t\t\t\t\
    if (first) {\n\t\t\t\t\tresult = temp;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\
    \t\t\telse {\n\t\t\t\t\tif (result.length() > temp.length()) {\n\t\t\t\t\t\tresult\
    \ = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::reverse(result.begin(),\
    \ result.end());\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd2721u0a: /tmp/tmpd2721u0a.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size(), index = -1;\n    for(int i = n - 1; i >= 0;\
    \ i--) {\n        if(tolower(word[i]) == 'a' || tolower(word[i]) == 'e' || tolower(word[i])\
    \ == 'i' ||\n            tolower(word[i]) == 'o' || tolower(word[i]) == 'u') {\n\
    \            index = i;\n            break;\n        }\n    }\n    if(index ==\
    \ -1) return \"\";\n    for(int i = index - 1; i >= 0; i--) {\n        if(tolower(word[i])\
    \ != 'a' && tolower(word[i]) != 'e' && tolower(word[i]) != 'i' &&\n          \
    \  tolower(word[i]) != 'o' && tolower(word[i]) != 'u') {\n            return std::string(1,\
    \ word[index]);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp69spvany: /tmp/tmp69spvany.cpp:37: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n   // your code goes here\n   std::string vowels = \"aeiou\";\n   std::string\
    \ emptyStr = \"\";\n   int l = word.length();\n   bool isPrevConsonent = false;\n\
    \   char prevChar = ' ';\n   char currChar = ' ';\n   for(int i = l-1; i >= 0;\
    \ i--) {\n      currChar = word[i];\n      if(isPrevConsonent) {\n         if(vowels.find(currChar)\
    \ != std::string::npos) {\n            return std::string(1, currChar);\n    \
    \     }\n      }\n      isPrevConsonent = (vowels.find(currChar) == std::string::npos);\n\
    \      prevChar = currChar;\n   }\n   return emptyStr;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpj6ld53q2: /tmp/tmpj6ld53q2.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int v = -1;\n  int c = -1;\n  int i = word.size() - 1;\n  for (;\
    \ i >= 0; i--) {\n    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u') {\n      v = i;\n      break;\n    }\n  }\n\
    \  for (; i >= 0; i--) {\n    if (word[i] != 'a' && word[i] != 'e' && word[i]\
    \ != 'i' && word[i] != 'o' && word[i] != 'u') {\n      c = i;\n      break;\n\
    \    }\n  }\n  if (v == -1 || c == -1) {\n    return \"\";\n  }\n  return std::string(1,\
    \ word[v]);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpfltqmsfn: /tmp/tmpfltqmsfn.cpp:40: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    //Your code here\n    int a = 0;\n    int len = word.length();\n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n \
    \           if(i - 1 < 0 || i == len - 1)\n            {\n                a =\
    \ 1;\n                break;\n            }\n            else if(!(word[i - 1]\
    \ == 'a' || word[i - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' ||\
    \ word[i - 1] == 'u')\n                && !(word[i + 1] == 'a' || word[i + 1]\
    \ == 'e' || word[i + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u'))\n\
    \            {\n                return word.substr(i, 1);\n            }\n   \
    \     }\n    }\n    if(a == 1)\n    {\n        return \"\";\n    }\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8pwk647i: /tmp/tmp8pwk647i.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = word.size() - 1;\n    std::string::iterator it;\n    for\
    \ (it = word.end() - 1; it >= word.begin(); it--) {\n        if (std::string(\"\
    aeiouAEIOU\").find(*it) != std::string::npos) {\n            return std::string(1,\
    \ *it);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphtzo02an: /tmp/tmphtzo02an.cpp:27: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return std::string(1, word[i]);\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7a0_qyld: /tmp/tmp7a0_qyld.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    return std::string();\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxyy03fjt: /tmp/tmpxyy03fjt.cpp:19: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int left=-1, right=-1;\n    for(int i=0; i<word.size(); i++) {\n\
    \        if(left!=-1 && right!=-1)\n            break;\n        if(std::find(vowels.begin(),\
    \ vowels.end(), word[i])==vowels.end()) {\n            if(left==-1)\n        \
    \        left=i;\n            else\n                right=i;\n        }\n    }\n\
    \    if(left==-1 || right==-1)\n        return \"\";\n    for(int i=right-1; i>left;\
    \ i--) {\n        if(std::find(vowels.begin(), vowels.end(), word[i])!=vowels.end())\n\
    \            return word.substr(i, 1);\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuecqx7ah.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpuecqx7ah.cpp:18:22: error: \u2018vowels\u2019 was not declared in this\
    \ scope\n   18 |         if(std::find(vowels.begin(), vowels.end(), word[i])==vowels.end())\
    \ {\n      |                      ^~~~~~\n/tmp/tmpuecqx7ah.cpp:28:22: error: \u2018\
    vowels\u2019 was not declared in this scope\n   28 |         if(std::find(vowels.begin(),\
    \ vowels.end(), word[i])!=vowels.end())\n      |                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660120046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowels[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0,\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpox6pb5xt.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpox6pb5xt.cpp:16:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018int\u2019\n   16 | int main() {\n      | ^~~\n/tmp/tmpox6pb5xt.cpp:31:1:\
    \ error: expected \u2018}\u2019 at end of input\n   31 | }\n      | ^\n/tmp/tmpox6pb5xt.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpox6pb5xt.cpp:31:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   31 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120045
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            if (i + 1 < word.size() && i - 1 >= 0) {\n                if\
    \ (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i +\
    \ 1] != 'o' && word[i + 1] != 'u' && word[i - 1] != 'a' && word[i - 1] != 'e'\
    \ && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u') {\n     \
    \               return word.substr(i, 1);\n                }\n            }\n\
    \        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowel = \"AEIOUaeiou\";\n    int i = word.size() -\
    \ 1;\n    while (i >= 0) {\n        if (vowel.find(word[i]) != std::string::npos)\
    \ {\n            if (i == word.size() - 1) {\n                return \"\";\n \
    \           }\n            else if (vowel.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp24g1zdi3: /tmp/tmp24g1zdi3.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    int\
    \ idx = word.size() - 1;\n    while (idx >= 0) {\n        if (std::find(vowels.begin(),\
    \ vowels.end(), word[idx]) != vowels.end()) {\n            int leftIdx = idx -\
    \ 1;\n            while (leftIdx >= 0) {\n                if (std::find(vowels.begin(),\
    \ vowels.end(), word[leftIdx]) != vowels.end()) {\n                    leftIdx--;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            return word[idx];\n        }\n        idx--;\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv51w5sq0.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpv51w5sq0.cpp:26:28: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)idx))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   26 |             return word[idx];\n      |                            ^\n\
    \      |                            |\n      |                            __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n  int vowel_index\
    \ = -1;\n  for (int i = word.size() - 1; i >= 0; i--) {\n    if (std::find(vowels.begin(),\
    \ vowels.end(), word[i]) != vowels.end()) {\n      vowel_index = i;\n      break;\n\
    \    }\n  }\n  if (vowel_index < 0) return \"\";\n  int consonant_index = vowel_index;\n\
    \  for (int i = vowel_index; i >= 0; i--) {\n    if (std::find(vowels.begin(),\
    \ vowels.end(), word[i]) == vowels.end()) {\n      consonant_index = i;\n    \
    \  break;\n    }\n  }\n  if (consonant_index == vowel_index) return \"\";\n  return\
    \ word.substr(vowel_index, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpc57hflug: /tmp/tmpc57hflug.cpp:39: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string ans;\n\tint n = word.size();\n\
    \tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos)\
    \ {\n\t\t\tans = word[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = n - 1; i >=\
    \ 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\tif (vowels.find(word[i\
    \ - 1]) == std::string::npos && vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n\t\t\t\tans = word[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2dfna7e4: /tmp/tmp2dfna7e4.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  \n  std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n  int\
    \ vowel_index = -1;\n  int index = word.size() - 1;\n  bool flag = false;\n  while(index\
    \ >= 0) {\n    auto v = std::find(vowels.begin(), vowels.end(), word[index]);\n\
    \    if(v != vowels.end()) {\n      vowel_index = index;\n      break;\n    }\n\
    \    index--;\n  }\n  if(vowel_index == -1) {\n    return \"\";\n  }\n  if(vowel_index\
    \ == 0) {\n    return \"\";\n  }\n  for(int i = vowel_index - 1; i >= 0; i--)\
    \ {\n    auto v = std::find(vowels.begin(), vowels.end(), word[i]);\n    if(v\
    \ == vowels.end()) {\n      flag = true;\n      break;\n    }\n  }\n  if(flag)\
    \ {\n    return word[vowel_index];\n  }\n  return \"\";\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkbtoiki6.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpkbtoiki6.cpp:41:28: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)vowel_index))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   41 |     return word[vowel_index];\n      |                            ^\n\
    \      |                            |\n      |                            __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120048
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::vector<char> v = {'a','e','i','o','u','A','E','I','O','U'};\n\
    \tstd::vector<int> vec;\n\tfor(int i = 0; i < word.size(); i++) {\n\t\tfor(int\
    \ j = 0; j < v.size(); j++) {\n\t\t\tif(word[i] == v[j]) {\n\t\t\t\tvec.push_back(i);\n\
    \t\t\t}\n\t\t}\n\t}\n\tif(vec.size() == 0) {\n\t\treturn \"\";\n\t}\n\tint len\
    \ = word.size();\n\tint b,e;\n\tint m = vec[0];\n\tfor(int i = 1; i < vec.size();\
    \ i++) {\n\t\tif(len - vec[i] < m) {\n\t\t\tm = len - vec[i];\n\t\t\tb = i;\n\t\
    \t}\n\t}\n\tfor(int i = 0; i < vec.size(); i++) {\n\t\tif(vec[i] > vec[b]) {\n\
    \t\t\te = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint index = (e - b - 1)/2 + b + 1;\n\
    \tstd::string res;\n\tres.push_back(word[index]);\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int length = word.length();\n    std::vector<int> vowel_index(length);\n\
    \    for(int i = 0; i < length; i++) {\n        vowel_index[i] = -1;\n    }\n\
    \    int j = 0;\n    for(int i = 0; i < length; i++) {\n        if(word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U') {\n            vowel_index[j] = i;\n            j++;\n        }\n  \
    \  }\n    vowel_index.resize(j);\n    if(vowel_index.size() == 0) {\n        return\
    \ \"\";\n    }\n    if(vowel_index.size() == 1) {\n        if(vowel_index[0] ==\
    \ 0 || vowel_index[0] == length - 1) {\n            return \"\";\n        }\n\
    \        else {\n            return word.substr(vowel_index[0], 1);\n        }\n\
    \    }\n    int first_vowel_index = vowel_index[0];\n    if(first_vowel_index\
    \ == 0) {\n        return word.substr(vowel_index[1], 1);\n    }\n    if(first_vowel_index\
    \ == length - 1) {\n        return word.substr(vowel_index[0], 1);\n    }\n  \
    \  if(vowel_index.size() == 2) {\n        return word.substr(vowel_index[1], 1);\n\
    \    }\n    else {\n        int second_vowel_index = vowel_index[1];\n       \
    \ if(second_vowel_index == length - 1) {\n            return word.substr(vowel_index[0],\
    \ 1);\n        }\n        else {\n            return word.substr(vowel_index[1\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuz99_q7h.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpuz99_q7h.cpp:54:45: error: expected \u2018]\u2019 before \u2018}\u2019\
    \ token\n   54 |             return word.substr(vowel_index[1\n      |       \
    \                                      ^\n      |                            \
    \                 ]\n   55 | }\n      | ~                                    \
    \        \n/tmp/tmpuz99_q7h.cpp:54:45: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   54 |             return word.substr(vowel_index[1\n      | \
    \                              ~             ^\n      |                      \
    \                       )\n   55 | }\n      | ~                              \
    \              \n/tmp/tmpuz99_q7h.cpp:54:45: error: expected \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   54 |             return word.substr(vowel_index[1\n\
    \      |                                             ^\n      |              \
    \                               ;\n   55 | }\n      | ~                      \
    \                      \n/tmp/tmpuz99_q7h.cpp:56:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   56 | int main() {\n     \
    \ |            ^\n/tmp/tmpuz99_q7h.cpp:71:1: error: expected \u2018}\u2019 at\
    \ end of input\n   71 | }\n      | ^\n/tmp/tmpuz99_q7h.cpp:48:10: note: to match\
    \ this \u2018{\u2019\n   48 |     else {\n      |          ^\n/tmp/tmpuz99_q7h.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpuz99_q7h.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n"
  stdout: ''
  timestamp: 1660120048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    //your code here...\n    if(word.size()==0) return \"\";\n    if(word.size()==1)\
    \ return \"\";\n    bool flag=true;\n    std::vector<int> res;\n    for(int i=0;i<word.size();i++){\n\
    \        if(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u'||word[i]=='A'||word[i]=='E'||word[i]=='I'||word[i]=='O'||word[i]=='U'){\n\
    \            flag=false;\n            res.push_back(i);\n        }\n    }\n  \
    \  if(flag) return \"\";\n    int mark=0;\n    for(int i=0;i<res.size();i++){\n\
    \        if(res[i]==word.size()-1) continue;\n        if(word[res[i]+1]=='a'||word[res[i]+1]=='e'||word[res[i]+1]=='i'||word[res[i]+1]=='o'||word[res[i]+1]=='u'||word[res[i]+1]=='A'||word[res[i]+1]=='E'||word[res[i]+1]=='I'||word[res[i]+1]=='O'||word[res[i]+1]=='U')\
    \ continue;\n        else{\n            mark=i;\n            break;\n        }\n\
    \    }\n    if(mark==0) return \"\";\n    return word.substr(res[mark],1);\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzda7s0e6: /tmp/tmpzda7s0e6.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  bool is_last_vowel_seen = false;\n  int last_vowel_pos = 0;\n  std::string\
    \ vowels = \"aeiouAEIOU\";\n  for (int i = 0; i < word.size(); i++) {\n    if\
    \ (vowels.find(word[i]) != std::string::npos) {\n      is_last_vowel_seen = true;\n\
    \      last_vowel_pos = i;\n    } else {\n      if (is_last_vowel_seen)\n    \
    \    return word.substr(last_vowel_pos, 1);\n    }\n  }\n  return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp565fdb4m: /tmp/tmp565fdb4m.cpp:30: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  char vowel[] = {'a', 'e', 'i', 'o', 'u'};\n  char c;\n  int pos =\
    \ -1;\n  int length = word.length();\n  int l = 0;\n  int r = 0;\n  for (int i\
    \ = length - 1; i >= 0; i--) {\n    c = word[i];\n    // find a consonant\n  \
    \  if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n      if (pos\
    \ != -1) {\n        r = i;\n        break;\n      }\n    } else {\n      pos =\
    \ i;\n      l = i;\n    }\n  }\n  if (pos == -1) {\n    return \"\";\n  }\n  int\
    \ distance = INT_MAX;\n  int index = -1;\n  for (int i = 0; i < 5; i++) {\n  \
    \  //check that vowel occurs between two consonants\n    if (vowel[i] == word[pos]\
    \ && pos < length - 1 && pos > 0 && \n      !(word[pos + 1] == 'a' || word[pos\
    \ + 1] == 'e' || word[pos + 1] == 'i' || word[pos + 1] == 'o' || word[pos + 1]\
    \ == 'u') &&\n      !(word[pos - 1] == 'a' || word[pos - 1] == 'e' || word[pos\
    \ - 1] == 'i' || word[pos - 1] == 'o' || word[pos - 1] == 'u')) {\n      if (pos\
    \ > (r + l) / 2) {\n        // if the vowel is to the right of the mid point\n\
    \        if (pos - r < distance) {\n          index = i;\n          distance =\
    \ pos - r;\n        }\n      } else {\n        // if the vowel is to the left\
    \ of the mid point\n        if (l - pos < distance) {\n          index = i;\n\
    \          distance = l - pos;\n        }\n      }\n    }\n  }\n  if (index ==\
    \ -1) {\n    return \"\";\n  }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels=\"aeiou\";\n\tstd::string s;\n\tfor(int i=0;i<word.length();i++)\n\
    \t{\n\t\tif(vowels.find(word[i])!=std::string::npos)\n\t\t{\n\t\t\tif(word[i-1]!='\
    \ ' and word[i+1]!=' ')\n\t\t\t{\n\t\t\t\ts=word[i];\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn s;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1ly_3f1r: /tmp/tmp1ly_3f1r.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string result = \"\";\n    int vowel_position = -1;\n    int\
    \ difference = std::numeric_limits<int>::max();\n    std::string vowels = \"aeiou\"\
    ;\n    for (int i = 0; i < word.size(); i++) {\n        int index = vowels.find(word[i]);\n\
    \        if (index == std::string::npos) continue;\n        if (i == 0 || i ==\
    \ word.size() - 1) continue;\n        if (word[i - 1] == word[i + 1]) continue;\n\
    \        int diff = i - vowel_position;\n        if (diff < difference) {\n  \
    \          difference = diff;\n            result = word[i];\n        }\n    \
    \    vowel_position = i;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_hjg4j7a: /tmp/tmp_hjg4j7a.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int pos = word.length() - 1;\n\
    \  while (pos > 0) {\n    if (vowels.find(word[pos]) != std::string::npos) {\n\
    \      if (vowels.find(word[pos - 1]) == std::string::npos)\n        return word.substr(pos,\
    \ 1);\n    }\n    pos--;\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpiz59p1tm: /tmp/tmpiz59p1tm.cpp:31: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string answer = \"\"\
    ;\n    std::vector<std::pair<int, int>> v;\n\n    for (auto i = 0; i < word.size();\
    \ i++) {\n        for (auto j = 0; j < vowels.size(); j++) {\n            if (word[i]\
    \ == vowels[j]) {\n                v.push_back(std::make_pair(i, j));\n      \
    \      }\n        }\n    }\n\n    for (auto i = 0; i < v.size(); i++) {\n    \
    \    auto left = std::find_if(word.begin(), word.begin() + v[i].first, [](auto\
    \ &c) {\n            return !(c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u');\n        });\n        auto right = std::find_if(word.begin() + v[i].first\
    \ + 1, word.end(), [](auto &c) {\n            return !(c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u');\n        });\n        if (left != word.begin()\
    \ + v[i].first && right != word.end()) {\n            return vowels.substr(v[i].second,\
    \ 1);\n        }\n    }\n\n    return answer;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmppd9o46fq: /tmp/tmppd9o46fq.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::transform(word.begin(),\
    \ word.end(), word.begin(), ::tolower);\n    int last_seen_vowel = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) !=\
    \ std::string::npos) {\n            last_seen_vowel = i;\n            break;\n\
    \        }\n    }\n    if (last_seen_vowel == -1) return \"\";\n    for (int i\
    \ = last_seen_vowel; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word[last_seen_vowel];\n        }\n    }\n    return \"\
    \";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpesiae0aq.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpesiae0aq.cpp:26:40: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)last_seen_vowel))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   26 |             return word[last_seen_vowel];\n      |                \
    \                        ^\n      |                                        |\n\
    \      |                                        __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"AEIOUaeiou\";\n  for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos) {\n\
    \      return word[i];\n    }\n  }\n  return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdizyh506.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpdizyh506.cpp:17:20: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   17 |       return word[i];\n      |                    ^\n      |      \
    \              |\n      |                    __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t//TODO: your code here\n\tstd::string vowels = \"aeiouAEIOU\";\n\t\
    std::string result;\n\tstd::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n\tstd::string::size_type idx = word.size() - 1;\n\tstd::string::size_type idx_c;\n\
    \tstd::string::size_type idx_v;\n\twhile (idx >= 0) {\n\t\tif (consonants.find(word[idx])\
    \ != std::string::npos) {\n\t\t\tidx_c = idx;\n\t\t\tstd::cout << idx_c << std::endl;\n\
    \t\t\tbreak;\n\t\t}\n\t\tidx--;\n\t}\n\tidx = idx_c - 1;\n\twhile (idx >= 0) {\n\
    \t\tif (vowels.find(word[idx]) != std::string::npos) {\n\t\t\tidx_v = idx;\n\t\
    \t\tstd::cout << idx_v << std::endl;\n\t\t\tbreak;\n\t\t}\n\t\tidx--;\n\t}\n\t\
    return word[idx_v];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp47dacq_2.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp47dacq_2.cpp:38:19: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](idx_v)\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   38 |  return word[idx_v];\n      |                   ^\n      |        \
    \           |\n      |                   __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // your code here\n  std::string result = \"\";\n  std::string vowels\
    \ = \"aeiou\";\n  //   result = word.size() == 1 ? \"\" : word[1];\n  //   return\
    \ result;\n  std::size_t found = word.find_last_of(vowels);\n  if (found == std::string::npos)\
    \ {\n    return result;\n  }\n  if (word.size() > 1) {\n    result = word[found];\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3b97vks7: /tmp/tmp3b97vks7.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here!\n    int len = word.length();\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int last_vowel = -1;\n    for(int i = len - 1;\
    \ i >= 0; i--){\n        if(vowels.find(word[i]) != std::string::npos){\n    \
    \        last_vowel = i;\n            break;\n        }\n    }\n    if(last_vowel\
    \ == -1) return \"\";\n    if(last_vowel == 0) return \"\";\n    int first_vowel\
    \ = -1;\n    for(int i = last_vowel - 1; i >= 0; i--){\n        if(vowels.find(word[i])\
    \ != std::string::npos){\n            first_vowel = i;\n            break;\n \
    \       }\n    }\n    if(first_vowel == -1) return \"\";\n    if(first_vowel ==\
    \ len - 1) return \"\";\n    return std::string(1, word[first_vowel]);\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpa4b6v9wo: /tmp/tmpa4b6v9wo.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\t// only keep consonants in\
    \ the word\n\tfor (int i = 0; i < word.size(); i++) {\n\t\tif (vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t\tword.erase(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\t\
    if (word.size() == 0) return \"\";\n\n\t// check if first or last letter is consonant\n\
    \tif (vowels.find(word[0]) != std::string::npos) return \"\";\n\tif (vowels.find(word[word.size()\
    \ - 1]) != std::string::npos) return \"\";\n\n\t// get the index in the word string\n\
    \tint closest_vowel_index = -1;\n\tint shortest_distance = word.size();\n\tfor\
    \ (int i = 0; i < word.size(); i++) {\n\t\tif (vowels.find(word[i]) != std::string::npos)\
    \ {\n\t\t\tint distance = i - closest_vowel_index - 1;\n\t\t\tif (distance < shortest_distance)\
    \ {\n\t\t\t\tshortest_distance = distance;\n\t\t\t\tclosest_vowel_index = i;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn std::string(1, word[closest_vowel_index]);\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpacgntwo4: /tmp/tmpacgntwo4.cpp:44: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    if(n <= 1) return \"\";\n    std::vector<char>\
    \ v = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    std::map<char,\
    \ bool> map;\n    for(auto i : v) map[i] = true;\n    int cons_ctr = 0;\n    for(int\
    \ i = n - 1; i >= 0; i--) {\n        if(map[word[i]]) {\n            if(cons_ctr\
    \ == 0) return \"\";\n            else return std::string(1, word[i]);\n     \
    \   }\n        cons_ctr++;\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpho7goumt: /tmp/tmpho7goumt.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  //your code here\n  std::string vowels = \"aeiou\";\n  for (auto\
    \ it = word.rbegin(); it != word.rend(); ++it) {\n    if (vowels.find(*it) !=\
    \ std::string::npos) {\n      return *it;\n    }\n  }\n  return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxljgf3hg.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpxljgf3hg.cpp:18:14: error: could not convert \u2018it.std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >::operator*()\u2019 from \u2018char\u2019\
    \ to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   18 |       return *it;\n      |              ^~~\n      |              |\n\
    \      |              char\n"
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string::iterator it = word.end()\
    \ - 1;\n\tbool first = true;\n\twhile (it != word.begin()) {\n\t\tif (vowels.find(*it)\
    \ != std::string::npos) {\n\t\t\tif (first) first = false;\n\t\t\telse return\
    \ std::string(1, *it);\n\t\t}\n\t\telse {\n\t\t\tif (!first) return std::string(1,\
    \ *it);\n\t\t}\n\t\tit--;\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3zwrmt3p: /tmp/tmp3zwrmt3p.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  bool prev_is_cons = true;\n\
    \  int closest_vowel_index = -1;\n  for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n    if (vowels.find(word[i]) != std::string::npos) {\n      if (!prev_is_cons)\
    \ {\n        closest_vowel_index = i;\n        break;\n      }\n    } else {\n\
    \      prev_is_cons = true;\n    }\n  }\n  if (closest_vowel_index == -1) return\
    \ \"\";\n  return std::string(1, word[closest_vowel_index]);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpdqix2t0x: /tmp/tmpdqix2t0x.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::set<char> vowels {'a', 'e', 'i', 'o', 'u'};\n\tint closest =\
    \ -1;\n\tfor (int i = word.size() - 1; i >= 0; i--) {\n\t\tif (vowels.count(word[i]))\
    \ {\n\t\t\tclosest = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = closest - 1;\
    \ i >= 0; i--) {\n\t\tif (!vowels.count(word[i])) {\n\t\t\treturn word.substr(closest,\
    \ 1);\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpz6m8t942: /tmp/tmpz6m8t942.cpp:35: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string s = \"\";\n\tint len = word.length();\n\tfor (int i =\
    \ len - 1; i >= 0; i--) {\n\t\tif (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n\t\t\tif (i == len - 1) {\n\t\
    \t\t\tcontinue;\n\t\t\t}\n\t\t\tif (word[i - 1] == 'a' || word[i - 1] == 'e' ||\
    \ word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u') {\n\t\t\t\t\
    continue;\n\t\t\t}\n\t\t\ts += word[i];\n\t\t\treturn s;\n\t\t}\n\t}\n\treturn\
    \ s;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgqjtgg0x: /tmp/tmpgqjtgg0x.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    string vowels(\"aeiouAEIOU\");\n    string consonants(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    );\n    string response;\n    int pos = word.size() - 1;\n    for (; pos >= 0;\
    \ pos--) {\n        if (consonants.find(word[pos]) != string::npos) {\n      \
    \      if (vowels.find(word[pos + 1]) != string::npos) {\n                response\
    \ = word[pos + 1];\n                break;\n            }\n        }\n    }\n\
    \    return response;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb7j26ay2.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpb7j26ay2.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope\n   14 |     string vowels(\"aeiouAEIOU\");\n      |     ^~~~~~\n/tmp/tmpb7j26ay2.cpp:14:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpb7j26ay2.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpb7j26ay2.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpb7j26ay2.cpp:15:11: error: expected \u2018;\u2019 before \u2018consonants\u2019\
    \n   15 |     string consonants(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    );\n      |           ^~~~~~~~~~~\n      |           ;\n/tmp/tmpb7j26ay2.cpp:16:11:\
    \ error: expected \u2018;\u2019 before \u2018response\u2019\n   16 |     string\
    \ response;\n      |           ^~~~~~~~~\n      |           ;\n/tmp/tmpb7j26ay2.cpp:19:13:\
    \ error: \u2018consonants\u2019 was not declared in this scope\n   19 |      \
    \   if (consonants.find(word[pos]) != string::npos) {\n      |        "
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  static const std::string vowels {\"aeiou\"};\n  static const std::string\
    \ consonants {\"bcdfghjklmnpqrstvwxyz\"};\n  std::string::size_type found_index\
    \ {};\n  std::string::size_type pos {};\n  for (std::string::size_type i {}; i\
    \ < word.size(); ++i) {\n    if (consonants.find(tolower(word[i])) != std::string::npos)\
    \ {\n      if (vowels.find(tolower(word[i+1])) != std::string::npos) {\n     \
    \   pos = i+1;\n        break;\n      }\n    }\n  }\n  return pos == 0 ? \"\"\
    \ : std::string(1, tolower(word[pos]));\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpiczumiup: /tmp/tmpiczumiup.cpp:30: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Let's build the vowel string\n    std::string vowel = \"AEIOUaeiou\"\
    ;\n    // Set a flag\n    bool isVowel = false;\n    // Set distance to maximum\
    \ value.\n    int distance = INT_MAX;\n    // Loop through the word\n    for (int\
    \ i = 0; i < word.length(); i++) {\n        // Check if the current character\
    \ is a vowel\n        if (vowel.find(word[i]) != std::string::npos) {\n      \
    \      // Loop through the consonants on right side of the vowel\n           \
    \ for (int j = i + 1; j < word.length(); j++) {\n                // Break if we\
    \ find a vowel\n                if (vowel.find(word[j]) != std::string::npos)\
    \ {\n                    break;\n                }\n                // Check if\
    \ the current distance is better than our initial distance\n                if\
    \ (j - i < distance) {\n                    // Update our distance\n         \
    \           distance = j - i;\n                    // Update our isVowel flag\n\
    \                    isVowel = true;\n                }\n            }\n     \
    \   }\n    }\n    // If no vowels were found, return empty string\n    if (!isVowel)\
    \ {\n        return \"\";\n    }\n    // Return the closest vowel found.\n   \
    \ return word[distance - 1];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp21vkvmjq.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp21vkvmjq.cpp:45:29: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(distance\
    \ - 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   45 |     return word[distance - 1];\n      |                           \
    \  ^\n      |                             |\n      |                         \
    \    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if(word.size() == 0)\n        return \"\";\n    int pos = word.size()\
    \ - 1;\n    int flag = 0;\n    while(pos > 0){\n        if(word[pos] == 'a' ||\
    \ word[pos] == 'e' || word[pos] == 'i' || word[pos] == 'o' || word[pos] == 'u'){\n\
    \            if(word[pos-1] != 'a' && word[pos-1] != 'e' && word[pos-1] != 'i'\
    \ && word[pos-1] != 'o' && word[pos-1] != 'u'){\n                flag = 1;\n \
    \               break;\n            }\n        }\n        pos--;\n    }\n    if(flag\
    \ == 1)\n        return word.substr(pos, 1);\n    else\n        return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi1uf6k6w: /tmp/tmpi1uf6k6w.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowel = \"aeiou\";\n    bool isVowel = false;\n   \
    \ int vowIndex = 0;\n    int k = 0;\n    int n = word.length();\n    for(int i\
    \ = n-1; i >= 0; i--) {\n        for(int j = 0; j < 5; j++) {\n            if(word[i]\
    \ == vowel[j]) {\n                isVowel = true;\n                vowIndex =\
    \ i;\n                k = j;\n                break;\n            }\n        }\n\
    \        if(isVowel) {\n            break;\n        }\n    }\n    if(isVowel)\
    \ {\n        for(int i = vowIndex-1; i >= 0; i--) {\n            for(int j = 0;\
    \ j < 5; j++) {\n                if(word[i] == vowel[j]) {\n                 \
    \   isVowel = false;\n                    break;\n                }\n        \
    \    }\n            if(!isVowel) {\n                break;\n            }\n  \
    \      }\n    }\n    if(isVowel) {\n        return vowel.substr(k, 1);\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqpo2kywv: /tmp/tmpqpo2kywv.cpp:52: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tfor (int i = word.size() - 1; i >= 0; i--) {\n\t\tif (isalpha(word[i]))\
    \ {\n\t\t\tif (i > 0 && isalpha(word[i - 1])) {\n\t\t\t\tswitch (word[i]) {\n\t\
    \t\t\tcase 'a':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'o':\n\t\t\
    \t\tcase 'u':\n\t\t\t\tcase 'A':\n\t\t\t\tcase 'E':\n\t\t\t\tcase 'I':\n\t\t\t\
    \tcase 'O':\n\t\t\t\tcase 'U':\n\t\t\t\t\treturn word.substr(i, 1);\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpt_flz0c5: /tmp/tmpt_flz0c5.cpp:39: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // pass last test case\n    // int len = word.length();\n    //\
    \ for(int i = len-1; i > 0; i--) {\n    //     if(word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n    //       \
    \  if(word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] != 'i' && word[i-1] !=\
    \ 'o' && word[i-1] != 'u') {\n    //             return word.substr(i,1);\n  \
    \  //         }\n    //     }\n    // }\n    // return \"\";\n    // ////////////////\n\
    \    std::string vowels = \"aeiou\";\n    std::string res = \"\";\n    // find\
    \ first consonant\n    int j = word.length() - 1;\n    while(vowels.find(word[j])\
    \ != std::string::npos) {\n        j--;\n    }\n    int best = word.length();\n\
    \    // find first vowel after consonant\n    while(vowels.find(word[j]) == std::string::npos)\
    \ {\n        j--;\n    }\n    best = j;\n    // loop through rest of letters\n\
    \    for(int i = j-1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            if(j-i < best) {\n                best = j-i;\n             \
    \   res = word.substr(i,1);\n            }\n        }\n        if(vowels.find(word[i])\
    \ == std::string::npos) {\n            j = i;\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3sim2w1v: /tmp/tmp3sim2w1v.cpp:54: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    std::string vowel=\"aeiouAEIOU\";\n    std::string\
    \ c=\"\";\n    for(int i=word.length()-1;i>=0;i--)\n    {\n        for(int j=0;j<vowel.length();j++)\n\
    \        {\n            if(word[i]==vowel[j])\n            {\n               \
    \ c=c+word[i];\n                for(int k=i-1;k>=0;k--)\n                {\n \
    \                   if(vowel.find(word[k])==std::string::npos)\n             \
    \       {\n                        return c;\n                    }\n        \
    \        }\n            }\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpr6suufst: /tmp/tmpr6suufst.cpp:42: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int l = word.length();\n  int index = -1;\n  int min = INT_MAX;\n\
    \  for(int i = 0; i < l; i++) {\n    char c = word[i];\n    if(c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') {\n      if(i > l - 3) continue;\n\
    \      int pre = i-1;\n      int next = i+1;\n      while(pre > 0 && (word[pre]\
    \ == 'a' || word[pre] == 'e' || word[pre] == 'i' || word[pre] == 'o' || word[pre]\
    \ == 'u')) {\n        pre--;\n      }\n      while(next < l && (word[next] ==\
    \ 'a' || word[next] == 'e' || word[next] == 'i' || word[next] == 'o' || word[next]\
    \ == 'u')) {\n        next++;\n      }\n      if(pre == -1 || next == l) continue;\n\
    \      if(i - pre < min) {\n        min = i - pre;\n        index = i;\n     \
    \ }\n    }\n  }\n  if(index == -1) return \"\";\n  return word.substr(index, 1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpljavtbom: /tmp/tmpljavtbom.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    std::set<char>\
    \ consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q',\
    \ 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'};\n    int left = -1;\n    int right\
    \ = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != vowels.end()) {\n            right = i;\n            break;\n        }\n\
    \    }\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (consonants.find(word[i])\
    \ != consonants.end()) {\n            left = i;\n            break;\n        }\n\
    \    }\n    if (left < 0 || right < 0) return \"\";\n    for (int i = left; i\
    \ >= 0; i--) {\n        if (vowels.find(word[i]) != vowels.end()) {\n        \
    \    return std::string(1, word[i]);\n        }\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpc4nr0czv: /tmp/tmpc4nr0czv.cpp:42: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ret = \"\";\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            if (i < word.size() - 1 && i > 0) {\n\
    \                if (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] !=\
    \ 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i + 1] != 'a' && word[i\
    \ + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u')\
    \ {\n                    ret = word[i];\n                    break;\n        \
    \        }\n            }\n        }\n    }\n    return ret;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxv6ou78c: /tmp/tmpxv6ou78c.cpp:29: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int idx = -1;\n    int minDiff\
    \ = INT_MAX;\n    int firstVowel = -1;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            firstVowel\
    \ = i;\n            break;\n        }\n    }\n    for (int i = firstVowel; i <\
    \ word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int diff = i - firstVowel;\n            if (diff < minDiff) {\n\
    \                minDiff = diff;\n                idx = i;\n            }\n  \
    \          firstVowel = i;\n        }\n    }\n    return idx == -1 ? \"\" : word.substr(idx,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6o1fh1t_: /tmp/tmp6o1fh1t_.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Define your regex here\n    std::regex regexVowel(\"[aeiou]\"\
    );\n    // Convert a string to a vector of characters\n    std::vector<char> word_c(word.begin(),\
    \ word.end());\n    // Reverse the vector of characters\n    std::reverse(word_c.begin(),\
    \ word_c.end());\n    // Convert a vector of characters to a string\n    std::string\
    \ word_r(word_c.begin(), word_c.end());\n    // Find the starting position of\
    \ the pattern in the word_r using regex\n    auto start = std::sregex_iterator(word_r.begin(),\
    \ word_r.end(), regexVowel);\n    // Find the ending position of the pattern in\
    \ the word_r using regex\n    auto end = std::sregex_iterator();\n    // Create\
    \ an iterator to iterate over the results\n    auto s_it = start;\n    // Create\
    \ a vector of pairs of integers to store start-end positions of vowels\n    std::vector<std::pair<int,\
    \ int>> positions;\n    // Create a vector of strings to store the vowels\n  \
    \  std::vector<std::string> vowels;\n    // Loop to find the starting and ending\
    \ positions of vowels\n    for (s_it; s_it != end; s_it++) {\n        positions.push_back(std::make_pair(s_it->position(),\
    \ s_it->position() + 1));\n    }\n    // Loop to find the vowel characters\n \
    \   for (int i = 0; i < positions.size(); i++) {\n        vowels.push_back(word_r.substr(positions[i].first,\
    \ positions[i].second));\n    }\n    // Loop to find the closest vowel\n    for\
    \ (int i = 0; i < vowels.size(); i++) {\n        // Find the closest character\
    \ that stands between two consonants\n        int pos = word_r.find(vowels[i]);\n\
    \        if (pos != -1) {\n            // Find the index of the character in the\
    \ word string\n            int index = word_r.size() - pos - 1;\n            //\
    \ Return the vowel character if its position is greater than 0\n            if\
    \ (\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjkb9ee7q.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpjkb9ee7q.cpp:49:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   49 | }\n      | ^\n/tmp/tmpjkb9ee7q.cpp:48:17: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   48 |             if (\n      |\
    \                ~^\n      |                 )\n   49 | }\n      | ~         \
    \       \n/tmp/tmpjkb9ee7q.cpp:49:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   49 | }\n      | ^\n/tmp/tmpjkb9ee7q.cpp:50:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   50\
    \ | int main() {\n      |            ^\n/tmp/tmpjkb9ee7q.cpp:65:1: error: expected\
    \ \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmpjkb9ee7q.cpp:41:45:\
    \ note: to match this \u2018{\u2019\n   41 |     for (int i = 0; i < vowels.size();\
    \ i++) {\n      |                                             ^\n/tmp/tmpjkb9ee7q.cpp:65:1:\
    \ error: expected \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmpjkb9ee7q.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpjkb9ee7q.cpp:65:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   65 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    std::vector<char>\
    \ conso = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'};\n    std::vector<char>::iterator it;\n \
    \   for(unsigned i = 0; i < word.length(); i++) {\n        it = std::find(vowels.begin(),\
    \ vowels.end(), word[i]);\n        if(it != vowels.end())\n            word[i]\
    \ = '*';\n        else {\n            it = std::find(conso.begin(), conso.end(),\
    \ word[i]);\n            if(it != conso.end())\n                word[i] = '_';\n\
    \        }\n    }\n    // std::cout << word << std::endl;\n    unsigned index\
    \ = word.length() - 1;\n    while(index > 0) {\n        if(word[index] == '*'\
    \ && word[index - 1] == '_') {\n            return std::string(1, word[index]);\n\
    \        }\n        index--;\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3je7eht4: /tmp/tmp3je7eht4.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your Code Here\n    std::string vowels = \"aeiou\";\n    std::string\
    \ closest_vowel;\n    int dist = INT_MAX;\n    int i = word.length() - 1;\n  \
    \  while (i >= 0) {\n        if (vowels.find(word[i]) != std::string::npos) {\n\
    \            closest_vowel = word[i];\n            break;\n        }\n       \
    \ i--;\n    }\n    return closest_vowel;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgnts9x5b: /tmp/tmpgnts9x5b.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string v = \"aeiou\";\n    char last_cons = '0';\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (v.find(word[i]) == std::string::npos)\
    \ {\n            last_cons = word[i];\n            break;\n        }\n    }\n\
    \    char first_cons = '0';\n    for (int i = 0; i < word.size(); i++) {\n   \
    \     if (v.find(word[i]) == std::string::npos) {\n            first_cons = word[i];\n\
    \            break;\n        }\n    }\n    if (last_cons == '0' || first_cons\
    \ == '0') return \"\";\n    int dist = 0;\n    char res = '0';\n    for (int i\
    \ = 0; i < word.size(); i++) {\n        if (v.find(word[i]) != std::string::npos)\
    \ {\n            if (word[i] < last_cons && word[i] > first_cons) {\n        \
    \        dist = (int) word[i] - (int) first_cons;\n                res = word[i];\n\
    \            }\n        }\n    }\n    if (res == '0') return \"\";\n    return\
    \ std::string(1, res);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_xapffxh: /tmp/tmp_xapffxh.cpp:45: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int len = word.length();\n  std::string vowels = \"aeiouAEIOU\";\n\
    \  for(int i = len - 1; i >= 0; i--) {\n    if(vowels.find(word[i]) != std::string::npos)\
    \ {\n      std::cout << word[i] << std::endl;\n      return std::string(1, word[i]);\n\
    \    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcyddz1i7: /tmp/tmpcyddz1i7.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: 'u

    u

    a

    '
  timestamp: 1660120049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    //0 = a, 4 = e, 8 = i, 14 = o, 20 = u\n    //assuming that the\
    \ following can only be the first vowel.\n    const int len = word.length();\n\
    \    char vowels[5] = {'a', 'e', 'i', 'o', 'u'};\n    bool* isVowel = new bool[5];\n\
    \    for(int i = 0; i < 5; i++) {\n        isVowel[i] = false;\n    }\n    for(int\
    \ i = 0; i < len; i++) {\n        char c = word[i];\n        if(c == 'a') {\n\
    \            isVowel[0] = true;\n        }\n        else if(c == 'e') {\n    \
    \        isVowel[1] = true;\n        }\n        else if(c == 'i') {\n        \
    \    isVowel[2] = true;\n        }\n        else if(c == 'o') {\n            isVowel[3]\
    \ = true;\n        }\n        else if(c == 'u') {\n            isVowel[4] = true;\n\
    \        }\n    }\n    for(int i = len - 1; i >= 0; i--) {\n        char c = word[i];\n\
    \        if(c == 'a') {\n            if(isVowel[0]) {\n                return\
    \ \"\";\n            }\n            else {\n                return \"a\";\n  \
    \          }\n        }\n        else if(c == 'e') {\n            if(isVowel[1])\
    \ {\n                return \"\";\n            }\n            else {\n       \
    \         return \"e\";\n            }\n        }\n        else if(c == 'i') {\n\
    \            if(isVowel[2]) {\n                return \"\";\n            }\n \
    \           else {\n                return \"i\";\n            }\n        }\n\
    \        else if(c == 'o') {\n            if(isVowel[3]) {\n                return\
    \ \"\";\n            }\n            else {\n                return \"o\";\n  \
    \          }\n        }\n        else if(c == 'u') {\n            if(isVowel[4])\
    \ {\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppcttd1qr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmppcttd1qr.cpp:77:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   77 | int main() {\n      |            ^\n/tmp/tmppcttd1qr.cpp:92:1:\
    \ error: expected \u2018}\u2019 at end of input\n   92 | }\n      | ^\n/tmp/tmppcttd1qr.cpp:74:27:\
    \ note: to match this \u2018{\u2019\n   74 |         else if(c == 'u') {\n   \
    \   |                           ^\n/tmp/tmppcttd1qr.cpp:92:1: error: expected\
    \ \u2018}\u2019 at end of input\n   92 | }\n      | ^\n/tmp/tmppcttd1qr.cpp:40:39:\
    \ note: to match this \u2018{\u2019\n   40 |     for(int i = len - 1; i >= 0;\
    \ i--) {\n      |                                       ^\n/tmp/tmppcttd1qr.cpp:92:1:\
    \ error: expected \u2018}\u2019 at end of input\n   92 | }\n      | ^\n/tmp/tmppcttd1qr.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmppcttd1qr.cpp:92:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   92 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tfor (int i = word.size() - 1;\
    \ i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\t\
    if (i == word.size() - 1) return \"\";\n\t\t\tif (vowels.find(word[i - 1]) ==\
    \ std::string::npos && vowels.find(word[i + 1]) == std::string::npos) return word.substr(i,\
    \ 1);\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_ahjyzkl: /tmp/tmp_ahjyzkl.cpp:28: int main(): Assertion `candidate(("eAsy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char>vowels = {'a','e','i','o','u','A','E','I','O','U'};\n\
    \    int i = word.size()-1;\n    int j = i-1;\n    while(i>=0){\n        if(std::find(vowels.begin(),vowels.end(),word[i])\
    \ != vowels.end()){\n            while(j>=0){\n                if(std::find(vowels.begin(),vowels.end(),word[j])\
    \ != vowels.end()){\n                    break;\n                }\n         \
    \       if(j==0){\n                    return \"\";\n                }\n     \
    \           j--;\n            }\n            if(j==-1){\n                return\
    \ \"\";\n            }\n            return std::string(1,word[i]);\n        }\n\
    \        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpiqhcolik: /tmp/tmpiqhcolik.cpp:41: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n\
    \  std::string closest_vowel;\n  int min = INT_MAX;\n  int flag = 0;\n  for(int\
    \ i = 0; i < word.length(); i++) {\n    for(int j = 0; j < 10; j++) {\n      if(word[i]\
    \ == vowels[j]) {\n        flag = 1;\n        int temp = i - 1;\n        while(temp\
    \ >= 0) {\n          if(!(word[temp] == 'a' || word[temp] == 'e' || word[temp]\
    \ == 'i' || word[temp] == 'o' || word[temp] == 'u' || word[temp] == 'A' || word[temp]\
    \ == 'E' || word[temp] == 'I' || word[temp] == 'O' || word[temp] == 'U')) {\n\
    \            if(min > i - temp) {\n              min = i - temp;\n           \
    \   closest_vowel = word[i];\n            }\n            break;\n          }\n\
    \          temp--;\n        }\n      }\n    }\n  }\n  if(flag == 0) {\n    return\
    \ \"\";\n  }\n  return closest_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwn9_55jc: /tmp/tmpwn9_55jc.cpp:43: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::vector<char> vowels {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U'};\n\tif (word.length() < 3) {\n\t\treturn \"\";\n\t}\n\tint vowel_index\
    \ = -1;\n\tint consonant_index = -1;\n\tfor (int i = word.length() - 1; i >= 0;\
    \ i--) {\n\t\tif (std::find(vowels.begin(), vowels.end(), word[i]) != vowels.end())\
    \ {\n\t\t\tvowel_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (vowel_index == -1)\
    \ {\n\t\treturn \"\";\n\t}\n\tfor (int i = vowel_index - 1; i >= 0; i--) {\n\t\
    \tif (std::find(vowels.begin(), vowels.end(), word[i]) == vowels.end()) {\n\t\t\
    \tconsonant_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (consonant_index == -1)\
    \ {\n\t\treturn \"\";\n\t}\n\treturn word.substr(vowel_index, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpq3makdbv: /tmp/tmpq3makdbv.cpp:46: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  return std::string();\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpsaxui31a: /tmp/tmpsaxui31a.cpp:18: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint n = word.length();\n\tbool is_found = false;\n\tint i = n - 1;\n\
    \twhile (i > 0) {\n\t\tif (word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u') {\n\t\t\tif (!(word[i - 1] == 'a' || word[i\
    \ - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u'))\
    \ {\n\t\t\t\tis_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\
    \tif (is_found) {\n\t\treturn word.substr(i, 1);\n\t}\n\treturn \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpb4e5lg2q: /tmp/tmpb4e5lg2q.cpp:37: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    std::string vowels = \"aeiou\";\n    std::string\
    \ found;\n    for(int i = word.length() - 1; i >= 0; i--) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            found = word[i];\n            break;\n\
    \        }\n    }\n    for(int i = found.length() - 1; i >= 0; i--) {\n      \
    \  if(vowels.find(word[i]) == std::string::npos) {\n            found = \"\";\n\
    \            break;\n        }\n    }\n    return found;\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjndzw_k4: /tmp/tmpjndzw_k4.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int i = word.size() - 1;\n\
    \    while (i > 0) {\n        if (vowels.find(word[i]) != std::string::npos) {\n\
    \            if (vowels.find(word[i-1]) == std::string::npos) {\n            \
    \    return std::string(1, word[i]);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpz9hjmfgo: /tmp/tmpz9hjmfgo.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tint minDistance = 99999;\n\tchar\
    \ closestVowel = '\\0';\n\tfor (int i = 0; i < word.length(); i++) {\n\t\tfor\
    \ (int j = 0; j < vowels.length(); j++) {\n\t\t\tif (word[i] == vowels[j]) {\n\
    \t\t\t\tint vowel_i = i;\n\t\t\t\tint consonant_i = i - 1;\n\t\t\t\twhile (consonant_i\
    \ >= 0 && !isalpha(word[consonant_i])) {\n\t\t\t\t\tconsonant_i--;\n\t\t\t\t}\n\
    \t\t\t\tif (consonant_i >= 0 && vowels.find(word[consonant_i]) == std::string::npos)\
    \ {\n\t\t\t\t\t// found consonant\n\t\t\t\t\tint consonant_i2 = i + 1;\n\t\t\t\
    \t\twhile (consonant_i2 < word.length() && !isalpha(word[consonant_i2])) {\n\t\
    \t\t\t\t\tconsonant_i2++;\n\t\t\t\t\t}\n\t\t\t\t\tif (consonant_i2 < word.length()\
    \ && vowels.find(word[consonant_i2]) == std::string::npos) {\n\t\t\t\t\t\t// found\
    \ second consonant\n\t\t\t\t\t\tint distance = consonant_i2 - consonant_i - 1;\n\
    \t\t\t\t\t\tif (distance < minDistance) {\n\t\t\t\t\t\t\tminDistance = distance;\n\
    \t\t\t\t\t\t\tclosestVowel = word[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\tif (closestVowel == '\\0') {\n\t\treturn \"\";\n\t}\n\t\
    else {\n\t\treturn std::string(1, closestVowel);\n\t}\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpavr19nyb: /tmp/tmpavr19nyb.cpp:52: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120051
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    for(int i = 0; i < word.size(); i++) {\n        if(word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n\
    \            return word[i];\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsqo6nrmr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpsqo6nrmr.cpp:16:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   16 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    int len = word.length();\n    int start\
    \ = len - 1;\n    while(start >= 0 && !isVowel(word[start]))\n        start--;\n\
    \    if(start < 0)\n        return \"\";\n    int end = start - 1;\n    while(end\
    \ >= 0 && isVowel(word[end]))\n        end--;\n    return word.substr(end + 1,\
    \ start - end);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n  \
    \  assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp29oifv6e.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp29oifv6e.cpp:17:26: error: \u2018isVowel\u2019 was not declared in\
    \ this scope; did you mean \u2018islower\u2019?\n   17 |     while(start >= 0\
    \ && !isVowel(word[start]))\n      |                          ^~~~~~~\n      |\
    \                          islower\n/tmp/tmp29oifv6e.cpp:22:23: error: \u2018\
    isVowel\u2019 was not declared in this scope; did you mean \u2018islower\u2019\
    ?\n   22 |     while(end >= 0 && isVowel(word[end]))\n      |                \
    \       ^~~~~~~\n      |                       islower\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    bool is_vowel = false;\n    int last_vowel_index = -1;\n    int\
    \ last_consonant_index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n\
    \        if (is_vowel) {\n            if (is_consonant(word[i])) {\n         \
    \       last_consonant_index = i;\n                break;\n            }\n   \
    \     } else {\n            if (is_vowel(word[i])) {\n                is_vowel\
    \ = true;\n                last_vowel_index = i;\n            }\n        }\n \
    \   }\n    return word.substr(last_vowel_index, 1);\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjm1hs40d.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpjm1hs40d.cpp:19:17: error: \u2018is_consonant\u2019 was not declared\
    \ in this scope\n   19 |             if (is_consonant(word[i])) {\n      |   \
    \              ^~~~~~~~~~~~\n/tmp/tmpjm1hs40d.cpp:24:33: error: \u2018is_vowel\u2019\
    \ cannot be used as a function\n   24 |             if (is_vowel(word[i])) {\n\
    \      |                                 ^\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tif (word.size() == 0) return \"\";\n\tstd::string vowels = \"aeiou\"\
    ;\n\tint n = word.size();\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--)\
    \ {\n\t\tint index = vowels.find(word[i]);\n\t\tif (index != std::string::npos)\
    \ {\n\t\t\tif (i != n - 1 && vowels.find(word[i + 1]) == std::string::npos)\n\t\
    \t\t\tans = i;\n\t\t\telse\n\t\t\t\tans = 0;\n\t\t}\n\t}\n\treturn ans ? word.substr(ans,\
    \ 1) : \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmplobznfqh: /tmp/tmplobznfqh.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tif (word.size() < 2) return \"\";\n\tfor (int i = word.size() - 1;\
    \ i >= 0; i--) {\n\t\tif (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u') {\n\t\t\tif (word[i - 1] != 'a' && word[i\
    \ - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u')\
    \ {\n\t\t\t\treturn std::string(1, word[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\
    \";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpji0vh78w: /tmp/tmpji0vh78w.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// TODO: your code here\n\tstd::string res;\n\tchar c = ' ';\n\t\
    std::string s = \"aeiouAEIOU\";\n\tfor (int i = word.size() - 1; i >= 0; i--)\
    \ {\n\t\tif (isalpha(word[i])) {\n\t\t\tif (s.find(word[i]) == std::string::npos)\
    \ {\n\t\t\t\tif (c != ' ') {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tc = word[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsxfq9ssa.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpsxfq9ssa.cpp:22:13: error: could not convert \u2018c\u2019 from \u2018\
    char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   22 |      return c;\n      |             ^\n      |             |\n    \
    \  |             char\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// your code here\n\tstd::string vowels = \"aeiou\";\n\tbool inConsonant\
    \ = false;\n\tfor (int i = word.length() - 1; i >= 0; i--) {\n\t\tif (vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t\tif (inConsonant) {\n\t\t\t\treturn std::string(1,\
    \ word[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tinConsonant = true;\n\t\t}\n\t\
    }\n\treturn \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph6pyc__m: /tmp/tmph6pyc__m.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::transform(word.begin(), word.end(), word.begin(), ::tolower);\n\
    \  int len = word.length();\n  if(len < 3)\n    return \"\";\n  int c2 = 0, c1\
    \ = 0, v1 = 0, v2 = 0;\n  int i = len - 1;\n  while(i >= 0) {\n    if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n      v2 = i;\n      break;\n    }\n    i--;\n  }\n  if(i == 0)\n    return\
    \ \"\";\n  i--;\n  while(i >= 0) {\n    if(word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n      v1 = i;\n     \
    \ break;\n    }\n    i--;\n  }\n  if(i == 0)\n    return \"\";\n  i--;\n  while(i\
    \ >= 0) {\n    if(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i]\
    \ != 'o' && word[i] != 'u') {\n      c2 = i;\n      break;\n    }\n    i--;\n\
    \  }\n  if(i == 0)\n    return \"\";\n  i--;\n  while(i >= 0) {\n    if(word[i]\
    \ != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u')\
    \ {\n      c1 = i;\n      break;\n    }\n    i--;\n  }\n  // printf(\"%d %d %d\
    \ %d\\n\", c1, c2, v1, v2);\n  if(c2 - v1 > v2 - c1)\n    return std::string(1,\
    \ word[v2]);\n  else\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk_iq1qea.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpk_iq1qea.cpp:61:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   61 | }\n      | ^\n/tmp/tmpk_iq1qea.cpp:61:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   61 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string res = \"\";\n\tint\
    \ minDis = std::numeric_limits<int>::max();\n\tfor (int i = word.size() - 1; i\
    \ >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\tint\
    \ j = i - 1;\n\t\t\twhile (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tif (i - j < minDis) {\n\
    \t\t\t\t\tminDis = i - j;\n\t\t\t\t\tres = word[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpowndcw2n: /tmp/tmpowndcw2n.cpp:39: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U'};\n    std::vector<std::string> answers;\n    int pos = word.length()\
    \ - 1;\n    for (int i = pos; i >= 0; i--) {\n        for (auto v : vowels) {\n\
    \            if (word[i] == v) {\n                answers.push_back(word.substr(i,\
    \ 1));\n            }\n        }\n    }\n    if (answers.size() == 0) {\n    \
    \    return \"\";\n    }\n    else {\n        return answers[0];\n    }\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcgv9pr7r: /tmp/tmpcgv9pr7r.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int right_of_last_vowel = -1;\n    int right_of_last_consonant\
    \ = -1;\n    int distance = INT_MAX;\n    int index = -1;\n    std::string vowels\
    \ = \"aeiouAEIOU\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    for (int i = 0; i < word.length(); i++) {\n        char c = word[i];\n\
    \        if (vowels.find(c) != std::string::npos) {\n            if (right_of_last_consonant\
    \ != -1) {\n                int d = i - right_of_last_consonant;\n           \
    \     if (d < distance) {\n                    distance = d;\n               \
    \     index = i;\n                }\n            }\n            right_of_last_vowel\
    \ = i;\n        } else if (consonants.find(c) != std::string::npos) {\n      \
    \      right_of_last_consonant = i;\n        }\n    }\n    if (index != -1) {\n\
    \        return word.substr(index, 1);\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbkx0pq0c: /tmp/tmpbkx0pq0c.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string result = \"\";\n  int index = word.size() - 1;\n  std::vector<char>\
    \ vowels = {'a', 'e', 'i', 'o', 'u'};\n  while (index >= 0) {\n    if (std::find(vowels.begin(),\
    \ vowels.end(), tolower(word[index])) != vowels.end()) {\n      result = word[index];\n\
    \      break;\n    }\n    index--;\n  }\n  return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpttdxg67y: /tmp/tmpttdxg67y.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n   std::set<char> vowels {'a', 'e', 'i', 'o', 'u'};\n   auto result\
    \ = word.rbegin();\n   for (; result != word.rend(); ++result) {\n     if (vowels.count(*result))\
    \ {\n        break;\n     }\n   }\n   auto search = result;\n   for (; search\
    \ != word.rend(); ++search) {\n     if (!vowels.count(*search)) {\n        break;\n\
    \     }\n   }\n   if (search == word.rend()) {\n      return \"\";\n   }\n   auto\
    \ result_distance = std::distance(result, word.rend());\n   auto search_distance\
    \ = std::distance(search, word.rend());\n   if (result_distance - search_distance\
    \ == 1) {\n      return \"\";\n   }\n   return std::string(1, *result);\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd2xrvyad: /tmp/tmpd2xrvyad.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tfor (int i = word.size() - 1;\
    \ i >= 0; i--) {\n\t\tif (vowels.find(word[i]) != std::string::npos) {\n\t\t\t\
    return word[i];\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy_p2o83x.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpy_p2o83x.cpp:17:17: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   17 |    return word[i];\n      |                 ^\n      |            \
    \     |\n      |                 __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tif (word.length() < 2) { return \"\"; }\n\tbool front_is_vowel =\
    \ is_vowel(word[0]);\n\tstd::string vowels = \"aeiouAEIOU\";\n\tstd::string closest_vowel\
    \ = \"\";\n\tint closest_vowel_pos = word.length();\n\tint pos = 1;\n\tint vowel_pos\
    \ = 0;\n\twhile (pos < word.length()) {\n\t\tvowel_pos = vowels.find(word[pos]);\n\
    \t\tif (vowel_pos != std::string::npos) {\n\t\t\tif (is_vowel(word[pos-1])) {\n\
    \t\t\t\tfront_is_vowel = true;\n\t\t\t} else {\n\t\t\t\tif (front_is_vowel) {\n\
    \t\t\t\t\tif (pos < closest_vowel_pos) {\n\t\t\t\t\t\tclosest_vowel = word[pos];\n\
    \t\t\t\t\t\tclosest_vowel_pos = pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\tpos++;\n\t}\n\treturn closest_vowel;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplvif0n52.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmplvif0n52.cpp:15:24: error: \u2018is_vowel\u2019 was not declared in\
    \ this scope\n   15 |  bool front_is_vowel = is_vowel(word[0]);\n      |     \
    \                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tauto found = word.find_last_of(\"aeiou\");\n\tfor (int i = found\
    \ - 1; i >= 0; i--) {\n\t\tif (isalpha(word[i]) && !isalpha(word[i - 1])) {\n\t\
    \t\treturn word.substr(found, 1);\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1g9ratgh: /tmp/tmp1g9ratgh.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::map<char,int> vowels = {{'a',1},{'e',1},{'i',1},{'o',1},{'u',1},{'A',1},{'E',1},{'I',1},{'O',1},{'U',1}};\n\
    \  int vowel_index = -1;\n  int prev_index = -1;\n  int pos = word.size()-1;\n\
    \  while(pos>=0){\n      if(vowels.find(word[pos]) != vowels.end()){\n       \
    \   vowel_index = pos;\n          break;\n      }\n      prev_index = pos;\n \
    \     pos--;\n  }\n  if(vowel_index == -1) return \"\";\n  if(prev_index == -1)\
    \ return \"\";\n  else if(vowel_index < prev_index) return \"\";\n  else{\n  \
    \    return word.substr(vowel_index,1);\n  }\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpywqq5f18: /tmp/tmpywqq5f18.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // Your code here\n  // return \"\";\n  int vowels[] = {'a', 'e',\
    \ 'i', 'o', 'u'};\n  int size = word.size();\n  if(size < 3) return \"\";\n  int\
    \ lastConsonantIndex = size - 1;\n  int closestVowelDistance = size;\n  int closestVowelIndex\
    \ = -1;\n  while(lastConsonantIndex >= 0) {\n    if(find(begin(vowels), end(vowels),\
    \ tolower(word[lastConsonantIndex])) == end(vowels)) break;\n    lastConsonantIndex--;\n\
    \  }\n  if(lastConsonantIndex == 0) return \"\";\n  for(int i = lastConsonantIndex\
    \ - 1; i >= 0; i--) {\n    if(find(begin(vowels), end(vowels), tolower(word[i]))\
    \ != end(vowels)) {\n      if(lastConsonantIndex - i < closestVowelDistance) {\n\
    \        closestVowelDistance = lastConsonantIndex - i;\n        closestVowelIndex\
    \ = i;\n      }\n    }\n  }\n  if(closestVowelIndex == -1) return \"\";\n  return\
    \ string(1, word[closestVowelIndex]);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3s5k3rim.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp3s5k3rim.cpp:23:13: error: \u2018begin\u2019 was not declared in this\
    \ scope\n   23 |     if(find(begin(vowels), end(vowels), tolower(word[lastConsonantIndex]))\
    \ == end(vowels)) break;\n      |             ^~~~~\n/tmp/tmp3s5k3rim.cpp:23:13:\
    \ note: suggested alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp3s5k3rim.cpp:2:\n/usr/include/c++/9/valarray:1224:5:\
    \ note:   \u2018std::begin\u2019\n 1224 |     begin(const valarray<_Tp>& __va)\n\
    \      |     ^~~~~\nIn file included from /usr/include/c++/9/filesystem:38,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmp3s5k3rim.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:516:3:\
    \ note:   \u2018std::filesystem::__cxx11::begin\u2019\n  516 |   begin(recursive_directory_iterator\
    \ __iter) noexcept\n      |   ^~~~~\n/tmp/tmp3s5k3rim.cpp:23:28: error: \u2018\
    end\u2019 was not declared in this scope\n   23 |     if(find(begin(vowels), end(vowels),\
    \ tolower(word[lastConsonantIndex])) == end(vowels)) break;\n      |         \
    \                   ^~~\n/tmp/tmp3s5k3rim.cpp:23:28: note: suggested alternatives:\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp3s5k3rim.cpp:2:\n/usr/include/c++/9/valarray:1244:5:\
    \ note:   \u2018std::end\u2019\n 1244 |     end(const valarray<_Tp>& __va)\n \
    \     |     ^~~\nIn file included from /usr/include/c++/9/filesystem:38,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n \
    \                from /tmp/tmp3s5k3rim.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:520:3:\
    \ note:   \u2018std::filesystem::__cxx11::end\u2019\n  520 |   end(recursive_directory_iterator)\
    \ noexcept\n      |   ^~~\n/tmp/tmp3s5k3rim.cpp:23:8: error: \u2018find\u2019\
    \ was not declared in this scope; did you mean \u2018std::find\u2019?\n   23 |\
    \     if(find(begin(vowels), end(vowels), tolower(word[lastConsonantIndex])) ==\
    \ end(vowels)) break;\n      |        ^~~~\n      |        std::find\n"
  stdout: ''
  timestamp: 1660120051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ret = \"\";\n    std::string vowels = \"aeiou\";\n\
    \    int len = word.length();\n    if (word[len-1] != 'a' && word[len-1] != 'e'\
    \ && word[len-1] != 'i' && word[len-1] != 'o' && word[len-1] != 'u') {\n     \
    \   ret = word[len-1];\n    }\n    for (int i = len-2; i >= 0; i--) {\n      \
    \  if (word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' &&\
    \ word[i] != 'u') {\n            if (word[i+1] == 'a' || word[i+1] == 'e' || word[i+1]\
    \ == 'i' || word[i+1] == 'o' || word[i+1] == 'u') {\n                ret = word[i+1];\n\
    \                break;\n            }\n        }\n    }\n    return ret;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqeqo71rs: /tmp/tmpqeqo71rs.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // code here\n  int flag = 0;\n  int i;\n  for(i = word.length()-1;\
    \ i >= 0; i--)\n  {\n    if(!(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u'))\n    {\n      flag = 1;\n      break;\n\
    \    }\n  }\n  if(flag == 0)\n    return \"\";\n  if(i == 0)\n    return \"\"\
    ;\n  for(int j = i-1; j >= 0; j--)\n  {\n    if(word[j] == 'a' || word[j] == 'e'\
    \ || word[j] == 'i' || word[j] == 'o' || word[j] == 'u')\n    {\n      return\
    \ word.substr(j,1);\n    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptm6gjutc: /tmp/tmptm6gjutc.cpp:42: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint i = word.size() - 1;\n\tint pos = 0;\n\tstd::string vowels =\
    \ \"aeiouAEIOU\";\n\twhile (i >= 0 && vowels.find(word[i]) == std::string::npos)\
    \ {\n\t\t--i;\n\t}\n\tpos = i;\n\ti = i - 1;\n\twhile (i >= 0 && vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t--i;\n\t}\n\tif (i == -1) {\n\t\treturn \"\";\n\
    \t}\n\tif (pos == word.size() - 1) {\n\t\treturn \"\";\n\t}\n\treturn word.substr(pos,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpy4n4y6nz: /tmp/tmpy4n4y6nz.cpp:44: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowel = \"aeiouAEIOU\";\n  std::string ans = \"\";\n\
    \  std::string alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n  int n = word.length();\n  int prev = -1;\n  int flag = 0;\n  for(int i =\
    \ n-1; i >= 0; i--) {\n    for(int j = 0; j < alphabets.length(); j++) {\n   \
    \   if(word[i] == alphabets[j]) {\n        flag = 1;\n        break;\n      }\n\
    \    }\n    if(flag == 0)\n      return \"\";\n    for(int j = 0; j < vowel.length();\
    \ j++) {\n      if(word[i] == vowel[j]) {\n        if(prev == -1)\n          return\
    \ word[i];\n        else {\n          if(i-prev < prev)\n            return word[i];\n\
    \          else\n            return ans;\n        }\n      }\n    }\n    if(prev\
    \ == -1)\n      prev = i;\n    else\n      ans = word[i];\n  }\n  return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsi3o4m9l.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpsi3o4m9l.cpp:32:24: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   32 |           return word[i];\n      |                        ^\n     \
    \ |                        |\n      |                        __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n/tmp/tmpsi3o4m9l.cpp:35:26: error: could not convert\
    \ \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   35 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int res = -1;\n    std::vector<int> vowels;\n    for (int i = 0;\
    \ i < word.size(); i++) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E'\
    \ || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n            vowels.push_back(i);\n\
    \        }\n    }\n    for (int i = vowels.size() - 1; i >= 0; i--) {\n      \
    \  if (vowels[i] == word.size() - 1) {\n            if (vowels[i - 1] == 0) {\n\
    \                continue;\n            }\n            else {\n              \
    \  res = vowels[i - 1];\n                break;\n            }\n        }\n  \
    \      else if (vowels[i] == 0) {\n            if (vowels[i + 1] == word.size()\
    \ - 1) {\n                continue;\n            }\n            else {\n     \
    \           res = vowels[i + 1];\n                break;\n            }\n    \
    \    }\n        else {\n            if (vowels[i + 1] == word.size() - 1) {\n\
    \                res = vowels[i - 1];\n                break;\n            }\n\
    \            else if (vowels[i - 1] == 0) {\n                res = vowels[i +\
    \ 1];\n                break;\n            }\n            else {\n           \
    \     if (vowels[i + 1] - vowels[i] < vowels[i] - vowels[i - 1]) {\n         \
    \           res = vowels[i + 1];\n                    break;\n               \
    \ }\n                else {\n                    res = vowels[i - 1];\n      \
    \              break;\n                }\n            }\n        }\n    }\n  \
    \  if (res == -1) {\n        return \"\";\n    }\n    else {\n        return std::string(1,\
    \ word[res]);\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo18_1r8_: /tmp/tmpo18_1r8_.cpp:70: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> vowel{\"a\", \"e\", \"i\", \"o\", \"u\"\
    };\n    for (int i = word.size() - 1; i >= 0; i--) {\n        for (auto c : vowel)\
    \ {\n            if (word[i] == c[0]) {\n                if (i > 0 && word[i -\
    \ 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o'\
    \ && word[i - 1] != 'u') {\n                    return c;\n                }\n\
    \            }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvugewrov: /tmp/tmpvugewrov.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowelPos = -1;\n    int prevVowelPos = -1;\n    int len = word.length();\n\
    \    for(int i = len - 1; i >= 0; i--) {\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ||\n          \
    \  word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U') {\n            vowelPos = i;\n            break;\n        }\n    }\n\
    \    if(vowelPos < 1) {\n        return \"\";\n    }\n    for(int i = vowelPos\
    \ - 1; i >= 0; i--) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' ||\n            word[i] == 'A' ||\
    \ word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n  \
    \          prevVowelPos = i;\n            break;\n        }\n    }\n    if(prevVowelPos\
    \ == -1) {\n        return word[vowelPos];\n    }\n    if(vowelPos - prevVowelPos\
    \ == 1) {\n        return \"\";\n    }\n    return word[vowelPos];\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp18uzno4f.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp18uzno4f.cpp:35:29: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)vowelPos))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   35 |         return word[vowelPos];\n      |                           \
    \  ^\n      |                             |\n      |                         \
    \    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}\n\
    /tmp/tmp18uzno4f.cpp:40:25: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)vowelPos))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   40 |     return word[vowelPos];\n      |                         ^\n   \
    \   |                         |\n      |                         __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120052
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string res = \"\";\n  int n = word.size();\n  std::vector<int>\
    \ v;\n  for(int i = 0; i < n; i++) {\n    if(word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n      v.push_back(i);\n\
    \    }\n  }\n  int m = v.size();\n  for(int i = 0; i < m; i++) {\n    if(v[i]\
    \ + 1 < n && v[i] - 1 >= 0) {\n      if(word[v[i] + 1] != 'a' && word[v[i] + 1]\
    \ != 'e' && word[v[i] + 1] != 'i' && word[v[i] + 1] != 'o' && word[v[i] + 1] !=\
    \ 'u' && word[v[i] + 1] != 'A' && word[v[i] + 1] != 'E' && word[v[i] + 1] != 'I'\
    \ && word[v[i] + 1] != 'O' && word[v[i] + 1] != 'U' && word[v[i] - 1] != 'a' &&\
    \ word[v[i] - 1] != 'e' && word[v[i] - 1] != 'i' && word[v[i] - 1] != 'o' && word[v[i]\
    \ - 1] != 'u' && word[v[i] - 1] != 'A' && word[v[i] - 1] != 'E' && word[v[i] -\
    \ 1] != 'I' && word[v[i] - 1] != 'O' && word[v[i] - 1] != 'U') {\n        res\
    \ = word[v[i]];\n        break;\n      }\n    }\n  }\n \n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int first_cons = -1;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        char ch = word[i];\n        if (ch != 'a' && ch != 'e' && ch\
    \ != 'i' && ch != 'o' && ch != 'u' &&\n            ch != 'A' && ch != 'E' && ch\
    \ != 'I' && ch != 'O' && ch != 'U') {\n            first_cons = i;\n         \
    \   break;\n        }\n    }\n    if (first_cons == -1) return \"\";\n    int\
    \ next_cons = -1;\n    for (int i = first_cons - 1; i >= 0; i--) {\n        char\
    \ ch = word[i];\n        if (ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o'\
    \ && ch != 'u' &&\n            ch != 'A' && ch != 'E' && ch != 'I' && ch != 'O'\
    \ && ch != 'U') {\n            next_cons = i;\n            break;\n        }\n\
    \    }\n    if (next_cons == -1) return \"\";\n    int closest_vowel = -1;\n \
    \   for (int i = next_cons + 1; i < first_cons; i++) {\n        char ch = word[i];\n\
    \        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||\n\
    \            ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n\
    \            closest_vowel = i;\n            break;\n        }\n    }\n    return\
    \ closest_vowel == -1 ? \"\" : std::string(1, word[closest_vowel]);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbaz26na4: /tmp/tmpbaz26na4.cpp:47: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    bool found = false;\n    std::string res;\n    std::vector<std::string>\
    \ vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n    std::vector<std::string>\
    \ consonants = {\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"};\n    for(int i = word.length() - 1; i >= 0; i--) {\n        if(i ==\
    \ 0) {\n            return \"\";\n        }\n        if(std::find(vowels.begin(),\
    \ vowels.end(), std::string(1, word[i])) != vowels.end()) {\n            if(std::find(consonants.begin(),\
    \ consonants.end(), std::string(1, word[i - 1])) != consonants.end()) {\n    \
    \            found = true;\n                res = std::string(1, word[i]);\n \
    \               break;\n            }\n        }\n    }\n    if(found) {\n   \
    \     return res;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgomviwsn: /tmp/tmpgomviwsn.cpp:41: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowel={'a','e','i','o','u','A','E','I','O','U'};\n\
    \    std::vector<char> word1;\n    int y;\n    int x;\n    for(int i=0;i<word.length();i++)\n\
    \    {\n        for(int j=0;j<vowel.size();j++)\n        {\n            if(word[i]==vowel[j])\n\
    \            {\n                word1.push_back(word[i]);\n            }\n   \
    \     }\n    }\n    if(word1.size()==0)\n    {\n        return \"\";\n    }\n\
    \    if(word1.size()==1)\n    {\n        std::string str;\n        str.push_back(word1[0]);\n\
    \        return str;\n    }\n    x=word1.size()-1;\n    y=x-1;\n    while(x!=word.length()&&y!=0)\n\
    \    {\n        if(y<0)\n        {\n            return \"\";\n        }\n    \
    \    if(word[x]!=word[y])\n        {\n            std::string str;\n         \
    \   str.push_back(word1[x]);\n            return str;\n        }\n        x--;\n\
    \        y--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpn5fru8hh: /tmp/tmpn5fru8hh.cpp:59: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowel{\"aeiou\"};\n    std::string result{\"\"};\n\
    \    int pos = 0;\n    for(int i = 0; i < word.size(); i++) {\n        for(int\
    \ j = 0; j < vowel.size(); j++) {\n            if(word[i] == vowel[j]) {\n   \
    \             pos = i;\n                break;\n            }\n        }\n   \
    \ }\n    if(pos != 0) {\n        if(pos == word.size() - 1) {\n            if(word[pos\
    \ - 1] != 'a' && word[pos - 1] != 'e' && word[pos - 1] != 'i' && word[pos - 1]\
    \ != 'o' && word[pos - 1] != 'u') {\n                result = word[pos];\n   \
    \         }\n        }\n        else {\n            if(word[pos - 1] != 'a' &&\
    \ word[pos - 1] != 'e' && word[pos - 1] != 'i' && word[pos - 1] != 'o' && word[pos\
    \ - 1] != 'u' && word[pos + 1] != 'a' && word[pos + 1] != 'e' && word[pos + 1]\
    \ != 'i' && word[pos + 1] != 'o' && word[pos + 1] != 'u') {\n                result\
    \ = word[pos];\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxdbzvluk: /tmp/tmpxdbzvluk.cpp:45: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int len = word.length();\n  int i = len - 1;\n  while(i >= 0) {\n\
    \    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u') {\n      if(i == len - 1) {\n        i--;\n        continue;\n\
    \      }\n      return word.substr(i, 1);\n    }\n    i--;\n  }\n  return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpoioa6gbw: /tmp/tmpoioa6gbw.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tfor (int i = word.size() - 1; i >= 0; i--) {\n\t\tif (word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n\t\t\tif (i == word.size() - 1) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\t\
    else if (word[i + 1] == 'a' || word[i + 1] == 'e' || word[i + 1] == 'i' || word[i\
    \ + 1] == 'o' || word[i + 1] == 'u') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\treturn word.substr(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqu2hnehg: /tmp/tmpqu2hnehg.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowl = 0;\n    std::vector<char> vowels {'a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U'};\n    std::vector<int> counts;\n    std::vector<char>\
    \ indices;\n    // takes care of the case where the word starts with a vowel\n\
    \    if (vowels.end() != std::find(vowels.begin(), vowels.end(), word[0])) {\n\
    \        for (int i = 0; i < word.length(); i++) {\n            if (vowels.end()\
    \ != std::find(vowels.begin(), vowels.end(), word[i])) {\n                vowl++;\n\
    \            }\n        }\n        if (vowl == 1) {\n            return \"\";\n\
    \        }\n    }\n    for (int i = 0; i < word.length(); i++) {\n        if (vowels.end()\
    \ != std::find(vowels.begin(), vowels.end(), word[i])) {\n            counts.push_back(i);\n\
    \            indices.push_back(word[i]);\n        }\n    }\n    std::vector<int>\
    \ dist;\n    std::vector<int> minIndex;\n    int min;\n    int minI;\n    int\
    \ minJ;\n    if (counts.size() > 1) {\n        for (int i = 0; i < counts.size()\
    \ - 1; i++) {\n            for (int j = i + 1; j < counts.size(); j++) {\n   \
    \             if (counts[j] - counts[i] > 0) {\n                    dist.push_back(counts[j]\
    \ - counts[i]);\n                    minIndex.push_back(i);\n                }\n\
    \            }\n        }\n        min = dist[0];\n        minI = minIndex[0];\n\
    \        minJ = 0;\n        for (int i = 0; i < dist.size(); i++) {\n        \
    \    if (dist[i] < min) {\n                min = dist[i];\n                minI\
    \ = minIndex[i];\n                minJ = i;\n            }\n        }\n\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplff8c95u.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmplff8c95u.cpp:61:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   61 | int main() {\n      |            ^\n/tmp/tmplff8c95u.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmplff8c95u.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmplff8c95u.cpp:76:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   76 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tbool flag=false;\n\tstd::string str1=\"aeiou\";\n\tfor(int i=word.length()-1;i>=0;i--)\n\
    \t{\n\t\tfor(int j=0;j<str1.length();j++)\n\t\t{\n\t\t\tif(word[i]==str1[j])\n\
    \t\t\t{\n\t\t\t\tif(i+1<word.length()&&i>0)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<str1.length();k++)\n\
    \t\t\t\t\t{\n\t\t\t\t\t\tif(word[i+1]!=str1[k]&&word[i-1]!=str1[k])\n\t\t\t\t\t\
    \t{\n\t\t\t\t\t\t\tif(flag==false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag=true;\n\
    \t\t\t\t\t\t\t\tstd::string str=\"\";\n\t\t\t\t\t\t\t\tstr=str+word[i];\n\t\t\t\
    \t\t\t\t\treturn str;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi01cphnl: /tmp/tmpi01cphnl.cpp:47: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Very good check here\n    if (word.size()<=2)\n        return\
    \ \"\";\n    std::vector<char> vowels = {'a','e','i','o','u','A','E','I','O','U'};\n\
    \    int index = word.size()-1;\n    // since if the last character is a vowel,\
    \ we need to check backward\n    if (std::find(vowels.begin(), vowels.end(), word[index])\
    \ != vowels.end())\n        index--;\n    for (int i=index; i>=0; i--) {\n   \
    \     // Find the first vowel that's between two consonants\n        if (std::find(vowels.begin(),\
    \ vowels.end(), word[i]) != vowels.end()) {\n            // if the first char\
    \ is a vowel, we need to check forward\n            if (i==0) {\n            \
    \    if (std::find(vowels.begin(), vowels.end(), word[i+1]) == vowels.end())\n\
    \                    return std::string(1, word[i]);\n            }\n        \
    \    // if there is a vowel before it and a vowel after it, we need to check the\
    \ next\n            else if (std::find(vowels.begin(), vowels.end(), word[i-1])\
    \ != vowels.end() ||\n                std::find(vowels.begin(), vowels.end(),\
    \ word[i+1]) != vowels.end())\n                continue;\n            // else\
    \ if there is a vowel before it, we need to check forward\n            else if\
    \ (std::find(vowels.begin(), vowels.end(), word[i-1]) != vowels.end()) {\n   \
    \             if (std::find(vowels.begin(), vowels.end(), word[i+1]) == vowels.end())\n\
    \                    return std::string(1, word[i]);\n            }\n        \
    \    // else it must be a vowel after it\n            else\n                return\
    \ std::string(1, word[i]);\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpsf1_jjdi: /tmp/tmpsf1_jjdi.cpp:52: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int dic = 0;\n  char vowel;\n  for(int i = word.size()-1; i >= 0;\
    \ i--) {\n    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I'\
    \ || word[i] == 'O' || word[i] == 'U') {\n      if(dic) {\n        return std::string(1,\
    \ word[i]);\n      }\n    } else {\n      dic++;\n    }\n  }\n  return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7525lj_p: /tmp/tmp7525lj_p.cpp:31: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  \n  //your code here\n  int l = word.length();\n  for(int i = l-1;\
    \ i>=0; i--)\n  {\n    if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u'\n       || word[i]=='A' || word[i]=='E' || word[i]=='I' || word[i]=='O'\
    \ || word[i]=='U')\n    {\n      if(i==l-1)\n        return \"\";\n      else\
    \ if(word[i-1]!='a' && word[i-1]!='e' && word[i-1]!='i' && word[i-1]!='o' && word[i-1]!='u'\n\
    \       && word[i-1]!='A' && word[i-1]!='E' && word[i-1]!='I' && word[i-1]!='O'\
    \ && word[i-1]!='U')\n      {\n        return word.substr(i,1);\n      }\n   \
    \ }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpi954iwis: /tmp/tmpi954iwis.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int wordPos = len - 1;\n    int vowelPos = 0;\n    std::vector<int> foundPositions;\n\
    \    while (wordPos >= 0) {\n        if (vowels.find(word[wordPos]) != std::string::npos)\
    \ {\n            foundPositions.push_back(wordPos);\n        }\n        wordPos--;\n\
    \    }\n    if (foundPositions.size() == 0) {\n        return \"\";\n    }\n \
    \   std::vector<int>::reverse_iterator it;\n    for (it = foundPositions.rbegin();\
    \ it != foundPositions.rend(); ++it) {\n        if (*it == len - 1) {\n      \
    \      continue;\n        }\n        if (vowels.find(word[*it + 1]) == std::string::npos)\
    \ {\n            return word.substr(*it, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxwny_gn2: /tmp/tmpxwny_gn2.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    const std::string vowels = \"aeiou\";\n    const std::string cons\
    \ = \"bcdfghjklmnpqrstvwxyz\";\n    for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n        if (cons.find(word[i]) != std::string::npos) {\n            for (int\
    \ j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j]) != std::string::npos)\
    \ {\n                    return std::string{word[j]};\n                }\n   \
    \         }\n            break;\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqq_6r4is: /tmp/tmpqq_6r4is.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    word = word.substr(word.find_first_not_of(' '),word.find_last_not_of('\
    \ ')+1);\n    if(!word.length())\n        return word;\n    std::string vowels\
    \ = \"aeiouAEIOU\";\n    int index = -1;\n    int start = 0;\n    while(start\
    \ != word.length()){\n        if(vowels.find(word[start]) != std::string::npos){\n\
    \            index = start;\n            break;\n        }\n        start++;\n\
    \    }\n    if(index == -1)\n        return \"\";\n    for(int i = index+1; i\
    \ < word.length(); i++){\n        if(vowels.find(word[i]) == std::string::npos)\n\
    \            return word.substr(index,1);\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp4khbv64f: /tmp/tmp4khbv64f.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // Write your code here\n  int vowel = 0;\n  int closest_vowel =\
    \ 0;\n  int vowel_distance = 0;\n  int closest_vowel_distance = 0;\n  for (int\
    \ i = word.length() - 1; i >= 0; i--) {\n    if (word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A'\
    \ || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n\
    \      vowel = i;\n      vowel_distance = word.length() - i;\n      if (vowel_distance\
    \ > closest_vowel_distance) {\n        closest_vowel = vowel;\n        closest_vowel_distance\
    \ = vowel_distance;\n      }\n    }\n  }\n  if (closest_vowel == 0) {\n    return\
    \ \"\";\n  }\n  else {\n    return word.substr(closest_vowel, 1);\n  }\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpachy4e7f: /tmp/tmpachy4e7f.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120053
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // std::cout << word << \"\\n\";\n    if (word.length() <= 1) {\n\
    \        return \"\";\n    }\n    int length = word.length();\n    std::string\
    \ vowels = \"aeiou\";\n    int left_offset = length - 1;\n    int right_offset\
    \ = length - 1;\n    int vowel_index = -1;\n    int left_index = -1;\n    int\
    \ right_index = -1;\n    while (vowel_index == -1 && left_offset >= 0) {\n   \
    \     for (int i = 0; i < vowels.length(); i++) {\n            // std::cout <<\
    \ \"left_offset\" << left_offset << \" \" <<  word[left_offset] << \" \" << vowels[i]\
    \ << \"\\n\";\n            if (word[left_offset] == vowels[i]) {\n           \
    \     vowel_index = i;\n                left_index = left_offset;\n          \
    \      break;\n            }\n        }\n        left_offset--;\n    }\n    while\
    \ (vowel_index == -1 && right_offset >= 0) {\n        for (int i = 0; i < vowels.length();\
    \ i++) {\n            // std::cout << \"right_offset\" << right_offset << \" \"\
    \ <<  word[right_offset] << \" \" << vowels[i] << \"\\n\";\n            if (word[right_offset]\
    \ == vowels[i]) {\n                vowel_index = i;\n                right_index\
    \ = right_offset;\n                break;\n            }\n        }\n        right_offset--;\n\
    \    }\n    if (left_index == -1 && right_index == -1) {\n        return \"\"\
    ;\n    }\n    if (left_index != -1 && right_index != -1) {\n        if (left_index\
    \ > right_index) {\n            return vowels.substr(vowel_index, 1);\n      \
    \  } else {\n            return vowels.substr(vowel_index, 1);\n        }\n  \
    \  }\n    if (left_index != -1) {\n        return vowels.substr(vowel_index, 1);\n\
    \   \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzpo1bpxy.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpzpo1bpxy.cpp:61:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   61 | int main() {\n      |            ^\n/tmp/tmpzpo1bpxy.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpzpo1bpxy.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpzpo1bpxy.cpp:76:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   76 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int wlen = word.length();\n  if\
    \ (wlen < 3) return \"\";\n  int last_c = -1;\n  for (int i = wlen - 1; i >= 0;\
    \ i--) {\n    if (vowels.find(word[i]) == std::string::npos) {\n      last_c =\
    \ i;\n      break;\n    }\n  }\n  if (last_c == -1) return \"\";\n  int first_c\
    \ = -1;\n  for (int i = last_c - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ == std::string::npos) {\n      first_c = i;\n      break;\n    }\n  }\n  if\
    \ (first_c == -1) return \"\";\n  int second_c = -1;\n  for (int i = first_c -\
    \ 1; i >= 0; i--) {\n    if (vowels.find(word[i]) == std::string::npos) {\n  \
    \    second_c = i;\n      break;\n    }\n  }\n  if (second_c == -1) return \"\"\
    ;\n  int first_v = -1;\n  for (int i = second_c - 1; i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      first_v = i;\n      break;\n    }\n  }\n  if\
    \ (first_v == -1) return \"\";\n  return word.substr(first_v, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmplk91vwe6: /tmp/tmplk91vwe6.cpp:53: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    if(len == 0) return \"\";\n    char\
    \ vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    std::string res = \"\";\n    for(int\
    \ i = len - 1; i >= 0; i--) {\n        for(int j = 0; j < 5; j++) {\n        \
    \    if(word[i] == vowels[j]) {\n                res = word[i];\n            \
    \    break;\n            }\n        }\n        if(res.size() > 0) {\n        \
    \    break;\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmppu0vlrmm: /tmp/tmppu0vlrmm.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // vowel: aeiouAEIOU\n    // consonant: b-df-hj-np-tv-zB-DF-HJ-NP-TV-Z\n\
    \    const std::string consonant = \"b-df-hj-np-tv-zB-DF-HJ-NP-TV-Z\";\n    const\
    \ std::string vowel = \"aeiouAEIOU\";\n    std::string::size_type pos_vowel;\n\
    \    std::string::size_type pos_consonant;\n    int min_distance = word.size();\n\
    \    char closest_vowel;\n    for (char& c : word) {\n        if (vowel.find(c)\
    \ != std::string::npos) {\n            pos_vowel = word.find(c);\n           \
    \ pos_consonant = word.find_last_of(consonant);\n            if (pos_consonant\
    \ != std::string::npos && pos_vowel > pos_consonant) {\n                int distance\
    \ = pos_vowel - pos_consonant;\n                if (distance < min_distance) {\n\
    \                    min_distance = distance;\n                    closest_vowel\
    \ = c;\n                }\n            }\n        }\n    }\n    return closest_vowel\
    \ ? std::string(1, closest_vowel) : \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpx3t8lt5j: /tmp/tmpx3t8lt5j.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int left_index = -1;\n    int right_index\
    \ = -1;\n    std::string vowel = \"aeiou\";\n    for(int i = 0; i < n; i++) {\n\
    \        if(vowel.find(word[i]) != std::string::npos) {\n            if(left_index\
    \ != -1)\n                return word[i];\n            right_index = i;\n    \
    \    }\n        else\n            left_index = i;\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxjaq87jr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpxjaq87jr.cpp:21:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   21 |                 return word[i];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660120053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int previous = -1;\n    int next = -1;\n    int current = -1;\n\
    \    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        current = i;\n        for (int j = 0; j < 5; j++)\
    \ {\n            if (word[i] == vowels[j]) {\n                if (previous !=\
    \ -1 && next != -1) {\n                    if (current - previous > next - current)\
    \ {\n                        return word.substr(next, 1);\n                  \
    \  } else {\n                        return word.substr(previous, 1);\n      \
    \              }\n                } else if (previous != -1) {\n             \
    \       return word.substr(previous, 1);\n                } else if (next != -1)\
    \ {\n                    return word.substr(next, 1);\n                }\n   \
    \         }\n        }\n        if (previous == -1) {\n            previous =\
    \ current;\n        } else if (next == -1) {\n            next = current;\n  \
    \      }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmppvwhzep7: /tmp/tmppvwhzep7.cpp:45: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    const std::string vowels = \"aeiou\";\n    auto pos = word.find_last_of(vowels);\n\
    \    while (true) {\n        if (pos == 0) return \"\";\n        if (vowels.find(word[pos\
    \ - 1]) == std::string::npos) break;\n        pos = word.find_last_of(vowels,\
    \ pos - 1);\n    }\n    return word.substr(pos, 1);\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1qr03q9v: /tmp/tmp1qr03q9v.cpp:29: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int word_len = word.length();\n    int last_c = 0;\n    bool found\
    \ = false;\n    int char_place = 0;\n    for (int i = word_len - 1; i >= 0; i--)\
    \ {\n        if (isalpha(word[i])) {\n            if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A'\
    \ || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n\
    \                found = true;\n                char_place = i;\n            \
    \    break;\n            }\n            else {\n                last_c = i;\n\
    \            }\n        }\n    }\n    if (found) {\n        return word.substr(char_place,\
    \ 1);\n    }\n    else {\n        return \"\";\n    }\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo0v6qbet: /tmp/tmpo0v6qbet.cpp:41: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string output = \"\";\n  int currentPosition = 0;\n  std::string\
    \ vowels = \"aeiouAEIOU\";\n  std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n  for (int i = 0; i < word.length(); i++) {\n    for (int j = 0; j < vowels.length();\
    \ j++) {\n      if (word[i] == vowels[j]) {\n        int count = 0;\n        for\
    \ (int k = i - 1; k >= 0; k--) {\n          for (int l = 0; l < consonants.length();\
    \ l++) {\n            if (word[k] == consonants[l]) {\n              count++;\n\
    \            }\n          }\n        }\n        if (count == 1) {\n          count\
    \ = 0;\n          for (int k = i + 1; k < word.length(); k++) {\n            for\
    \ (int l = 0; l < consonants.length(); l++) {\n              if (word[k] == consonants[l])\
    \ {\n                count++;\n              }\n            }\n          }\n \
    \         if (count == 1) {\n            return word.substr(i, 1);\n         \
    \ }\n        }\n      }\n    }\n  }\n  return output;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6uz_z_ym: /tmp/tmp6uz_z_ym.cpp:49: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string last_consonant,consonant,vowel;\n  for(auto x:word){\n\
    \    if(x!='a' && x!='e' && x!='i' && x!='o' && x!='u' && x!='A' && x!='E' &&\
    \ x!='I' && x!='O' && x!='U'){\n      consonant=x;\n    }\n    else{\n      vowel=x;\n\
    \      if(last_consonant!=\"\"){\n        return vowel;\n      }\n    }\n    if(consonant!=\"\
    \"){\n      last_consonant=consonant;\n      consonant=\"\";\n    }\n  }\n  return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpaxyawdzu: /tmp/tmpaxyawdzu.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::vector<std::string> vowels = {\"a\", \"e\", \"i\", \"o\", \"\
    u\"};\n  int len = word.length();\n  int i = len - 1;\n  std::vector<int> ind(len);\n\
    \  while(i >= 0) {\n    if(std::find(vowels.begin(), vowels.end(), word.substr(i,\
    \ 1)) != vowels.end()) {\n      ind[i] = 1;\n    }\n    i--;\n  }\n  if(ind[len\
    \ - 1] == 1) {\n    for(int i = len - 2; i >= 0; i--) {\n      if(ind[i] == 1)\
    \ {\n        return word.substr(i, 1);\n      }\n    }\n  }\n  return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpccwszg_e: /tmp/tmpccwszg_e.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string result{};\n\tstd::string vowels{ \"aeiou\" };\n\tstd::vector<char>\
    \ chars{};\n\tfor (int i = 0; i < word.size(); i++) {\n\t\tchars.push_back(word[i]);\n\
    \t}\n\tfor (int i = chars.size() - 1; i >= 0; i--) {\n\t\tif (vowels.find(chars[i])\
    \ != std::string::npos) {\n\t\t\tresult += chars[i];\n\t\t\tbreak;\n\t\t}\n\t\
    }\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgse3uol8: /tmp/tmpgse3uol8.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120054
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  \n  std::vector<std::string> tmp;\n  std::vector<std::string> tmp2;\n\
    \  std::string result;\n  std::string result2;\n  std::string s = \"UuEeIiOoAa\"\
    ;\n  int flag = 0;\n  int flag2 = 0;\n  for(int i = 0; i < word.length(); i++)\n\
    \  {\n      if(s.find(word[i]) != std::string::npos)\n      {\n        tmp.push_back(word.substr(i,1));\n\
    \        flag = 1;\n      }\n  }\n  if(flag == 0)\n  {\n    return \"\";\n  }\n\
    \  else\n  {\n    for(int i = 0; i < tmp.size(); i++)\n    {\n      if(i == 0\
    \ && s.find(word[i]) != std::string::npos)\n      {\n        tmp2.push_back(tmp[i]);\n\
    \      }\n      else if(i == tmp.size()-1 && s.find(word[i]) != std::string::npos)\n\
    \      {\n        tmp2.push_back(tmp[i]);\n      }\n      else if(s.find(word[i-1])\
    \ == std::string::npos && s.find(word[i+1]) == std::string::npos)\n      {\n \
    \       tmp2.push_back(tmp[i]);\n        flag2 = 1;\n      }\n    }\n    if(flag2\
    \ == 0)\n    {\n      return \"\";\n    }\n    else\n    {\n      result = tmp2[0];\n\
    \      result2 = tmp2[0];\n      for(int i = 0; i < tmp2.size(); i++)\n      {\n\
    \        if(word.find(tmp2[i]) > word.find(result))\n        {\n          result\
    \ = tmp2[i];\n        }\n        if(word.find(tmp2[i]) < word.find(result2))\n\
    \        {\n          result2 = tmp2[i];\n        }\n      }\n      if(word.find(result)\
    \ == word.find(result\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbymoe3kv.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpbymoe3kv.cpp:71:47: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   71 |       if(word.find(result) == word.find(result\n      |     \
    \                                   ~      ^\n      |                        \
    \                       )\n   72 | }\n      | ~                              \
    \                \n/tmp/tmpbymoe3kv.cpp:71:47: error: expected \u2018)\u2019 before\
    \ \u2018}\u2019 token\n   71 |       if(word.find(result) == word.find(result\n\
    \      |         ~                                     ^\n      |            \
    \                                   )\n   72 | }\n      | ~                  \
    \                            \n/tmp/tmpbymoe3kv.cpp:72:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmpbymoe3kv.cpp:73:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   73 | int main() {\n      |            ^\n/tmp/tmpbymoe3kv.cpp:88:1: error:\
    \ expected \u2018}\u2019 at end of input\n   88 | }\n      | ^\n/tmp/tmpbymoe3kv.cpp:35:3:\
    \ note: to match this \u2018{\u2019\n   35 |   {\n      |   ^\n/tmp/tmpbymoe3kv.cpp:88:1:\
    \ error: expected \u2018}\u2019 at end of input\n   88 | }\n      | ^\n/tmp/tmpbymoe3kv.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpbymoe3kv.cpp:88:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   88 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120054
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    bool flag = false;\n    int i = word.size() - 1;\n    std::vector<char>\
    \ v = {'a', 'e', 'i', 'o', 'u'};\n    for (; i >= 0; i--) {\n        if (std::find(v.begin(),\
    \ v.end(), word[i]) != v.end()) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    for (int j = i - 1; j >= 0; j--) {\n        if (std::find(v.begin(),\
    \ v.end(), word[j]) == v.end()) {\n            if (j == 0)\n                return\
    \ word[i];\n            else\n                return word[i];\n        }\n   \
    \ }\n    if (flag)\n        return word[i];\n    else\n        return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpue6uummm.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpue6uummm.cpp:26:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   26 |                 return word[i];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n/tmp/tmpue6uummm.cpp:28:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   28 |                 return word[i];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n/tmp/tmpue6uummm.cpp:32:22: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   32 |         return word[i];\n      |                      ^\n      |  \
    \                    |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120054
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::size_t found = word.find_last_of(vowels);\n\
    \  while (found != std::string::npos) {\n    std::string c = word.substr(found,\
    \ 1);\n    if (found > 0 && vowels.find(word.substr(found - 1, 1)) == std::string::npos\
    \ &&\n        vowels.find(word.substr(found + 1, 1)) == std::string::npos) {\n\
    \      return c;\n    }\n    found = word.find_last_of(vowels, found - 1);\n \
    \ }\n  return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660120059
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // Write your code here.\n  int n = word.length();\n  int pos = -1;\n\
    \  for(int i = n-1; i>=0; i--){\n    if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E'\
    \ || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'){\n      if(i != n-1 &&\
    \ i != 0){\n        if(word[i+1] != 'a' && word[i+1] != 'e' && word[i+1] != 'i'\
    \ && word[i+1] != 'o' && word[i+1] != 'u' && word[i+1] != 'A' && word[i+1] !=\
    \ 'E' && word[i+1] != 'I' && word[i+1] != 'O' && word[i+1] != 'U' &&\n       \
    \   word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] != 'i' && word[i-1] != 'o'\
    \ && word[i-1] != 'u' && word[i-1] != 'A' && word[i-1] != 'E' && word[i-1] !=\
    \ 'I' && word[i-1] != 'O' && word[i-1] != 'U'){\n          pos = i;\n        \
    \  break;\n        }\n      }\n    }\n  }\n  if(pos == -1)\n    return \"\";\n\
    \  else\n    return word.substr(pos, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // your code here\n  std::string vowels=\"aeiouAEIOU\";\n  std::string\
    \ consonants=\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n  int min=INT_MAX;\n\
    \  int i;\n  char v;\n  for(i=0;i<word.length();i++)\n  {\n      if(vowels.find(word[i])!=std::string::npos)\n\
    \      {\n          if(min>i)\n          {\n              min=i;\n           \
    \   v=word[i];\n          }\n      }\n  }\n  std::cout<<min<<std::endl;\n  if(min==0\
    \ || min==word.length()-1)\n    return \"\";\n  for(i=min-1;i>=0;i--)\n  {\n \
    \     if(consonants.find(word[i])!=std::string::npos)\n      {\n          std::cout<<\"\
    here\";\n          if(min-i==1)\n          {\n              return \"\";\n   \
    \       }\n          else{\n              return std::string(1,v);\n         \
    \ }\n      }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpeg6rli4w: /tmp/tmpeg6rli4w.cpp:52: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: '1

    '
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// regex(\"[aeiouy]\")\n\tstd::vector<char> vowels({'a', 'e', 'i',\
    \ 'o', 'u', 'y'});\n\t// std::cout << vowels.size() << '\\n';\n\t// std::cout\
    \ << vowels[2] << '\\n';\n\t// std::cout << word << '\\n';\n\tint count = 0;\n\
    \tbool vowel = false;\n\tint index = 0;\n\tstd::string answer = \"\";\n\tfor (int\
    \ i = word.size() - 1; i >= 0; i--) {\n\t\t// std::cout << word[i] << \" \";\n\
    \t\tif (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' || word[i] == 'y') {\n\t\t\tvowel = true;\n\t\t\tindex = i;\n\
    \t\t\t// std::cout << \"Vowel\" << '\\n';\n\t\t}\n\t\tif (vowel == true && count\
    \ > 0) {\n\t\t\t// std::cout << \"Vowel\" << '\\n';\n\t\t\tanswer = word[index];\n\
    \t\t\treturn answer;\n\t\t}\n\t\tif (vowel == false) {\n\t\t\t// std::cout <<\
    \ \"Consonant\" << '\\n';\n\t\t\tcount++;\n\t\t}\n\t}\n\t// std::cout << word[index]\
    \ << '\\n';\n\tif (answer == \"\") {\n\t\tanswer = \"\";\n\t}\n\treturn answer;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmplc1axedx: /tmp/tmplc1axedx.cpp:55: int main(): Assertion `candidate(("ab"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string v = \"aeiou\";\n    std::string res = \"\";\n    int\
    \ i = word.size() - 1;\n    while (i > 0) {\n        if (v.find(word[i]) != std::string::npos)\
    \ {\n            res = word[i];\n            break;\n        }\n        i--;\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkvfw77mj: /tmp/tmpkvfw77mj.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::regex vowels(\"[aeiou]\");\n    std::sregex_iterator pos(word.begin(),\
    \ word.end(), vowels);\n    std::sregex_iterator end;\n    std::string result(\"\
    \");\n    for (; pos != end; ++pos) {\n        auto cur = pos->str();\n      \
    \  if (std::islower(cur[0])) {\n            char left = std::islower(pos->prefix().str()[0])\
    \ ? pos->prefix().str()[0] : 0;\n            char right = std::islower(pos->suffix().str()[0])\
    \ ? pos->suffix().str()[0] : 0;\n            if (left && right) {\n          \
    \      result = cur;\n                break;\n            }\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqomqzg5d: /tmp/tmpqomqzg5d.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint len = word.length();\n\tstd::string vowels = \"aeiou\";\n\tstd::string\
    \ ret = \"\";\n\tfor (int i = len - 1; i >= 0; i--) {\n\t\tif (std::string::npos\
    \ != vowels.find(word[i])) {\n\t\t\t//we find a vowel\n\t\t\tint j = i;\n\t\t\t\
    for (j = i - 1; j >= 0; j--) {\n\t\t\t\tif (std::string::npos != vowels.find(word[j]))\
    \ {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == -1) {\n\t\t\t\t// all\
    \ the letters from 0 -> i-1 are consonants\n\t\t\t\treturn word[i];\n\t\t\t}\n\
    \t\t\telse {\n\t\t\t\tint k = i;\n\t\t\t\tfor (k = i + 1; k < len; k++) {\n\t\t\
    \t\t\tif (std::string::npos != vowels.find(word[k])) {\n\t\t\t\t\t\tbreak;\n\t\
    \t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k == len) {\n\t\t\t\t\t// all the letters from\
    \ i+1 -> len are consonants\n\t\t\t\t\treturn word[i];\n\t\t\t\t}\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn ret;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5bn6fqoa.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp5bn6fqoa.cpp:28:18: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   28 |     return word[i];\n      |                  ^\n      |          \
    \        |\n      |                  __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n/tmp/tmp5bn6fqoa.cpp:39:19: error: could not convert\
    \ \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   39 |      return word[i];\n      |                   ^\n      |        \
    \           |\n      |                   __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    const int size = word.size();\n    if (size <= 1) return \"\";\n\
    \    int cons = size;\n    for (int i = size - 1; i >= 0; --i) {\n        char\
    \ c = word[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            if (cons - i > 1) return std::string(1, c);\n       \
    \     else return \"\";\n        }\n        else cons = i;\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpy0orxf8o: /tmp/tmpy0orxf8o.cpp:29: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string res = \"\";\n    std::map<int, std::string> vowel_pos;\n\
    \    std::string word_lower_case = word;\n    std::transform(word_lower_case.begin(),\
    \ word_lower_case.end(), word_lower_case.begin(), ::tolower);\n    for (int i\
    \ = 0; i < word_lower_case.length(); i++) {\n        if (word_lower_case[i] ==\
    \ 'a' || word_lower_case[i] == 'e' || word_lower_case[i] == 'i' || word_lower_case[i]\
    \ == 'o' || word_lower_case[i] == 'u') {\n            vowel_pos[i] = word[i];\n\
    \        }\n    }\n    int vowel_count = vowel_pos.size();\n    if (vowel_count\
    \ == 0) {\n        return res;\n    }\n    else if (vowel_count == 1) {\n    \
    \    return vowel_pos.begin()->second;\n    }\n    else {\n        int min_dist\
    \ = INT_MAX;\n        int idx = INT_MAX;\n        for (auto itr = vowel_pos.begin();\
    \ itr != vowel_pos.end(); itr++) {\n            int dist = itr->first - (vowel_pos.begin()->first\
    \ + 1);\n            if (dist >= 0 && dist < min_dist) {\n                min_dist\
    \ = dist;\n                idx = itr->first;\n            }\n        }\n     \
    \   if (idx != INT_MAX) {\n            res = vowel_pos[idx];\n        }\n    \
    \    return res;\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwbzxl29r: /tmp/tmpwbzxl29r.cpp:50: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here!\n    int i=0;\n    int index = -1;\n    bool\
    \ flag = false;\n    for(i=word.length()-1;i>=0;i--){\n      if(word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'){\n\
    \        if(flag == true){\n          index = i;\n          break;\n        }\n\
    \      }\n      else{\n        flag = true;\n      }\n    }\n    if(index == -1){\n\
    \      return \"\";\n    }\n    return word.substr(index,1);\n  }\n  \nint main()\
    \ {\n  assert(get_closest_vowel(\"yogurt\") == \"u\");\n  assert(get_closest_vowel(\"\
    FULL\") == \"U\");\n  assert(get_closest_vowel(\"quick\") == \"\");\n  assert(get_closest_vowel(\"\
    ab\") == \"\");\n  assert(get_closest_vowel(\"ALOHA\") == \"A\");\n  assert(get_closest_vowel(\"\
    mist\") == \"i\");\n  assert(get_closest_vowel(\"awake\") == \"a\");\n  assert(get_closest_vowel(\"\
    distinguish\") == \"i\");\n  assert(get_closest_vowel(\"friends\") == \"i\");\n\
    \  assert(get_closest_vowel(\"another\") == \"o\");\n  assert(get_closest_vowel(\"\
    THOROUGH\") == \"O\");\n  assert(get_closest_vowel(\"perform\") == \"o\");\n \
    \ assert(get_closest_vowel(\"WORLD\") == \"O\");\n  assert(get_closest_vowel(\"\
    own\") == \"o\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptakqz2ia.cpp:49:38: warning: missing terminating \" character\n\
    \   49 |   assert(get_closest_vowel(\"own\") == \"o\n      |                 \
    \                     ^\n/tmp/tmptakqz2ia.cpp:66: error: unterminated argument\
    \ list invoking macro \"assert\"\n   66 | }\n      | \n/tmp/tmptakqz2ia.cpp: In\
    \ function \u2018int main()\u2019:\n/tmp/tmptakqz2ia.cpp:49:3: error: \u2018assert\u2019\
    \ was not declared in this scope\n   49 |   assert(get_closest_vowel(\"own\")\
    \ == \"o\n      |   ^~~~~~\n/tmp/tmptakqz2ia.cpp:3:1: note: \u2018assert\u2019\
    \ is defined in header \u2018<cassert>\u2019; did you forget to \u2018#include\
    \ <cassert>\u2019?\n    2 | #include<bits/stdc++.h>\n  +++ |+#include <cassert>\n\
    \    3 | // You are given a word. Your task is to find the closest vowel that\
    \ stands between\n/tmp/tmptakqz2ia.cpp:49:3: error: expected \u2018}\u2019 at\
    \ end of input\n   49 |   assert(get_closest_vowel(\"own\") == \"o\n      |  \
    \ ^~~~~~\n/tmp/tmptakqz2ia.cpp:35:12: note: to match this \u2018{\u2019\n   35\
    \ | int main() {\n      |            ^\n"
  stdout: ''
  timestamp: 1660120054
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string::iterator last_found_vowel;\n\
    \  std::string::iterator it;\n  for (it = word.end() - 1; it != word.begin();\
    \ it--) {\n    if (vowels.find(*it) != std::string::npos) {\n      if (last_found_vowel\
    \ == NULL) {\n        last_found_vowel = it;\n      } else {\n        if (last_found_vowel\
    \ == word.end() - 1) {\n          return std::string(\"\");\n        }\n     \
    \   std::string::iterator it2 = it;\n        while (it2 != last_found_vowel) {\n\
    \          it2++;\n          if (vowels.find(*it2) == std::string::npos) {\n \
    \           return *it;\n          }\n        }\n        last_found_vowel = it;\n\
    \      }\n    }\n  }\n  return std::string(\"\");\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_7_3ntpn.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp_7_3ntpn.cpp:19:28: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019}\
    \ and \u2018long int\u2019)\n   19 |       if (last_found_vowel == NULL) {\n \
    \     |                            ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp_7_3ntpn.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/uchar.h:29,\n\
    \                 from /usr/include/c++/9/cuchar:53,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:61,\n\
    \                 from /tmp/tmp_7_3ntpn.cpp:2:\n/tmp/tmp_7_3ntpn.cpp:19:31: note:\
    \   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorR, _Container>\u2019\
    \ and \u2018long int\u2019\n   19 |       if (last_found_vowel == NULL) {\n  \
    \    |                               ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp_7_3ntpn.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note: candidate: \u2018template<class _Iterator, class _Container> bool"
  stdout: ''
  timestamp: 1660120054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int l = word.length();\n  bool flag = false;\n  int i,j;\n  if(l==0)\n\
    \    return \"\";\n  for(i=l-1;i>=0;i--)\n  {\n    if(!(word[i]=='a' || word[i]=='e'\
    \ || word[i]=='i' || word[i]=='o' || word[i]=='u' || word[i]=='A' || word[i]=='E'\
    \ || word[i]=='I' || word[i]=='O' || word[i]=='U'))\n    {\n      flag = true;\n\
    \      break;\n    }\n  }\n  if(flag==false)\n    return \"\";\n  flag = false;\n\
    \  for(j=i-1;j>=0;j--)\n  {\n    if(word[j]=='a' || word[j]=='e' || word[j]=='i'\
    \ || word[j]=='o' || word[j]=='u' || word[j]=='A' || word[j]=='E' || word[j]=='I'\
    \ || word[j]=='O' || word[j]=='U')\n    {\n      flag = true;\n      break;\n\
    \    }\n  }\n  if(flag==false)\n    return \"\";\n  else\n    return word.substr(j,1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpg71oyoml: /tmp/tmpg71oyoml.cpp:47: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    int cnt = 0;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) !=\
    \ std::string::npos) {\n            cnt++;\n        } else {\n            if (cnt\
    \ == 1) {\n                return word.substr(i, 1);\n            } else {\n \
    \               cnt = 0;\n            }\n        }\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpyf8y5__v: /tmp/tmpyf8y5__v.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string letter =\
    \ \"\";\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            letter = word[i];\n            break;\n\
    \        }\n    }\n    return letter;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcuzhmz0o: /tmp/tmpcuzhmz0o.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\tint i =\
    \ 0;\n\tint pos = -1;\n\tfor (char c : word) {\n\t\tif (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n\t\t\tpos = i;\n\t\t}\n\t\ti++;\n\t}\n\t\
    return std::string(1, word[pos]);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbcx5sfhv: /tmp/tmpbcx5sfhv.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // Your code here\n  std::vector<char> vowels = {'a', 'e', 'i', 'o',\
    \ 'u'};\n  int res = -1;\n  for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \ if (std::find(vowels.begin(), vowels.end(), word[i]) != vowels.end()) {\n  \
    \    res = i;\n      break;\n    }\n  }\n  if (res == -1) return \"\";\n  std::vector<char>\
    \ consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q',\
    \ 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'};\n  int left = -1;\n  for (int i = res\
    \ - 1; i >= 0; i--) {\n    if (std::find(consonants.begin(), consonants.end(),\
    \ word[i]) != consonants.end()) {\n      left = i;\n      break;\n    }\n  }\n\
    \  if (left == -1) return \"\";\n  std::string ret;\n  ret += word[res];\n  return\
    \ ret;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwyzncbdo: /tmp/tmpwyzncbdo.cpp:43: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint idx;\n\tfor (idx = word.size() - 1; idx >= 0; idx--) {\n\t\t\
    if (std::find(std::begin(vowels), std::end(vowels), word[idx]) != std::end(vowels))\
    \ {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn word.substr(idx, 1);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4cyf30sr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp4cyf30sr.cpp:16:28: error: \u2018vowels\u2019 was not declared in this\
    \ scope\n   16 |   if (std::find(std::begin(vowels), std::end(vowels), word[idx])\
    \ != std::end(vowels)) {\n      |                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660120055
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint ind = -1;\n\tfor (int i = 0; i < word.size(); i++) {\n\t\tif\
    \ (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u') {\n\t\t\tif (i > 0 && word[i - 1] != 'a' && word[i - 1] != 'e' && word[i\
    \ - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u') {\n\t\t\t\tif (i <\
    \ word.size() - 1 && word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] !=\
    \ 'i' && word[i + 1] != 'o' && word[i + 1] != 'u') {\n\t\t\t\t\tif (ind == -1)\
    \ {\n\t\t\t\t\t\tind = i;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (i >\
    \ ind) {\n\t\t\t\t\t\t\tind = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\tif (ind == -1) {\n\t\treturn \"\";\n\t}\n\telse {\n\t\tstd::string\
    \ ans = \"\";\n\t\tans += word[ind];\n\t\treturn ans;\n\t}\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \            return word.substr(i, 1);\n        i--;\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpc5vkhfk1: /tmp/tmpc5vkhfk1.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::vector<char> vec{'a','e','i','o','u','A','E','I','O','U'};\n\
    \  std::string str = \"\";\n  int flag = 0;\n  for(int i = word.length()-1; i>=0;\
    \ i--){\n    for(int j = 0; j<vec.size(); j++){\n      if(word[i] == vec[j]){\n\
    \        flag++;\n        break;\n      }\n    }\n    if(flag > 1){\n      str\
    \ += word[i+1];\n      break;\n    }\n  }\n  return str;\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1oo6sv33: /tmp/tmp1oo6sv33.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int left = 0;\n    int right = len-1;\n\
    \    int left_count = 0;\n    int right_count = 0;\n    std::string ans;\n   \
    \ while(left < len){\n        if(word[left] == 'a' || word[left] == 'e' || word[left]\
    \ == 'i' || word[left] == 'o' || word[left] == 'u'){\n            left_count =\
    \ 0;\n        }\n        else{\n            left_count++;\n        }\n       \
    \ left++;\n    }\n    while(right >= 0){\n        if(word[right] == 'a' || word[right]\
    \ == 'e' || word[right] == 'i' || word[right] == 'o' || word[right] == 'u'){\n\
    \            right_count = 0;\n        }\n        else{\n            right_count++;\n\
    \        }\n        right--;\n    }\n    // std::cout << left_count << \" \" <<\
    \ right_count << \"\\n\";\n    if(left_count == len || right_count == len){\n\
    \        return ans;\n    }\n    for(int i = len-1; i >= 0; i--){\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'){\n\
    \            return std::string(1, word[i]);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp64ecvtpn: /tmp/tmp64ecvtpn.cpp:53: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if(word.size() == 0)\n        return \"\";\n    if(word.size()\
    \ == 1)\n        return \"\";\n    if(word.size() == 2)\n        return \"\";\n\
    \    if(word.size() == 3){\n        if(isalpha(word[0]) && isalpha(word[1]) &&\
    \ isalpha(word[2])){\n            if(word[1] == 'a' || word[1] == 'e' || word[1]\
    \ == 'i' || word[1] == 'o' || word[1] == 'u')\n                return word.substr(1,\
    \ 1);\n            else return \"\";\n        }\n        else return \"\";\n \
    \   }\n    if(word.size() == 4){\n        if(isalpha(word[0]) && isalpha(word[1])\
    \ && isalpha(word[2]) && isalpha(word[3])){\n            if(word[1] == 'a' ||\
    \ word[1] == 'e' || word[1] == 'i' || word[1] == 'o' || word[1] == 'u')\n    \
    \            return word.substr(1, 1);\n            else if(word[2] == 'a' ||\
    \ word[2] == 'e' || word[2] == 'i' || word[2] == 'o' || word[2] == 'u')\n    \
    \            return word.substr(2, 1);\n            else return \"\";\n      \
    \  }\n        else return \"\";\n    }\n    // word size >= 5\n    int size =\
    \ word.size();\n    char a = word[size - 1];\n    char b = word[size - 2];\n \
    \   if(isalpha(a) && isalpha(b)){\n        if(a == 'a' || a == 'e' || a == 'i'\
    \ || a == 'o' || a == 'u')\n            return word.substr(size - 1, 1);\n   \
    \     else{\n            for(int i = size - 3; i >= 0; i--){\n               \
    \ if(isalpha(word[i])){\n                    if(word[i] == 'a' || word[i] == 'e'\
    \ || word\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpebcmmjrr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpebcmmjrr.cpp:48:57: error: no match for \u2018operator||\u2019 (operand\
    \ types are \u2018bool\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   48 |                     if(word[i] == 'a' || word[i] == 'e' || word\n\
    \      |                                                         ^~ ~~~~\n   \
    \   |                                                            |\n      |  \
    \                                                          std::string {aka std::__cxx11::basic_string<char>}\n\
    /tmp/tmpebcmmjrr.cpp:48:57: note: candidate: \u2018operator||(bool, bool)\u2019\
    \ <built-in>\n   48 |                     if(word[i] == 'a' || word[i] == 'e'\
    \ || word\n/tmp/tmpebcmmjrr.cpp:48:57: note:   no known conversion for argument\
    \ 2 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018bool\u2019\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpebcmmjrr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:416:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__logical_or,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__logical_or,\
    \ typename _Dom1::value_type>::result_type> std::operator||(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  416 |     _DEFINE_EXPR_BINARY_OPERATOR(||, __logical_or)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:416:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpebcmmjrr.cpp:48:60: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018bool\u2019\n   48 |            \
    \         if(word[i] == 'a' || word[i] == 'e' || word\n      |               \
    \                                             ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-g"
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string answer = \"\";\n\t\
    for (int i = word.length() - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j < vowels.length();\
    \ j++) {\n\t\t\tif (word[i] == vowels[j]) {\n\t\t\t\tif (i == word.length() -\
    \ 1) {\n\t\t\t\t\tif (word[i - 1] == vowels[j]) {\n\t\t\t\t\t\tanswer = word[i];\n\
    \t\t\t\t\t\treturn answer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (i == 0) {\n\
    \t\t\t\t\tif (word[i + 1] == vowels[j]) {\n\t\t\t\t\t\tanswer = word[i];\n\t\t\
    \t\t\t\treturn answer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (word[i\
    \ - 1] == vowels[j] || word[i + 1] == vowels[j]) {\n\t\t\t\t\t\tanswer = word[i];\n\
    \t\t\t\t\t\treturn answer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ answer;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp82npeibn: /tmp/tmp82npeibn.cpp:44: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  //code here\n  std::string vowels = \"aeiouAEIOU\";\n  std::cout\
    \ << word << std::endl;\n  int i = word.size() - 2;\n  while (i >= 0) {\n    if\
    \ (vowels.find(word[i]) != std::string::npos && vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n      break;\n    }\n    i--;\n  }\n  return i >= 0 ? word.substr(i, 1) :\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkx5uaqo4: /tmp/tmpkx5uaqo4.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: 'yogurt

    full

    easy

    '
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// Good luck.\n\tstd::vector<char> vowels{ 'a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U' };\n\tstd::vector<char> consonants{ 'b', 'c', 'd', 'f',\
    \ 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y',\
    \ 'z', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S',\
    \ 'T', 'V', 'W', 'X', 'Y', 'Z' };\n\tint consonant_count = 0;\n\tfor (int i =\
    \ word.length() - 1; i >= 0; i--) {\n\t\tauto it = std::find(vowels.begin(), vowels.end(),\
    \ word[i]);\n\t\tif (it != vowels.end()) {\n\t\t\tif (consonant_count >= 2) {\n\
    \t\t\t\treturn std::string(1, word[i]);\n\t\t\t}\n\t\t\tconsonant_count = 0;\n\
    \t\t}\n\t\telse {\n\t\t\tconsonant_count++;\n\t\t}\n\t}\n\treturn \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph0dnxol9: /tmp/tmph0dnxol9.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    char c;\n    bool\
    \ cons_found = false;\n    int min_i = -1;\n    int min_dist = INT_MAX;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        c = word[i];\n        if (std::find(std::begin(vowels),\
    \ std::end(vowels), tolower(c)) != std::end(vowels)) {\n            cons_found\
    \ = true;\n            continue;\n        }\n        if (cons_found) {\n     \
    \       min_i = i;\n            break;\n        }\n    }\n    if (min_i == -1)\
    \ {\n        return \"\";\n    }\n    for (int i = min_i + 1; i < word.size();\
    \ i++) {\n        c = word[i];\n        if (std::find(std::begin(vowels), std::end(vowels),\
    \ tolower(c)) != std::end(vowels)) {\n            if (min_dist > i - min_i) {\n\
    \                min_dist = i - min_i;\n            }\n        }\n    }\n    for\
    \ (int i = min_i + 1; i < word.size(); i++) {\n        c = word[i];\n        if\
    \ (std::find(std::begin(vowels), std::end(vowels), tolower(c)) != std::end(vowels))\
    \ {\n            if (min_dist == i - min_i) {\n                return std::string(1,\
    \ c);\n            }\n        }\n    }\n    return \"\";\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxuazp25d: /tmp/tmpxuazp25d.cpp:57: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120055
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int sz = word.size(), cnt = 0;\n    for(int i = sz - 1; i >= 0;\
    \ i--) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            if(cnt >= 2) {\n                return\
    \ std::string(1, word[i]);\n            }\n        } else {\n            cnt++;\n\
    \        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_lhe4oj0: /tmp/tmp_lhe4oj0.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int len = word.length();\n  if(len\
    \ < 3) return \"\";\n  for(int i = len - 2; i >= 0; i--) {\n    for(int j = 0;\
    \ j < 5; j++) {\n      if(word[i] == vowels[j]) {\n        return word.substr(i,\
    \ 1);\n      }\n    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8nbsqv11: /tmp/tmp8nbsqv11.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string s;\n\t//converting string to vector\n\tstd::vector<char>\
    \ v;\n\tfor (int i = 0; i < word.length(); i++) {\n\t\tv.push_back(word[i]);\n\
    \t}\n\tint p = 0;\n\tbool f = false;\n\t//check for consecutive consonants\n\t\
    for (int i = 0; i < v.size() - 1; i++) {\n\t\tif (v[i] != 'a' && v[i] != 'e' &&\
    \ v[i] != 'i' && v[i] != 'o' && v[i] != 'u' && v[i] != 'A' && v[i] != 'E' && v[i]\
    \ != 'I' && v[i] != 'O' && v[i] != 'U') {\n\t\t\tif (v[i + 1] != 'a' && v[i +\
    \ 1] != 'e' && v[i + 1] != 'i' && v[i + 1] != 'o' && v[i + 1] != 'u' && v[i +\
    \ 1] != 'A' && v[i + 1] != 'E' && v[i + 1] != 'I' && v[i + 1] != 'O' && v[i +\
    \ 1] != 'U') {\n\t\t\t\t//if consecutive consonants are found return the vowel\n\
    \t\t\t\t//that comes right after it\n\t\t\t\ts = v[i + 1];\n\t\t\t\tf = true;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (f == false) {\n\t\t//if consecutive\
    \ consonants are not found return empty string\n\t\ts = \"\";\n\t}\n\treturn s;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp862zbr3p: /tmp/tmp862zbr3p.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string result;\n\tfor (int\
    \ i = 0; i < word.size(); i++) {\n\t\tif (word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n\t\t\tif (word[i - 1]\
    \ == 'a' || word[i - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' ||\
    \ word[i - 1] == 'u') {\n\t\t\t\tresult = \"\";\n\t\t\t}\n\t\t\telse if (word[i\
    \ + 1] == 'a' || word[i + 1] == 'e' || word[i + 1] == 'i' || word[i + 1] == 'o'\
    \ || word[i + 1] == 'u') {\n\t\t\t\tresult = \"\";\n\t\t\t}\n\t\t\telse if (word[i\
    \ - 1] == ' ') {\n\t\t\t\tresult = \"\";\n\t\t\t}\n\t\t\telse if (word[i + 1]\
    \ == ' ') {\n\t\t\t\tresult = \"\";\n\t\t\t}\n\t\t\telse if (vowels.find(word[i])\
    \ != std::string::npos) {\n\t\t\t\tresult = word[i];\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbn1d7w0r: /tmp/tmpbn1d7w0r.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while(i >= 0 && word[i]\
    \ != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u'){\n\
    \        i--;\n    }\n    if(i == -1){\n        return \"\";\n    }\n    if(i\
    \ != 0 && word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i\
    \ - 1] != 'o' && word[i - 1] != 'u'){\n        return word.substr(i, 1);\n   \
    \ }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpau8kkb60: /tmp/tmpau8kkb60.cpp:33: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int p = word.size() -\
    \ 1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) ==\
    \ std::string::npos) {\n                p = i;\n                break;\n     \
    \       }\n        }\n    }\n    if (p == word.size() - 1) return \"\";\n    else\
    \ return word.substr(p, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpaxg52zi_: /tmp/tmpaxg52zi_.cpp:38: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  \n  std::string vowels = \"AEIOUaeiou\";\n  std::string cnsnts =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n  std::string closestVowel;\n\
    \  if(vowels.find(word[0]) != std::string::npos || vowels.find(word[word.length()-1])\
    \ != std::string::npos)\n  {\n    return \"\";\n  }\n  for(auto it = word.rbegin();\
    \ it != word.rend(); it++)\n  {\n    if(vowels.find(*it) != std::string::npos)\n\
    \    {\n      closestVowel = *it;\n      break;\n    }\n  }\n  return closestVowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpt4mlv5pq: /tmp/tmpt4mlv5pq.cpp:43: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string str=\"aeiouAEIOU\";\n    int len=word.length();\n \
    \   int i,j;\n    int d=1000;\n    int first=0;\n    int second=0;\n    int pos=0;\n\
    \    int pos2=0;\n    for(i=0;i<len;i++)\n    {\n        for(j=0;j<10;j++)\n \
    \       {\n            if(word[i]==str[j])\n            {\n                pos=i;\n\
    \                for(int k=i;k<len;k++)\n                {\n                 \
    \   for(int l=0;l<10;l++)\n                    {\n                        if(word[k]==str[l])\n\
    \                        {\n                            pos2=k;\n            \
    \                first=pos;\n                            second=pos2;\n      \
    \                      if(d>second-first)\n                            {\n   \
    \                             d=second-first;\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    if(d==1000)\n    {\n        return \"\";\n    }\n\
    \    else\n    {\n        return word.substr(first,d);\n    }\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3tj56wpw: /tmp/tmp3tj56wpw.cpp:59: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size(), i = n - 1;\n    while (i >= 0 && !(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'))\
    \ {\n        i--;\n    }\n    if (i == 0) return \"\";\n    char res = word[i];\n\
    \    for (int j = i - 1; j >= 0; j--) {\n        if (word[j] == 'a' || word[j]\
    \ == 'e' || word[j] == 'i' || word[j] == 'o' || word[j] == 'u') {\n          \
    \  return res;\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_qi1n2ie.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp_qi1n2ie.cpp:22:20: error: could not convert \u2018res\u2019 from \u2018\
    char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   22 |             return res;\n      |                    ^~~\n      |  \
    \                  |\n      |                    char\n"
  stdout: ''
  timestamp: 1660120056
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> consonants = {\"B\", \"C\", \"D\", \"\
    F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"\
    S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n    std::vector<std::string>\
    \ vowels = {\"A\", \"E\", \"I\", \"O\", \"U\"};\n    std::map<std::string, int>\
    \ distance_to_vowel;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   for (int j = 0; j < vowels.size(); j++) {\n            if (word[i] == vowels[j][0])\
    \ {\n                if (i != word.size() - 1) {\n                    distance_to_vowel[vowels[j]]\
    \ = word.size() - i - 1;\n                }\n            }\n        }\n      \
    \  for (int j = 0; j < consonants.size(); j++) {\n            if (word[i] == consonants[j][0])\
    \ {\n                return distance_to_vowel.empty() ? \"\" : vowels[std::min_element(distance_to_vowel.begin(),\
    \ distance_to_vowel.end(),\n                                                 \
    \                               [](const std::pair<std::string, int>& p1, const\
    \ std::pair<std::string, int>& p2) {\n                                       \
    \                                             return p1.second < p2.second;\n\
    \                                                                            \
    \    })->first][0];\n            }\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbxaxrygm.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpbxaxrygm.cpp:27:63: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::vector<std::__cxx11::basic_string<char> >\u2019 and \u2018\
    const std::__cxx11::basic_string<char>\u2019)\n   27 |                 return\
    \ distance_to_vowel.empty() ? \"\" : vowels[std::min_element(distance_to_vowel.begin(),\
    \ distance_to_vowel.end(),\n      |                                          \
    \                     ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbxaxrygm.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1040:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::reference = std::__cxx11::basic_string<char>&; std::vector<_Tp, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1040 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1040:28: note: \
    \  no known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<std::__cxx11::basic_string<char> >::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n 1040 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n\
    \      |                  ~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1058:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::const_reference = const std::__cxx11::basic_string<char>&; st"
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    for (int i = word.size() -\
    \ 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n\
    \            if (i + 1 < word.size() && vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \ }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbxe67c7h: /tmp/tmpbxe67c7h.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string::iterator it = word.end()\
    \ - 1;\n  int ind = -1;\n  while (it >= word.begin()) {\n    if (vowels.find(*it)\
    \ != std::string::npos) {\n      ind = vowels.find(*it);\n      break;\n    }\n\
    \    it--;\n  }\n  if (ind != -1) {\n    it--;\n    while (it >= word.begin())\
    \ {\n      if (vowels.find(*it) == std::string::npos) {\n        return vowels[ind];\n\
    \      }\n      it--;\n    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp36e_gmjl.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp36e_gmjl.cpp:28:26: error: could not convert \u2018vowels.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)ind))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   28 |         return vowels[ind];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"AEIOUaeiou\";\n\tint len = word.length();\n\
    \tchar temp;\n\tfor (int i = len - 1; i >= 0; i--) {\n\t\ttemp = word[i];\n\t\t\
    for (int j = 0; j < vowels.length(); j++) {\n\t\t\tif (temp == vowels[j]) {\n\t\
    \t\t\treturn word.substr(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7zpxaibo: /tmp/tmp7zpxaibo.cpp:31: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::set<char> vowels{'a','e','i','o','u','A','E','I','O','U'};\n\
    \tstd::string res;\n\tint len = word.length();\n\tfor(int i = len-1; i >= 0; i--)\
    \ {\n\t\tif(vowels.find(word[i]) != vowels.end()) {\n\t\t\tif(i > 0 && vowels.find(word[i-1])\
    \ == vowels.end()) {\n\t\t\t\tres += word[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzxb_x76e: /tmp/tmpzxb_x76e.cpp:33: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint n = word.length();\n\tstd::string ans = \"\";\n\tif(n <= 1) {\n\
    \t\treturn ans;\n\t}\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\tif(word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' ||\n\
    \t\t   word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' ||\
    \ word[i] == 'U') {\n\t\t\tfor(int j = i - 1; j >= 0; j--) {\n\t\t\t\tif(word[j]\
    \ != 'a' && word[j] != 'e' && word[j] != 'i' && word[j] != 'o' && word[j] != 'u'\
    \ &&\n\t\t\t\t   word[j] != 'A' && word[j] != 'E' && word[j] != 'I' && word[j]\
    \ != 'O' && word[j] != 'U') {\n\t\t\t\t\tfor(int k = j - 1; k >= 0; k--) {\n\t\
    \t\t\t\t\tif(word[k] != 'a' && word[k] != 'e' && word[k] != 'i' && word[k] !=\
    \ 'o' && word[k] != 'u' &&\n\t\t\t\t\t\t   word[k] != 'A' && word[k] != 'E' &&\
    \ word[k] != 'I' && word[k] != 'O' && word[k] != 'U') {\n\t\t\t\t\t\t\tans = word[i];\n\
    \t\t\t\t\t\t\treturn ans;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzta464lx: /tmp/tmpzta464lx.cpp:41: int main(): Assertion `candidate(("full"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string::size_type pos;\n\
    \  std::string::size_type idx;\n  std::string::size_type ix;\n  std::string::size_type\
    \ ixx;\n  std::string::size_type ixxx;\n  std::string::size_type ixxxx;\n  std::string::size_type\
    \ ixxxxx;\n  std::string x = \"\";\n  if (word.find_first_of(vowels) == std::string::npos)\n\
    \    return x;\n  else {\n    pos = word.find_last_of(vowels);\n    idx = word.rfind(\"\
    \", pos);\n    ix = word.rfind(\"\", idx - 1);\n    ixx = word.rfind(\"\", ix\
    \ - 1);\n    ixxx = word.rfind(\"\", ixx - 1);\n    ixxxx = word.rfind(\"\", ixxx\
    \ - 1);\n    ixxxxx = word.rfind(\"\", ixxxx - 1);\n    // std::cout << pos <<\
    \ std::endl;\n    // std::cout << idx << std::endl;\n    // std::cout << ix <<\
    \ std::endl;\n    // std::cout << ixx << std::endl;\n    // std::cout << ixxx\
    \ << std::endl;\n    // std::cout << ixxxx << std::endl;\n    // std::cout <<\
    \ ixxxxx << std::endl;\n    for (int i = pos; i > ix; i--) {\n      if (vowels.find(word[i])\
    \ != std::string::npos) {\n        if (word[i - 1] != vowels[0] && word[i - 1]\
    \ != vowels[1] &&\n          word[i - 1] != vowels[2] && word[i - 1] != vowels[3]\
    \ &&\n          word[i - 1] != vowels[4] && word[i - 1] != vowels[5] &&\n    \
    \      word[i - 1] !=\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuboyg8n2.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpuboyg8n2.cpp:46:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   46 | }\n      | ^\n/tmp/tmpuboyg8n2.cpp:45:25: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   45 |           word[i - 1] !=\n\
    \      |                         ^\n      |                         )\n   46 |\
    \ }\n      | ~                        \n/tmp/tmpuboyg8n2.cpp:42:12: note: to match\
    \ this \u2018(\u2019\n   42 |         if (word[i - 1] != vowels[0] && word[i -\
    \ 1] != vowels[1] &&\n      |            ^\n/tmp/tmpuboyg8n2.cpp:46:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   46 | }\n      | ^\n\
    /tmp/tmpuboyg8n2.cpp:47:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   47 | int main() {\n      |            ^\n/tmp/tmpuboyg8n2.cpp:62:1:\
    \ error: expected \u2018}\u2019 at end of input\n   62 | }\n      | ^\n/tmp/tmpuboyg8n2.cpp:40:36:\
    \ note: to match this \u2018{\u2019\n   40 |     for (int i = pos; i > ix; i--)\
    \ {\n      |                                    ^\n/tmp/tmpuboyg8n2.cpp:62:1:\
    \ error: expected \u2018}\u2019 at end of input\n   62 | }\n      | ^\n/tmp/tmpuboyg8n2.cpp:25:8:\
    \ note: to match this \u2018{\u2019\n   25 |   else {\n      |        ^\n/tmp/tmpuboyg8n2.cpp:62:1:\
    \ error: expected \u2018}\u2019 at end of input\n   62 | }\n      | ^\n/tmp/tmpuboyg8n2.cpp:13:49:\
    \ note: to match this \u2018{\u2019\n   13 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpuboyg8n2.cpp:62:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   62 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string output = \"\";\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::vector<char> vowels_list(vowels.begin(), vowels.end());\n    for (int\
    \ i = 0; i < word.size(); i++) {\n        char letter = word[i];\n        char\
    \ next_letter = word[i + 1];\n        if (std::find(vowels_list.begin(), vowels_list.end(),\
    \ letter) != vowels_list.end()) {\n            if (std::find(vowels_list.begin(),\
    \ vowels_list.end(), next_letter) == vowels_list.end()) {\n                output\
    \ = letter;\n                break;\n            }\n        }\n    }\n    return\
    \ output;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_jmglg0u: /tmp/tmp_jmglg0u.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpw59vlz9w: /tmp/tmpw59vlz9w.cpp:19: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int position = 0;\n    for (int i = word.length() - 1; i >= 0;\
    \ i--) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            position = i;\n            if (i !=\
    \ 0) {\n                if (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i\
    \ - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u') {\n               \
    \     break;\n                }\n            }\n        }\n    }\n    if (position\
    \ != 0) {\n        return word.substr(position, 1);\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf4h7lnzb: /tmp/tmpf4h7lnzb.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiouAEIOU\";\n\tint last_vowel_pos = -1;\n\
    \tint first_consonant_pos = -1;\n\tfor (int i = word.size() - 1; i >= 0; i--)\
    \ {\n\t\tchar ch = word[i];\n\t\tif (vowels.find(ch) != std::string::npos) {\n\
    \t\t\tlast_vowel_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (last_vowel_pos == -1)\
    \ return \"\";\n\tfor (int i = last_vowel_pos; i >= 0; i--) {\n\t\tchar ch = word[i];\n\
    \t\tif (vowels.find(ch) == std::string::npos) {\n\t\t\tfirst_consonant_pos = i;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\tif (first_consonant_pos == -1) return \"\";\n\treturn\
    \ word.substr(first_consonant_pos + 1, last_vowel_pos - first_consonant_pos -\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxcxpo1h3: /tmp/tmpxcxpo1h3.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int distance = word.size();\n  int index = -1;\n  std::string vowels\
    \ = \"aeiouAEIOU\";\n  for (int i = 0; i < word.size(); i++) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      int temp = word.size() - i;\n      if (temp <=\
    \ distance) {\n        distance = temp;\n        index = i;\n      }\n    }\n\
    \  }\n  if (index == -1) {\n    return \"\";\n  }\n  return word.substr(index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpyjssvfr3: /tmp/tmpyjssvfr3.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\
    \n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==>\
    \ \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string cur;\n  \
    \  int v{}, c{};\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) != std::string::npos) {\n            v = i;\n        \
    \    if (c) {\n                return word.substr(v, 1);\n            }\n    \
    \    } else {\n            c = i;\n            if (v) {\n                return\
    \ word.substr(v, 1);\n            }\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpupib6qgo: /tmp/tmpupib6qgo.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120056
