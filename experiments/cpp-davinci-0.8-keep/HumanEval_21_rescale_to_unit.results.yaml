name: HumanEval_21_rescale_to_unit
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n\n    // get max and min\n    float max = numbers[0];\n    float min\
    \ = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min) {\n            min = numbers[i];\n        }\n    }\n\n    std::vector<float>\
    \ result(numbers.size());\n    for (int i = 0; i < numbers.size(); i++) {\n  \
    \      result[i] = (numbers[i] - min) / (max - min);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ n : numbers) {\n        if (n < min) {\n            min = n;\n        }\n  \
    \      if (n > max) {\n            max = n;\n        }\n    }\n    float d = max\
    \ - min;\n    std::vector<float> result;\n    for (auto n : numbers) {\n     \
    \   result.push_back((n - min) / d);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ >= 2);\n  std::vector<float> result(numbers.size());\n  float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n  float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \  float scale = max - min;\n  for (int i = 0; i < numbers.size(); i++) {\n  \
    \  result[i] = (numbers[i] - min) / scale;\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tstd::vector<float>\
    \ result;\n\tfloat min = numbers[0];\n\tfloat max = numbers[0];\n\tfor (int i\
    \ = 0; i < numbers.size(); i++) {\n\t\tif (numbers[i] < min)\n\t\t\tmin = numbers[i];\n\
    \t\tif (numbers[i] > max)\n\t\t\tmax = numbers[i];\n\t}\n\tfloat divider = max\
    \ - min;\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tresult.push_back((numbers[i]\
    \ - min) / divider);\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n\tfloat max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n\tstd::vector<float> scaled_values;\n\tfor (int i = 0; i <\
    \ numbers.size(); i++) {\n\t\tscaled_values.push_back((numbers[i] - min) / (max\
    \ - min));\n\t}\n\treturn scaled_values;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    auto min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    auto max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> result;\n    for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n        result.push_back((*it - min) / (max -\
    \ min));\n    }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat min\
    \ = numbers[0];\n\tfloat max = numbers[0];\n\tfor (float number : numbers) {\n\
    \t\tif (number < min) min = number;\n\t\tif (number > max) max = number;\n\t}\n\
    \tfloat diff = max - min;\n\tstd::vector<float> rescaled;\n\tfor (float number\
    \ : numbers) {\n\t\trescaled.push_back((number - min) / diff);\n\t}\n\treturn\
    \ rescaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ ret;\n    float max = *std::max_element(numbers.begin(), numbers.end());\n \
    \   float min = *std::min_element(numbers.begin(), numbers.end());\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        ret.push_back((numbers[i] - min)\
    \ / (max - min));\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    std::vector<float> result(numbers.size());\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        result[i] = (numbers[i]\
    \ - min) / (max - min);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    // if it's empty, we can't do anything.\n    auto max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    auto min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    // find max and min\n    if (min == max) {\n        return numbers;\n   \
    \ }\n    for (int i = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i]\
    \ - min) / (max - min);\n    }\n    return numbers;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    auto x_min = *min_element(numbers.begin(), numbers.end());\n   \
    \ auto x_max = *max_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ result;\n    std::transform(numbers.begin(), numbers.end(), back_inserter(result),\
    \ [=](float x) {\n        return (x - x_min) / (x_max - x_min);\n    });\n   \
    \ return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n   \
    \ assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // assert(numbers.size()\
    \ > 1);\n    float x_min, x_max;\n    x_min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    x_max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float a, b;\n    a = 1 / (x_max - x_min);\n    b = 1 - a * x_max;\n    std::vector<float>\
    \ result(numbers.size());\n    std::transform(numbers.begin(), numbers.end(),\
    \ result.begin(),\n        [a, b](float x) { return a * x + b; });\n    return\
    \ result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "tmpzmop4zmw: /tmp/tmpzmop4zmw.cpp:22: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result(numbers.size());\n    float min_n = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max_n = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float div = (max_n - min_n);\n    float diff = 0;\n    if (div == 0)\n  \
    \      div = 1;\n    for (int i = 0; i < numbers.size(); i++) {\n        diff\
    \ = numbers[i] - min_n;\n        result[i] = diff / div;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> numbers_new = numbers;\n    float min = *min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *max_element(numbers.begin(), numbers.end());\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        numbers_new[i] = (numbers[i]\
    \ - min) / (max - min);\n    }\n    return numbers_new;\n}\nint main() {\n   \
    \ auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min=numbers[0];\n\
    \    float max=numbers[0];\n    for(int i=0;i<numbers.size();i++){\n        if(numbers[i]<min){\n\
    \            min=numbers[i];\n        }\n        if(numbers[i]>max){\n       \
    \     max=numbers[i];\n        }\n    }\n    std::vector<float> v;\n    for(int\
    \ i=0;i<numbers.size();i++){\n        v.push_back((numbers[i]-min)/(max-min));\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n  float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n  float factor = 1.0/(max-min);\n  std::vector<float> output(numbers.size());\n\
    \  std::transform(numbers.begin(), numbers.end(), output.begin(),\n    [factor,\
    \ min](float x) -> float { return (x-min)*factor; }\n  );\n  return output;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ z;\n    int max = *std::max_element(numbers.begin(), numbers.end());\n    int\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    for (float n :\
    \ numbers) {\n        z.push_back((n - min) / (max - min));\n    }\n    return\
    \ z;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "tmp54kj_qnt: /tmp/tmp54kj_qnt.cpp:18: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    if (max == min) {\n        return numbers;\n    }\n\n \
    \   std::vector<float> output(numbers.size());\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        output[i] = (numbers[i] - min) / (max - min);\n    }\n    return\
    \ output;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> newNumbers;\n  for (auto number : numbers)\
    \ {\n    newNumbers.push_back((number - min) / (max - min));\n  }\n  return newNumbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    for (int i = 0; i < numbers.size(); i++) {\n       \
    \ numbers[i] = (numbers[i] - min) / range;\n    }\n    return numbers;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_number\
    \ = numbers[0];\n    float max_number = numbers[0];\n    std::vector<float> normalized_numbers;\n\
    \    for (float current_number : numbers) {\n        min_number = std::min(min_number,\
    \ current_number);\n        max_number = std::max(max_number, current_number);\n\
    \    }\n    for (float current_number : numbers) {\n        float rescaled_number\
    \ = (current_number - min_number) / (max_number - min_number);\n        normalized_numbers.push_back(rescaled_number);\n\
    \    }\n    return normalized_numbers;\n}\nint main() {\n    auto candidate =\
    \ rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9}))) ==\
    \ (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    float max_num = 0;\n    float min_num = std::numeric_limits<float>::max();\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max_num)\
    \ {\n            max_num = numbers[i];\n        }\n        if (numbers[i] < min_num)\
    \ {\n            min_num = numbers[i];\n        }\n    }\n    for (int i = 0;\
    \ i < numbers.size(); i++) {\n        result.push_back((numbers[i] - min_num)\
    \ / (max_num - min_num));\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat max\
    \ = numbers[0];\n\tfloat min = numbers[0];\n\tfor (float num : numbers) {\n\t\t\
    if (num > max) {\n\t\t\tmax = num;\n\t\t}\n\t\tif (num < min) {\n\t\t\tmin = num;\n\
    \t\t}\n\t}\n\tfloat diff = max - min;\n\tfor (int i = 0; i < numbers.size(); i++)\
    \ {\n\t\tnumbers[i] = (numbers[i] - min) / diff;\n\t}\n\treturn numbers;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // Save\
    \ the min and max of the input, so that we know what the delta is\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float delta = max - min;\n    // Now scale all numbers\
    \ to a fraction of the range\n    for (float &n : numbers) {\n        n = (n -\
    \ min) / delta;\n    }\n    return numbers;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max_number\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float min_number =\
    \ *std::min_element(numbers.begin(), numbers.end());\n    float range = max_number\
    \ - min_number;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(),\
    \ numbers.end(), std::back_inserter(rescaled_numbers),\n                   [range,\
    \ min_number](float x) { return (x - min_number) / range; });\n    return rescaled_numbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ rescaled_values;\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    for (int i = 0; i < numbers.size(); i++) {\n       \
    \ float rescaled_value = (numbers[i] - min) / range;\n        rescaled_values.push_back(rescaled_value);\n\
    \    }\n    return rescaled_values;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> list;\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    float num = (numbers[i] - min) / (max - min);\n    list.push_back(num);\n\
    \  }\n  return list;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> rescaled;\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    rescaled.push_back((numbers[i] - min) / (max - min));\n  }\n  return\
    \ rescaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tif (numbers.size()\
    \ < 2) {\n\t\tthrow std::domain_error(\"rescale_to_unit requires at least two\
    \ numbers\");\n\t}\n\tfloat max_val = -std::numeric_limits<float>::infinity();\n\
    \tfloat min_val = std::numeric_limits<float>::infinity();\n\tfor (float number\
    \ : numbers) {\n\t\tif (number > max_val) {\n\t\t\tmax_val = number;\n\t\t}\n\t\
    \tif (number < min_val) {\n\t\t\tmin_val = number;\n\t\t}\n\t}\n\tfloat diff =\
    \ max_val - min_val;\n\tif (diff == 0) {\n\t\tthrow std::domain_error(\"all numbers\
    \ are equal in rescale_to_unit\");\n\t}\n\tstd::vector<float> scaled;\n\tfor (float\
    \ number : numbers) {\n\t\tscaled.push_back((number - min_val) / diff);\n\t}\n\
    \treturn scaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n   \
    \ assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // check\
    \ for an empty list\n    if (numbers.size() == 0) {\n        return numbers;\n\
    \    }\n    // find min and max\n    float min = numbers[0];\n    float max =\
    \ numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if (numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float denominator\
    \ = max - min;\n    std::vector<float> result(numbers.size());\n    for (int i\
    \ = 0; i < numbers.size(); i++) {\n        result[i] = (numbers[i] - min) / denominator;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    auto min\
    \ = std::min_element(numbers.begin(), numbers.end());\n    auto max = std::max_element(numbers.begin(),\
    \ numbers.end());\n    auto div = *max - *min;\n    std::vector<float> result;\n\
    \    for (auto n : numbers) {\n        result.push_back((n - *min) / div);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat min,\
    \ max;\n\tmin = max = numbers[0];\n\tfor (int i = 1; i < numbers.size(); i++)\
    \ {\n\t\tif (numbers[i] < min)\n\t\t\tmin = numbers[i];\n\t\tif (numbers[i] >\
    \ max)\n\t\t\tmax = numbers[i];\n\t}\n\tassert(min != max);\n\tstd::vector<float>\
    \ result;\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tresult.push_back((numbers[i]\
    \ - min) / (max - min));\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size()\
    \ < 2) {\n        throw new std::invalid_argument(\"list must contain at least\
    \ two numbers\");\n    }\n    auto min_max = std::minmax_element(numbers.begin(),\
    \ numbers.end());\n    float min = *min_max.first;\n    float max = *min_max.second;\n\
    \    float diff = max - min;\n    std::vector<float> result;\n    for (float n\
    \ : numbers) {\n        result.push_back((n - min) / diff);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat maxx\
    \ = *max_element(numbers.begin(), numbers.end());\n\tfloat minn = *min_element(numbers.begin(),\
    \ numbers.end());\n\tstd::vector<float> result;\n\tfor (int i = 0; i < numbers.size();\
    \ i++) {\n\t\tresult.push_back((numbers[i] - minn) / (maxx - minn));\n\t}\n\t\
    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min_n = std::numeric_limits<float>::max();\n    float max_n\
    \ = std::numeric_limits<float>::min();\n    for (auto n : numbers) {\n       \
    \ if (n < min_n) {\n            min_n = n;\n        }\n        if (n > max_n)\
    \ {\n            max_n = n;\n        }\n    }\n    float range = max_n - min_n;\n\
    \    if (range == 0) {\n        return std::vector<float>(numbers.size(), 0.0);\n\
    \    }\n    std::vector<float> res;\n    for (auto n : numbers) {\n        res.push_back((n\
    \ - min_n) / range);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat max_value\
    \ = *max_element(numbers.begin(), numbers.end());\n\tfloat min_value = *min_element(numbers.begin(),\
    \ numbers.end());\n\tfor (float &n : numbers) {\n\t\tn = (n - min_value) / (max_value\
    \ - min_value);\n\t}\n\treturn numbers;\n}\nint main() {\n    auto candidate =\
    \ rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9}))) ==\
    \ (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n  float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> result;\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    result.push_back((numbers[i] - min) / (max - min));\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    \n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "tmpo78nff42: /tmp/tmpo78nff42.cpp:12: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tstd::vector<float>\
    \ res;\n\tfloat max_n = *max_element(numbers.begin(), numbers.end());\n\tfloat\
    \ min_n = *min_element(numbers.begin(), numbers.end());\n\tfor (auto num : numbers)\
    \ {\n\t\tres.push_back((num - min_n) / (max_n - min_n));\n\t}\n\treturn res;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // Get max\
    \ and min numbers\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    // Rescale\
    \ the numbers\n    for (int i = 0; i < numbers.size(); i++) {\n        numbers[i]\
    \ = (numbers[i] - min) / (max - min);\n    }\n    return numbers;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat min_value\
    \ = *std::min_element(numbers.begin(), numbers.end());\n\tfloat max_value = *std::max_element(numbers.begin(),\
    \ numbers.end());\n\tassert(min_value != max_value);\n\tstd::vector<float> scaled_values;\n\
    \tfor (auto element : numbers) {\n\t\tscaled_values.push_back((element - min_value)\
    \ / (max_value - min_value));\n\t}\n\treturn scaled_values;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\t// find min\
    \ and max values\n\tfloat min = *std::min_element(numbers.begin(), numbers.end());\n\
    \tfloat max = *std::max_element(numbers.begin(), numbers.end());\n\t// normalize\n\
    \tstd::vector<float> normalized;\n\tfor (auto i : numbers) {\n\t\tnormalized.push_back((i\
    \ - min) / (max - min));\n\t}\n\treturn normalized;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size()\
    \ < 2) {\n        throw std::invalid_argument(\"list of numbers should contain\
    \ at least two elements\");\n    }\n    auto min_max = std::minmax_element(numbers.begin(),\
    \ numbers.end());\n    float old_min = *min_max.first;\n    float old_max = *min_max.second;\n\
    \    float old_range = old_max - old_min;\n    float new_range = 1.0 - 0.0;\n\
    \    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(),\
    \ numbers.end(), std::back_inserter(rescaled_numbers),\n        [&](float x) {\n\
    \            return (x - old_min) * new_range / old_range;\n        });\n    return\
    \ rescaled_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // write\
    \ your code here\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ vec_min_max(2);\n    vec_min_max[0] = min_val;\n    vec_min_max[1] = max_val;\n\
    \    std::vector<float> result;\n    float diff = max_val - min_val;\n    for\
    \ (int i = 0; i < numbers.size(); i++) {\n        result.push_back((numbers[i]\
    \ - min_val) / diff);\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float smallest\
    \ = numbers[0];\n  float largest = numbers[0];\n  for (unsigned int i = 0; i <\
    \ numbers.size(); i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n\
    \    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n    }\n\
    \  }\n  assert(largest > smallest);\n  float size = largest - smallest;\n  for\
    \ (unsigned int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i]\
    \ - smallest) / size;\n  }\n  return numbers;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float difference = max - min;\n    std::vector<float> rescaledNumbers;\n\
    \    for (float number : numbers) {\n        float rescaledNumber = (number -\
    \ min) / difference;\n        rescaledNumbers.push_back(rescaledNumber);\n   \
    \ }\n    return rescaledNumbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (auto & number : numbers)\
    \ {\n        if (number < min) {\n            min = number;\n        }\n     \
    \   if (number > max) {\n            max = number;\n        }\n    }\n    std::vector<float>\
    \ result;\n    for (auto & number : numbers) {\n        result.push_back((number\
    \ - min) / (max - min));\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ scaled(numbers.size());\n    std::transform(numbers.begin(), numbers.end(),\
    \ scaled.begin(),\n        [=](float n) {\n            return (n - min) / (max\
    \ - min);\n        });\n    return scaled;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size()\
    \ < 2)\n        throw std::invalid_argument(\"The list should contain at least\
    \ two elements\");\n    float min_num = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max_num = *std::max_element(numbers.begin(), numbers.end());\n    for\
    \ (int i = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min_num)\
    \ / (max_num - min_num);\n    }\n    return numbers;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ lst;\n    float min=*min_element(numbers.begin(),numbers.end());\n    float\
    \ max=*max_element(numbers.begin(),numbers.end());\n    float range=max-min;\n\
    \    for(int i=0;i<numbers.size();i++)\n    {\n        lst.push_back((numbers[i]-min)/range);\n\
    \    }\n    return lst;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // Implement\
    \ this\n  std::vector<float> v;\n  float min = *min_element(numbers.begin(), numbers.end());\n\
    \  float max = *max_element(numbers.begin(), numbers.end());\n  for (float n :\
    \ numbers) {\n    float r = (n - min) / (max - min);\n    v.push_back(r);\n  }\n\
    \  return v;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    if (max == min)\n        return numbers;\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min) /\
    \ (max - min);\n    }\n    return numbers;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // first find\
    \ min and max\n  auto min_max = std::minmax_element(numbers.begin(), numbers.end());\n\
    \  // normalize the values using (x - min)/(max - min)\n  std::vector<float> normalized;\n\
    \  float min = *min_max.first;\n  float max = *min_max.second;\n  for (auto num\
    \ : numbers) {\n    normalized.push_back((num - min)/(max - min));\n  }\n  return\
    \ normalized;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat max\
    \ = numbers[0];\n\tfloat min = numbers[0];\n\tfor (float n : numbers) {\n\t\t\
    if (n > max) {\n\t\t\tmax = n;\n\t\t}\n\t\tif (n < min) {\n\t\t\tmin = n;\n\t\t\
    }\n\t}\n\tstd::vector<float> scaled_numbers;\n\tfor (float n : numbers) {\n\t\t\
    scaled_numbers.push_back((n - min) / (max - min));\n\t}\n\treturn scaled_numbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> results;\n    int max = numbers[0];\n    int\
    \ min = numbers[0];\n    //get max and min\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    for (int i = 0; i < numbers.size(); i++) {\n        results.push_back((numbers[i]\
    \ - min) / (max - min));\n    }\n    return results;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "tmprilsgak1: /tmp/tmprilsgak1.cpp:28: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    std::vector<float> ans;\n    auto it = std::minmax_element(numbers.begin(),\
    \ numbers.end());\n    float min = *it.first;\n    float max = *it.second;\n \
    \   float d = max - min;\n    for (float x : numbers) {\n        ans.push_back((x\
    \ - min) / d);\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9}))) ==\
    \ (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    auto minmax = std::minmax_element(numbers.begin(), numbers.end());\n\
    \    float min = *minmax.first;\n    float max = *minmax.second;\n    float base\
    \ = max - min;\n    std::vector<float> result;\n    for (float number : numbers)\
    \ {\n        result.push_back((number - min) / base);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n   std::vector<float>\
    \ result;\n   float max_number = *std::max_element(numbers.begin(), numbers.end());\n\
    \   float min_number = *std::min_element(numbers.begin(), numbers.end());\n  \
    \ for (int i = 0; i < numbers.size(); i++) {\n      result.push_back((numbers[i]\
    \ - min_number) / (max_number - min_number));\n   }\n   return result;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  if (numbers.size()\
    \ < 2) {\n    std::cout << \"Not enouph numbers in the list, to perform rescaling\"\
    \ << std::endl;\n    exit(1);\n  }\n  float min = numbers[0];\n  float max = numbers[0];\n\
    \  for (int i = 0; i < numbers.size(); i++) {\n    if (numbers[i] < min)\n   \
    \   min = numbers[i];\n    if (numbers[i] > max)\n      max = numbers[i];\n  }\n\
    \  float max_min_diff = max - min;\n  float temp = 0;\n  std::vector<float> result;\n\
    \  for (int i = 0; i < numbers.size(); i++) {\n    temp = (numbers[i] - min) /\
    \ max_min_diff;\n    result.push_back(temp);\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    std::vector<float> rescaled_numbers;\n    for (int i\
    \ = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back((numbers[i]\
    \ - min) / range);\n    }\n    return rescaled_numbers;\n}\nint main() {\n   \
    \ auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // replace\
    \ with your code\n  std::vector<float> rescaled_numbers;\n  float max = numbers[0];\n\
    \  float min = numbers[0];\n  for (int i = 0; i < numbers.size(); i++) {\n   \
    \ if (numbers[i] > max) {\n      max = numbers[i];\n    }\n    if (numbers[i]\
    \ < min) {\n      min = numbers[i];\n    }\n  }\n  float denominator = max - min;\n\
    \  for (int i = 0; i < numbers.size(); i++) {\n    float result = (numbers[i]\
    \ - min) / denominator;\n    rescaled_numbers.push_back(result);\n  }\n  return\
    \ rescaled_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> normalized;\n  for (float number : numbers)\
    \ {\n    normalized.push_back((number - min) / (max - min));\n  }\n  return normalized;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max_number\
    \ = numbers[0];\n  float min_number = numbers[0];\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    max_number = std::max(max_number, numbers[i]);\n    min_number =\
    \ std::min(min_number, numbers[i]);\n  }\n  std::vector<float> result;\n  for\
    \ (int i = 0; i < numbers.size(); i++) {\n    result.push_back((numbers[i] - min_number)\
    \ / (max_number - min_number));\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    // find the range of the input\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n \
    \       if (numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if (numbers[i] > max) {\n            max = numbers[i];\n        }\n   \
    \ }\n    // now that we know the range, scale each element to the new range\n\
    \    float scale = 1.0 / (max - min);\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        numbers[i] = (numbers[i] - min) * scale;\n    }\n    return\
    \ numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ >= 2);\n  // @TODO\n  float min, max;\n  min = *min_element(numbers.begin(),\
    \ numbers.end());\n  max = *max_element(numbers.begin(), numbers.end());\n  for\
    \ (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min)\
    \ / (max - min);\n  }\n  return numbers;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = numbers[0];\n    float min = numbers[0];\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    for (int i = 0; i < numbers.size(); i++) {\n        numbers[i]\
    \ = (numbers[i] - min) / (max - min);\n    }\n    return numbers;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float large\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float small = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    for (int i = 0; i < numbers.size(); i++) {\n        float\
    \ num = numbers[i];\n        numbers[i] = (num - small) / (large - small);\n \
    \   }\n    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\t// Find minimum\
    \ number\n\tfloat minimum = numbers[0];\n\tfor (float n : numbers) {\n\t\tif (n\
    \ < minimum) {\n\t\t\tminimum = n;\n\t\t}\n\t}\n\t// Apply linear transform\n\t\
    std::vector<float> result;\n\tfor (float n : numbers) {\n\t\tfloat t = (n - minimum)\
    \ / (maximum - minimum);\n\t\tresult.push_back(t);\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb0t5qcks.cpp: In function \u2018std::vector<float> rescale_to_unit(std::vector<float>)\u2019\
    :\n/tmp/tmpb0t5qcks.cpp:18:30: error: \u2018maximum\u2019 was not declared in\
    \ this scope; did you mean \u2018minimum\u2019?\n   18 |   float t = (n - minimum)\
    \ / (maximum - minimum);\n      |                              ^~~~~~~\n     \
    \ |                              minimum\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_v\
    \ = std::numeric_limits<float>::max();\n    float max_v = std::numeric_limits<float>::min();\n\
    \    for (auto n : numbers) {\n        if (n < min_v) min_v = n;\n        if (n\
    \ > max_v) max_v = n;\n    }\n    std::vector<float> result(numbers.size());\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        result[i] = (numbers[i]\
    \ - min_v) / (max_v - min_v);\n    }\n    return result;\n}\nint main() {\n  \
    \  auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (float n : numbers) {\n\
    \        if (n < min) {\n            min = n;\n        }\n        if (n > max)\
    \ {\n            max = n;\n        }\n    }\n    std::vector<float> result;\n\
    \    for (float n : numbers) {\n        result.push_back((n - min) / (max - min));\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float smallest\
    \ = numbers[0];\n  float largest = numbers[0];\n  for (int i = 1; i < numbers.size();\
    \ i++) {\n    if (numbers[i] < smallest) smallest = numbers[i];\n    if (numbers[i]\
    \ > largest) largest = numbers[i];\n  }\n  std::vector<float> res;\n  for (int\
    \ i = 0; i < numbers.size(); i++) {\n    res.push_back((numbers[i] - smallest)\
    \ / (largest - smallest));\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    int minimum\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    int maximum = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    for (int i = 0; i < numbers.size(); i++) {\n        numbers[i]\
    \ = (numbers[i] - minimum) / (maximum - minimum);\n    }\n    return numbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "tmppug3pjtf: /tmp/tmppug3pjtf.cpp:17: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_num\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max_num = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> new_numbers;\n    for (float num : numbers)\
    \ {\n        float new_num = (num - min_num) / (max_num - min_num);\n        new_numbers.push_back(new_num);\n\
    \    }\n    return new_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> output;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (float n : numbers) {\n        if (n < min) {\n \
    \           min = n;\n        }\n        if (n > max) {\n            max = n;\n\
    \        }\n    }\n    for (float n : numbers) {\n        output.push_back((n\
    \ - min) / (max - min));\n    }\n    return output;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  float max= *std::max_element(numbers.begin(), numbers.end());\n \
    \ float min= *std::min_element(numbers.begin(), numbers.end());\n  for(int i=0;\
    \ i<numbers.size(); i++){\n    result.push_back((numbers[i]-min)/(max-min));\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    for (int i = 0; i < numbers.size(); i++) {\n       \
    \ numbers[i] = (numbers[i] - min) / range;\n    }\n    return numbers;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size()\
    \ < 2)\n        throw std::invalid_argument(\"Input list is too short\");\n  \
    \  float max = *std::max_element(numbers.begin(), numbers.end());\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    for (float &n : numbers)\n\
    \        n = (n - min) / (max - min);\n    return numbers;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ rescaled_numbers(numbers.size());\n  float largest_number = *max_element(begin(numbers),\
    \ end(numbers));\n  float smallest_number = *min_element(begin(numbers), end(numbers));\n\
    \  // int i = 0;\n  // for (float number : numbers) {\n  //   rescaled_numbers[i]\
    \ = (number - smallest_number) / (largest_number - smallest_number);\n  //   i++;\n\
    \  // }\n  transform(begin(numbers), end(numbers), begin(rescaled_numbers), [&](float\
    \ number) {\n    return (number - smallest_number) / (largest_number - smallest_number);\n\
    \  });\n  return rescaled_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // find\
    \ min and max\n    float min = numbers[0];\n    float max = numbers[0];\n    for\
    \ (size_t i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n\
    \            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n \
    \           max = numbers[i];\n        }\n    }\n    // apply linear transform\n\
    \    std::vector<float> result(numbers.size());\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        result[i] = (numbers[i] - min) / (max - min);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n   \
    \     }\n        if (numbers[i] > max) {\n            max = numbers[i];\n    \
    \    }\n    }\n    std::vector<float> rescaled(numbers.size());\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        rescaled[i] = (numbers[i] - min)\
    \ / (max - min);\n    }\n    return rescaled;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float largest = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float smallest = *std::min_element(numbers.begin(), numbers.end());\n   \
    \ //std::cout << smallest << \" \" << largest << std::endl;\n    std::vector<float>\
    \ res;\n    for (int i = 0; i < numbers.size(); i++) {\n        float val = numbers[i];\n\
    \        res.push_back((val - smallest) / (largest - smallest));\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ x : numbers) {\n        if (x < min) {\n            min = x;\n        }\n  \
    \      if (x > max) {\n            max = x;\n        }\n    }\n    std::vector<float>\
    \ result;\n    for (auto x : numbers) {\n        result.push_back((x - min) /\
    \ (max - min));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // find min\
    \ and max\n  float min = std::numeric_limits<float>::max();\n  float max = std::numeric_limits<float>::min();\n\
    \  for (auto &number : numbers) {\n    if (number < min) {\n      min = number;\n\
    \    }\n    if (number > max) {\n      max = number;\n    }\n  }\n  assert(min\
    \ < max);\n  // rescale\n  std::vector<float> scaled_numbers;\n  float inverse_range\
    \ = 1.0 / (max - min);\n  for (auto &number : numbers) {\n    scaled_numbers.push_back((number\
    \ - min) * inverse_range);\n  }\n  return scaled_numbers;\n}\nint main() {\n \
    \   auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max_num\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min_num = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> rescaled_numbers(numbers.size());\n  for\
    \ (int i = 0; i < numbers.size(); i++) {\n    rescaled_numbers[i] = (numbers[i]\
    \ - min_num) / (max_num - min_num);\n  }\n  return rescaled_numbers;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // find largest\
    \ number\n  float largest = *std::max_element(numbers.begin(), numbers.end());\n\
    \  // find smallest number\n  float smallest = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  // get difference between largest and smallest\n  float difference\
    \ = largest - smallest;\n  // copy each number into the new vector and rescale\
    \ it\n  std::vector<float> result;\n  for (auto number : numbers) {\n    result.push_back((number\
    \ - smallest) / difference);\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // implement\
    \ function here\n    float min=numbers[0];\n    float max=numbers[0];\n    for(int\
    \ i=0;i<numbers.size();i++)\n    {\n        if(numbers[i]<min)\n            min=numbers[i];\n\
    \        if(numbers[i]>max)\n            max=numbers[i];\n    }\n    std::vector<float>\
    \ n2;\n    for(int i=0;i<numbers.size();i++)\n    {\n        n2.push_back((numbers[i]-min)/(max-min));\n\
    \    }\n    return n2;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ > 1);\n  // TODO\n  return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmpc0yynwk2: /tmp/tmpc0yynwk2.cpp:14: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  // Determine min and max\n  float min_val, max_val;\n  min_val =\
    \ max_val = numbers[0];\n  for (int i = 1; i < numbers.size(); i++) {\n    if\
    \ (numbers[i] < min_val) {\n      min_val = numbers[i];\n    }\n    if (numbers[i]\
    \ > max_val) {\n      max_val = numbers[i];\n    }\n  }\n  // Apply linear transform\n\
    \  for (int i = 0; i < numbers.size(); i++) {\n    result.push_back((numbers[i]\
    \ - min_val) / (max_val - min_val));\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    auto min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    auto max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> result;\n    for (auto &i : numbers)\
    \ {\n        result.push_back((i - min) / (max - min));\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // get the\
    \ max and min of the vector\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i] < min)\
    \ {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n\
    \            max = numbers[i];\n        }\n    }\n    // push the rescaled values\
    \ into new vector\n    std::vector<float> rescaled;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        // x = (x-min)/(max-min)\n        float rescaled_val = (numbers[i]\
    \ - min) / (max - min);\n        rescaled.push_back(rescaled_val);\n    }\n  \
    \  return rescaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ scaled_numbers;\n    for (const auto number : numbers) {\n        scaled_numbers.push_back((number\
    \ - min) / (max - min));\n    }\n    return scaled_numbers;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ res;\n    auto max_elem = *std::max_element(numbers.begin(), numbers.end());\n\
    \    auto min_elem = *std::min_element(numbers.begin(), numbers.end());\n    auto\
    \ range = max_elem - min_elem;\n    for (auto number : numbers) {\n        auto\
    \ new_number = (number - min_elem) / range;\n        res.push_back(new_number);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\t// get max\
    \ and min\n\tfloat max = *std::max_element(numbers.begin(), numbers.end());\n\t\
    float min = *std::min_element(numbers.begin(), numbers.end());\n\t// compute range\n\
    \tfloat range = max - min;\n\t// form a new vector\n\tstd::vector<float> rescaled;\n\
    \tfor (int i = 0; i < numbers.size(); i++) {\n\t\trescaled.push_back((numbers[i]\
    \ - min) / range);\n\t}\n\treturn rescaled;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n\tfloat min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n\tfor (float &n : numbers) {\n\t\tn = (n - min) / (max - min);\n\
    \t}\n\treturn numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> rescaled;\n    rescaled.clear();\n \
    \   for (int i = 0; i < numbers.size(); i++) {\n        float new_number = (numbers[i]\
    \ - min) / (max - min);\n        rescaled.push_back(new_number);\n    }\n    return\
    \ rescaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tint min =\
    \ 0;\n\tint max = 0;\n\tint i;\n\tfor (i = 0; i < numbers.size(); i++) {\n\t\t\
    if (numbers[i] < numbers[min]) {\n\t\t\tmin = i;\n\t\t}\n\t\tif (numbers[i] >\
    \ numbers[max]) {\n\t\t\tmax = i;\n\t\t}\n\t}\n\tfloat factor = numbers[max] -\
    \ numbers[min];\n\tstd::vector<float> result;\n\tfor (i = 0; i < numbers.size();\
    \ i++) {\n\t\tresult.push_back((numbers[i] - numbers[min]) / factor);\n\t}\n\t\
    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tstd::vector<float>\
    \ out;\n\tfloat min = *std::min_element(numbers.begin(), numbers.end());\n\tfloat\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n\tfor (int i = 0;\
    \ i < numbers.size(); i++) {\n\t\tfloat temp = (numbers[i] - min) / (max - min);\n\
    \t\tout.push_back(temp);\n\t}\n\treturn out;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_num\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max_num = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = 1 / (max_num - min_num);\n    for (int i\
    \ = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min_num)\
    \ * scale;\n    }\n    return numbers;\n}\nint main() {\n    auto candidate =\
    \ rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9}))) ==\
    \ (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float denom = max - min;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        numbers[i] = (numbers[i] - min) / denom;\n    }\n    return\
    \ numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>::iterator\
    \ max = std::max_element(numbers.begin(), numbers.end());\n    float max_num =\
    \ *max;\n    std::vector<float>::iterator min = std::min_element(numbers.begin(),\
    \ numbers.end());\n    float min_num = *min;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        numbers[i] = (numbers[i] - min_num) / (max_num - min_num);\n\
    \    }\n    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  if (numbers.size()\
    \ < 2) {\n    throw std::runtime_error(\"List of numbers should have at least\
    \ two elements\");\n  }\n  auto min_max = std::minmax_element(numbers.begin(),\
    \ numbers.end());\n  float min = *min_max.first;\n  float max = *min_max.second;\n\
    \  std::vector<float> scaled_numbers;\n  for (int i = 0; i < numbers.size(); i++)\
    \ {\n    float scaled_number = (numbers[i] - min) / (max - min);\n    scaled_numbers.push_back(scaled_number);\n\
    \  }\n  return scaled_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    std::vector<float> output(numbers.size());\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        output[i] = (numbers[i]\
    \ - min) / range;\n    }\n    return output;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ >= 2);\n  float min_number = *std::min_element(numbers.begin(), numbers.end());\n\
    \  float max_number = *std::max_element(numbers.begin(), numbers.end());\n  std::vector<float>\
    \ ret;\n  for (auto num : numbers) {\n    ret.push_back((num - min_number) / (max_number\
    \ - min_number));\n  }\n  return ret;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max_number\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min_number = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float> result;\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    result.push_back((numbers[i] - min_number) / (max_number - min_number));\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // YOUR\
    \ CODE HERE\n    std::vector<float> max_min(2);\n    max_min[0] = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    max_min[1] = *std::min_element(numbers.begin(), numbers.end());\n\
    \    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num\
    \ - max_min[1]) / (max_min[0] - max_min[1]));\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    result.clear();\n    assert(numbers.size() >= 2);\n    if (numbers.size()\
    \ == 2) {\n        result.push_back(0.0);\n        result.push_back(1.0);\n  \
    \      return result;\n    }\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i] < min)\
    \ {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n\
    \            max = numbers[i];\n        }\n    }\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        result.push_back(((numbers[i] - min) / (max - min)));\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmpn3luti51: /tmp/tmpn3luti51.cpp:34: int main(): Assertion `candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    int n =\
    \ numbers.size();\n    std::vector<float> result;\n    float min = *min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *max_element(numbers.begin(), numbers.end());\n\
    \    for (int i = 0; i < n; i++) {\n        result.push_back((numbers[i] - min)\
    \ / (max - min));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tassert(numbers.size()\
    \ >= 2);\n\tstd::vector<float> result;\n\tfloat min_number = *std::min_element(numbers.begin(),\
    \ numbers.end());\n\tfloat max_number = *std::max_element(numbers.begin(), numbers.end());\n\
    \tfor (float number : numbers) {\n\t\tresult.push_back((number - min_number) /\
    \ (max_number - min_number));\n\t}\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  auto result\
    \ = numbers;\n  float max = std::numeric_limits<float>::min();\n  float min =\
    \ std::numeric_limits<float>::max();\n  for (const auto &element : numbers) {\n\
    \    max = std::max(max, element);\n    min = std::min(min, element);\n  }\n \
    \ std::transform(result.begin(), result.end(), result.begin(),\n             \
    \    [max, min](float element) { return (element - min) / (max - min); });\n \
    \ return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n   \
    \ assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\t\n\tfloat\
    \ max = 0;\n\tfloat min = numbers[0];\n\tstd::vector<float> result;\n\tfor (int\
    \ i = 0; i < numbers.size(); i++) {\n\t\tif (numbers[i] > max) {\n\t\t\tmax =\
    \ numbers[i];\n\t\t}\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\
    \t}\n\t}\n\tif (max == min) {\n\t\tresult.push_back(1);\n\t\treturn result;\n\t\
    }\n\tfloat newmax = 1;\n\tfloat newmin = 0;\n\tfloat a = (newmax - newmin) / (max\
    \ - min);\n\tfloat b = newmin - (a * min);\n\tfor (int i = 0; i < numbers.size();\
    \ i++) {\n\t\tresult.push_back(a * numbers[i] + b);\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float largest\
    \ = *max_element(numbers.begin(), numbers.end());\n    float smallest = *min_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> result;\n    for (float number : numbers)\
    \ {\n        result.push_back((number - smallest) / (largest - smallest));\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // find min\
    \ and max values\n  float min = numbers[0];\n  float max = numbers[0];\n  for\
    \ (size_t i = 1; i < numbers.size(); i++) {\n    if (numbers[i] < min) {\n   \
    \   min = numbers[i];\n    }\n    if (numbers[i] > max) {\n      max = numbers[i];\n\
    \    }\n  }\n  // apply linear transform\n  for (size_t i = 0; i < numbers.size();\
    \ i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n  return numbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // find\
    \ the smallest element\n    float min = INT_MAX;\n    float max = INT_MIN;\n \
    \   for (int i = 0; i < numbers.size(); i++) {\n        min = std::min(min, numbers[i]);\n\
    \        max = std::max(max, numbers[i]);\n    }\n    std::vector<float> rescaled;\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        rescaled.push_back((numbers[i]\
    \ - min) / (max - min));\n    }\n    return rescaled;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n// variables\n\
    \t\tfloat large_num = 0.0;\n\t\tfloat small_num = 0.0;\n\t\tfloat diff = 0.0;\n\
    \t\tint i=0;\n//for (int i = 0; i < numbers.size(); i++) {\n\t\tsmall_num = numbers[0];\n\
    \t\tlarge_num = numbers[0];\n\t\tfor (int j = 0; j < numbers.size(); j++) {\n\t\
    \t\tif (numbers[j] > large_num) {\n\t\t\t\tlarge_num = numbers[j];\n\t\t\t}\n\t\
    \t\tif (numbers[j] < small_num) {\n\t\t\t\tsmall_num = numbers[j];\n\t\t\t}\n\t\
    \t}\n\t\tdiff = large_num - small_num;\n\t\tfor (int k = 0; k < numbers.size();\
    \ k++) {\n\t\t\tnumbers[k] = (numbers[k] - small_num) / diff;\n\t\t}\n\t//}\n\t\
    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  auto minmax\
    \ = std::minmax_element(std::begin(numbers), std::end(numbers));\n  // minmax.first:\
    \ pointer to smallest element\n  // minmax.second: pointer to largest element\n\
    \  float min = *minmax.first;\n  float max = *minmax.second;\n  float min_max_diff\
    \ = max - min;\n  std::vector<float> rescaled;\n  for (float n : numbers) {\n\
    \    float rescaled_n = (n - min) / min_max_diff;\n    rescaled.push_back(rescaled_n);\n\
    \  }\n  return rescaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) {\n            min = number;\n\
    \        }\n        if (number > max) {\n            max = number;\n        }\n\
    \    }\n    std::vector<float> rescaled(numbers.size());\n    float a = 1 / (max\
    \ - min);\n    float b = -a * min;\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        rescaled[i] = a * numbers[i] + b;\n    }\n    return rescaled;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    if (numbers.size() == 0) {\n        return result;\n    }\n   \
    \ float max_of_vector = *std::max_element(numbers.begin(), numbers.end());\n \
    \   float min_of_vector = *std::min_element(numbers.begin(), numbers.end());\n\
    \    if (max_of_vector - min_of_vector == 0) {\n        return result;\n    }\n\
    \    std::transform(numbers.begin(), numbers.end(), std::back_inserter(result),\
    \ [&](float x) { return (x - min_of_vector) / (max_of_vector - min_of_vector);\
    \ });\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // Your code\
    \ here\n  std::vector<float> rescaled;\n  float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \  for (int i = 0; i < numbers.size(); i++) {\n    float element = (numbers[i]\
    \ - min) / (max - min);\n    rescaled.push_back(element);\n  }\n  return rescaled;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n   // TODO Write\
    \ code here!\n  float min = numbers[0];\n  float max = numbers[0];\n  for(int\
    \ i = 0; i < numbers.size(); ++i){\n    if(numbers[i] > max) max = numbers[i];\n\
    \    if(numbers[i] < min) min = numbers[i];\n  }\n  std::vector<float> result;\n\
    \  for(int i = 0; i < numbers.size(); ++i){\n    result.push_back((numbers[i]\
    \ - min)/(max - min));\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    std::vector<float> scaled_numbers;\n    float lowest, highest;\n\
    \    lowest = numbers[0];\n    highest = numbers[0];\n    for (int i = 0; i <\
    \ numbers.size(); i++) {\n        if (numbers[i] < lowest) {\n            lowest\
    \ = numbers[i];\n        }\n        if (numbers[i] > highest) {\n            highest\
    \ = numbers[i];\n        }\n    }\n    for (int i = 0; i < numbers.size(); i++)\
    \ {\n        float diff = highest - lowest;\n        float scaled_num = (numbers[i]\
    \ - lowest) / diff;\n        scaled_numbers.push_back(scaled_num);\n    }\n  \
    \  return scaled_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> res;\n    for (const auto &number :\
    \ numbers) {\n        res.push_back((number - min) / (max - min));\n    }\n  \
    \  return res;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  // convert to double and then find max and min\n  std::vector<double>\
    \ temp(numbers.begin(), numbers.end());\n  double min = *std::min_element(temp.begin(),\
    \ temp.end());\n  double max = *std::max_element(temp.begin(), temp.end());\n\
    \  // std::cout << min << \"\\n\";\n  // std::cout << max << \"\\n\";\n  // calculate\
    \ difference\n  double diff = max - min;\n  // initialize result vector\n  //\
    \ std::cout << diff << \"\\n\";\n  for (int i = 0; i < numbers.size(); i++) {\n\
    \    result.push_back((numbers[i] - min) / diff);\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \  float min = *std::min_element(numbers.begin(), numbers.end());\n  float range\
    \ = max - min;\n  if (range == 0.0) {\n    range = 1.0;\n  }\n  for (int i = 0;\
    \ i < numbers.size(); i++) {\n    result.push_back((numbers[i] - min) / range);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min_element = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max_element = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float denominator = max_element - min_element;\n    assert(denominator !=\
    \ 0);\n    std::vector<float> ret;\n    for (float element : numbers) {\n    \
    \    ret.push_back((element - min_element) / denominator);\n    }\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n        if (numbers[i] > max) {\n        \
    \    max = numbers[i];\n        }\n    }\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        result.push_back((numbers[i] - min) / (max - min));\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> scaled;\n    auto maxIt = std::max_element(numbers.begin(),\
    \ numbers.end());\n    auto minIt = std::min_element(numbers.begin(), numbers.end());\n\
    \    auto maxVal = *maxIt;\n    auto minVal = *minIt;\n    auto range = maxVal\
    \ - minVal;\n    for (auto & num : numbers) {\n        auto newNum = (num - minVal)\
    \ / range;\n        scaled.push_back(newNum);\n    }\n    return scaled;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float largest\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float smallest = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  float scale = largest - smallest;\n  if (scale == 0) {\n\
    \    // All numbers are the same, so return them as 0.0\n    std::vector<float>\
    \ r;\n    for (unsigned int i = 0; i < numbers.size(); i++) {\n      r.push_back(0.0);\n\
    \    }\n    return r;\n  }\n  std::vector<float> result;\n  for (unsigned int\
    \ i = 0; i < numbers.size(); i++) {\n    result.push_back((numbers[i] - smallest)\
    \ / scale);\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ > 1);\n    //finds the max and min in the list of numbers\n    float max=*std::max_element(numbers.begin(),numbers.end());\n\
    \    float min=*std::min_element(numbers.begin(),numbers.end());\n    std::vector<float>\
    \ vector_new;\n    //transforms the list of numbers\n    for(int i=0;i<numbers.size();i++){\n\
    \      vector_new.push_back((numbers[i]-min)/(max-min));\n    }\n    return vector_new;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float small\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float big = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> new_list;\n    for (float i : numbers)\
    \ {\n        new_list.push_back((i - small) / (big - small));\n    }\n    return\
    \ new_list;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_num\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max_num = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float diff = max_num - min_num;\n    std::vector<float>\
    \ numbers_unit;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(numbers_unit),\
    \ [min_num, diff](float n) {\n        return (n - min_num) / diff;\n    });\n\
    \    return numbers_unit;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max_number\
    \ = numbers[0];\n    float min_number = numbers[0];\n    for (float x : numbers)\
    \ {\n        if (x > max_number) {\n            max_number = x;\n        }\n \
    \       if (x < min_number) {\n            min_number = x;\n        }\n    }\n\
    \    std::vector<float> result;\n    for (float x : numbers) {\n        result.push_back((x\
    \ - min_number) / (max_number - min_number));\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  assert(numbers.size() >= 2);\n  float minimum = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  float maximum = *std::max_element(numbers.begin(), numbers.end());\n\
    \  for (auto &number : numbers) {\n    result.push_back((number - minimum) / (maximum\
    \ - minimum));\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min;\n\
    \    float max;\n    // Find min and max\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        if (i == 0) {\n            min = numbers[i];\n            max\
    \ = numbers[i];\n        }\n        else {\n            if (numbers[i] < min)\n\
    \                min = numbers[i];\n            if (numbers[i] > max)\n      \
    \          max = numbers[i];\n        }\n    }\n    std::vector<float> rescaled_list(numbers.size());\n\
    \    // Rescale\n    for (int i = 0; i < numbers.size(); i++) {\n        rescaled_list[i]\
    \ = (numbers[i] - min) / (max - min);\n    }\n    return rescaled_list;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min\
    \ = std::numeric_limits<float>::max();\n  float max = std::numeric_limits<float>::min();\n\
    \  for (auto const& num : numbers) {\n    if (num < min) {\n      min = num;\n\
    \    }\n    if (num > max) {\n      max = num;\n    }\n  }\n  std::vector<float>\
    \ scaled;\n  for (auto const& num : numbers) {\n    scaled.push_back((num - min)\
    \ / (max - min));\n  }\n  return scaled;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    // check if there are at least two elements in vector\n    assert(numbers.size()\
    \ >= 2);\n    // find smallest and largest numbers\n    float max = numbers[0];\n\
    \    float min = numbers[0];\n    for (auto i : numbers) {\n        if (i > max)\
    \ {\n            max = i;\n        }\n        if (i < min) {\n            min\
    \ = i;\n        }\n    }\n    // calculate linear transform\n    float range =\
    \ max - min;\n    // apply linear transform\n    for (auto i : numbers) {\n  \
    \      result.push_back((i - min) / range);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        if\
    \ (*it < smallest) {\n            smallest = *it;\n        }\n        if (*it\
    \ > largest) {\n            largest = *it;\n        }\n    }\n    float range\
    \ = largest - smallest;\n    std::vector<float> result;\n    for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n        result.push_back((*it - smallest) / range);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tassert(numbers.size()\
    \ >= 2);\n\tfloat max = numbers[0];\n\tfloat min = numbers[0];\n\tfor (int i =\
    \ 0; i < numbers.size(); i++) {\n\t\tif (numbers[i] < min)\n\t\t\tmin = numbers[i];\n\
    \t\tif (numbers[i] > max)\n\t\t\tmax = numbers[i];\n\t}\n\tfor (int i = 0; i <\
    \ numbers.size(); i++) {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min);\n\
    \t}\n\treturn numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  float max, min;\n  if (numbers.size() >= 2) {\n    max = numbers[0];\n\
    \    min = numbers[0];\n    for (int i = 0; i < numbers.size(); i++) {\n     \
    \ if (numbers[i] > max) {\n        max = numbers[i];\n      }\n      if (numbers[i]\
    \ < min) {\n        min = numbers[i];\n      }\n    }\n    for (int i = 0; i <\
    \ numbers.size(); i++) {\n      result.push_back((numbers[i] - min) / (max - min));\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> result;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        result.push_back((numbers[i] - min) / (max - min));\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    auto minmax\
    \ = std::minmax_element(numbers.begin(), numbers.end());\n    assert(minmax.first\
    \ != minmax.second);\n    float min = *minmax.first;\n    float max = *minmax.second;\n\
    \    assert(min != max);\n    std::vector<float> rescaled;\n    for (auto i =\
    \ numbers.begin(); i != numbers.end(); ++i) {\n        float delta = (*i - min)\
    \ / (max - min);\n        rescaled.push_back(delta);\n    }\n    return rescaled;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ res;\n    float min = *min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *max_element(numbers.begin(), numbers.end());\n    float range = max -\
    \ min;\n    for (float i : numbers) {\n        res.push_back((i - min) / range);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result = numbers;\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    for (float &x : result) {\n        x = (x - min) / (max - min);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // find\
    \ min and max\n    float min = numbers[0];\n    float max = numbers[0];\n    for\
    \ (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n  \
    \          min = numbers[i];\n        }\n        if (numbers[i] > max) {\n   \
    \         max = numbers[i];\n        }\n    }\n    // rescale\n    for (int i\
    \ = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min) / (max\
    \ - min);\n    }\n    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max_val\
    \ = -1, min_val = std::numeric_limits<float>::max();\n    for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n        if (*it > max_val) {\n            max_val\
    \ = *it;\n        }\n        if (*it < min_val) {\n            min_val = *it;\n\
    \        }\n    }\n    std::cout << \"Min \" << min_val << \" max \" << max_val\
    \ << std::endl;\n    float val_range = max_val - min_val;\n    if (val_range ==\
    \ 0) {\n        return std::vector<float>(numbers.size(), 0);\n    }\n    for\
    \ (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        *it = (*it\
    \ - min_val) / val_range;\n    }\n    return numbers;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: "Min 2 max 49.9\nMin 49.9 max 100\nMin 1 max 5\nMin 1 max 5\nMin 11 max\
    \ 15\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = numbers[0];\n    float min = numbers[0];\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    float max_min = max - min;\n    std::vector<float> unit_vect;\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        float num = (numbers[i]\
    \ - min) / max_min;\n        unit_vect.push_back(num);\n    }\n    return unit_vect;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  if (numbers.size() < 2)\n    return result;\n  float min = numbers[0];\n\
    \  float max = numbers[0];\n  // find the max and min\n  for (float number : numbers)\
    \ {\n    if (number < min)\n      min = number;\n    if (number > max)\n     \
    \ max = number;\n  }\n  // apply a linear transform to scale the values between\
    \ [0, 1]\n  for (float number : numbers) {\n    float scaled = (number - min)\
    \ / (max - min);\n    result.push_back(scaled);\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> output(numbers.size());\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float range;\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n   \
    \     }\n        if (numbers[i] > max) {\n            max = numbers[i];\n    \
    \    }\n    }\n    range = max - min;\n    if (range == 0) {\n        return numbers;\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        output[i] =\
    \ (numbers[i] - min) / range;\n    }\n    return output;\n}\nint main() {\n  \
    \  auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min=FLT_MAX;\n\
    \    float max=FLT_MIN;\n    for(int i=0;i<numbers.size();i++){\n        if(numbers[i]<min)\n\
    \            min=numbers[i];\n        if(numbers[i]>max)\n            max=numbers[i];\n\
    \    }\n    std::vector<float> res;\n    for(int i=0;i<numbers.size();i++){\n\
    \        float x=(numbers[i]-min)/(max-min);\n        res.push_back(x);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n   \
    \ assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // Your\
    \ code here\n    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmpro7oqb5e: /tmp/tmpro7oqb5e.cpp:13: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // max and\
    \ min of the numbers\n    float max = numbers[0];\n    float min = numbers[0];\n\
    \    for (float value : numbers) {\n        if (value > max) max = value;\n  \
    \      if (value < min) min = value;\n    }\n    // create a vector to store rescaled\
    \ values\n    std::vector<float> result;\n    for (float value : numbers) {\n\
    \        result.push_back((value - min) / (max - min));\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result = numbers;\n    double max_ = *std::max_element(result.begin(), result.end());\n\
    \    double min_ = *std::min_element(result.begin(), result.end());\n    double\
    \ numerator;\n    for (int i = 0; i < result.size(); i++) {\n        numerator\
    \ = result[i] - min_;\n        result[i] = numerator / (max_ - min_);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ unit_vector;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    if (min\
    \ == max) {\n        for (int i = 0; i < numbers.size(); i++) {\n            unit_vector.push_back(0.0);\n\
    \        }\n    } else {\n        for (int i = 0; i < numbers.size(); i++) {\n\
    \            unit_vector.push_back((numbers[i] - min) / (max - min));\n      \
    \  }\n    }\n    return unit_vector;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>result(numbers.size());\n\
    \    float max = numbers[0];\n    float min = numbers[0];\n    for (auto &i :\
    \ numbers) {\n        if (i > max) {\n            max = i;\n        }\n      \
    \  if (i < min) {\n            min = i;\n        }\n    }\n    for (int i = 0;\
    \ i < numbers.size(); i++) {\n        result[i] = (numbers[i] - min) / (max -\
    \ min);\n    }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        numbers[i] = (numbers[i] - min) / range;\n    }\n    return\
    \ numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tassert(numbers.size()\
    \ >= 2);\n\tfloat min = *std::min_element(numbers.begin(), numbers.end());\n\t\
    float max = *std::max_element(numbers.begin(), numbers.end());\n\tfor (int i =\
    \ 0; i < numbers.size(); i++) {\n\t\tnumbers[i] = (numbers[i] - min) / (max -\
    \ min);\n\t}\n\treturn numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  // Find max\
    \ and min\n  std::vector<float>::iterator max_element = std::max_element(numbers.begin(),\
    \ numbers.end());\n  std::vector<float>::iterator min_element = std::min_element(numbers.begin(),\
    \ numbers.end());\n  float min = *min_element;\n  float max = *max_element;\n\
    \  float new_min = 0.0;\n  float new_max = 1.0;\n  float delta = new_max - new_min;\n\
    \  for (auto &number : numbers) {\n    number = (number - min) / (max - min) *\
    \ delta + new_min;\n  }\n  return numbers;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float smallest\
    \ = numbers[0];\n  float largest = numbers[0];\n  for (int i = 1; i < numbers.size();\
    \ i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n   \
    \ }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n    }\n  }\n\
    \  std::vector<float> result;\n  float range = largest - smallest;\n  for (int\
    \ i = 0; i < numbers.size(); i++) {\n    result.push_back((numbers[i] - smallest)\
    \ / range);\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // work\
    \ with a copy, to prevent modifying the original\n    std::vector<float> result\
    \ = numbers;\n    auto minmax = std::minmax_element(result.begin(), result.end());\n\
    \    auto min = *minmax.first;\n    auto max = *minmax.second;\n    auto diff\
    \ = max - min;\n    // avoid division by zero\n    if (diff == 0) {\n        //\
    \ all numbers are the same, so let's just return a vector\n        // of zeros\
    \ of the same length\n        return std::vector<float>(result.size(), 0);\n \
    \   } else {\n        // rescale each element to unit\n        for (auto& number\
    \ : result) {\n            number = (number - min) / diff;\n        }\n      \
    \  return result;\n    }\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  /* Your code\
    \ goes here */\n  float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \  float max = *std::max_element(numbers.begin(), numbers.end());\n  std::vector<float>\
    \ rescaled(numbers.size());\n  for (int i = 0; i < numbers.size(); i++) {\n  \
    \  rescaled[i] = (numbers[i] - min) / (max - min);\n  }\n  return rescaled;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tassert(numbers.size()\
    \ > 1);\n\t\n\tfloat minNumber = *std::min_element(numbers.begin(), numbers.end());\n\
    \tfloat maxNumber = *std::max_element(numbers.begin(), numbers.end());\n\t\n\t\
    for (unsigned i = 0; i < numbers.size(); i++) {\n\t\tnumbers[i] = (numbers[i]\
    \ - minNumber) / (maxNumber - minNumber);\n\t}\n\t\n\treturn numbers;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> normalized(numbers.size());\n    std::transform(numbers.begin(),\
    \ numbers.end(), normalized.begin(), [&min, &max](float num) { return (num - min)\
    \ / (max - min); });\n    return normalized;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min=numbers[0];\n\
    \    float max=numbers[0];\n    for(float num:numbers){\n        if(num<min)\n\
    \            min=num;\n        if(num>max)\n            max=num;\n    }\n    float\
    \ factor=(1-0)/(max-min);\n    float b=1-factor*max;\n    std::vector<float> result(numbers.size());\n\
    \    for(int i=0;i<numbers.size();i++){\n        result[i]=factor*numbers[i]+b;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmprjh9q20o: /tmp/tmprjh9q20o.cpp:26: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tstd::vector<float>\
    \ out;\n\tfloat mn=*std::min_element(numbers.begin(),numbers.end());\n\tfloat\
    \ mx=*std::max_element(numbers.begin(),numbers.end());\n\tfor(auto x:numbers){\n\
    \t\tfloat y=(x-mn)/(mx-mn);\n\t\tout.push_back(y);\n\t}\n\treturn out;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    float max=*max_element(numbers.begin(),numbers.end());\n    float\
    \ min=*min_element(numbers.begin(),numbers.end());\n    for(int i=0;i<numbers.size();i++)\n\
    \    {\n        result.push_back((numbers[i]-min)/(max-min));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ >= 2);\n  // mean\n  float sum = std::accumulate(numbers.begin(), numbers.end(),\
    \ 0.0);\n  float mean = sum / numbers.size();\n  // std\n  std::vector<float>\
    \ diff(numbers.size());\n  std::transform(numbers.begin(), numbers.end(), diff.begin(),\n\
    \                 std::bind2nd(std::minus<float>(), mean));\n  float sq_sum =\
    \ std::inner_product(diff.begin(), diff.end(), diff.begin(), 0.0);\n  float stdev\
    \ = std::sqrt(sq_sum / numbers.size());\n  // rescale\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    numbers[i] = (numbers[i] - mean) / stdev;\n  }\n  return numbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: "tmpiuis91pz: /tmp/tmpiuis91pz.cpp:26: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float min_value = *std::min_element(numbers.begin(), numbers.end());\n  \
    \  for (float x : numbers) {\n        result.push_back((x - min_value) / (max_value\
    \ - min_value));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tassert(numbers.size()\
    \ >= 2);\n\tfloat max=numbers[0];\n\tfloat min=numbers[0];\n\tfor(int i=0;i<numbers.size();i++)\n\
    \t{\n\t\tif(numbers[i]>max)\n\t\t{\n\t\t\tmax=numbers[i];\n\t\t}\n\t\tif(numbers[i]<min)\n\
    \t\t{\n\t\t\tmin=numbers[i];\n\t\t}\n\t}\n\tfor(int i=0;i<numbers.size();i++)\n\
    \t{\n\t\tnumbers[i]=(numbers[i]-min)/(max-min);\n\t}\n\treturn numbers;\n}\nint\
    \ main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n\tfloat min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n\t//std::cout << \"Max \" << max << std::endl;\n\t//std::cout\
    \ << \"Min \" << min << std::endl;\n\t//numbers.pop_back();\n\t//numbers.pop_back();\n\
    \t//std::cout << \"Vector \" << numbers[0] << std::endl;\n\t//std::cout << \"\
    Vector \" << numbers[1] << std::endl;\n\t//std::cout << \"Vector \" << numbers[2]\
    \ << std::endl;\n\t//std::cout << \"Vector \" << numbers[3] << std::endl;\n\t\
    //std::cout << \"Vector \" << numbers[4] << std::endl;\n\t//transform(numbers.begin(),\
    \ numbers.end(), numbers.begin(), bind2nd(std::minus<float>(), numbers[0]));\n\
    \t//std::cout << \"Vector \" << numbers[0] << std::endl;\n\t//std::cout << \"\
    Vector \" << numbers[1] << std::endl;\n\t//std::cout << \"Vector \" << numbers[2]\
    \ << std::endl;\n\t//std::cout << \"Vector \" << numbers[3] << std::endl;\n\t\
    //std::cout << \"Vector \" << numbers[4] << std::endl;\n\tfloat sub = max - min;\n\
    \t//std::cout << \"Sub \" << sub << std::endl;\n\tstd::vector<float> newVector;\n\
    \tfor (int i = 0; i < numbers.size(); i++) {\n\t\tnumbers[i] = numbers[i] - min;\n\
    \t\tnumbers[i] = numbers[i] / sub;\n\t\tnewVector.push_back(numbers[i]);\n\t}\n\
    \treturn newVector;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    float min, max;\n    for (int i = 0; i < numbers.size(); i++) {\n\
    \        if (i == 0) {\n            min = numbers[i];\n            max = numbers[i];\n\
    \        }\n        else {\n            if (numbers[i] < min) {\n            \
    \    min = numbers[i];\n            }\n            if (numbers[i] > max) {\n \
    \               max = numbers[i];\n            }\n        }\n    }\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        result.push_back((numbers[i] - min)\
    \ / (max - min));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < min) {\n            min = number;\n\
    \        }\n        if (number > max) {\n            max = number;\n        }\n\
    \    }\n    float diff = max - min;\n    std::vector<float> results;\n    for\
    \ (float number : numbers) {\n        results.push_back((number - min) / diff);\n\
    \    }\n    return results;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ > 1);\n  std::vector<float> rescaled_numbers(numbers.size());\n  float max =\
    \ *std::max_element(numbers.begin(), numbers.end());\n  float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  float denominator = max - min;\n  std::transform(numbers.begin(),\
    \ numbers.end(), rescaled_numbers.begin(), [denominator, min](float x) { return\
    \ (x - min) / denominator; });\n  return rescaled_numbers;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ min_max;\n    min_max.push_back(*min_element(numbers.begin(), numbers.end()));\n\
    \    min_max.push_back(*max_element(numbers.begin(), numbers.end()));\n    for\
    \ (int i = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min_max[0])\
    \ / (min_max[1] - min_max[0]);\n    }\n    return numbers;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min\
    \ = INT_MAX;\n  float max = INT_MIN;\n  for (auto num : numbers) {\n    if (num\
    \ < min) min = num;\n    if (num > max) max = num;\n  }\n  std::vector<float>\
    \ result;\n  for (auto num : numbers) {\n    result.push_back((num - min) / (max\
    \ - min));\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = 0;\n    float min = 0;\n    int i;\n    for(i=0;i<numbers.size();i++)\n  \
    \  {\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    std::vector<float> v(numbers.size());\n\
    \    for(i=0;i<numbers.size();i++)\n    {\n        v[i] = (numbers[i] - min)/(max\
    \ - min);\n    }\n    return v;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmpybvesw7j: /tmp/tmpybvesw7j.cpp:27: int main(): Assertion `candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float>\
    \ result;\n  float smallest = numbers[0];\n  float largest = numbers[0];\n  for\
    \ (float n : numbers) {\n    if (n < smallest) {\n      smallest = n;\n    }\n\
    \    if (n > largest) {\n      largest = n;\n    }\n  }\n  float range = largest\
    \ - smallest;\n  for (float n : numbers) {\n    result.push_back((n - smallest)\
    \ / range);\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> results(numbers.size());\n    float nmax = -std::numeric_limits<float>::infinity();\n\
    \    float nmin = std::numeric_limits<float>::infinity();\n    for (float i :\
    \ numbers) {\n        nmax = std::max(nmax, i);\n        nmin = std::min(nmin,\
    \ i);\n    }\n    for (unsigned i = 0; i < numbers.size(); i++) {\n        results[i]\
    \ = (numbers[i] - nmin) / (nmax - nmin);\n    }\n    return results;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat max_n\
    \ = numbers[0];\n\tfloat min_n = numbers[0];\n\tfor (float i : numbers) {\n\t\t\
    if (i < min_n) {\n\t\t\tmin_n = i;\n\t\t}\n\t\tif (i > max_n) {\n\t\t\tmax_n =\
    \ i;\n\t\t}\n\t}\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tnumbers[i]\
    \ = (numbers[i] - min_n) / (max_n - min_n);\n\t}\n\treturn numbers;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  int n = numbers.size();\n\
    \  std::vector<float> unit_scaled_numbers;\n  // C++ sort function.\n  std::sort(numbers.begin(),\
    \ numbers.end());\n  float max_value = numbers[n-1];\n  float min_value = numbers[0];\n\
    \  for (int i = 0; i < n; i++) {\n    float scaled_value = (numbers[i] - min_value)\
    \ / (max_value - min_value);\n    unit_scaled_numbers.push_back(scaled_value);\n\
    \  }\n  return unit_scaled_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmpfh2j5df9: /tmp/tmpfh2j5df9.cpp:23: int main(): Assertion `candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    // find min and max\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for (auto num : numbers) {\n        if (num < min) {\n  \
    \          min = num;\n        }\n        if (num > max) {\n            max =\
    \ num;\n        }\n    }\n    // apply transformation\n    float res_min = 0;\n\
    \    float res_max = 1;\n    float length = max - min;\n    for (unsigned int\
    \ i = 0; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min) /\
    \ length;\n    }\n    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n  float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n  float normalization_factor = max - min;\n  float offset =\
    \ min;\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i]\
    \ - offset) / normalization_factor;\n  }\n  return numbers;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_number\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max_number =\
    \ *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n\
    \    for (auto number : numbers) {\n        result.push_back((number - min_number)\
    \ / (max_number - min_number));\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float maxi\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float mini = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> numbers_rescaled;\n    float length\
    \ = maxi - mini;\n    for (std::vector<float>::iterator i = numbers.begin(); i\
    \ != numbers.end(); ++i) {\n        numbers_rescaled.push_back((*i - mini) / length);\n\
    \    }\n    return numbers_rescaled;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  if (numbers.size()\
    \ < 2) {\n    assert(false);\n  }\n  const float min_number = *min_element(numbers.begin(),\
    \ numbers.end());\n  const float max_number = *max_element(numbers.begin(), numbers.end());\n\
    \  std::vector<float> result;\n  for (const float number : numbers) {\n    result.push_back((number\
    \ - min_number) / (max_number - min_number));\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float max\
    \ = -999999999.0;\n  float min = 999999999.0;\n  for (std::vector<float>::iterator\
    \ it = numbers.begin(); it != numbers.end(); ++it) {\n    if (*it > max) {\n \
    \     max = *it;\n    }\n    if (*it < min) {\n      min = *it;\n    }\n  }\n\
    \  std::vector<float> result;\n  for (std::vector<float>::iterator it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n    result.push_back((*it - min) / (max - min));\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float largest\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float smallest = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  float delta = largest - smallest;\n  std::vector<float> result;\n\
    \  for (auto element : numbers) {\n    result.push_back((element - smallest) /\
    \ delta);\n  }\n  return result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size()\
    \ >= 2);\n  float min = *min_element(numbers.begin(), numbers.end());\n  float\
    \ max = *max_element(numbers.begin(), numbers.end());\n  float range = max - min;\n\
    \  std::vector<float> rescaled;\n  for (auto number : numbers) {\n    rescaled.push_back((number\
    \ - min) / range);\n  }\n  return rescaled;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min=numbers[0];\n\
    \  float max=numbers[0];\n  for(int i=0;i<numbers.size();i++){\n    if(numbers[i]<min){\n\
    \      min=numbers[i];\n    }\n    if(numbers[i]>max){\n      max=numbers[i];\n\
    \    }\n  }\n  std::vector<float> res;\n  for(int i=0;i<numbers.size();i++){\n\
    \    float x=(numbers[i]-min)/(max-min);\n    res.push_back(x);\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\t// initialize\
    \ variables\n\tstd::vector<float> result;\n\tfloat max = numbers[0];\n\tfloat\
    \ min = numbers[0];\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tif (numbers[i]\
    \ > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t\tif (numbers[i] < min) {\n\t\t\t\
    min = numbers[i];\n\t\t}\n\t}\n\tfloat dist = max - min;\n\tfor (int i = 0; i\
    \ < numbers.size(); i++) {\n\t\tresult.push_back((numbers[i] - min) / dist);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat min_num\
    \ = *std::min_element(numbers.begin(), numbers.end());\n\tfloat max_num = *std::max_element(numbers.begin(),\
    \ numbers.end());\n\tfloat range = max_num - min_num;\n\tstd::vector<float> new_numbers;\n\
    \tfor (auto n : numbers) {\n\t\tfloat res = (n - min_num) / range;\n\t\tnew_numbers.push_back(res);\n\
    \t}\n\treturn new_numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\t\n\tstd::vector<float>\
    \ a;\n\tfloat max = *max_element(numbers.begin(), numbers.end());\n\tfloat min\
    \ = *min_element(numbers.begin(), numbers.end());\n\tfor (int i = 0; i < numbers.size();\
    \ i++) {\n\t\ta.push_back((numbers[i] - min) / (max - min));\n\t}\n\treturn a;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    \n    //assert(numbers.size()\
    \ >= 2);\n    // Your code here\n    int i,j;\n    float min = *std::min_element(numbers.begin(),numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(),numbers.end());\n    for(i=0;i<numbers.size();i++)\n\
    \    {\n        numbers[i] = (numbers[i]-min)/(max-min);\n    }\n    return numbers;\n\
    }\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // compute\
    \ min/max\n    float min_n = std::numeric_limits<float>::max();\n    float max_n\
    \ = std::numeric_limits<float>::min();\n    for (auto& n : numbers) {\n      \
    \  if (n < min_n) {\n            min_n = n;\n        }\n        if (n > max_n)\
    \ {\n            max_n = n;\n        }\n    }\n    // then apply linear transform\n\
    \    std::vector<float> result;\n    for (auto& n : numbers) {\n        result.push_back((n\
    \ - min_n) / (max_n - min_n));\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size()\
    \ >= 2);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (float&\
    \ num : numbers) {\n        if (num < min) {\n            min = num;\n       \
    \ }\n        if (num > max) {\n            max = num;\n        }\n    }\n    assert(min\
    \ < max);\n    std::vector<float> numbers_copy;\n    for (float& num : numbers)\
    \ {\n        float scaled_num = (num - min) / (max - min);\n        numbers_copy.push_back(scaled_num);\n\
    \    }\n    return numbers_copy;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float smallest\
    \ = numbers[0];\n    float largest = numbers[0];\n    for (auto &number : numbers)\
    \ {\n        if (number < smallest) {\n            smallest = number;\n      \
    \  }\n        if (number > largest) {\n            largest = number;\n       \
    \ }\n    }\n    float range = largest - smallest;\n    assert(range > 0);\n  \
    \  std::vector<float> result;\n    for (auto &number : numbers) {\n        result.push_back((number\
    \ - smallest) / range);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // sort\
    \ the numbers to find the min and max\n    std::sort(numbers.begin(), numbers.end());\n\
    \    float min = numbers[0];\n    float max = numbers[numbers.size() - 1];\n \
    \   assert(max > min);\n    // perform linear rescaling\n    for (int i = 0; i\
    \ < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n\
    \    }\n    return numbers;\n}\nint main() {\n    auto candidate = rescale_to_unit;\n\
    \    assert(candidate((std::vector<float>({2.0, 49.9}))) == (std::vector<float>({0.0,\
    \ 1.0})));\n    assert(candidate((std::vector<float>({100.0, 49.9}))) == (std::vector<float>({1.0,\
    \ 0.0})));\n    assert(candidate((std::vector<float>({1.0, 2.0, 3.0, 4.0, 5.0})))\
    \ == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n    assert(candidate((std::vector<float>({2.0,\
    \ 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    \    assert(candidate((std::vector<float>({12.0, 11.0, 15.0, 13.0, 14.0}))) ==\
    \ (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n}\n"
  stdout: ''
  stderr: "tmppmxgp4xz: /tmp/tmppmxgp4xz.cpp:22: int main(): Assertion `candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n\tfloat smallest\
    \ = *std::min_element(numbers.begin(), numbers.end());\n\tfloat largest = *std::max_element(numbers.begin(),\
    \ numbers.end());\n\tfloat range = largest - smallest;\n\tstd::vector<float> rescaled(numbers.size());\n\
    \tstd::transform(numbers.begin(), numbers.end(), rescaled.begin(), [=](float a)\
    \ {\n\t\treturn (a - smallest) / range;\n\t});\n\treturn rescaled;\n}\nint main()\
    \ {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    std::vector<float>\
    \ result;\n    float minimum, maximum;\n    minimum = maximum = numbers[0];\n\
    \    for (auto number : numbers) {\n        if (number < minimum)\n          \
    \  minimum = number;\n        if (number > maximum)\n            maximum = number;\n\
    \    }\n    for (auto number : numbers) {\n        result.push_back((number -\
    \ minimum) / (maximum - minimum));\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_number\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max_number =\
    \ *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n\
    \    for (float number : numbers) {\n        result.push_back((number - min_number)\
    \ / (max_number - min_number));\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    int a;\n\
    \    std::vector<float> b;\n    //for(a = 0; a < numbers.size(); a++)\n    //{\n\
    \    \n    float diff = *std::max_element(numbers.begin(), numbers.end()) - *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float minval = *std::min_element(numbers.begin(), numbers.end());\n\
    \    for(int i = 0; i < numbers.size(); i++)\n    {\n        b.push_back(((numbers[i]\
    \ - minval)/diff));\n    }\n    //}\n    return b;\n}\nint main() {\n    auto\
    \ candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
    \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n// such\
    \ that the smallest number will become 0 and the largest will become 1\n// >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float max\
    \ = numbers[0];\n    float min = numbers[0];\n    for (auto n : numbers) {\n \
    \       if (n > max) max = n;\n        if (n < min) min = n;\n    }\n    std::vector<float>\
    \ result;\n    for (auto n : numbers) {\n        result.push_back((n - min) /\
    \ (max - min));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0, 49.9})))\
    \ == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
    \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
    \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
    \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
    \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
    \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
