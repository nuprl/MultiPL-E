language: cpp
name: HumanEval_68_pluck
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> smalest_value_index;\n  long small_even_value=0;\n\
    \  long index =0;\n  bool found = false;\n  for(long i=0;i<arr.size();i++){\n\
    \    if(arr[i]%2==0 && arr[i]!=0){\n      found = true;\n      small_even_value\
    \ = arr[i];\n      index = i;\n      break;\n    }\n  }\n  if(found == false){\n\
    \    smalest_value_index.push_back(0);\n    smalest_value_index.push_back(0);\n\
    \    return smalest_value_index;\n  }\n  for(long i=0;i<arr.size();i++){\n   \
    \ if(arr[i]%2==0 && arr[i]<small_even_value){\n      small_even_value = arr[i];\n\
    \      index = i;\n    }\n  }\n  smalest_value_index.push_back(small_even_value);\n\
    \  smalest_value_index.push_back(index);\n  return smalest_value_index;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpcwrvuckb: /tmp/tmpcwrvuckb.cpp:60: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117718
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// TODO: Write - Your - Code\n\tint smallest_index = -1;\n\tlong smallest_value\
    \ = LONG_MAX;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 ==\
    \ 0 && arr[i] < smallest_value) {\n\t\t\tsmallest_value = arr[i];\n\t\t\tsmallest_index\
    \ = i;\n\t\t}\n\t}\n\tif (smallest_index != -1) {\n\t\treturn { smallest_value,\
    \ smallest_index };\n\t}\n\treturn {};\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // Your code here\n  std::vector<long> res(2);\n  if(arr.size()<1)\n\
    \    return res;\n  int minEven=INT_MAX;\n  int index=INT_MAX;\n  int i=0;\n \
    \ for(auto &x:arr)\n  {\n    if(x%2==0 && x<minEven)\n    {\n      minEven=x;\n\
    \      index=i;\n    }\n    i++;\n  }\n  if(minEven==INT_MAX)\n    return res;\n\
    \  res[0]=minEven;\n  res[1]=index;\n  return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmptnw8ouf5: /tmp/tmptnw8ouf5.cpp:55: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117718
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// code goes here\n\t// sum = 0;\n\t// if(!arr.size())\n\t// {\n\t\
    // \treturn sum;\n\t// }\n\t// std::sort(arr.begin(), arr.end());\n\t// int i\
    \ = 0;\n\t// while(arr[i]%2 != 0)\n\t// {\n\t// \ti++;\n\t// }\n\t// sum = arr[i];\n\
    \t// return sum;\n\tint n = arr.size();\n\tif(n==0)\n\t{\n\t\treturn arr;\n\t\
    }\n\tlong min_index = 1e9, min_value = 1e9;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\
    \tif(arr[i]%2==0)\n\t\t{\n\t\t\tif(arr[i]<min_value)\n\t\t\t{\n\t\t\t\tmin_value\
    \ = arr[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t}\n\tarr.erase(arr.begin()+min_index);\n\
    \tarr.insert(arr.begin(), min_value);\n\treturn arr;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1nlrd5ng: /tmp/tmp1nlrd5ng.cpp:66: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() < 1) {\n    return {};\n  }\n  std::vector<long> min_of_smallest_even_value\
    \ = {arr[0], 0};\n  bool found_even = false;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] % 2 == 0) {\n      if (!found_even) {\n        min_of_smallest_even_value[0]\
    \ = arr[i];\n        min_of_smallest_even_value[1] = i;\n        found_even =\
    \ true;\n      } else {\n        if (arr[i] < min_of_smallest_even_value[0]) {\n\
    \          min_of_smallest_even_value[0] = arr[i];\n          min_of_smallest_even_value[1]\
    \ = i;\n        }\n      }\n    }\n  }\n  if (found_even) {\n    return min_of_smallest_even_value;\n\
    \  } else {\n    return {};\n  }\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\tstd::vector<long> ret(2);\n\tint i = 0;\n\tstd::sort(arr.begin(),\
    \ arr.end());\n\twhile (i < arr.size()) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\t\
    ret[0] = arr[i];\n\t\t\tret[1] = i;\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t}\n\
    \treturn {};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp0rg8jlpq: /tmp/tmp0rg8jlpq.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> empty;\n  if (arr.size() == 0) return empty;\n \
    \ long smallest;\n  int index = 0;\n  int i = 0;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] % 2 == 0) {\n      if (smallest == NULL) {\n        smallest\
    \ = arr[i];\n        index = i;\n      } else if (arr[i] < smallest) {\n     \
    \   smallest = arr[i];\n        index = i;\n      }\n    }\n  }\n  if (smallest\
    \ == NULL) return empty;\n  std::vector<long> answer;\n  answer.push_back(smallest);\n\
    \  answer.push_back(index);\n  return answer;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmph0k2nw45: /tmp/tmph0k2nw45.cpp:56: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> ans = {};\n  if (arr.size() == 0) {\n    return\
    \ ans;\n  }\n  long min_even = 10000, min_even_idx = 10000;\n  for (int i = 0;\
    \ i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min_even) {\n  \
    \    min_even = arr[i];\n      min_even_idx = i;\n    }\n  }\n  if (min_even !=\
    \ 10000) {\n    ans.push_back(min_even);\n    ans.push_back(min_even_idx);\n \
    \ }\n  return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long min=INT_MAX;\n  int index;\n  for(long i=0;i<arr.size();i++){\n\
    \    if(arr[i]%2==0){\n      if(arr[i]<min){\n        min=arr[i];\n        index=i;\n\
    \      }\n    }\n  }\n  if(min==INT_MAX){\n    std::vector<long> a{};\n    return\
    \ a;\n  }\n  std::vector<long> a={min,index};\n  return a;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  \t//if arr is empty\n\tif(arr.size()==0)\n\t\treturn {};\n\t//std::vector<int>\
    \ for min and min index\n\tstd::vector<long> min;\n\t//foreach value in arr\n\t\
    for(int i=0;i<arr.size();i++){\n\t\t//if value is even\n\t\tif(arr[i]%2==0){\n\
    \t\t\t//if min is empty then push value\n\t\t\tif(min.size()==0){\n\t\t\t\tmin.push_back(arr[i]);\n\
    \t\t\t\tmin.push_back(i);\n\t\t\t}else{\n\t\t\t\t//if min is not empty then compare\n\
    \t\t\t\tif(arr[i]<min[0]){\n\t\t\t\t\tmin[0]=arr[i];\n\t\t\t\t\tmin[1]=i;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//if min is empty then return empty\n\tif(min.size()==0)\n\
    \t\treturn {};\n\t//else return min\n\treturn min;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0)\n\t\treturn {};\n\tlong lowest_even_value = INT_MAX;\n\
    \tint lowest_even_value_index = -1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\
    \t\tif (arr[i] % 2 == 0 && arr[i] < lowest_even_value) {\n\t\t\tlowest_even_value\
    \ = arr[i];\n\t\t\tlowest_even_value_index = i;\n\t\t}\n\t}\n\treturn { lowest_even_value,\
    \ lowest_even_value_index };\n}\nint main() {\n    auto candidate = pluck;\n \
    \   assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp77lg24ua: /tmp/tmp77lg24ua.cpp:50: int main(): Assertion `candidate((std::vector<long>({7,
    9, 7, 1}))) == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> vec;\n    long min= arr[0];\n    long ind= 0;\n\
    \    long pluckedValue= 0;\n    for(long i= 0; i< arr.size(); i++) {\n       \
    \ if(arr[i]%2== 0) {\n            if(arr[i]< min) {\n                min= arr[i];\n\
    \                ind= i;\n            }\n        }\n    }\n    if(min%2== 0) {\n\
    \        vec.push_back(min);\n        vec.push_back(ind);\n    }\n    else\n \
    \       vec.push_back(0);\n    return vec;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmprvhirryv: /tmp/tmprvhirryv.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> v;\n\tif (arr.size() == 0)\n\t\treturn v;\n\tlong\
    \ min = arr[0];\n\tint index = 0;\n\tlong min_index = 0;\n\tfor (int i = 0; i\
    \ < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\tif (arr[i] < min) {\n\
    \t\t\t\tmin = arr[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (min\
    \ % 2 == 0) {\n\t\tv.push_back(min);\n\t\tv.push_back(min_index);\n\t}\n\treturn\
    \ v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpxy1b7q7p: /tmp/tmpxy1b7q7p.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0)\n        return {};\n    std::vector<long> even;\n\
    \    long minIdx = INT_MAX;\n    long minVal = INT_MAX;\n    for(int i = 0; i\
    \ < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n            even.push_back(arr[i]);\n\
    \            if(arr[i] < minVal) {\n                minVal = arr[i];\n       \
    \         minIdx = i;\n            }\n        }\n    }\n    if(even.size() ==\
    \ 0)\n        return {};\n    else\n        return {minVal, minIdx};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\tstd::vector<long> a;\n\tstd::vector<long> b;\n\
    \tlong temp = INT_MAX;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ % 2 == 0) {\n\t\t\ta.push_back(arr[i]);\n\t\t\tb.push_back(i);\n\t\t}\n\t}\n\
    \tif (a.size() == 0)\n\t\treturn {};\n\tfor (int i = 0; i < a.size(); i++) {\n\
    \t\tif (a[i] < temp) {\n\t\t\ttemp = a[i];\n\t\t}\n\t}\n\tstd::vector<long> ans;\n\
    \tans.push_back(temp);\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] ==\
    \ temp) {\n\t\t\tans.push_back(b[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ans;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res;\n  std::vector<long> index;\n  int small;\n\
    \  long x, y;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 ==\
    \ 0) {\n      res.push_back(arr[i]);\n      index.push_back(i);\n    }\n  }\n\
    \  small = res[0];\n  x = res[0];\n  y = index[0];\n  for (int i = 0; i < res.size();\
    \ i++) {\n    if (res[i] < small) {\n      small = res[i];\n      x = res[i];\n\
    \      y = index[i];\n    }\n  }\n  if (x == 0) {\n    for (int i = 0; i < res.size();\
    \ i++) {\n      if (res[i] == 0) {\n        res[i] = INT_MAX;\n      }\n    }\n\
    \    for (int i = 0; i < res.size(); i++) {\n      if (res[i] < small) {\n   \
    \     small = res[i];\n        x = res[i];\n        y = index[i];\n      }\n \
    \   }\n  }\n  res.clear();\n  res.push_back(x);\n  res.push_back(y);\n  return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    if(arr.size() == 0) return {};\n    int size\
    \ = arr.size();\n    vector<long> ans;\n    int idx = 0;\n    while(idx < size)\
    \ {\n        if(arr[idx] % 2 == 0) {\n            ans.push_back(arr[idx]);\n \
    \           ans.push_back(idx);\n            return ans;\n        }\n        idx++;\n\
    \    }\n    return {};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf9xsm1xs.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpf9xsm1xs.cpp:32:5: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   32 |     vector<long> ans;\n      |     ^~~~~~\n/tmp/tmpf9xsm1xs.cpp:32:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf9xsm1xs.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf9xsm1xs.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpf9xsm1xs.cpp:32:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     vector<long>\
    \ ans;\n      |            ^~~~\n/tmp/tmpf9xsm1xs.cpp:36:13: error: \u2018ans\u2019\
    \ was not declared in this scope; did you mean \u2018abs\u2019?\n   36 |     \
    \        ans.push_back(arr[idx]);\n      |             ^~~\n      |          \
    \   abs\n"
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> result = {};\n  if (arr.size() == 0) {\n    return\
    \ result;\n  }\n  std::vector<long> even_nums = {};\n  long index = 0;\n  for\
    \ (long i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      even_nums.push_back(arr[i]);\n\
    \      index = i;\n    }\n  }\n  if (even_nums.size() == 0) {\n    return result;\n\
    \  }\n  long min = *std::min_element(even_nums.begin(), even_nums.end());\n  result.push_back(min);\n\
    \  result.push_back(index);\n  return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpift_3uyw: /tmp/tmpift_3uyw.cpp:54: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    if(arr.size() == 0)\n        return\
    \ res;\n    std::vector<long> even,odd;\n    int i=0;\n    for(auto &&num:arr){\n\
    \        if(num%2 == 0)\n            even.push_back(num);\n        else\n    \
    \        odd.push_back(num);\n    }\n    if(even.size() == 0)\n        return\
    \ res;\n    std::sort(even.begin(),even.end());\n    std::sort(odd.begin(),odd.end());\n\
    \    for(auto &&num:arr){\n        if(num == even[0]){\n            res.push_back(num);\n\
    \            res.push_back(i);\n            break;\n        }\n        i++;\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    std::vector<long> emptyVector;\n    if(arr.size()\
    \ == 0)\n        return emptyVector;\n    long min = 1e9+1;\n    long index =\
    \ -1;\n    for(long i = 0; i < arr.size(); i++)\n    {\n        if(arr[i] % 2\
    \ == 0)\n        {\n            if(arr[i] < min)\n            {\n            \
    \    min = arr[i];\n                index = i;\n            }\n        }\n   \
    \ }\n    if(index == -1)\n        return emptyVector;\n    return {min, index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size()<1)\n        return std::vector<long>();\n    std::vector<long>\
    \ ans;\n    long sml=INT_MAX;\n    int idx=INT_MAX;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0 && arr[i]<sml){\n            sml=arr[i];\n           \
    \ idx=i;\n        }\n    }\n    if(sml==INT_MAX)\n        return std::vector<long>();\n\
    \    ans.push_back(sml);\n    ans.push_back(idx);\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\t// PSEUDOCODE:\n\t// if array is empty, return\
    \ empty array\n\t// else,\n\t// initialize vector to return\n\t// initialize smallest\
    \ value to 0\n\t// initialize smallest value index to 0\n\t// traverse the array\n\
    \t// if the current element is not zero and\n\t// if the current element is even\
    \ and\n\t// if the current element is smaller than the smallest element,\n\t//\
    \ update the smallest element to the current element\n\t// update the smallest\
    \ element index to the current index\n\t// after the loop,\n\t// if the smallest\
    \ element is 0, return an empty array\n\t// else, return a vector containing the\
    \ smallest value and its index\n\tif (arr.empty()) {\n\t\treturn {};\n\t}\n\t\
    else {\n\t\tstd::vector<long> smallest_even_value;\n\t\tlong smallest_value =\
    \ 0;\n\t\tlong smallest_value_index = 0;\n\t\tfor (long i = 0; i < arr.size();\
    \ i++) {\n\t\t\tif (arr[i] != 0 && arr[i] % 2 == 0 && arr[i] < smallest_value)\
    \ {\n\t\t\t\tsmallest_value = arr[i];\n\t\t\t\tsmallest_value_index = i;\n\t\t\
    \t}\n\t\t}\n\t\tif (smallest_value == 0) {\n\t\t\treturn {};\n\t\t}\n\t\telse\
    \ {\n\t\t\tsmallest_even_value.push_back(smallest_value);\n\t\t\tsmallest_even_value.push_back(smallest_value_index);\n\
    \t\t\treturn smallest_even_value;\n\t\t}\n\t}\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpv_i4jppz: /tmp/tmpv_i4jppz.cpp:70: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0) return {};\n    std::vector<long> ans;\n   \
    \ long min = arr[0];\n    long min_ind = 0;\n    for(long i = 0; i < arr.size();\
    \ i++){\n        if(arr[i]%2 == 0 && arr[i] < min){\n            min = arr[i];\n\
    \            min_ind = i;\n        }\n    }\n    if(min == arr[0]) return {};\n\
    \    ans.push_back(min);\n    ans.push_back(min_ind);\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpe973zhg0: /tmp/tmpe973zhg0.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long sz=arr.size();\n    if(sz==0) return {};\n    std::vector<long>\
    \ ans;\n    long f=0;\n    long sm=arr[0];\n    long idx=0;\n    for(long i=0;i<sz;i++){\n\
    \        if(arr[i]%2==0){\n            f=1;\n            if(arr[i]<sm){\n    \
    \            sm=arr[i];\n                idx=i;\n            }\n        }\n  \
    \  }\n    if(f==0) return {};\n    ans.push_back(sm);\n    ans.push_back(idx);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp7z6kbhj2: /tmp/tmp7z6kbhj2.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117720
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> ret;\n  long even = 1e9;\n  long index = 1e9;\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] <\
    \ even) {\n      even = arr[i];\n      index = i;\n    }\n  }\n  if (even != 1e9)\
    \ {\n    ret.push_back(even);\n    ret.push_back(index);\n  }\n  return ret;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> answer{};\n    if(arr.size() == 0) return answer;\n\
    \    long min = INT_MAX;\n    for(long i = 0; i < arr.size(); i++){\n        if(arr[i]\
    \ % 2 == 0 && arr[i] < min){\n            min = arr[i];\n            answer.clear();\n\
    \            answer.push_back(min);\n            answer.push_back(i);\n      \
    \  }\n    }\n    if(answer.size() == 0) answer.clear();\n    return answer;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  if(arr.size() == 0)\n    return {};\n  std::vector<long>\
    \ evens;\n  std::vector<long> evensIndex;\n  for(int i = 0; i < arr.size(); i++)\n\
    \  {\n    if(arr[i] % 2 == 0)\n    {\n      evens.push_back(arr[i]);\n      evensIndex.push_back(i);\n\
    \    }\n  }\n  std::sort(evens.begin(), evens.end());\n  for(int i = 0; i < evens.size();\
    \ i++)\n  {\n    if(evens[i] % 2 == 0)\n    {\n      return {evens[i], evensIndex[i]};\n\
    \    }\n  }\n  return {};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpid57hzij: /tmp/tmpid57hzij.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int min_index = -1;\n    long min_value = INT_MAX;\n    int i =\
    \ 0;\n    while (i < arr.size()) {\n        if (arr[i] % 2 == 0 && arr[i] < min_value)\
    \ {\n            min_value = arr[i];\n            min_index = i;\n        }\n\
    \        i++;\n    }\n    if (min_index == -1) {\n        return {};\n    }\n\
    \    std::vector<long> ret;\n    ret.push_back(min_value);\n    ret.push_back(min_index);\n\
    \    return ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long size = arr.size();\n    if(!size) return {};\n    long min\
    \ = 1e9;\n    long index = -1;\n    for(long i = 0; i < size; i++) {\n       \
    \ if(arr[i] % 2 == 0 && arr[i] < min) {\n            min = arr[i];\n         \
    \   index = i;\n        }\n    }\n    if(index == -1) return {};\n    return {min,\
    \ index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  long min=10000000000000;\n  std::vector<long>\
    \ result;\n  for(long i=0;i<arr.size();i++)\n  {\n    if(arr[i]%2==0)\n    {\n\
    \      if(arr[i]<min)\n      {\n        min=arr[i];\n        result.push_back(min);\n\
    \        result.push_back(i);\n      }\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpm_vx0cmt: /tmp/tmpm_vx0cmt.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    std::vector<long> result;\n    long min =\
    \ LONG_MAX;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2\
    \ == 0 && arr[i] < min) {\n            min = arr[i];\n            result.clear();\n\
    \            result.push_back(arr[i]);\n            result.push_back(i);\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    std::vector<long> res(2, 0);\n    long min_val\
    \ = LONG_MAX;\n    long min_idx = -1;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] < min_val && arr[i] % 2 == 0) {\n            min_val =\
    \ arr[i];\n            min_idx = i;\n        }\n    }\n    if (min_idx != -1)\
    \ {\n        res[0] = min_val;\n        res[1] = min_idx;\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp8mrbr8y_: /tmp/tmp8mrbr8y_.cpp:49: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117718
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> result;\n  if (arr.size() == 0) {\n    return result;\n\
    \  }\n  long min_even = 1e10;\n  long min_index = -1;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] < min_even && arr[i] % 2 == 0) {\n      min_even = arr[i];\n\
    \      min_index = i;\n    }\n  }\n  if (min_index == -1) {\n    return result;\n\
    \  }\n  result.push_back(min_even);\n  result.push_back(min_index);\n  return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> res;\n\tif (arr.size() == 0) return res;\n\tlong\
    \ min_val = INT_MAX;\n\tlong min_idx = INT_MAX;\n\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\tif (arr[i] % 2 == 0 && arr[i] < min_val) {\n\t\t\tmin_val = arr[i];\n\
    \t\t\tmin_idx = i;\n\t\t}\n\t}\n\tif (min_val == INT_MAX) return res;\n\tres.push_back(min_val);\n\
    \tres.push_back(min_idx);\n\treturn res;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long smallest = -1;\n    int index\
    \ = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smallest == -1) {\n                smallest = arr[i];\n\
    \                index = i;\n            } else if (arr[i] < smallest) {\n   \
    \             smallest = arr[i];\n                index = i;\n            }\n\
    \        }\n    }\n    if (smallest != -1) {\n        result.push_back(smallest);\n\
    \        result.push_back(index);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n   int n = arr.size();\n   if(n == 0)\n       return {};\n   int min\
    \ = INT_MAX;\n   int index = -1;\n   for(int i = 0; i < n; i++)\n   {\n      \
    \ if(arr[i] % 2 == 0 && arr[i] < min)\n       {\n           min = arr[i];\n  \
    \         index = i;\n       }\n   }\n   if(index == -1)\n       return {};\n\
    \   else\n       return {min, index};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() == 0) {\n    return {};\n  }\n  long min_even_value\
    \ = INT_MAX;\n  long min_even_index = INT_MAX;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min_even_value) {\n      min_even_value\
    \ = arr[i];\n      min_even_index = i;\n    }\n  }\n  if (min_even_value == INT_MAX)\
    \ {\n    return {};\n  }\n  return {min_even_value, min_even_index};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  long minIndex = -1;\n  long minEven = -1;\n \
    \ for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      if\
    \ (minEven == -1) {\n        minEven = arr[i];\n        minIndex = i;\n      }\
    \ else if (arr[i] < minEven) {\n        minEven = arr[i];\n        minIndex =\
    \ i;\n      }\n    }\n  }\n  if (minIndex == -1) {\n    return {};\n  }\n  return\
    \ {minEven, minIndex};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> vec;\n    if(arr.size() == 0)\n        return\
    \ vec;\n    long min = arr[0];\n    long min_idx = 0;\n    for(int i = 0; i <\
    \ arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min) {\n        \
    \    min = arr[i];\n            min_idx = i;\n        }\n    }\n    if(min % 2\
    \ == 0) {\n        vec.push_back(min);\n        vec.push_back(min_idx);\n    }\n\
    \    return vec;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp9wnddllx: /tmp/tmp9wnddllx.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tlong size = arr.size();\n\tstd::vector<long> answer;\n\tif (size ==\
    \ 0) {\n\t\treturn answer;\n\t}\n\tlong i = 0;\n\tlong index;\n\tlong smallest\
    \ = arr[0];\n\twhile (i < size) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\tif (arr[i]\
    \ <= smallest) {\n\t\t\t\tsmallest = arr[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\
    }\n\t\ti++;\n\t}\n\tif (smallest == arr[0]) {\n\t\tanswer.push_back(smallest);\n\
    \t\tanswer.push_back(index);\n\t\treturn answer;\n\t}\n\telse {\n\t\treturn answer;\n\
    \t}\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpmwf2foh1: /tmp/tmpmwf2foh1.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long first_even = -1;\n    int size = arr.size();\n    if(size ==\
    \ 0)\n        return {};\n    for(int i = 0; i < size; i++) {\n        if(arr[i]\
    \ % 2 == 0) {\n            first_even = arr[i];\n            break;\n        }\n\
    \    }\n    if(first_even == -1)\n        return {};\n    long min_even = INT_MAX;\n\
    \    int min_even_index = 0;\n    for(int i = 0; i < size; i++) {\n        if(arr[i]\
    \ == first_even) {\n            min_even = arr[i];\n            min_even_index\
    \ = i;\n            break;\n        }\n    }\n    for(int i = 0; i < size; i++)\
    \ {\n        if(arr[i] == first_even && i < min_even_index) {\n            min_even\
    \ = arr[i];\n            min_even_index = i;\n        }\n    }\n    return {min_even,\
    \ min_even_index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpa1xt4ht1: /tmp/tmpa1xt4ht1.cpp:60: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// 1 <= nodes.length <= 10000\n\tassert(arr.size() > 0 && arr.size()\
    \ <= 10000);\n\tfor (auto i : arr) {\n\t\t// 0 <= node.value\n\t\tassert(i >=\
    \ 0);\n\t}\n\t// O(n)\n\t// [4,2,3]\n\t// [1,2,3]\n\t// [5, 0, 3, 0, 4, 2]\n\t\
    long smallest_value = -1;\n\tsize_t smallest_index = -1;\n\tsize_t num_zeros =\
    \ 0;\n\tfor (size_t i = 0; i < arr.size(); ++i) {\n\t\tif (arr[i] == 0) {\n\t\t\
    \tnum_zeros++;\n\t\t\tif (num_zeros == 1) {\n\t\t\t\tsmallest_value = 0;\n\t\t\
    \t\tsmallest_index = i;\n\t\t\t}\n\t\t}\n\t\tif (arr[i] > 0 && arr[i] % 2 == 0)\
    \ {\n\t\t\tif (smallest_value == -1) {\n\t\t\t\tsmallest_value = arr[i];\n\t\t\
    \t\tsmallest_index = i;\n\t\t\t}\n\t\t\telse if (arr[i] < smallest_value) {\n\t\
    \t\t\tsmallest_value = arr[i];\n\t\t\t\tsmallest_index = i;\n\t\t\t}\n\t\t}\n\t\
    }\n\tif (smallest_value == -1) {\n\t\treturn {};\n\t}\n\telse {\n\t\treturn {\
    \ smallest_value, smallest_index };\n\t}\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdt4hbmws: /tmp/tmpdt4hbmws.cpp:30: std::vector<long int> pluck(std::vector<long
    int>): Assertion `arr.size() > 0 && arr.size() <= 10000'' failed.

    '
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> ret;\n  if (arr.size() == 0) {\n    return ret;\n\
    \  }\n  std::vector<long> even_nums;\n  std::vector<long> even_nums_idx;\n  for\
    \ (long i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      even_nums.push_back(arr[i]);\n\
    \      even_nums_idx.push_back(i);\n    }\n  }\n  if (even_nums.size() == 0) {\n\
    \    return ret;\n  }\n  long min_even_num = even_nums[0];\n  long min_even_num_idx\
    \ = even_nums_idx[0];\n  for (long i = 1; i < even_nums.size(); i++) {\n    if\
    \ (even_nums[i] < min_even_num) {\n      min_even_num = even_nums[i];\n      min_even_num_idx\
    \ = even_nums_idx[i];\n    }\n  }\n  ret.push_back(min_even_num);\n  ret.push_back(min_even_num_idx);\n\
    \  return ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // Our answer variable\n  std::vector<long> result{};\n  // Check\
    \ if our array contains anything\n  if (arr.size() == 0) {\n    return result;\n\
    \  }\n  // Our variable to track the lowest even number\n  long lowest_even =\
    \ 0;\n  // Our variable to track which index the lowest even number is at\n  long\
    \ lowest_even_index = 0;\n  // Our variable to track if we have even number\n\
    \  bool have_even = false;\n  // Loop through our array\n  for (long i = 0; i\
    \ < arr.size(); i++) {\n    // Check if the current value is even\n    if (arr[i]\
    \ % 2 == 0) {\n      // Check if we have an even number yet\n      if (!have_even)\
    \ {\n        // Set our lowest even number\n        lowest_even = arr[i];\n  \
    \      // Set our lowest even index\n        lowest_even_index = i;\n        //\
    \ Set our have even variable\n        have_even = true;\n      } else {\n    \
    \    // Check if our current value is lower than our lowest even\n        if (arr[i]\
    \ < lowest_even) {\n          // Set our lowest even number\n          lowest_even\
    \ = arr[i];\n          // Set our lowest even index\n          lowest_even_index\
    \ = i;\n        }\n      }\n    }\n  }\n  // Check if we have an even\n  if (have_even)\
    \ {\n    // Add our even number to our answer\n    result.push_back(lowest_even);\n\
    \    // Add our even index to our answer\n    result.push_back(lowest_even_index);\n\
    \  }\n  // Return our answer\n  return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long min_even = 10001;\n  long min_idx = 0;\n  for (int i = 0; i <\
    \ arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min_even) {\n      min_even\
    \ = arr[i];\n      min_idx = i;\n    }\n  }\n  if (min_even == 10001) {\n    return\
    \ {};\n  }\n  std::vector<long> result;\n  result.push_back(min_even);\n  result.push_back(min_idx);\n\
    \  return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0) return std::vector<long>();\n    std::vector<long>\
    \ result;\n    long min_even = 10001;\n    long min_i = 0;\n    for(long i = 0;\
    \ i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_even) {\n\
    \            min_even = arr[i];\n            min_i = i;\n        }\n    }\n  \
    \  if(min_even == 10001) return std::vector<long>();\n    result.push_back(min_even);\n\
    \    result.push_back(min_i);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117719
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  int n = arr.size();\n  long  idx=-1, min=-1;\n  for(int i=0; i<n;\
    \ i++){\n    if(arr[i]%2==0 && arr[i]!=0){\n      if(min==-1 || arr[i]<min){\n\
    \        min = arr[i];\n        idx = i;\n      }\n    }\n  }\n  if(idx!=-1)\n\
    \    return {min, idx};\n  return {};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpmlf445ju: /tmp/tmpmlf445ju.cpp:48: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v;\n    if(arr.size()==0)\n        return v;\n\
    \    else\n    {\n        long min=arr[0];\n        long index=0;\n        for(long\
    \ i=0;i<arr.size();i++)\n        {\n            if(arr[i]<min && arr[i]%2==0)\n\
    \            {\n                min=arr[i];\n                index=i;\n      \
    \      }\n        }\n        if(min%2==0)\n        {\n            v.push_back(min);\n\
    \            v.push_back(index);\n        }\n        return v;\n    }\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp3399l1xj: /tmp/tmp3399l1xj.cpp:55: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> v;\n  int curr = INT_MAX;\n  int x;\n  for(int i\
    \ = 0; i < arr.size(); i++) {\n    if(arr[i] % 2 == 0) {\n      if(arr[i] < curr)\
    \ {\n        curr = arr[i];\n        x = i;\n      }\n    }\n  }\n  if(curr !=\
    \ INT_MAX) {\n    v.push_back(curr);\n    v.push_back(x);\n  }\n  return v;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> result;\n  if (arr.size() == 0) {\n    return result;\n\
    \  }\n  auto min = arr[0];\n  auto min_index = 0;\n  for (auto i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i]%2 == 0 && arr[i] < min) {\n      min = arr[i];\n    \
    \  min_index = i;\n    }\n  }\n  if (min%2 == 0) {\n    result.push_back(min);\n\
    \    result.push_back(min_index);\n  }\n  return result;\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp2duwp94w: /tmp/tmp2duwp94w.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v;\n    if(arr.size() == 0)\n        return v;\n\
    \    std::vector<long> even;\n    std::vector<long> even_index;\n    for(int i\
    \ = 0; i < arr.size(); i++){\n        if(arr[i] % 2 == 0){\n            even.push_back(arr[i]);\n\
    \            even_index.push_back(i);\n        }\n    }\n    if(even.size() ==\
    \ 0)\n        return v;\n    long min = INT_MAX;\n    long min_index = 0;\n  \
    \  for(int i = 0; i < even.size(); i++){\n        if(even[i] < min){\n       \
    \     min = even[i];\n            min_index = i;\n        }\n    }\n    v.push_back(min);\n\
    \    v.push_back(even_index[min_index]);\n    return v;\n}\nint main() {\n   \
    \ auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long smallestEvenNum = arr[0];\n  long ind = 0;\n  for (long i = 0;\
    \ i < arr.size(); i++) {\n    if (arr[i] < smallestEvenNum && arr[i] % 2 == 0)\
    \ {\n      smallestEvenNum = arr[i];\n      ind = i;\n    }\n  }\n  std::vector<long>\
    \ ans = {};\n  if (smallestEvenNum % 2 == 0) {\n    ans.push_back(smallestEvenNum);\n\
    \    ans.push_back(ind);\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpgpesjr7n: /tmp/tmpgpesjr7n.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long min= INT_MAX;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0){\n            if(arr[i]<min){\n                min=arr[i];\n\
    \                result.clear();\n                result.push_back(arr[i]);\n\
    \                result.push_back(i);\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code goes here\n  std::vector<long> evens;\n  std::vector<long>\
    \ output;\n  for(int i = 0; i < arr.size(); i++){\n    if(arr[i]%2 == 0){\n  \
    \    evens.push_back(arr[i]);\n    }\n  }\n  if(evens.size() == 0){\n    return\
    \ output;\n  }\n  long smallest = *std::min_element(evens.begin(), evens.end());\n\
    \  for(int i = 0; i < arr.size(); i++){\n    if(arr[i] == smallest){\n      output.push_back(smallest);\n\
    \      output.push_back(i);\n      return output;\n    }\n  }\n  return output;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  long min=-1;\n  int ind=-1;\n  for(int i=0;i<arr.size();i++)\n\
    \  {\n    if(arr[i]%2==0 && arr[i]<min)\n    {\n      min=arr[i];\n      ind=i;\n\
    \    }\n  }\n  if(min==-1)\n  {\n    vector<long> res;\n    return res;\n  }\n\
    \  vector<long> res;\n  res.push_back(min);\n  res.push_back(ind);\n  return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppzg7ugcc.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppzg7ugcc.cpp:42:5: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   42 |     vector<long> res;\n      |     ^~~~~~\n/tmp/tmppzg7ugcc.cpp:42:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppzg7ugcc.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppzg7ugcc.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmppzg7ugcc.cpp:42:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   42 |     vector<long>\
    \ res;\n      |            ^~~~\n/tmp/tmppzg7ugcc.cpp:43:12: error: \u2018res\u2019\
    \ was not declared in this scope\n   43 |     return res;\n      |           \
    \ ^~~\n/tmp/tmppzg7ugcc.cpp:45:3: error: \u2018vector\u2019 was not declared in\
    \ this scope\n   45 |   vector<long> res;\n      |   ^~~~~~\n/tmp/tmppzg7ugcc.cpp:45:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppzg7ug"
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> a;\n  if(arr.size()==0)\n  {\n    return a;\n  }\n\
    \  else\n  {\n    int small =arr[0];\n    int index = 0;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n      if(arr[i]%2==0 && arr[i]<small)\n      {\n        small = arr[i];\n\
    \        index = i;\n      }\n    }\n    if(small%2==0)\n    {\n      a.push_back(small);\n\
    \      a.push_back(index);\n      return a;\n    }\n    else\n    {\n      return\
    \ a;\n    }\n  }\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp5gz8gw7w: /tmp/tmp5gz8gw7w.cpp:61: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n   std::vector<long> answer;\n   long smallest_even_value = 10000;\n\
    \   long smallest_even_index = 0;\n   bool even_found = false;\n   for (unsigned\
    \ int i = 0; i < arr.size(); i++) {\n      if (arr[i] % 2 == 0 && arr[i] < smallest_even_value)\
    \ {\n         smallest_even_value = arr[i];\n         smallest_even_index = i;\n\
    \         even_found = true;\n      }\n   }\n   if (even_found) {\n      answer.push_back(smallest_even_value);\n\
    \      answer.push_back(smallest_even_index);\n   }\n   return answer;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// use an even_found flag to account for the case when there are no\
    \ evens\n\tbool even_found = false;\n\t// initialize the smallest even value to\
    \ be the first value in the array\n\tlong smallest_even = arr[0];\n\t// initialize\
    \ the smallest index to be 0\n\tlong smallest_index = 0;\n\t// loop over the rest\
    \ of the array values\n\tfor (int i = 1; i < arr.size(); i++) {\n\t\t// check\
    \ if the current value is even\n\t\tif (arr[i] % 2 == 0) {\n\t\t\t// if the current\
    \ value is smaller than the smallest even value\n\t\t\tif (arr[i] < smallest_even)\
    \ {\n\t\t\t\t// set the smallest even value to be the current value\n\t\t\t\t\
    smallest_even = arr[i];\n\t\t\t\t// set the smallest index to be the current index\n\
    \t\t\t\tsmallest_index = i;\n\t\t\t}\n\t\t\t// set the even_found flag to true\n\
    \t\t\teven_found = true;\n\t\t}\n\t}\n\t// if an even was found\n\tif (even_found)\
    \ {\n\t\t// return a vector containing the smallest even value and its index\n\
    \t\treturn { smallest_even, smallest_index };\n\t}\n\t// if an even was not found\n\
    \telse {\n\t\t// return an empty vector\n\t\treturn {};\n\t}\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpqgddwdp4: /tmp/tmpqgddwdp4.cpp:64: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long k=0;\n    int i;\n    for(i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]%2==0)\n        {\n            k=arr[i];\n          \
    \  break;\n        }\n    }\n    if(i==arr.size())\n    {\n        return result;\n\
    \    }\n    int j=i;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]<k\
    \ && arr[i]%2==0)\n        {\n            k=arr[i];\n            j=i;\n      \
    \  }\n    }\n    result.push_back(k);\n    result.push_back(j);\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v;\n    long m = 99999999999;\n    long i = 0;\n\
    \    int flag = 0;\n    for(auto c: arr){\n        if(c%2 == 0){\n           \
    \ if(m > c){\n                m = c;\n                flag = 1;\n            }\n\
    \        }\n    }\n    if(flag == 1){\n        v.push_back(m);\n        for(auto\
    \ c: arr){\n            if(c == m){\n                v.push_back(i);\n       \
    \         break;\n            }\n            i++;\n        }\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long min_value = 0;\n    long min_index = -1;\n    for (long i =\
    \ 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (min_index\
    \ == -1) {\n                min_value = arr[i];\n                min_index = i;\n\
    \            } else {\n                if (arr[i] < min_value) {\n           \
    \         min_value = arr[i];\n                    min_index = i;\n          \
    \      }\n            }\n        }\n    }\n    if (min_index == -1) {\n      \
    \  return {};\n    }\n    return {min_value, min_index};\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() == 0) return {};\n  long minIndex = 0;\n  long minEven\
    \ = 0;\n  bool found = false;\n  for (long i = 0; i < arr.size(); i++) {\n   \
    \ if (arr[i] % 2 == 0) {\n      if (!found) {\n        minEven = arr[i];\n   \
    \     minIndex = i;\n        found = true;\n      } else {\n        if (arr[i]\
    \ < minEven) {\n          minEven = arr[i];\n          minIndex = i;\n       \
    \ }\n      }\n    }\n  }\n  if (found) return {minEven, minIndex};\n  return {};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0)\n\t\treturn {};\n\tint n = arr.size();\n\tvector<long>\
    \ result;\n\tlong minVal = LONG_MAX;\n\tint minValIndex = -1;\n\tfor (int i =\
    \ 0; i < n; i++) {\n\t\tif (arr[i] % 2 == 0 && arr[i] < minVal) {\n\t\t\tminVal\
    \ = arr[i];\n\t\t\tminValIndex = i;\n\t\t}\n\t}\n\tif (minValIndex == -1)\n\t\t\
    return {};\n\tresult.push_back(minVal);\n\tresult.push_back(minValIndex);\n\t\
    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprc5_nmhd.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmprc5_nmhd.cpp:32:2: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   32 |  vector<long> result;\n      |  ^~~~~~\n/tmp/tmprc5_nmhd.cpp:32:2:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprc5_nmhd.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprc5_nmhd.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmprc5_nmhd.cpp:32:9:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |  vector<long>\
    \ result;\n      |         ^~~~\n/tmp/tmprc5_nmhd.cpp:43:2: error: \u2018result\u2019\
    \ was not declared in this scope\n   43 |  result.push_back(minVal);\n      |\
    \  ^~~~~~\n"
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size()==0)\n        return {};\n    std::vector<long> result(2);\n\
    \    result[0]=INT_MAX;\n    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]%2==0)\n\
    \        {\n            if(arr[i]<result[0])\n            {\n                result[0]=arr[i];\n\
    \                result[1]=i;\n            }\n        }\n    }\n    if(result[0]==INT_MAX)\n\
    \        return {};\n    return result;\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  int idx = -1;\n  long smallest_even_value = 10001;\n  for (int i =\
    \ 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      if (arr[i] % 2 == 0)\
    \ {\n        if (arr[i] < smallest_even_value) {\n          smallest_even_value\
    \ = arr[i];\n          idx = i;\n        }\n      }\n    }\n  }\n  if (idx ==\
    \ -1) {\n    return {};\n  }\n  return {smallest_even_value, idx};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpvppk3rgm: /tmp/tmpvppk3rgm.cpp:51: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp2yw4wst5: /tmp/tmp2yw4wst5.cpp:33: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res;\n  std::vector<long>::iterator min_it = arr.end();\n\
    \  std::vector<long>::iterator min_even_it = arr.end();\n  for (std::vector<long>::iterator\
    \ it = arr.begin(); it != arr.end(); ++it) {\n    if (min_it == arr.end() || *it\
    \ < *min_it) {\n      min_it = it;\n    }\n    if (*it % 2 == 0 && (min_even_it\
    \ == arr.end() || *it < *min_even_it)) {\n      min_even_it = it;\n    }\n  }\n\
    \  if (min_even_it != arr.end()) {\n    res.push_back(*min_even_it);\n    res.push_back(min_even_it\
    \ - arr.begin());\n  }\n  return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  int result;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i]\
    \ % 2 == 0) {\n      result = arr[i];\n      break;\n    }\n  }\n  std::vector<long>\
    \ resultVec;\n  resultVec.push_back(result);\n  resultVec.push_back(i);\n  return\
    \ resultVec;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnijpp63q.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpnijpp63q.cpp:38:23: error: \u2018i\u2019 was not declared\
    \ in this scope\n   38 |   resultVec.push_back(i);\n      |                  \
    \     ^\n"
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long even=INT_MAX;\n    long pos=INT_MAX;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]<even && arr[i]%2==0){\n            even=arr[i];\n         \
    \   pos=i;\n        }\n    }\n    std::vector<long> res;\n    if(even!=INT_MAX\
    \ && pos!=INT_MAX){\n        res.push_back(even);\n        res.push_back(pos);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  std::vector<long> out;\n  // out[0] = 0;\n  //\
    \ out[1] = 0;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 ==\
    \ 0) {\n      out.push_back(arr[i]);\n      out.push_back(i);\n      break;\n\
    \    }\n  }\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0\
    \ && arr[i] < out[0]) {\n      out[0] = arr[i];\n      out[1] = i;\n    }\n  }\n\
    \  return out;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    if(arr.size()==0)\n        return ans;\n\
    \    long min_even = INT_MAX;\n    long min_even_idx = INT_MAX;\n    for(long\
    \ i=0;i<arr.size();i++){\n        if(arr[i]%2==0){\n            if(arr[i]<min_even){\n\
    \                min_even = arr[i];\n                min_even_idx = i;\n     \
    \       }\n        }\n    }\n    if(min_even!=INT_MAX){\n        ans.push_back(min_even);\n\
    \        ans.push_back(min_even_idx);\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code goes here\n\tif (arr.size() <= 0)\n\t\treturn {};\n\t\
    std::vector<long> result = {};\n\tstd::vector<long> even = {};\n\tfor (int i =\
    \ 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\teven.push_back(arr[i]);\n\
    \t\t}\n\t}\n\tif (even.size() <= 0)\n\t\treturn {};\n\tlong min = even[0];\n\t\
    for (int i = 0; i < even.size(); i++) {\n\t\tif (even[i] < min) {\n\t\t\tmin =\
    \ even[i];\n\t\t}\n\t}\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ == min) {\n\t\t\tresult.push_back(min);\n\t\t\tresult.push_back(i);\n\t\t\t\
    return result;\n\t\t}\n\t}\n\treturn {};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> b;\n  long sml_evn = INT_MAX;\n  long index_sml_evn\
    \ = INT_MAX;\n  bool flag = false;\n  for(long i = 0; i < arr.size(); i++) {\n\
    \    if(arr[i] % 2 == 0) {\n      flag = true;\n      if(arr[i] < sml_evn) {\n\
    \        sml_evn = arr[i];\n        index_sml_evn = i;\n      }\n    }\n  }\n\
    \  if(flag) {\n    b.push_back(sml_evn);\n    b.push_back(index_sml_evn);\n  }\n\
    \  return b;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ret_val;\n    long min_val = INT_MAX;\n    long\
    \ min_index = INT_MAX;\n    for (long i = 0; i < arr.size(); i++) {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n   \
    \         min_index = i;\n        }\n    }\n    if (min_val != INT_MAX) {\n  \
    \      ret_val.push_back(min_val);\n        ret_val.push_back(min_index);\n  \
    \  }\n    return ret_val;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() < 1) return {};\n  int minEven = std::numeric_limits<int>::max();\n\
    \  int minIndex = std::numeric_limits<int>::max();\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] % 2 == 0 && arr[i] < minEven) {\n      minEven = arr[i];\n\
    \      minIndex = i;\n    }\n  }\n  if (minEven == std::numeric_limits<int>::max())\
    \ return {};\n  else return {minEven, minIndex};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ret;\n    if (arr.size() == 0) return ret;\n \
    \   long smallest = LONG_MAX;\n    long ind = -1;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] < smallest && arr[i] % 2 == 0) {\n            smallest\
    \ = arr[i];\n            ind = i;\n        }\n    }\n    if (ind == -1) return\
    \ ret;\n    ret.push_back(smallest);\n    ret.push_back(ind);\n    return ret;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    if(arr.size() == 0)\n        return\
    \ res;\n    long min = INT_MAX;\n    long idx = -1;\n    for(int i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] != 0 && arr[i] % 2 == 0 && arr[i] < min) {\n     \
    \       min = arr[i];\n            idx = i;\n        }\n    }\n    if(idx == -1)\n\
    \        return res;\n    res.push_back(min);\n    res.push_back(idx);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmppr8_s2h5: /tmp/tmppr8_s2h5.cpp:51: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0)\n        return arr;\n    long min = INT_MAX;\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n  \
    \          if(arr[i] < min) {\n                min = arr[i];\n            }\n\
    \        }\n    }\n    std::vector<long> vec;\n    if(min != INT_MAX) {\n    \
    \    vec.push_back(min);\n        for(int i = 0; i < arr.size(); i++) {\n    \
    \        if(arr[i] == min) {\n                vec.push_back(i);\n            \
    \    break;\n            }\n        }\n    }\n    return vec;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ret;\n    long min_even_val = std::numeric_limits<long>::max();\n\
    \    long min_even_index = std::numeric_limits<long>::max();\n    for (long i\
    \ = 0; i < arr.size(); ++i) {\n        long val = arr[i];\n        if (val % 2\
    \ == 0) {\n            if (val < min_even_val) {\n                min_even_val\
    \ = val;\n                min_even_index = i;\n            }\n        }\n    }\n\
    \    if (min_even_val != std::numeric_limits<long>::max()) {\n        ret.push_back(min_even_val);\n\
    \        ret.push_back(min_even_index);\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t\tif(arr.size() == 0) return {};\n\t\tlong min = INT_MAX;\n\t\tlong\
    \ res = INT_MAX;\n\t\tint idx = -1;\n\t\tfor(int i = 0; i < arr.size(); i++) {\n\
    \t\t\t\tif(arr[i] % 2 == 0) {\n\t\t\t\t\t\tif(arr[i] < min) {\n\t\t\t\t\t\t\t\t\
    res = arr[i];\n\t\t\t\t\t\t\t\tidx = i;\n\t\t\t\t\t\t\t\tmin = arr[i];\n\t\t\t\
    \t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tif(idx == -1) return {};\n\t\treturn {res, idx};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans = {};\n    if (arr.size() == 0) {\n      \
    \  return ans;\n    }\n    // initialize the array \n    long min_value = INT_MAX;\n\
    \    long min_index = INT_MAX;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] % 2 == 0 && arr[i] < min_value) {\n            min_value =\
    \ arr[i];\n            min_index = i;\n        }\n    }\n    if (min_value !=\
    \ INT_MAX) {\n        ans.push_back(min_value);\n        ans.push_back(min_index);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  vector<long> v ;\n  long min = INT_MAX;\n  int i = 0;\n  int j = 0;\n\
    \  bool flag = false;\n  while(i < arr.size()){\n    if(arr[i] % 2 == 0){\n  \
    \    flag = true;\n      if(arr[i] < min){\n        min = arr[i];\n        j =\
    \ i;\n      }\n    }\n    i++;\n  }\n  if(flag){\n    v.push_back(min);\n    v.push_back(j);\n\
    \  }\n  return v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2ji9l869.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp2ji9l869.cpp:29:3: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   29 |   vector<long> v ;\n      |   ^~~~~~\n/tmp/tmp2ji9l869.cpp:29:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ji9l869.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ji9l869.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp2ji9l869.cpp:29:10:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |   vector<long>\
    \ v ;\n      |          ^~~~\n/tmp/tmp2ji9l869.cpp:45:5: error: \u2018v\u2019\
    \ was not declared in this scope\n   45 |     v.push_back(min);\n      |     ^\n\
    /tmp/tmp2ji9l869.cpp:48:10: error: \u2018v\u2019 was not declared in this scope\n\
    \   48 |   return v;\n      |          ^\n"
  stdout: ''
  timestamp: 1660117721
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    std::vector<long> res;\n    if(arr.size()==0)\n\
    \        return res;\n    long min_even_idx = -1;\n    long min_even_val = INT_MAX;\n\
    \    long min_idx = -1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]==0\
    \ && min_even_idx==-1){\n            min_even_idx = i;\n            min_even_val\
    \ = arr[i];\n            min_idx = i;\n        }\n        else if(arr[i]%2==0\
    \ && arr[i]<min_even_val){\n            min_even_idx = i;\n            min_even_val\
    \ = arr[i];\n            min_idx = i;\n        }\n        else if(arr[i]%2==0\
    \ && arr[i]==min_even_val && i<min_idx){\n            min_even_idx = i;\n    \
    \        min_even_val = arr[i];\n            min_idx = i;\n        }\n    }\n\
    \    if(min_even_idx==-1)\n        return res;\n    res.push_back(min_even_val);\n\
    \    res.push_back(min_even_idx);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    std::vector<long> ans;\n    if(arr.size()\
    \ == 0)\n        return ans;\n    long min = 10000000;\n    long index = 0;\n\
    \    for(int i = 0; i < arr.size(); i++)\n    {\n        if(arr[i] % 2 == 0 &&\
    \ arr[i] < min)\n        {\n            min = arr[i];\n            index = i;\n\
    \        }\n    }\n    if(min == 10000000)\n        return ans;\n    ans.push_back(min);\n\
    \    ans.push_back(index);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result(2);\n    int n = arr.size();\n    int min_even_index;\n\
    \    if(n == 0)\n        return result;\n    long min_even = INT_MAX;\n    for(int\
    \ i = 0; i < n; i++) {\n        if(arr[i] % 2 == 0) {\n            if(arr[i] <\
    \ min_even) {\n                min_even = arr[i];\n                min_even_index\
    \ = i;\n            }\n        }\n    }\n    if(min_even == INT_MAX)\n       \
    \ return result;\n    result[0] = min_even;\n    result[1] = min_even_index;\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpv3x6x1gm: /tmp/tmpv3x6x1gm.cpp:53: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    long smallest=INT_MAX;\n    std::vector<long>\
    \ output;\n    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=0 &&\
    \ (arr[i]&1)==0)\n        {\n            if(arr[i]<smallest)\n            {\n\
    \                smallest=arr[i];\n                output.clear();\n         \
    \       output.push_back(arr[i]);\n                output.push_back(i);\n    \
    \        }\n        }\n    }\n    return output;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpwwekk1sz: /tmp/tmpwwekk1sz.cpp:52: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t//initialize an empty vector\n\tstd::vector<long> emptyVec;\n\t//\
    \ if the array is empty, return the empty vector\n\tif (arr.empty()) {\n\t\treturn\
    \ emptyVec;\n\t}\n\t// find the size of the array\n\tint len = arr.size();\n\t\
    // initialize the smallest value as the first value in the array\n\tint smallest\
    \ = arr[0];\n\t// initialize the smallest index as 0\n\tint smallestIndex = 0;\n\
    \t// iterate through the array\n\tfor (int i = 0; i < len; i++) {\n\t\t// if the\
    \ current value is even\n\t\tif (arr[i] % 2 == 0) {\n\t\t\t// if the current value\
    \ is less than the smallest value\n\t\t\tif (arr[i] < smallest) {\n\t\t\t\t//\
    \ set the smallest value to the current value\n\t\t\t\tsmallest = arr[i];\n\t\t\
    \t\t// set the smallest index to the current index\n\t\t\t\tsmallestIndex = i;\n\
    \t\t\t}\n\t\t}\n\t}\n\t// if the smallest value is still the first value in the\
    \ array\n\tif (smallest == arr[0]) {\n\t\t// return the empty vector\n\t\treturn\
    \ emptyVec;\n\t}\n\t// return the vector containing the smallest value and the\
    \ smallest index\n\treturn { smallest, smallestIndex };\n}\nint main() {\n   \
    \ auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpy5chn4di: /tmp/tmpy5chn4di.cpp:65: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> result;\n\tif(arr.size() == 0)\n\t\treturn result;\n\
    \tlong min = (1<<31) - 1;\n\tint min_idx = 0;\n\tfor(int i = 0; i < arr.size();\
    \ i++) {\n\t\tif(arr[i]%2 == 0 && arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\t\
    min_idx = i;\n\t\t}\n\t}\n\tif(min == (1<<31) - 1) {\n\t\treturn result;\n\t}\n\
    \tresult.push_back(min);\n\tresult.push_back(min_idx);\n\treturn result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> retVal;\n    long smallestVal = -1;\n    long\
    \ index = -1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] ==\
    \ 0) {\n            if(index == -1) {\n                index = i;\n          \
    \  }\n            continue;\n        }\n        if(arr[i]%2 == 0) {\n        \
    \    if(smallestVal == -1) {\n                smallestVal = arr[i];\n        \
    \        index = i;\n            }\n            else if(arr[i] < smallestVal)\
    \ {\n                smallestVal = arr[i];\n                index = i;\n     \
    \       }\n        }\n    }\n    if(smallestVal == -1) {\n        return retVal;\n\
    \    }\n    retVal.push_back(smallestVal);\n    retVal.push_back(index);\n   \
    \ return retVal;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpvql8togh: /tmp/tmpvql8togh.cpp:62: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  int smallestValue=INT_MAX;\n  int smallestValueIndex;\n  for(int i=0;i<arr.size();i++){\n\
    \    if(arr[i]%2==0 && arr[i]<smallestValue){\n      smallestValue=arr[i];\n \
    \     smallestValueIndex=i;\n    }\n  }\n  std::vector<long> ret;\n  if(smallestValue==INT_MAX){\n\
    \    return ret;\n  }\n  ret.push_back(smallestValue);\n  ret.push_back(smallestValueIndex);\n\
    \  return ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> ret;\n\tlong min = 0x7fffffff;\n\tfor (size_t i\
    \ = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0 && arr[i] < min) {\n\t\t\
    \tmin = arr[i];\n\t\t\tret.clear();\n\t\t\tret.push_back(arr[i]);\n\t\t\tret.push_back(i);\n\
    \t\t}\n\t}\n\treturn ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117722
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    if(arr.size() == 0)\n        return\
    \ result;\n    // if(arr.size() == 1)\n    //     return arr;\n    long min =\
    \ INT_MAX;\n    long index = 0;\n    for(int i = 0; i < arr.size(); i++){\n  \
    \      if(arr[i]%2 == 0 && arr[i] < min){\n            min = arr[i];\n       \
    \     index = i;\n        }\n    }\n    result.push_back(min);\n    result.push_back(index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmph76hab5z: /tmp/tmph76hab5z.cpp:55: int main(): Assertion `candidate((std::vector<long>({7,
    9, 7, 1}))) == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117722
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    std::vector<long> evens;\n    std::vector<long>\
    \ evens_indices;\n    long val;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        val = arr[i];\n        if (val % 2 == 0) {\n            evens.push_back(val);\n\
    \            evens_indices.push_back(i);\n        }\n    }\n    if (evens.size()\
    \ == 0) {\n        return result;\n    }\n    val = *std::min_element(evens.begin(),\
    \ evens.end());\n    long val_index = -1;\n    for (long i = 0; i < evens.size();\
    \ i++) {\n        if (evens[i] == val) {\n            val_index = evens_indices[i];\n\
    \            break;\n        }\n    }\n    result.push_back(val);\n    result.push_back(val_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    long min = INT_MAX;\n    long index = -1;\n\
    \    for(long i = 0; i < arr.size(); i++){\n        if(arr[i] % 2 == 0 && arr[i]\
    \ < min){\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if(index == -1){\n        std::vector<long> vec;\n        return vec;\n \
    \   }\n    std::vector<long> res;\n    res.push_back(min);\n    res.push_back(index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    //your code here\n    int smallestEven=arr[0];\n    int smallestEvenIndex=0;\n\
    \    int hasEven=0;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]%2==0){\n\
    \            if(hasEven==0){\n                smallestEven=arr[i];\n         \
    \       smallestEvenIndex=i;\n                hasEven=1;\n            }\n    \
    \        else{\n                if(arr[i]<smallestEven){\n                   \
    \ smallestEven=arr[i];\n                    smallestEvenIndex=i;\n           \
    \     }\n            }\n        }\n    }\n    if(hasEven==0){\n        std::vector<long>\
    \ empty={};\n        return empty;\n    }\n    else{\n        std::vector<long>\
    \ result;\n        result.push_back(smallestEven);\n        result.push_back(smallestEvenIndex);\n\
    \        return result;\n    }\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() == 0) {\n    return {};\n  }\n  long min_even = LONG_MAX;\n\
    \  int idx = -1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2\
    \ == 0 && arr[i] < min_even) {\n      min_even = arr[i];\n      idx = i;\n   \
    \ }\n  }\n  if (idx == -1) {\n    return {};\n  }\n  return {min_even, idx};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    if(arr.size() == 0)\n        return\
    \ res;\n    long min_val = arr[0];\n    long min_index = 0;\n    bool flag = false;\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n  \
    \          if(!flag) {\n                min_val = arr[i];\n                min_index\
    \ = i;\n                flag = true;\n            }\n            else {\n    \
    \            if(arr[i] < min_val) {\n                    min_val = arr[i];\n \
    \                   min_index = i;\n                }\n            }\n       \
    \ }\n    }\n    if(flag) {\n        res.push_back(min_val);\n        res.push_back(min_index);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    if(arr.size() <= 0) return result;\n\
    \    long smallestEvenVal = INT_MAX;\n    for(long i = 0; i < arr.size(); i++)\
    \ {\n        if(arr[i] % 2 == 0 && arr[i] < smallestEvenVal) {\n            smallestEvenVal\
    \ = arr[i];\n        }\n    }\n    if(smallestEvenVal != INT_MAX) {\n        result.push_back(smallestEvenVal);\n\
    \        result.push_back(std::distance(arr.begin(), std::find(arr.begin(), arr.end(),\
    \ smallestEvenVal)));\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto itr = arr.begin();\n    std::vector<long> plucked_node;\n \
    \   while(itr != arr.end()) {\n        if (*itr % 2 == 0) {\n            plucked_node.push_back(*itr);\n\
    \            plucked_node.push_back(itr - arr.begin());\n            return plucked_node;\n\
    \        }\n        itr++;\n    }\n    return plucked_node;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpg92ppved: /tmp/tmpg92ppved.cpp:43: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    std::vector<long> min;\n    long\
    \ minVal = INT_MAX;\n    bool isMinValEven = false;\n    long idx = 0;\n    long\
    \ count = 0;\n    for (auto &item : arr) {\n        if (item % 2 == 0) {\n   \
    \         if (item < minVal) {\n                minVal = item;\n             \
    \   isMinValEven = true;\n                idx = count;\n            }\n      \
    \  }\n        count++;\n    }\n    if (isMinValEven) {\n        min.push_back(minVal);\n\
    \        min.push_back(idx);\n        return min;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long i, min=arr[0], min_idx=0;\n    for(i=0; i<arr.size(); i++)\
    \ {\n        if(arr[i]==0)\n            return {0,i};\n        if(arr[i]<min)\
    \ {\n            min = arr[i];\n            min_idx = i;\n        }\n    }\n \
    \   if(min%2==0)\n        return {min, min_idx};\n    return {};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp6j3hm3un: /tmp/tmp6j3hm3un.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117724
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    vector<long> res;\n    //your code here\n    long min=INT_MAX;\n\
    \    int min_index=-1;\n    int index=-1;\n    if(arr.size()==0)\n    {\n    \
    \    return res;\n    }\n    for(auto i:arr)\n    {\n        index++;\n      \
    \  if(i%2==0 && i<min)\n        {\n            min=i;\n            min_index=index;\n\
    \        }\n    }\n    if(min_index==-1)\n    {\n        return res;\n    }\n\
    \    res.push_back(min);\n    res.push_back(min_index);\n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg324pcv4.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpg324pcv4.cpp:29:5: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   29 |     vector<long> res;\n      |     ^~~~~~\n/tmp/tmpg324pcv4.cpp:29:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg324pcv4.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg324pcv4.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpg324pcv4.cpp:29:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     vector<long>\
    \ res;\n      |            ^~~~\n/tmp/tmpg324pcv4.cpp:36:16: error: \u2018res\u2019\
    \ was not declared in this scope\n   36 |         return res;\n      |       \
    \         ^~~\n/tmp/tmpg324pcv4.cpp:49:16: error: \u2018res\u2019 was not declared\
    \ in this scope\n   49 |         return res;\n      |                ^~~\n/tmp/tmpg324pcv4.cpp:51:5:\
    \ error: \u2018res\u2019 was not declared in this scope\n   51 |     res.push_back(min);\n\
    \      |     ^~~\n"
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size()==0) return {};\n    int min=INT_MAX;\n    for(int\
    \ i=0;i<arr.size();i++){\n        if(arr[i]%2==0 && arr[i]<min){\n           \
    \ min=arr[i];\n        }\n    }\n    if(min==INT_MAX) return {};\n    std::vector<long>\
    \ res(2);\n    res[0]=min;\n    res[1]=std::find(arr.begin(),arr.end(),min)-arr.begin();\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0) {\n\t\treturn {};\n\t}\n\tlong min_even_value\
    \ = INT_MAX;\n\tlong index = 0;\n\tfor (long i = 0; i < arr.size(); i++) {\n\t\
    \tif (arr[i] % 2 == 0 && arr[i] < min_even_value) {\n\t\t\tmin_even_value = arr[i];\n\
    \t\t\tindex = i;\n\t\t}\n\t}\n\tif (min_even_value == INT_MAX) {\n\t\treturn {};\n\
    \t}\n\treturn { min_even_value, index };\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  vector<long> result;\n  vector<long> index;\n\
    \  vector<long> even;\n  vector<long> odd;\n  vector<long>::iterator itr;\n  long\
    \ temp = -1;\n  long counter = 0;\n  long N = arr.size();\n  for(long i = 0; i\
    \ < N; i++){\n    if(arr[i] % 2 == 0){\n      even.push_back(arr[i]);\n      index.push_back(i);\n\
    \    }\n    else\n      odd.push_back(arr[i]);\n  }\n  if(even.size() == 0)\n\
    \    return result;\n  itr = min_element(even.begin(), even.end());\n  temp =\
    \ itr - even.begin();\n  temp = index[temp];\n  result.push_back(arr[temp]);\n\
    \  result.push_back(temp);\n  return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmps38mqmaw.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmps38mqmaw.cpp:30:3: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   30 |   vector<long> result;\n      |   ^~~~~~\n/tmp/tmps38mqmaw.cpp:30:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps38mqmaw.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps38mqmaw.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmps38mqmaw.cpp:30:10:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |   vector<long>\
    \ result;\n      |          ^~~~\n/tmp/tmps38mqmaw.cpp:31:10: error: expected\
    \ primary-expression before \u2018long\u2019\n   31 |   vector<long> index;\n\
    \      |          ^~~~\n/tmp/tmps38mqmaw.cpp:32:10: error: expected primary-expression\
    \ before \u2018long\u2019\n   32 |   vector<long> even;\n      |          ^~~~\n\
    /tmp/tmps38mqmaw.cpp:33:10: error: expected primary-expression before \u2018long\u2019\
    \n   33 |   vector<long> odd;\n      |          ^~~~\n/tmp/tmps38mqmaw.cpp:34:10:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |   vector<long>::iterator\
    \ itr;\n      |          ^~~~\n/tmp/tmps38mqmaw.cpp:40:7: error: \u2018even\u2019\
    \ was not declared in this scope\n   40 |       even.push_back(arr[i]);\n "
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int sz = arr.size();\n    if(sz == 0)\n        return {};\n    long\
    \ min = INT_MAX;\n    int index = 0;\n    for(int i = 0; i < sz; i++) {\n    \
    \    if(arr[i] % 2 == 0) {\n            if(arr[i] < min) {\n                min\
    \ = arr[i];\n                index = i;\n            }\n        }\n    }\n   \
    \ if(min == INT_MAX)\n        return {};\n    return {min, index};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int i;\n    if(arr.size()==0)\n        return arr;\n    if(arr.size()==1)\n\
    \    {\n        if(arr[0]%2==0)\n            return arr;\n        else{\n    \
    \        arr.clear();\n            return arr;\n        }\n    }\n    std::vector<long>\
    \ result;\n    long smallest_even = INT_MAX;\n    for(i=0;i<arr.size();i++)\n\
    \    {\n        if(arr[i]%2==0)\n        {\n            if(arr[i]<smallest_even)\n\
    \            {\n                smallest_even = arr[i];\n                result.clear();\n\
    \                result.push_back(smallest_even);\n                result.push_back(i);\n\
    \            }\n        }\n    }\n    if(result.size()==0)\n        return result;\n\
    \    else\n        return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size()==0) return arr;\n    int min;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0){\n            min=arr[i];\n            break;\n     \
    \   }\n    }\n    int minIndex=0;\n    for(int i=0;i<arr.size();i++){\n      \
    \  if(arr[i]%2==0){\n            if(arr[i]<min){\n                min=arr[i];\n\
    \                minIndex=i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result(2);\n    result[0]=min;\n    result[1]=minIndex;\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpfankshgp: /tmp/tmpfankshgp.cpp:54: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code goes here\n  if(arr.size()==0)\n  {\n    std::vector<long>\
    \ v;\n    return v;\n  }\n  if(arr.size()==1)\n  {\n    if(arr[0]%2==0)\n    {\n\
    \      std::vector<long> v;\n      v.push_back(arr[0]);\n      v.push_back(0);\n\
    \      return v;\n    }\n    else\n    {\n      std::vector<long> v;\n      return\
    \ v;\n    }\n  }\n  long min=arr[0];\n  long index=0;\n  long minIndex=0;\n  int\
    \ flag=0;\n  for(int i=0;i<arr.size();i++)\n  {\n    if(arr[i]%2==0)\n    {\n\
    \      flag=1;\n      if(arr[i]<min)\n      {\n        min=arr[i];\n        minIndex=i;\n\
    \      }\n    }\n  }\n  if(flag==0)\n  {\n    std::vector<long> v;\n    return\
    \ v;\n  }\n  std::vector<long> v;\n  v.push_back(min);\n  v.push_back(minIndex);\n\
    \  return v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpt3lm2d38: /tmp/tmpt3lm2d38.cpp:79: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  std::vector<long> result;\n  if(arr.size()==0)\n\
    \  {\n    return result;\n  }\n  long min=arr[0];\n  int i;\n  for(i=0;i<arr.size();i++)\n\
    \  {\n    if(arr[i]%2==0)\n    {\n      min=arr[i];\n      break;\n    }\n  }\n\
    \  if(i==arr.size())\n  {\n    return result;\n  }\n  int index=i;\n  for(int\
    \ i=0;i<arr.size();i++)\n  {\n    if(arr[i]%2==0)\n    {\n      if(arr[i]<min)\n\
    \      {\n        min=arr[i];\n        index=i;\n      }\n    }\n  }\n  result.push_back(min);\n\
    \  result.push_back(index);\n  return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() == 0) return std::vector<long>{};\n  long minSoFar\
    \ = INT_MAX;\n  int index = 0;\n  for (int i = 0; i < arr.size(); i++) {\n   \
    \ if (arr[i] % 2 == 0 && arr[i] < minSoFar) {\n      minSoFar = arr[i];\n    \
    \  index = i;\n    }\n  }\n  if (minSoFar == INT_MAX) return std::vector<long>{};\n\
    \  return std::vector<long>{minSoFar, index};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    if(arr.size() == 0)\n        return\
    \ result;\n    auto min = *std::min_element(arr.begin(), arr.end());\n    if(min\
    \ % 2 != 0)\n        return result;\n    long index = std::distance(arr.begin(),\
    \ std::find(arr.begin(), arr.end(), min));\n    result.push_back(min);\n    result.push_back(index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpwfuqxuzm: /tmp/tmpwfuqxuzm.cpp:43: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long min = INT_MAX;\n  long index = -1;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] < min && arr[i] % 2 == 0) {\n      min = arr[i];\n  \
    \    index = i;\n    }\n  }\n  std::vector<long> result;\n  if (index != -1) {\n\
    \    result.push_back(min);\n    result.push_back(index);\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res;\n  if (arr.size() == 0) {\n    return res;\n\
    \  }\n  long min = INT_MAX;\n  long min_i = INT_MAX;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min) {\n      min = arr[i];\n  \
    \    min_i = i;\n    }\n  }\n  if (min == INT_MAX) {\n    return res;\n  }\n \
    \ res.push_back(min);\n  res.push_back(min_i);\n  return res;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    if(arr.size() == 0)\n        return {};\n\
    \    long min_val = std::numeric_limits<long>::max();\n    long index = 0;\n \
    \   bool has_even = false;\n    for(long i = 0; i < arr.size(); i++)\n    {\n\
    \        if(arr[i]%2 == 0)\n        {\n            has_even = true;\n        \
    \    if(arr[i] < min_val)\n            {\n                min_val = arr[i];\n\
    \                index = i;\n            }\n        }\n    }\n    if(has_even)\n\
    \        return {min_val, index};\n    else\n        return {};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n   // Write your code here\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp5cges88s: /tmp/tmp5cges88s.cpp:33: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long min_even = INT_MAX;\n  long index = 0;\n  for (auto i = 0; i\
    \ < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min_even) {\n    \
    \  min_even = arr[i];\n      index = i;\n    }\n  }\n  std::vector<long> v;\n\
    \  if (min_even == INT_MAX)\n    return v;\n  v.push_back(min_even);\n  v.push_back(index);\n\
    \  return v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> result;\n\tstd::vector<long>::iterator it;\n\tlong\
    \ min = INT_MAX;\n\tlong index = -1;\n\tif(arr.size() == 0) {\n\t\treturn result;\n\
    \t}\n\tfor(long i = 0; i < arr.size(); i++) {\n\t\tif(arr[i] % 2 == 0 && arr[i]\
    \ < min) {\n\t\t\tmin = arr[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif(index != -1)\
    \ {\n\t\tresult.push_back(min);\n\t\tresult.push_back(index);\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> even;\n    std::vector<long> res;\n    for(long\
    \ i = 0; i < arr.size(); i++){\n        if(arr[i] % 2 == 0){\n            even.push_back(arr[i]);\n\
    \        }\n    }\n    if(even.size() == 0){\n        return res;\n    }\n   \
    \ long min = *std::min_element(even.begin(), even.end());\n    auto it = std::find(arr.begin(),\
    \ arr.end(), min);\n    res.push_back(min);\n    res.push_back(it - arr.begin());\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() <= 0) {\n\t\treturn {};\n\t}\n\tlong smallest = LONG_MAX;\n\
    \tlong smallIndex = 0;\n\tfor (long i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ % 2 == 0 && arr[i] < smallest) {\n\t\t\tsmallest = arr[i];\n\t\t\tsmallIndex\
    \ = i;\n\t\t}\n\t}\n\tif (smallest == LONG_MAX) {\n\t\treturn {};\n\t}\n\treturn\
    \ { smallest, smallIndex };\n}\nint main() {\n    auto candidate = pluck;\n  \
    \  assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    std::vector<long> answer(2);\n    if(arr.size()==0)\n\
    \        return answer;\n    long min_value = *min_element(arr.begin(), arr.end());\n\
    \    std::vector<long>::iterator it;\n    if(min_value%2==0)\n    {\n        answer[0]\
    \ = min_value;\n        it = std::find(arr.begin(), arr.end(), min_value);\n \
    \       answer[1] = std::distance(arr.begin(), it);\n    }\n    else\n    {\n\
    \        answer[0] = min_value+1;\n        for(long i=0; i<arr.size(); i++)\n\
    \        {\n            if(arr[i]%2 == 0 && arr[i]>=min_value+1)\n           \
    \ {\n                answer[0] = arr[i];\n                answer[1] = i;\n   \
    \             break;\n            }\n        }\n    }\n    return answer;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1m42bkqe: /tmp/tmp1m42bkqe.cpp:60: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code goes here\n  std::vector<long> result;\n  if(arr.size()\
    \ <= 0)\n    return result;\n  long min = std::numeric_limits<long>::max();\n\
    \  long small = min;\n  int index = -1;\n  for(int i = 0; i < arr.size(); i++)\n\
    \  {\n    if(arr[i] % 2 == 0)\n    {\n      if(arr[i] < min)\n      {\n      \
    \  min = arr[i];\n        index = i;\n      }\n    }\n  }\n  if(min == small)\n\
    \    return result;\n  result.push_back(min);\n  result.push_back(index);\n  return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\tint n = arr.size();\n\t// First find index of\
    \ the smallest even value.\n\t// Stores smallest even value found so far\n\tint\
    \ min = INT_MAX;\n\t// Stores index of the smallest even value found so far\n\t\
    int index = -1;\n\t// Stores index of the smallest value found so far\n\tint min_index\
    \ = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\t// If current element is even and\
    \ smaller than min,\n\t\t// then update min and min_index\n\t\tif (arr[i] % 2\
    \ == 0 && arr[i] <= min) {\n\t\t\tmin = arr[i];\n\t\t\tindex = i;\n\t\t}\n\t\t\
    // We have to always update min_index.\n\t\tif (arr[i] <= arr[min_index]) {\n\t\
    \t\tmin_index = i;\n\t\t}\n\t}\n\tstd::vector<long> ans;\n\tif (index != -1) {\n\
    \t\tans.push_back(min);\n\t\tans.push_back(index);\n\t}\n\telse {\n\t\tans.push_back(arr[min_index]);\n\
    \t\tans.push_back(min_index);\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int arr_len = arr.size();\n    if (arr_len < 1)\n        return\
    \ {};\n    std::vector<long> ans;\n    long min_even_value = INT64_MAX;\n    int\
    \ min_even_value_index = -1;\n    for (int i = 0; i < arr_len; i++) {\n      \
    \  if (arr[i] % 2 == 0) {\n            if (arr[i] < min_even_value) {\n      \
    \          min_even_value = arr[i];\n                min_even_value_index = i;\n\
    \            }\n        }\n    }\n    if (min_even_value_index == -1)\n      \
    \  return {};\n    ans.push_back(min_even_value);\n    ans.push_back(min_even_value_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    std::vector<long> result;\n    // int min_even\
    \ = INT_MAX;\n    int min_even = INT_MAX;\n    int index = -1;\n    for(int i\
    \ = 0; i < arr.size(); i++){\n        if(arr[i] % 2 == 0 && arr[i] < min_even){\n\
    \            min_even = arr[i];\n            index = i;\n        }\n    }\n  \
    \  if(index != -1){\n        result.push_back(min_even);\n        result.push_back(index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117724
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> v;\n  if(arr.size()==0) return v;\n  long min=arr[0];\n\
    \  long idx=0;\n  for(int i=0;i<arr.size();i++){\n    if(arr[i]%2==0){\n     \
    \ if(arr[i]<min){\n        min=arr[i];\n        idx=i;\n      }\n    }\n  }\n\
    \  if(min%2==0){\n    v.push_back(min);\n    v.push_back(idx);\n  }\n  return\
    \ v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpesbeoxta: /tmp/tmpesbeoxta.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tvector<long> result;\n\tlong smalest_value = LONG_MAX;\n\tlong index\
    \ = -1;\n\tfor (long i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] < smalest_value\
    \ && arr[i] % 2 == 0) {\n\t\t\tsmalest_value = arr[i];\n\t\t\tindex = i;\n\t\t\
    }\n\t}\n\tif (index == -1)\n\t\treturn result;\n\tresult.push_back(smalest_value);\n\
    \tresult.push_back(index);\n\treturn result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpxaddeevp.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpxaddeevp.cpp:29:2: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   29 |  vector<long> result;\n      |  ^~~~~~\n/tmp/tmpxaddeevp.cpp:29:2:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxaddeevp.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxaddeevp.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpxaddeevp.cpp:29:9:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |  vector<long>\
    \ result;\n      |         ^~~~\n/tmp/tmpxaddeevp.cpp:39:10: error: \u2018result\u2019\
    \ was not declared in this scope\n   39 |   return result;\n      |          ^~~~~~\n\
    /tmp/tmpxaddeevp.cpp:40:2: error: \u2018result\u2019 was not declared in this\
    \ scope\n   40 |  result.push_back(smalest_value);\n      |  ^~~~~~\n"
  stdout: ''
  timestamp: 1660117724
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    long small = (arr[0]%2 == 0) ? arr[0]\
    \ : 2e9;\n    int index = -1;\n    for(int i = 0; i < arr.size(); i++) {\n   \
    \     if(arr[i]%2 == 0) {\n            if(arr[i] < small) {\n                small\
    \ = arr[i];\n                index = i;\n            }\n        }\n    }\n   \
    \ if(index >= 0) {\n        ans.push_back(small);\n        ans.push_back(index);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0)\n        return {};\n    long min = -1;\n  \
    \  long index = -1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ % 2 == 0 && (min == -1 || arr[i] < min)) {\n            min = arr[i];\n    \
    \        index = i;\n        }\n    }\n    if(min == -1)\n        return {};\n\
    \    return {min, index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code goes here\n\tif (arr.size() == 0)\n\t\treturn {};\n\t\
    long min = INT_MAX;\n\tlong index = 0;\n\tfor (long i = 0; i < arr.size(); i++)\
    \ {\n\t\tif (arr[i] % 2 == 0 && arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\tindex\
    \ = i;\n\t\t}\n\t}\n\tif (min == INT_MAX)\n\t\treturn {};\n\treturn { min, index\
    \ };\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code goes here\n  \n  std::vector<long> output;\n  if(arr.size()==0)\n\
    \    return output;\n  std::vector<long>::iterator it = std::find_if(arr.begin(),\
    \ arr.end(), [](int i){return (i%2==0);});\n  if(it == arr.end())\n    return\
    \ output;\n  long min = *it;\n  long minIndex = std::distance(arr.begin(), it);\n\
    \  while(it != arr.end())\n  {\n    if(*it%2==0 && *it<min)\n    {\n      min\
    \ = *it;\n      minIndex = std::distance(arr.begin(), it);\n    }\n    it = std::find_if(it+1,\
    \ arr.end(), [](int i){return (i%2==0);});\n  }\n  output.push_back(min);\n  output.push_back(minIndex);\n\
    \  return output;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here!\n  long minEven = 10001;\n  long minEvenIndex =\
    \ -1;\n  for(unsigned long i = 0; i < arr.size(); i++){\n      if(arr[i] % 2 ==\
    \ 0 && arr[i] < minEven){\n          minEven = arr[i];\n          minEvenIndex\
    \ = i;\n      }\n  }\n  if(minEven == 10001){\n      std::vector<long> res;\n\
    \      return res;\n  }\n  std::vector<long> res = {minEven, minEvenIndex};\n\
    \  return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> evens;\n    std::vector<long> result;\n    long\
    \ evenCount = 0;\n    long minEven = 0;\n    long minIndex = 0;\n    long i =\
    \ 0;\n    while (i < arr.size()) {\n        if (arr[i] % 2 == 0) {\n         \
    \   evens.push_back(arr[i]);\n            evenCount++;\n        }\n        i++;\n\
    \    }\n    if (evenCount == 0) {\n        return result;\n    }\n    else {\n\
    \        minEven = evens[0];\n        for (i = 0; i < evens.size(); i++) {\n \
    \           if (evens[i] < minEven) {\n                minEven = evens[i];\n \
    \               minIndex = i;\n            }\n        }\n        result.push_back(minEven);\n\
    \        result.push_back(minIndex);\n        return result;\n    }\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmptvsqaba5: /tmp/tmptvsqaba5.cpp:61: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long m=arr.size();\n    long i,min_even_no,min_even_pos;\n    if(m==0)\n\
    \    {\n        std::vector<long> res;\n        return res;\n    }\n    min_even_no=INT_MAX;\n\
    \    min_even_pos=INT_MAX;\n    for(i=0;i<m;i++)\n    {\n        if(arr[i]%2==0\
    \ && arr[i]<min_even_no)\n        {\n            min_even_no=arr[i];\n       \
    \     min_even_pos=i;\n        }\n    }\n    if(min_even_no==INT_MAX)\n    {\n\
    \        std::vector<long> res;\n        return res;\n    }\n    std::vector<long>\
    \ res={min_even_no,min_even_pos};\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> result;\n  if (arr.size() == 0) {\n    return result;\n\
    \  }\n  long lowestIndex = -1;\n  long lowestValue = -1;\n  for (int i = 0; i\
    \ < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      if (lowestIndex == -1\
    \ || arr[i] < lowestValue) {\n        lowestIndex = i;\n        lowestValue =\
    \ arr[i];\n      }\n    }\n  }\n  if (lowestIndex != -1) {\n    result.push_back(lowestValue);\n\
    \    result.push_back(lowestIndex);\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // find the smallest even value\n    long smallest_value;\n    for\
    \ (long v : arr) {\n        if (v % 2 == 0) {\n            smallest_value = v;\n\
    \            break;\n        }\n    }\n    // record the index of the smallest\
    \ even value\n    long smallest_index;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] == smallest_value) {\n            smallest_index = i;\n\
    \            break;\n        }\n    }\n    // update smallest_value and smallest_index\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (arr[i] < smallest_value) {\n                smallest_value =\
    \ arr[i];\n                smallest_index = i;\n            }\n        }\n   \
    \ }\n    std::vector<long> result = {smallest_value, smallest_index};\n    return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp9bdufuwa: /tmp/tmp9bdufuwa.cpp:61: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    std::vector<long> ans(2);\n    ans[0] =\
    \ INT_MAX;\n    ans[1] = -1;\n    if(n==0) return ans;\n    for(int i=0;i<n;i++){\n\
    \        if(arr[i]%2==0 && arr[i]<ans[0]){\n            ans[0] = arr[i];\n   \
    \         ans[1] = i;\n        }\n    }\n    if(ans[0]==INT_MAX){\n        ans[0]\
    \ = 0;\n        ans[1] = 0;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp41d34_xi: /tmp/tmp41d34_xi.cpp:50: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0) {\n\t\treturn {};\n\t}\n\tstd::vector<long> ans;\n\
    \tlong min = LONG_MAX;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ % 2 == 0 && arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\tans.clear();\n\t\t\t\
    ans.push_back(arr[i]);\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\tif (ans.size()\
    \ == 0) {\n\t\treturn {};\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117725
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\tlong val = 100000000, index;\n\tstd::vector<long>\
    \ result;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0 &&\
    \ arr[i] < val) {\n\t\t\tval = arr[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (val\
    \ == 100000000) {\n\t\treturn result;\n\t}\n\tresult.push_back(val);\n\tresult.push_back(index);\n\
    \treturn result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117726
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\tstd::vector<long> temp(2);\n\ttemp[0] = -1;\n\
    \ttemp[1] = -1;\n\tif (arr.size() < 1) {\n\t\treturn temp;\n\t}\n\telse {\n\t\t\
    long minEven = 10001;\n\t\tint minIndex = 0;\n\t\tint index = 0;\n\t\tfor (long\
    \ i : arr) {\n\t\t\tif (i % 2 == 0 && i < minEven) {\n\t\t\t\tminEven = i;\n\t\
    \t\t\tminIndex = index;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tif (minEven == 10001)\
    \ {\n\t\t\treturn temp;\n\t\t}\n\t\telse {\n\t\t\ttemp[0] = minEven;\n\t\t\ttemp[1]\
    \ = minIndex;\n\t\t\treturn temp;\n\t\t}\n\t}\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpmzja3gnf: /tmp/tmpmzja3gnf.cpp:61: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117726
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> ret;\n  int min_val = INT_MAX;\n  int min_ind =\
    \ -1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i]\
    \ < min_val) {\n      min_val = arr[i];\n      min_ind = i;\n    }\n  }\n  if\
    \ (min_ind == -1) {\n    return ret;\n  }\n  ret.push_back(min_val);\n  ret.push_back(min_ind);\n\
    \  return ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117726
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long minIndex= -1;\n  long minValue = -1;\n  for(int i=0; i<arr.size();\
    \ i++) {\n    if(arr[i]%2==0) {\n      if(minIndex==-1) {\n        minIndex =\
    \ i;\n        minValue = arr[i];\n      } else {\n        if(arr[i]<minValue)\
    \ {\n          minIndex = i;\n          minValue = arr[i];\n        }\n      }\n\
    \    }\n  }\n  std::vector<long> ans;\n  if(minIndex==-1) return ans;\n  ans.push_back(minValue);\n\
    \  ans.push_back(minIndex);\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117726
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res(2);\n  long minEven = 0, minEvenIndex = 0;\n\
    \  for (long i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n     \
    \ if (minEven == 0 || arr[i] < minEven) {\n        minEven = arr[i];\n       \
    \ minEvenIndex = i;\n      }\n    }\n  }\n  if (minEven == 0) {\n    return res;\n\
    \  }\n  res[0] = minEven;\n  res[1] = minEvenIndex;\n  return res;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpwaqywe4i: /tmp/tmpwaqywe4i.cpp:50: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here...\n    if(arr.size() == 0) return {};\n    int\
    \ min_even = -1;\n    int min_idx = 0;\n    for(int i = 0; i < arr.size(); i++){\n\
    \        if(arr[i] % 2 == 0 && (min_even == -1 || arr[i] < min_even)){\n     \
    \       min_even = arr[i];\n            min_idx = i;\n        }\n    }\n    if(min_even\
    \ == -1) return {};\n    return {min_even, min_idx};\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117726
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> ret = {};\n\tlong size = arr.size();\n\tif (size\
    \ > 0) {\n\t\tlong even_idx = -1;\n\t\tlong i = 0;\n\t\twhile (i < size) {\n\t\
    \t\tif (arr[i] % 2 == 0) {\n\t\t\t\teven_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\
    \t\ti++;\n\t\t}\n\t\tif (even_idx != -1) {\n\t\t\tfor (i = even_idx + 1; i < size;\
    \ i++) {\n\t\t\t\tif (arr[i] % 2 == 0 && arr[i] < arr[even_idx]) {\n\t\t\t\t\t\
    even_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.push_back(arr[even_idx]);\n\t\t\t\
    ret.push_back(even_idx);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117726
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    //cout<<\"size of array: \"<<sizeof(arr)/sizeof(arr[0])<<endl;\n\
    \    int length = arr.size();\n    cout<<\"length of array: \"<<length<<endl;\n\
    \    //bool flag = false;\n    std::vector<long> result;\n    long min = INT_MAX;\n\
    \    int index = -1;\n    for(int i=0; i<length; i++){\n        if(arr[i]%2 ==\
    \ 0 && arr[i]<min){\n            min = arr[i];\n            index = i;\n     \
    \       //flag = true;\n        }\n    }\n    if(index == -1){\n        return\
    \ result;\n    }\n    result.push_back(min);\n    result.push_back(index);\n \
    \   return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbp39qs1q.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpbp39qs1q.cpp:31:5: error: \u2018cout\u2019 was not declared\
    \ in this scope; did you mean \u2018std::cout\u2019?\n   31 |     cout<<\"length\
    \ of array: \"<<length<<endl;\n      |     ^~~~\n      |     std::cout\nIn file\
    \ included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:75,\n      \
    \           from /tmp/tmpbp39qs1q.cpp:2:\n/usr/include/c++/9/iostream:61:18: note:\
    \ \u2018std::cout\u2019 declared here\n   61 |   extern ostream cout;  /// Linked\
    \ to standard output\n      |                  ^~~~\n/tmp/tmpbp39qs1q.cpp:31:40:\
    \ error: \u2018endl\u2019 was not declared in this scope; did you mean \u2018\
    std::endl\u2019?\n   31 |     cout<<\"length of array: \"<<length<<endl;\n   \
    \   |                                        ^~~~\n      |                   \
    \                     std::endl\nIn file included from /usr/include/c++/9/istream:39,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpbp39qs1q.cpp:2:\n/usr/include/c++/9/ostream:599:5: note: \u2018std::endl\u2019\
    \ declared here\n  599 |     endl(basic_ostream<_CharT, _Traits>& __os)\n    \
    \  |     ^~~~\n"
  stdout: ''
  timestamp: 1660117726
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v;\n    if(arr.size() <= 0){\n        return v;\n\
    \    }\n    long smallest = INT_MAX;\n    int index = -1;\n    for(int i = 0;\
    \ i < arr.size(); i++){\n        if(arr[i] % 2 == 0 && arr[i] < smallest){\n \
    \           smallest = arr[i];\n            index = i;\n        }\n    }\n   \
    \ if(index == -1){\n        return v;\n    }\n    v.push_back(smallest);\n   \
    \ v.push_back(index);\n    return v;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> result;\n\tstd::map<long,long> memo;\n\tlong minimum\
    \ = LONG_MAX;\n\tfor(auto i:arr){\n\t\tif(i%2==0){\n\t\t\tif(i<minimum){\n\t\t\
    \t\tminimum = i;\n\t\t\t}\n\t\t\tmemo[i]++;\n\t\t}\n\t}\n\tif(minimum!=LONG_MAX){\n\
    \t\tfor(long i=0;i<arr.size();i++){\n\t\t\tif(arr[i]==minimum && memo[minimum]>0){\n\
    \t\t\t\tresult.push_back(minimum);\n\t\t\t\tresult.push_back(i);\n\t\t\t\tmemo[minimum]--;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res;\n  if (arr.size() == 0) {\n    return res;\n\
    \  }\n  if (arr.size() == 1) {\n    if (arr[0] % 2 == 0) {\n      res.push_back(arr[0]);\n\
    \      res.push_back(0);\n    }\n    return res;\n  }\n  long min = arr[0];\n\
    \  long min_index = 0;\n  for (long i = 0; i < arr.size(); i++) {\n    if (arr[i]\
    \ % 2 == 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        min_index\
    \ = i;\n      }\n    }\n  }\n  if (min != arr[0]) {\n    res.push_back(min);\n\
    \    res.push_back(min_index);\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpdbqul9k8: /tmp/tmpdbqul9k8.cpp:59: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long minEven = arr[0];\n    int index = 0;\n    bool found = false;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            found = true;\n            if (arr[i] < minEven) {\n            \
    \    minEven = arr[i];\n                index = i;\n            }\n        }\n\
    \    }\n    if (found)\n        return {minEven, index};\n    else\n        return\
    \ {};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpvlbn2npi: /tmp/tmpvlbn2npi.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> output{};\n  int min_even = INT_MAX;\n  bool contains_even\
    \ = false;\n  for (auto i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0)\
    \ {\n      contains_even = true;\n      if (arr[i] < min_even) {\n        min_even\
    \ = arr[i];\n        output.clear();\n        output.push_back(min_even);\n  \
    \      output.push_back(i);\n      }\n    }\n  }\n  if (!contains_even) {\n  \
    \  output.clear();\n  }\n  return output;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v2;\n    long min = -1;\n    long minIndex = -1;\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && (min\
    \ == -1 || arr[i] < min)) {\n            min = arr[i];\n            minIndex =\
    \ i;\n        }\n    }\n    if(minIndex != -1) {\n        v2.push_back(min);\n\
    \        v2.push_back(minIndex);\n    }\n    return v2;\n}\nint main() {\n   \
    \ auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    if(arr.size()==0)\n        return\
    \ result;\n    std::vector<long> v;\n    for(long i=0;i<arr.size();i++)\n    {\n\
    \        if(arr[i]%2==0)\n            v.push_back(arr[i]);\n    }\n    if(v.size()==0)\n\
    \        return result;\n    long index=0;\n    long min=INT_MAX;\n    for(long\
    \ i=0;i<v.size();i++)\n    {\n        if(v[i]<min)\n        {\n            min=v[i];\n\
    \            index=i;\n        }\n    }\n    result.push_back(min);\n    result.push_back(index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpnk7oyw64: /tmp/tmpnk7oyw64.cpp:57: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() == 0) {\n    return {};\n  }\n\n  std::vector<long>\
    \ plucked(2);\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 ==\
    \ 0) {\n      if (plucked[0] == 0) {\n        plucked[0] = arr[i];\n        plucked[1]\
    \ = i;\n      } else if (arr[i] < plucked[0]) {\n        plucked[0] = arr[i];\n\
    \        plucked[1] = i;\n      }\n    }\n  }\n\n  if (plucked[0] == 0) {\n  \
    \  return {};\n  }\n\n  return plucked;\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp580j6e1r: /tmp/tmp580j6e1r.cpp:57: int main(): Assertion `candidate((std::vector<long>({5,
    0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117727
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code goes here\n  vector<long> res;\n  vector<long>::iterator\
    \ it;\n  long min = INT_MAX;\n  long i = 0;\n  for(it = arr.begin(); it != arr.end();\
    \ it++, i++)\n  {\n      if((*it) % 2 == 0 && (*it) < min)\n      {\n        \
    \  min = (*it);\n          res.clear();\n          res.push_back(*it);\n     \
    \     res.push_back(i);\n      }\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_93sbg8v.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_93sbg8v.cpp:30:3: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   30 |   vector<long> res;\n      |   ^~~~~~\n/tmp/tmp_93sbg8v.cpp:30:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_93sbg8v.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_93sbg8v.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp_93sbg8v.cpp:30:10:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |   vector<long>\
    \ res;\n      |          ^~~~\n/tmp/tmp_93sbg8v.cpp:31:10: error: expected primary-expression\
    \ before \u2018long\u2019\n   31 |   vector<long>::iterator it;\n      |     \
    \     ^~~~\n/tmp/tmp_93sbg8v.cpp:34:7: error: \u2018it\u2019 was not declared\
    \ in this scope; did you mean \u2018i\u2019?\n   34 |   for(it = arr.begin();\
    \ it != arr.end(); it++, i++)\n      |       ^~\n      |       i\n/tmp/tmp_93sbg8v.cpp:39:11:\
    \ error: \u2018res\u2019 was not declared in this scope\n   39 |           res.clear();\n\
    \      |           ^~~\n/tmp/tmp_93sbg8v.cpp:44:10: error: \u2018res\u2019 was\
    \ not declared in this scope\n   44 |   return res;\n      |          ^~~\n"
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long s = INT_MAX;\n  long position = INT_MAX;\n  for (long i = 0;\
    \ i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < s) {\n      s =\
    \ arr[i];\n      position = i;\n    }\n  }\n  std::vector<long> v = {};\n  if\
    \ (s != INT_MAX) {\n    v.push_back(s);\n    v.push_back(position);\n  }\n  return\
    \ v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code here\n\tstd::vector<long> output{};\n\tstd::set<long>\
    \ evens{};\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0)\
    \ {\n\t\t\tevens.insert(arr[i]);\n\t\t}\n\t}\n\tif (evens.size() == 0) {\n\t\t\
    return output;\n\t}\n\tlong first = *evens.begin();\n\tfor (int i = 0; i < arr.size();\
    \ i++) {\n\t\tif (arr[i] == first) {\n\t\t\toutput.push_back(first);\n\t\t\toutput.push_back(i);\n\
    \t\t\treturn output;\n\t\t}\n\t}\n\treturn output;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    int min_even = INT_MAX;\n    int min_even_idx\
    \ = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_even_idx\
    \ = i;\n        }\n    }\n    if (min_even_idx != -1) {\n        res.push_back(min_even);\n\
    \        res.push_back(min_even_idx);\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int len = arr.size();\n    long min_value=LONG_MAX;\n    long min_index=LONG_MAX;\n\
    \    bool flag=false;\n    for(int i=0;i<len;i++){\n        if(arr[i]%2==0 &&\
    \ arr[i]<min_value){\n            min_value=arr[i];\n            min_index=i;\n\
    \            flag=true;\n        }\n    }\n    if(flag)\n        return {min_value,min_index};\n\
    \    else\n        return {};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v;\n    int size = arr.size();\n    long smallest\
    \ = INT_MAX;\n    int index = -1;\n    int i = 0;\n    while(i < size) {\n   \
    \     if(arr[i] % 2 == 0 && arr[i] < smallest) {\n            smallest = arr[i];\n\
    \            index = i;\n        }\n        i++;\n    }\n    if(index != -1) {\n\
    \        v.push_back(smallest);\n        v.push_back(index);\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // use a intialize vector to store the result\n    std::vector<long>\
    \ result;\n    // initial the index of the smallest even value,\n    // and the\
    \ value itself.\n    long index = -1;\n    long value = -1;\n    // loop the array\
    \ to find the smallest even value\n    for (int i = 0; i < arr.size(); i++) {\n\
    \        // if it is even\n        if (arr[i] % 2 == 0) {\n            // compare\
    \ it with the value we got so far.\n            if (arr[i] < value || value ==\
    \ -1) {\n                // if it is smaller or there is no even value so far\n\
    \                // update the value and the index\n                value = arr[i];\n\
    \                index = i;\n            }\n        }\n    }\n    // if there\
    \ is even value\n    if (value != -1) {\n        // push both the value and the\
    \ index to the result\n        result.push_back(value);\n        result.push_back(index);\n\
    \    }\n    // return the result\n    return result;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code goes here\n  std::vector<long> res{};\n  if(arr.size()\
    \ == 0)\n  {\n    return res;\n  }\n  std::sort(arr.begin(), arr.end());\n  std::cout\
    \ << \"test\" << std::endl;\n  //std::sort(arr.begin(), arr.end());\n  // std::cout\
    \ << arr.size() << std::endl;\n  long smallEvenIndex = -1;\n  for(long i = 0;\
    \ i < arr.size(); i++)\n  {\n    if(arr[i] % 2 == 0)\n    {\n      smallEvenIndex\
    \ = i;\n      break;\n    }\n  }\n  if(smallEvenIndex == -1)\n  {\n    return\
    \ res;\n  }\n  res.push_back(arr[smallEvenIndex]);\n  res.push_back(smallEvenIndex);\n\
    \  return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp8ue0jiop: /tmp/tmp8ue0jiop.cpp:58: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: 'test

    '
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    int min_index = INT_MAX;\n    long min_val\
    \ = LONG_MAX;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] % 2 == 0 &&\
    \ arr[i] < min_val) {\n            min_val = arr[i];\n            min_index =\
    \ i;\n        }\n    }\n    if(min_index == INT_MAX) {\n        return {};\n \
    \   }\n    return {min_val, min_index};\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> v;\n  long min = INT_MAX;\n  int idx = -1;\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min)\
    \ {\n      min = arr[i];\n      idx = i;\n    }\n  }\n  if (idx == -1)\n    return\
    \ v;\n  v.push_back(min);\n  v.push_back(idx);\n  return v;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // your code here\n  return {};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmppoaub6mb: /tmp/tmppoaub6mb.cpp:34: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> result;\n\tlong min = INT_MAX;\n\tlong minIndex\
    \ = -1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0 &&\
    \ arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\tminIndex = i;\n\t\t}\n\t}\n\tif\
    \ (minIndex >= 0) {\n\t\tresult.push_back(min);\n\t\tresult.push_back(minIndex);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> plucked(2);\n    long index, minimum = 10001;\n\
    \    bool noEvens = true;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            noEvens = false;\n            if (arr[i]\
    \ < minimum) {\n                minimum = arr[i];\n                index = i;\n\
    \            }\n        }\n    }\n    if (noEvens) {\n        return plucked;\n\
    \    }\n    plucked[0] = minimum;\n    plucked[1] = index;\n    return plucked;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp8kj89dmy: /tmp/tmp8kj89dmy.cpp:52: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// Your code here\n\n\tint size = arr.size();\n\tstd::vector<long>\
    \ result;\n\t//if (size == 0) {\n\t//\tresult.push_back(0);\n\t//\tresult.push_back(0);\n\
    \t//\treturn result;\n\t//}\n\t//long min = arr[0];\n\t//int minIndex = 0;\n\t\
    //for (int i = 0; i < size; i++) {\n\t//\tif (arr[i] < min && arr[i] % 2 == 0)\
    \ {\n\t//\t\tmin = arr[i];\n\t//\t\tminIndex = i;\n\t//\t}\n\t//}\n\t//\n\t//if\
    \ (min % 2 == 0) {\n\t//\tresult.push_back(min);\n\t//\tresult.push_back(minIndex);\n\
    \t//}\n\t//else {\n\t//\tresult.push_back(0);\n\t//\tresult.push_back(0);\n\t\
    //}\n\t//// Your code here\n\t//return result;\n\n\t// The following is not accepted\
    \ by the online test!!!\n\t// WTF!!!!!!\n\t// Wrong answer:\n\t// Input:\n\t//\
    \ [12,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18,6,18\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpoc7fzb_k: /tmp/tmpoc7fzb_k.cpp:66: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0)\n\t\treturn arr;\n\tint ind = 0;\n\twhile (arr[ind]\
    \ % 2 != 0) {\n\t\tind++;\n\t\tif (ind == arr.size())\n\t\t\treturn {};\n\t}\n\
    \tlong min = arr[ind];\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ % 2 == 0 && arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\tind = i;\n\t\t}\n\t\
    }\n\treturn {min, ind};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    int mini = INT_MAX;\n    int flag =\
    \ 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n\
    \            if(arr[i] < mini) {\n                mini = arr[i];\n           \
    \     res.clear();\n                res.push_back(mini);\n                res.push_back(i);\n\
    \                flag = 1;\n            }\n        }\n    }\n    if(flag == 0)\n\
    \        return res;\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // Good luck!\n  std::vector<long> res;\n  int ctr = 0;\n  long ans\
    \ = -1;\n  int index = -1;\n  for(int i = 0; i < arr.size(); i++) {\n    if(arr[i]\
    \ % 2 == 0) {\n      ctr++;\n      if(ctr == 1) {\n        ans = arr[i];\n   \
    \     index = i;\n      }\n      else {\n        if(arr[i] < ans) {\n        \
    \  ans = arr[i];\n          index = i;\n        }\n      }\n    }\n  }\n  if(ctr\
    \ != 0) {\n    res.push_back(ans);\n    res.push_back(index);\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0) return {};\n    int n = arr.size();\n    int\
    \ i;\n    int min_even = INT_MAX;\n    int idx = -1;\n    for(i = 0; i < n; i++)\
    \ {\n        if(arr[i]%2 == 0 && arr[i] < min_even) {\n            min_even =\
    \ arr[i];\n            idx = i;\n        }\n    }\n    if(idx == -1) return {};\n\
    \    else return {min_even, idx};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even=arr[0];\n    long smallest_index=0;\n    long\
    \ ival=0;\n    std::vector<long> myvector;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0 && arr[i]<smallest_even){\n            smallest_even=arr[i];\n\
    \            smallest_index=i;\n        }\n    }\n    myvector.push_back(smallest_even);\n\
    \    myvector.push_back(smallest_index);\n    return myvector;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpi6nfij1h: /tmp/tmpi6nfij1h.cpp:46: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> v;\n  if(arr.size() == 0) return v;\n  long min\
    \ = 0;\n  for(int i = 0; i < arr.size(); i++) {\n    if(arr[i] < min && arr[i]\
    \ % 2 == 0) {\n      min = arr[i];\n      v.push_back(arr[i]);\n      v.push_back(i);\n\
    \    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpuagtfr54: /tmp/tmpuagtfr54.cpp:43: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size()==0)\n        return {};\n    std::vector<long> res;\n\
    \    std::vector<long> val, index;\n    for(int i=0;i<arr.size();i++){\n     \
    \   if(arr[i]%2==0){\n            val.push_back(arr[i]);\n            index.push_back(i);\n\
    \        }\n    }\n    if(val.size()==0)\n        return {};\n    long min = val[0];\n\
    \    long min_index = index[0];\n    for(int i=1;i<val.size();i++){\n        if(val[i]<min){\n\
    \            min = val[i];\n            min_index = index[i];\n        }\n   \
    \ }\n    res.push_back(min);\n    res.push_back(min_index);\n    return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    int min_even = INT_MAX;\n    std::vector<long>\
    \ res;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] % 2 == 0) {\n    \
    \        if(arr[i] < min_even) {\n                min_even = arr[i];\n       \
    \         res.clear();\n                res.push_back(arr[i]);\n             \
    \   res.push_back(i);\n            }\n        }\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0)\n\t\treturn {};\n\tstd::vector<long> res;\n\t\
    std::vector<long> temp;\n\tfor (long i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ % 2 == 0)\n\t\t\ttemp.push_back(arr[i]);\n\t}\n\tif (temp.size() == 0)\n\t\t\
    return {};\n\tlong smallest = *std::min_element(temp.begin(), temp.end());\n\t\
    for (long i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] == smallest) {\n\t\t\t\
    res.push_back(smallest);\n\t\t\tres.push_back(i);\n\t\t\treturn res;\n\t\t}\n\t\
    }\n\treturn {};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    vector<long> result;\n    vector<long>::iterator it;\n    int count=0;\n\
    \    for(it=arr.begin();it!=arr.end();it++)\n    {\n        if((*it)%2==0)\n \
    \       {\n            count++;\n            result.push_back(*it);\n        \
    \    result.push_back(count);\n            break;\n        }\n        count++;\n\
    \    }\n    if(count!=0)\n    {\n        for(it=arr.begin();it!=arr.end();it++)\n\
    \        {\n            if((*it)%2==0)\n            {\n                if((*it)<result[0])\n\
    \                {\n                    result[0]=(*it);\n                   \
    \ result[1]=count;\n                }\n            }\n            count++;\n \
    \       }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpta7hh4jj.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpta7hh4jj.cpp:29:5: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   29 |     vector<long> result;\n      |     ^~~~~~\n/tmp/tmpta7hh4jj.cpp:29:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpta7hh4jj.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpta7hh4jj.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpta7hh4jj.cpp:29:12:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     vector<long>\
    \ result;\n      |            ^~~~\n/tmp/tmpta7hh4jj.cpp:30:12: error: expected\
    \ primary-expression before \u2018long\u2019\n   30 |     vector<long>::iterator\
    \ it;\n      |            ^~~~\n/tmp/tmpta7hh4jj.cpp:32:9: error: \u2018it\u2019\
    \ was not declared in this scope; did you mean \u2018int\u2019?\n   32 |     for(it=arr.begin();it!=arr.end();it++)\n\
    \      |         ^~\n      |         int\n/tmp/tmpta7hh4jj.cpp:37:13: error: \u2018\
    result\u2019 was not declared in this scope\n   37 |             result.push_back(*it);\n\
    \      |             ^~~~~~\n/tmp/tmpta7hh4jj.cpp:45:13: error: \u2018it\u2019\
    \ was not declared in this scope; did you mean \u2018int\u2019?\n   45 |     \
    \    for(it=arr.begin();it!=arr.end();it++)\n      |"
  stdout: ''
  timestamp: 1660117727
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// Write your code here\n\tlong small_even=INT_MAX;\n\tlong ind=INT_MAX;\n\
    \tif(arr.size()==0)\n\t\treturn {};\n\tfor(long i=0;i<arr.size();i++)\n\t{\n\t\
    \tif(arr[i]%2==0)\n\t\t{\n\t\t\tif(arr[i]<small_even)\n\t\t\t{\n\t\t\t\tsmall_even=arr[i];\n\
    \t\t\t\tind=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(small_even==INT_MAX)\n\t\treturn {};\n\
    \treturn {small_even,ind};\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // filter all the even values\n    std::vector<long> res;\n    long\
    \ min = 100000;\n    long idx = -1;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < min) {\n       \
    \         min = arr[i];\n                idx = i;\n            }\n        }\n\
    \    }\n    if (idx != -1) {\n        res.push_back(min);\n        res.push_back(idx);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117727
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long>vec;\n    vec.push_back(0);\n    vec.push_back(0);\n\
    \    // TODO: implement your code here\n    if(arr.size()==0)\n        return\
    \ vec;\n    int sml_idx=0;\n    long sml_val=arr[0];\n    long prev=sml_val;\n\
    \    int flag=0;\n    int j;\n    for(int i=0;i<arr.size();i++)\n    {\n     \
    \   if(arr[i]%2==0)\n        {\n            if(arr[i]<sml_val)\n            {\n\
    \                sml_val=arr[i];\n                sml_idx=i;\n            }\n\
    \            prev=arr[i];\n            flag=1;\n        }\n    }\n    if(flag==0)\n\
    \        return vec;\n    std::vector<long>res;\n    res.push_back(sml_val);\n\
    \    res.push_back(sml_idx);\n    return res;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp9xg057p9: /tmp/tmp9xg057p9.cpp:63: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  auto smallest_even_it = std::find_if(arr.begin(), arr.end(), [](const\
    \ auto& n) { return n % 2 == 0; });\n  if (smallest_even_it == arr.end()) {\n\
    \    return {};\n  }\n  const auto smallest_even = *smallest_even_it;\n  const\
    \ auto smallest_even_index = std::distance(arr.begin(), smallest_even_it);\n \
    \ const auto it = std::find_if(smallest_even_it + 1, arr.end(), [smallest_even](const\
    \ auto& n) { return n == smallest_even; });\n  if (it == arr.end()) {\n    return\
    \ {smallest_even, smallest_even_index};\n  }\n  const auto index = std::distance(arr.begin(),\
    \ it);\n  return {smallest_even, index};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp_83z4bdq: /tmp/tmp_83z4bdq.cpp:44: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\treturn {};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmptwtyw7sg: /tmp/tmptwtyw7sg.cpp:33: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res;\n  // your code here\n  return res;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp87vcuhih: /tmp/tmp87vcuhih.cpp:35: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_index = arr.size();\n    long smallest_value = 1e9;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < smallest_value) {\n            smallest_value = arr[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    if (smallest_index == arr.size()) {\n        return\
    \ {};\n    }\n    std::vector<long> ans = {smallest_value, smallest_index};\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        if(arr[i] % 2 == 0) {\n            result.push_back(arr[i]);\n  \
    \          result.push_back(i);\n            return result;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpn56iwvja: /tmp/tmpn56iwvja.cpp:41: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tint len = arr.size();\n\tstd::vector<long> v;\n\tlong min = 100000000;\n\
    \tlong min_index = -1;\n\tfor (int i = 0; i < len; i++) {\n\t\tif (arr[i] % 2\
    \ == 0 && arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\tmin_index = i;\n\t\t}\n\t\
    }\n\tif (min_index == -1)\n\t\treturn v;\n\tv.push_back(min);\n\tv.push_back(min_index);\n\
    \treturn v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> result(2);\n  long minIndex = -1;\n  long minValue\
    \ = -1;\n  for (long i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n \
    \     minIndex = minIndex == -1 ? i : minIndex;\n      minValue = minValue ==\
    \ -1 ? arr[i] : minValue;\n    } else if (arr[i] % 2 == 0) {\n      if (minValue\
    \ == -1 || arr[i] < minValue) {\n        minIndex = i;\n        minValue = arr[i];\n\
    \      }\n    }\n  }\n  if (minIndex == -1) {\n    return {};\n  }\n  result[0]\
    \ = minValue;\n  result[1] = minIndex;\n  return result;\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp4s3olh_t: /tmp/tmp4s3olh_t.cpp:56: int main(): Assertion `candidate((std::vector<long>({1,
    2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660117728
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> answer;\n    for(auto index = arr.begin(); index\
    \ != arr.end(); index++) {\n        if((*index % 2) == 0) {\n            answer.push_back(*index);\n\
    \            answer.push_back(index - arr.begin());\n            return answer;\n\
    \        }\n    }\n    return answer;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpuyagryte: /tmp/tmpuyagryte.cpp:41: int main(): Assertion `candidate((std::vector<long>({4,
    2, 3}))) == (std::vector<long>({2, 1}))'' failed.

    '
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if (arr.size() == 0) return {};\n  long min = LONG_MAX;\n  std::vector<long>\
    \ ret = {};\n  for (size_t i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 ==\
    \ 0 && arr[i] < min) {\n      min = arr[i];\n      ret = { min, i };\n    }\n\
    \  }\n  if (min == LONG_MAX) return {};\n  return ret;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> ans = {};\n\tstd::vector<long> even = {};\n\tfor\
    \ (auto x : arr) {\n\t\tif (x % 2 == 0) {\n\t\t\teven.push_back(x);\n\t\t}\n\t\
    }\n\tif (even.size() == 0) return ans;\n\tlong min = even[0];\n\tfor (auto x :\
    \ even) {\n\t\tif (x < min) min = x;\n\t}\n\tfor (int i = 0; i < arr.size(); i++)\
    \ {\n\t\tif (arr[i] == min) {\n\t\t\tans.push_back(min);\n\t\t\tans.push_back(i);\n\
    \t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long lowest = INT_MAX;\n  long index = 0;\n  int count = 0;\n  for\
    \ (long i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < lowest)\
    \ {\n      lowest = arr[i];\n      index = i;\n      count = 1;\n    } else if\
    \ (arr[i] % 2 == 0 && arr[i] == lowest) {\n      count++;\n    }\n  }\n  if (count\
    \ == 0) {\n    return {};\n  }\n  return {lowest, index};\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117728
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// your code goes here\n\tvector<long> res(2);\n\tbool is_even_found\
    \ = false;\n\tint index = 0;\n\tint even_index = INT_MAX;\n\tif (arr.size() ==\
    \ 0)\n\t\treturn res;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i]\
    \ % 2 == 0) {\n\t\t\tis_even_found = true;\n\t\t\tif (arr[i] < index) {\n\t\t\t\
    \tindex = arr[i];\n\t\t\t\teven_index = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_even_found)\
    \ {\n\t\tres[0] = index;\n\t\tres[1] = even_index;\n\t}\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp81barqi7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp81barqi7.cpp:30:2: error: \u2018vector\u2019 was not declared\
    \ in this scope\n   30 |  vector<long> res(2);\n      |  ^~~~~~\n/tmp/tmp81barqi7.cpp:30:2:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp81barqi7.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp81barqi7.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp81barqi7.cpp:30:9:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |  vector<long>\
    \ res(2);\n      |         ^~~~\n/tmp/tmp81barqi7.cpp:35:10: error: \u2018res\u2019\
    \ was not declared in this scope\n   35 |   return res;\n      |          ^~~\n\
    /tmp/tmp81barqi7.cpp:46:3: error: \u2018res\u2019 was not declared in this scope\n\
    \   46 |   res[0] = index;\n      |   ^~~\n/tmp/tmp81barqi7.cpp:49:9: error: \u2018\
    res\u2019 was not declared in this scope\n   49 |  return res;\n      |      \
    \   ^~~\n"
  stdout: ''
  timestamp: 1660117728
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> even_values;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            even_values.push_back(arr[i]);\n\
    \        }\n    }\n    if (even_values.size() == 0) {\n        return {};\n  \
    \  } else {\n        std::sort(even_values.begin(), even_values.end());\n    \
    \    std::vector<long> result;\n        result.push_back(even_values[0]);\n  \
    \      for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] == even_values[0])\
    \ {\n                result.push_back(i);\n                return result;\n  \
    \          }\n        }\n    }\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long min = INT_MAX;\n  long minIndex = INT_MAX;\n  for (int i = 0;\
    \ i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min) {\n      min\
    \ = arr[i];\n      minIndex = i;\n    }\n  }\n  if (min == INT_MAX) {\n    return\
    \ {};\n  }\n  return {min, minIndex};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long minEven = -1;\n  long minEvenIdx = -1;\n  long minIdx = -1;\n\
    \  bool hasEven = false;\n  bool firstEven = true;\n  bool firstIdx = true;\n\
    \  for (long i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n     \
    \ hasEven = true;\n      if (firstEven) {\n        minEven = arr[i];\n       \
    \ minEvenIdx = i;\n        firstEven = false;\n      } else {\n        if (arr[i]\
    \ < minEven) {\n          minEven = arr[i];\n          minEvenIdx = i;\n     \
    \   }\n      }\n    } else {\n      if (firstIdx) {\n        minIdx = i;\n   \
    \     firstIdx = false;\n      } else {\n        if (i < minIdx) {\n         \
    \ minIdx = i;\n        }\n      }\n    }\n  }\n  if (hasEven) {\n    return {minEven,\
    \ minEvenIdx};\n  } else {\n    return {};\n  }\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // your code here\n    std::vector<long> sol;\n    if(arr.size()==0)\
    \ return sol;\n    long min = 100000;\n    long index = 0;\n    for(int i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0 && arr[i]<min){\n            min = arr[i];\n         \
    \   index = i;\n        }\n    }\n    if(min==100000) return sol;\n    sol.push_back(min);\n\
    \    sol.push_back(index);\n    return sol;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> ans;\n  if (arr.size() == 0) {\n    return ans;\n\
    \  }\n  long ans_min_even = INT_MAX;\n  long ans_min_idx = INT_MAX;\n  for (long\
    \ i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      if (arr[i]\
    \ < ans_min_even) {\n        ans_min_even = arr[i];\n        ans_min_idx = i;\n\
    \      }\n    }\n  }\n  if (ans_min_even == INT_MAX) {\n    return ans;\n  }\n\
    \  ans.push_back(ans_min_even);\n  ans.push_back(ans_min_idx);\n  return ans;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    if(arr.size()==0)\n        return\
    \ result;\n    long smval=INT_MAX;\n    long index=INT_MAX;\n    bool flag=true;\n\
    \    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]%2==0&&arr[i]<smval)\n\
    \        {\n            flag=false;\n            smval=arr[i];\n            index=i;\n\
    \        }\n    }\n    if(flag)\n        return result;\n    result.push_back(smval);\n\
    \    result.push_back(index);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tif (arr.size() == 0)\n\t\treturn {};\n\tint min = -1;\n\tint min_index\
    \ = -1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0) {\n\
    \t\t\tif (min == -1) {\n\t\t\t\tmin = arr[i];\n\t\t\t\tmin_index = i;\n\t\t\t\
    }\n\t\t\telse if (arr[i] < min) {\n\t\t\t\tmin = arr[i];\n\t\t\t\tmin_index =\
    \ i;\n\t\t\t}\n\t\t}\n\t}\n\tif (min == -1)\n\t\treturn {};\n\telse\n\t\treturn\
    \ {min, min_index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660117729
