name: HumanEval_128_prod_signs
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // iterate arr\n\
    \    //   sum magnitudes\n    //   iterate signs\n    //     prod signs\n    if\
    \ (arr.empty()) {\n        return std::nullopt;\n    }\n    long sum = 0;\n  \
    \  long product = 1;\n    for (auto const val : arr) {\n        sum += std::abs(val);\n\
    \        product *= std::signbit(val) ? -1 : 1;\n    }\n    return sum * product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp59e97c6n: /tmp/tmp59e97c6n.cpp:30: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int pos = 0;\n  \
    \  int neg = 0;\n    long sum = 0;\n    if (arr.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    for (int i = 0; i < arr.size(); i++) {\n        if\
    \ (arr[i] < 0) {\n            neg++;\n        }\n        if (arr[i] > 0) {\n \
    \           pos++;\n        }\n        sum += abs(arr[i]);\n    }\n    int prod\
    \ = (neg % 2 == 0) ? 1 : -1;\n    prod *= (pos > 0) ? 1 : 0;\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp9z9kdeie: /tmp/tmp9z9kdeie.cpp:34: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Implement me!\n\
    \  int count = 0;\n  long mul = 1;\n  for(int i = 0; i < arr.size(); i++){\n \
    \   if(arr[i] == 0){\n      return 0;\n    }\n    else if(arr[i] < 0){\n     \
    \ mul *= -1;\n      count++;\n    }\n  }\n  if(count % 2 == 0){\n    return mul;\n\
    \  }\n  else {\n    return mul * -1;\n  }\n  return 0;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp6_ohrdho: /tmp/tmp6_ohrdho.cpp:34: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long result = 0;\n    long signs\
    \ = 1;\n    for (auto num : arr) {\n        signs *= num < 0 ? -1 : num == 0 ?\
    \ 0 : 1;\n        result += std::abs(num);\n    }\n    return result * signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmptfxsvy2m: /tmp/tmptfxsvy2m.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long long int sum\
    \ = 0;\n    long long int prod = 1;\n    for (auto i = arr.begin(); i != arr.end();\
    \ i++) {\n        if (*i != 0) {\n            if (*i > 0)\n                prod\
    \ *= 1;\n            else\n                prod *= -1;\n            sum += std::abs(*i);\n\
    \        }\n    }\n    if (sum == 0) {\n        return {};\n    }\n    return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmphfyhh13q: /tmp/tmphfyhh13q.cpp:31: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  // your code here\n  long sign = 1;\n  long\
    \ res = 0;\n  for (int i : arr) {\n    res += i * sign;\n    sign *= (i == 0 ?\
    \ 1 : i / abs(i));\n  }\n  return res;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpb81bwi5d: /tmp/tmpb81bwi5d.cpp:26: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // return std::nullopt;\n\
    \    // return std::make_optional(0L);\n    long sum = 0;\n    for (auto it =\
    \ arr.begin(); it != arr.end(); it++) {\n        sum += *it;\n    }\n    return\
    \ std::make_optional(sum);\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp_n5fyruq: /tmp/tmp_n5fyruq.cpp:22: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    long sum = 0;\n    if (arr.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    for (int x : arr) {\n        if (x < 0) {\n            product *=\
    \ -1;\n        } else if (x > 0) {\n            product *= 1;\n        } else\
    \ {\n            product *= 0;\n        }\n        sum += std::abs(x);\n    }\n\
    \    return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpp65n0_zh: /tmp/tmpp65n0_zh.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long mult = 1;\n  long sum = 0;\n  for (auto\
    \ n : arr) {\n    if (n < 0) {\n      mult *= -1;\n    } else if (n > 0) {\n \
    \     sum += std::abs(n);\n    }\n  }\n  return mult * sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpj3rriwtm: /tmp/tmpj3rriwtm.cpp:28: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long prod = 1;\n  long sum = 0;\n  for (auto\
    \ num : arr) {\n    if (num > 0) {\n      prod *= 1;\n    } else if (num < 0)\
    \ {\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n    sum += std::abs(num);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmppvsjyy6f: /tmp/tmppvsjyy6f.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  if\
    \ (arr.size() == 0) {\n    return std::nullopt;\n  }\n  else {\n    for (int i\
    \ = 0; i < arr.size(); i++) {\n      if (arr[i] < 0) {\n        sum += arr[i];\n\
    \      }\n      else if (arr[i] > 0) {\n        sum += arr[i];\n      }\n    }\n\
    \    return sum;\n  }\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpnh65bt7y: /tmp/tmpnh65bt7y.cpp:30: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    long sum = 0;\n    for (auto it = arr.begin(); it != arr.end(); it++) {\n\
    \        if (*it > 0) {\n            product *= 1;\n            sum += *it;\n\
    \        } else if (*it < 0) {\n            product *= -1;\n            sum +=\
    \ *it * -1;\n        } else {\n            product *= 0;\n        }\n    }\n \
    \   if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    return sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmps_w2e2j4: /tmp/tmps_w2e2j4.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  long sum=0;\n  long prod=1;\n  if(arr.size()==0)\n    return {};\n  else\n\
    \  {\n    for(int i=0;i<arr.size();i++)\n    {\n      if(arr[i]>0)\n        prod=prod*1;\n\
    \      else if(arr[i]<0)\n        prod=prod*-1;\n      else\n        prod=prod*0;\n\
    \      sum=sum+abs(arr[i]);\n    }\n    sum=sum*prod;\n    return sum;\n  }\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpq6xkmwcu: /tmp/tmpq6xkmwcu.cpp:38: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (long e : arr) {\n \
    \   if (e == 0) {\n      prod = 0;\n      break;\n    }\n    prod *= (e < 0 ?\
    \ -1 : 1);\n    sum += std::abs(e);\n  }\n  return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpsrxfptxk: /tmp/tmpsrxfptxk.cpp:30: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long sum = 0;\n    long product = 1;\n    for (const\
    \ auto& n : arr) {\n        product *= n < 0 ? -1 : n > 0 ? 1 : 0;\n        sum\
    \ += std::abs(n);\n    }\n    return product * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpm2x0c71b: /tmp/tmpm2x0c71b.cpp:26: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // iterate over input\
    \ vector\n    int i = 0;\n    long sign_product = 1;\n    long sum_magnitudes\
    \ = 0;\n    for (auto val : arr) {\n        if (val == 0) {\n            sign_product\
    \ = 0;\n            sum_magnitudes += 0;\n        } else if (val > 0) {\n    \
    \        sign_product *= 1;\n            sum_magnitudes += val;\n        } else\
    \ {\n            sign_product *= -1;\n            sum_magnitudes += val * -1;\n\
    \        }\n    }\n    if (sign_product == 0) {\n        return sign_product;\n\
    \    } else {\n        return sum_magnitudes * sign_product;\n    }\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tstd::optional<long>\
    \ arr_size = arr.size();\n\tif (arr_size == 0) {\n\t\treturn {};\n\t}\n\tint signs\
    \ = 0;\n\tint magnitudes = 0;\n\tfor (auto const& it : arr) {\n\t\tif (it > 0)\
    \ {\n\t\t\tsigns += 1;\n\t\t\tmagnitudes += it;\n\t\t}\n\t\telse if (it < 0) {\n\
    \t\t\tsigns -= 1;\n\t\t\tmagnitudes += it;\n\t\t}\n\t}\n\tif (signs == 0) {\n\t\
    \treturn 0;\n\t}\n\treturn signs * magnitudes;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpxs8btx78: /tmp/tmpxs8btx78.cpp:35: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long mul = 1;\n \
    \   long sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ > 0) {\n            mul *= 1;\n            sum += arr[i];\n        } else if\
    \ (arr[i] < 0) {\n            mul *= -1;\n            sum += std::abs(arr[i]);\n\
    \        } else {\n            mul *= 0;\n        }\n    }\n    if (mul == 0)\
    \ {\n        return std::nullopt;\n    }\n    return mul * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmptvrc1ymu: /tmp/tmptvrc1ymu.cpp:33: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 1;\n    for (auto i : arr) {\n        res\
    \ *= (i > 0) - (i < 0);\n    }\n    return res * std::accumulate(arr.begin(),\
    \ arr.end(), 0l,\n        [](long a, long b) { return std::abs(a) + std::abs(b);\
    \ });\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpbww0ir95: /tmp/tmpbww0ir95.cpp:25: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int sign = 1;\n  long result = 0;\n  for (const auto& elem\
    \ : arr) {\n    if (elem == 0) {\n      sign = 0;\n      continue;\n    }\n  \
    \  result += std::abs(elem);\n    sign *= elem < 0 ? -1 : 1;\n  }\n  return result\
    \ * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpy5wk6tq2: /tmp/tmpy5wk6tq2.cpp:30: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    const int magnitudes = std::accumulate(arr.begin(),\
    \ arr.end(), 0,\n        [](const int accumulator, const int current) {\n    \
    \        return accumulator + std::abs(current);\n        });\n\n    const int\
    \ signs = std::accumulate(arr.begin(), arr.end(), 1,\n        [](const int accumulator,\
    \ const int current) {\n            return accumulator * ((current < 0) ? -1 :\
    \ (current > 0) ? 1 : 0);\n        });\n\n    return magnitudes * signs;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpu02e2aom: /tmp/tmpu02e2aom.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        int n = arr[i];\n       \
    \ if (n < 0) {\n            prod *= -1;\n        } else if (n > 0) {\n       \
    \     prod *= 1;\n        } else {\n            prod *= 0;\n        }\n      \
    \  sum += std::abs(n);\n    }\n    return prod * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp64juyz2n: /tmp/tmp64juyz2n.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int mul = 1;\n    long sum = 0;\n\
    \    for (const auto& element : arr) {\n        if (element < 0) {\n         \
    \   mul *= -1;\n        } else if (element > 0) {\n            mul *= 1;\n   \
    \     } else {\n            mul *= 0;\n        }\n        sum += std::abs(element);\n\
    \    }\n    return mul * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp1xz_xfob: /tmp/tmp1xz_xfob.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long long prod = 1;\n\
    \  long long sum = 0;\n  for (long num : arr) {\n    sum += abs(num);\n    prod\
    \ *= (num > 0) - (num < 0);\n  }\n  return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int product = 1;\n\
    \    long sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ > 0) {\n            product *= 1;\n            sum += arr[i];\n        } else\
    \ if (arr[i] < 0) {\n            product *= -1;\n            sum += arr[i];\n\
    \        } else {\n            product *= 0;\n        }\n    }\n    if (arr.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    sum *= product;\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp2mbt1s4l: /tmp/tmp2mbt1s4l.cpp:33: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long acc = 0;\n    for (long& l : arr) acc += abs(l);\n\
    \    long prod = 1;\n    for (long& l : arr) {\n        if (l == 0) continue;\n\
    \        if (l > 0) prod *= 1;\n        else prod *= -1;\n    }\n    return acc\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp8dzzkcs6: /tmp/tmp8dzzkcs6.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sum = 0;\n    if (arr.size() == 0)\n        return std::nullopt;\n \
    \   for (auto &i : arr) {\n        if (i < 0) {\n            prod *= -1;\n   \
    \         sum += std::abs(i);\n        } else if (i > 0) {\n            sum +=\
    \ i;\n        }\n    }\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp56v2mlqa: /tmp/tmp56v2mlqa.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong product = 1;\n\
    \tlong sum = 0;\n\tfor (auto i = arr.begin(); i != arr.end(); i++) {\n\t\tif (*i\
    \ > 0) {\n\t\t\tproduct *= 1;\n\t\t\tsum += *i;\n\t\t}\n\t\telse if (*i < 0) {\n\
    \t\t\tproduct *= -1;\n\t\t\tsum += *i;\n\t\t}\n\t\telse if (*i == 0) {\n\t\t\t\
    product *= 0;\n\t\t}\n\t}\n\tif (arr.size() == 0) {\n\t\treturn {};\n\t}\n\treturn\
    \ { product * sum };\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpwufcfdff: /tmp/tmpwufcfdff.cpp:34: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  long product = 1;\n  long sum = 0;\n  int count = 0;\n  for(int i = 0; i <\
    \ arr.size(); i++){\n    if(arr[i] > 0){\n      count++;\n      product *= 1;\n\
    \      sum += arr[i];\n    }\n    else if(arr[i] < 0){\n      count++;\n     \
    \ product *= -1;\n      sum += arr[i];\n    }\n    else if(arr[i] == 0){\n   \
    \   count++;\n      product *= 0;\n      sum += arr[i];\n    }\n  }\n  if(count\
    \ != 0){\n    return product * sum;\n  }\n  else{\n    return std::nullopt;\n\
    \  }\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmps1_80_y2: /tmp/tmps1_80_y2.cpp:42: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(arr.size()\
    \ <= 50);\n    long sum_magnitudes = 0;\n    long product_signs = 1;\n    for\
    \ (auto num : arr) {\n        sum_magnitudes += std::abs(num);\n        product_signs\
    \ *= std::copysign(1, num);\n    }\n    return sum_magnitudes * product_signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp7jj7yk0x: /tmp/tmp7jj7yk0x.cpp:24: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ it : arr) {\n    if (it < 0) {\n      prod *= -1;\n    } else if (it > 0) {\n\
    \      sum += it;\n    }\n  }\n  return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpa82u0317: /tmp/tmpa82u0317.cpp:28: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Vectors are dynamically\
    \ sized arrays.\n    if (arr.size() == 0) {\n        return std::nullopt;\n  \
    \  }\n    long sum = 0;\n    long prod = 1;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n            prod\
    \ *= 1;\n        } else if (arr[i] < 0) {\n            sum += arr[i];\n      \
    \      prod *= -1;\n        } else {\n            prod *= 0;\n        }\n    }\n\
    \    if (prod == 0) {\n        return std::nullopt;\n    }\n    return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp765teuvs: /tmp/tmp765teuvs.cpp:36: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n\
    \    for (long elem : arr) {\n        if (elem < 0) {\n            prod *= -1;\n\
    \        } else if (elem > 0) {\n            sum += elem;\n        }\n    }\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmphvcfvyg4: /tmp/tmphvcfvyg4.cpp:28: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong product = 0;\n\tlong sum = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tlong prod = 0;\n\t\tif (arr[i] < 0) {\n\t\
    \t\tprod = 1;\n\t\t} else if (arr[i] > 0) {\n\t\t\tprod = -1;\n\t\t}\n\t\tproduct\
    \ *= prod;\n\t\tsum += std::abs(arr[i]);\n\t}\n\tlong ans = product * sum;\n\t\
    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpm1sh1ot4: /tmp/tmpm1sh1ot4.cpp:32: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tint sum = 0;\n\tint\
    \ count = 0;\n\tint sum1 = 0;\n\tint product = 1;\n\tfor (auto& x : arr) {\n\t\
    \tif (x > 0) {\n\t\t\tcount++;\n\t\t\tsum = sum + x;\n\t\t}\n\t\telse if (x <\
    \ 0) {\n\t\t\tcount++;\n\t\t\tsum1 = sum1 + x;\n\t\t}\n\t\telse {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\tif (count == 0) {\n\t\treturn {};\n\t}\n\tproduct = product * count;\n\
    \treturn sum * sum1 * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp1ynrp38e: /tmp/tmp1ynrp38e.cpp:37: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code here\n\
    \    if(arr.size()==0) return {};\n    long mults = 1;\n    long sum = 0;\n  \
    \  for(auto x: arr){\n        int s = 1;\n        if(x<0) s = -1;\n        mults\
    \ *= s;\n        sum += abs(x);\n    }\n    return sum*mults;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpbfalbbhx: /tmp/tmpbfalbbhx.cpp:27: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long result = 0;\n    long sign = 1;\n    for (long\
    \ num : arr) {\n        result += std::abs(num);\n        if (num > 0) sign *=\
    \ 1;\n        else if (num < 0) sign *= -1;\n        else sign *= 0;\n    }\n\
    \    return sign * result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpam5zcjmb: /tmp/tmpam5zcjmb.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // I have no idea what\
    \ this function does.\n  // I don't think it's possible to write an accurate function,\n\
    \  // or at least any effort would require far more information than\n  // is\
    \ given to us in the problem.\n  long count=0;\n  int neg = 0;\n  int zero = 0;\n\
    \  long total = 1;\n  if(arr.size()==0){\n    return {};\n  }\n  for(long num:\
    \ arr){\n    if(num<0){\n      count += num;\n      neg += 1;\n    }else if(num==0){\n\
    \      zero += 1;\n    }else{\n      count += num;\n    }\n  }\n  if(neg>0 &&\
    \ zero == 0){\n    return {-count};\n  }else if(neg>0 && zero > 0){\n    return\
    \ {0};\n  }else{\n    return {count};\n  }\n  // return {};\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpcrx0e_hm: /tmp/tmpcrx0e_hm.cpp:44: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int number_of_negatives = 0;\n  int number_of_zeros\
    \ = 0;\n  for (auto element : arr) {\n    if (element == 0) {\n      number_of_zeros++;\n\
    \    } else if (element < 0) {\n      number_of_negatives++;\n    }\n  }\n  if\
    \ (number_of_zeros > 0) {\n    return 0;\n  }\n  if (number_of_negatives % 2 ==\
    \ 0) {\n    return 1;\n  }\n  return -1;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpoh19iw3h: /tmp/tmpoh19iw3h.cpp:34: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long val = 1;\n  long sum = 0;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    val *= std::signbit(arr[i]) ? -1 : 1;\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * val;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp2li7jpbf: /tmp/tmp2li7jpbf.cpp:24: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ctr=0;\n   \
    \ long ctr0=0;\n    for(long i=0;i<arr.size();i++){\n        if(arr[i]>0){\n \
    \           ctr+=1;\n        }\n        else if(arr[i]<0){\n            ctr+=-1;\n\
    \        }\n        else{\n            ctr0+=1;\n        }\n    }\n    if(ctr0==arr.size()){\n\
    \        return std::nullopt;\n    }\n    long sum=0;\n    for(long i=0;i<arr.size();i++){\n\
    \        if(arr[i]>0){\n            sum+=arr[i];\n        }\n        else if(arr[i]<0){\n\
    \            sum+=-arr[i];\n        }\n    }\n    return sum*ctr;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpoeawsu1p: /tmp/tmpoeawsu1p.cpp:41: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum=0;\n   \
    \ long prod=1;\n    for(auto i:arr){\n        if(i==0){\n            continue;\n\
    \        }\n        else if(i>0){\n            sum+=i;\n            prod*=1;\n\
    \        }\n        else{\n            sum+=abs(i);\n            prod*=-1;\n \
    \       }\n    }\n    if(arr.size()==0){\n        return std::nullopt;\n    }\n\
    \    else{\n        return sum*prod;\n    }\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpbbh97szr: /tmp/tmpbbh97szr.cpp:37: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto& item : arr) {\n        if (item == 0) {\n            continue;\n\
    \        }\n        product *= item / std::abs(item);\n        sum += std::abs(item);\n\
    \    }\n    return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp8jnr042x: /tmp/tmp8jnr042x.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long prod = 1;\n  int\
    \ count = 0;\n  for (long x : arr) {\n    count += 1;\n    if (x > 0) {\n    \
    \  prod *= 1;\n    } else if (x < 0) {\n      prod *= -1;\n    } else {\n    \
    \  prod *= 0;\n    }\n  }\n  if (count > 0) {\n    long result = 0;\n    for (long\
    \ x : arr) {\n      result += std::abs(x);\n    }\n    return result * prod;\n\
    \  } else {\n    return std::nullopt;\n  }\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpkrdu2_6b: /tmp/tmpkrdu2_6b.cpp:39: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ a : arr) {\n    if (a > 0) {\n      sum += a;\n      prod *= 1;\n    } else\
    \ if (a < 0) {\n      sum += -a;\n      prod *= -1;\n    } else {\n      prod\
    \ *= 0;\n    }\n  }\n  return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp5g0zx5v_: /tmp/tmp5g0zx5v_.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong prod = 1;\n\t\
    long sum = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] < 0)\n\
    \t\t\tprod *= -1;\n\t\telse if (arr[i] > 0)\n\t\t\tprod *= 1;\n\t\telse\n\t\t\t\
    prod *= 0;\n\t\tsum += abs(arr[i]);\n\t}\n\treturn sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto result = 1LL;\n    auto sum\
    \ = 0LL;\n    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        auto\
    \ cur = *it;\n        sum += std::abs(cur);\n        if (cur > 0) {\n        \
    \    result *= 1;\n        } else if (cur < 0) {\n            result *= -1;\n\
    \        } else {\n            result *= 0;\n        }\n    }\n    return result\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp8qtguh3u: /tmp/tmp8qtguh3u.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    \    return 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpj6n4_p96: /tmp/tmpj6n4_p96.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // replace with your\
    \ solution\n    std::optional<long> result;\n    int prod = 1;\n    long sum =\
    \ 0;\n    for (int i = 0; i < arr.size(); i++) {\n        int sign = 0;\n    \
    \    if (arr[i] < 0) {\n            prod *= -1;\n            sign = -1;\n    \
    \    } else if (arr[i] > 0) {\n            sign = 1;\n        }\n        sum +=\
    \ sign * arr[i];\n    }\n    result = sum * prod;\n    return result;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpzgzp438j: /tmp/tmpzgzp438j.cpp:32: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code goes here\n\
    \  std::optional<long> result;\n  for (auto element : arr) {\n    if (result)\
    \ {\n      result = result.value() + element;\n    } else {\n      result = element;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpchqp67dt: /tmp/tmpchqp67dt.cpp:25: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sign_product = 1;\n  for (auto i : arr)\
    \ {\n    if (i < 0) {\n      sign_product *= -1;\n    } else if (i > 0) {\n  \
    \    sign_product *= 1;\n    } else {\n      sign_product *= 0;\n    }\n  }\n\
    \  long sum = 0;\n  for (auto i : arr) {\n    sum += std::abs(i);\n  }\n  return\
    \ sign_product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmppsu5ppam: /tmp/tmppsu5ppam.cpp:36: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here.\n\
    \    int product = 1;\n    int sum = 0;\n    if(arr.size() == 0)\n        return\
    \ {};\n    for(int i = 0; i < arr.size(); i++)\n    {\n        if(arr[i] < 0)\n\
    \        {\n            product *= -1;\n            sum += -1 * arr[i];\n    \
    \    }\n        else if(arr[i] > 0)\n        {\n            sum += arr[i];\n \
    \       }\n        else\n        {\n            product = 0;\n        }\n    }\n\
    \    return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmptyy_b0or: /tmp/tmptyy_b0or.cpp:40: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int zeroFlag = 0;\n\
    \    int negativeCount = 0;\n    long product = 1;\n    long sum = 0;\n    if(arr.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    for(long i : arr) {\n    \
    \    if(i == 0) {\n            zeroFlag = 1;\n        }\n        if(i < 0) {\n\
    \            negativeCount++;\n        }\n        sum += abs(i);\n    }\n    product\
    \ = pow(-1, negativeCount);\n    if(zeroFlag == 1) {\n        return std::nullopt;\n\
    \    }\n    return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpg80032dy: /tmp/tmpg80032dy.cpp:37: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long result = 1;\n  long magnitude_sum = 0;\n  for (auto x\
    \ : arr) {\n    if (x == 0) continue;\n    magnitude_sum += std::abs(x);\n   \
    \ result *= std::copysign(1, x);\n  }\n  return magnitude_sum * result;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpthcgqxkt: /tmp/tmpthcgqxkt.cpp:25: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  std::array<int, 3> signs_cnt = {0, 0, 0};\n\
    \  long prod = 1;\n  for (long l : arr) {\n    if (l == 0) {\n      signs_cnt[0]++;\n\
    \    } else if (l > 0) {\n      signs_cnt[1]++;\n    } else {\n      signs_cnt[2]++;\n\
    \    }\n    prod *= std::abs(l);\n  }\n  assert(signs_cnt[0] >= 0);\n  // For\
    \ more than 1 zero, return is 0\n  if (signs_cnt[0] > 1) {\n    return 0;\n  }\n\
    \  // For 1 zero, return = 0\n  if (signs_cnt[0] == 1) {\n    return 0;\n  }\n\
    \  // For 0 zeros, return = prod\n  if (signs_cnt[0] == 0) {\n    return prod;\n\
    \  }\n  // For number of -ve even, return = prod\n  if (signs_cnt[2] % 2 == 0)\
    \ {\n    return prod;\n  }\n  // For number of -ve odd, return = -prod\n  if (signs_cnt[2]\
    \ % 2 == 1) {\n    return -prod;\n  }\n  // This should never be reached\n  assert(false);\n\
    \  return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpr9588zqr: /tmp/tmpr9588zqr.cpp:54: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sum = 0;\n\tint prod = 1;\n\tfor (auto &e : arr) {\n\t\
    \tif (e < 0) prod *= -1;\n\t\tsum += abs(e);\n\t}\n\treturn sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpmgrbdcfx: /tmp/tmpmgrbdcfx.cpp:24: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  auto product = 1;\n  auto sum = 0;\n  for\
    \ (auto i = 0; i < arr.size(); i++) {\n    auto sign = arr[i] == 0 ? 0 : arr[i]\
    \ / std::abs(arr[i]);\n    product *= sign;\n    sum += std::abs(arr[i]);\n  }\n\
    \  return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpfcjsr6bu: /tmp/tmpfcjsr6bu.cpp:30: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  int sign_multiply = 1;\n  int sum_magnitude\
    \ = 0;\n  for (long & number : arr) {\n    if (number == 0) {\n      continue;\n\
    \    }\n    sign_multiply *= number / std::abs(number);\n    sum_magnitude +=\
    \ std::abs(number);\n  }\n  return sign_multiply * sum_magnitude;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpwwxir0na: /tmp/tmpwwxir0na.cpp:30: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    if(arr.size() == 0)\n        return std::nullopt;\n    int pos = 0,\
    \ neg = 0, zero = 0;\n    for(int i = 0; i < arr.size(); i++){\n        if(arr[i]\
    \ > 0)\n            pos++;\n        else if(arr[i] < 0)\n            neg++;\n\
    \        else\n            zero++;\n    }\n    int pos_neg = pos*neg;\n    if(pos_neg\
    \ == 0)\n        return 0;\n    if(zero > 0)\n        return -1;\n    long answer\
    \ = 0;\n    for(int i = 0; i < arr.size(); i++){\n        answer += std::abs(arr[i]);\n\
    \    }\n    return answer;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp2oshxa61: /tmp/tmp2oshxa61.cpp:37: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tint sign_sum = 0;\n\tfor (const auto& x : arr) {\n\t\tif (x\
    \ > 0) sign_sum++;\n\t\telse if (x < 0) sign_sum--;\n\t}\n\tlong magn_sum = 0;\n\
    \tfor (const auto& x : arr) {\n\t\tmagn_sum += std::abs(x);\n\t}\n\treturn magn_sum\
    \ * sign_sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmps9euuwcz: /tmp/tmps9euuwcz.cpp:26: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int sum = 0;\n  \
    \  long prod = 1;\n    for (const auto& num : arr) {\n        if (num == 0) {\n\
    \            continue;\n        } else if (num > 0) {\n            sum += num;\n\
    \            prod *= 1;\n        } else {\n            sum += std::abs(num);\n\
    \            prod *= -1;\n        }\n    }\n    if (sum == 0) {\n        return\
    \ std::nullopt;\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpf2jwubc1: /tmp/tmpf2jwubc1.cpp:33: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  double prod_of_signs = 1;\n  double sum_of_magnitudes\
    \ = 0;\n  for (const auto& el : arr) {\n    prod_of_signs *= std::signbit(el)\
    \ ? -1 : 1;\n    sum_of_magnitudes += std::abs(el);\n  }\n\n  return prod_of_signs\
    \ * sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpzkpver6l: /tmp/tmpzkpver6l.cpp:28: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong long ans = 1;\n\
    \tlong long sum = 0;\n\tfor (long n : arr) {\n\t\tsum += std::abs(n);\n\t\tif\
    \ (n < 0) ans *= -1;\n\t}\n\tif (arr.size() == 0) return {};\n\treturn {sum *\
    \ ans};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpmb9_t85h: /tmp/tmpmb9_t85h.cpp:24: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  auto sign_prod = 1;\n  auto mag_sum = 0;\n \
    \ for (auto x : arr) {\n    if (x > 0) {\n      sign_prod *= 1;\n    } else if\
    \ (x < 0) {\n      sign_prod *= -1;\n    } else {\n      sign_prod *= 0;\n   \
    \ }\n    mag_sum += std::abs(x);\n  }\n  return sign_prod * mag_sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpvwfb1pmc: /tmp/tmpvwfb1pmc.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long result{1};\n  for (auto elem : arr) {\n    if (elem >\
    \ 0) result *= 1;\n    else if (elem < 0) result *= -1;\n    else result *= 0;\n\
    \  }\n  for (auto elem : arr) {\n    result *= abs(elem);\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp6h3ay7kj: /tmp/tmp6h3ay7kj.cpp:26: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (auto el : arr) {\n\
    \    if (el < 0) prod *= -1;\n    if (el > 0) sum += el;\n  }\n  return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp8ek596ta: /tmp/tmp8ek596ta.cpp:23: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long result = 1;\n    long sum = 0;\n    for (auto\
    \ i : arr) {\n        if (i > 0) {\n            result *= 1;\n            sum\
    \ += i;\n        } else if (i < 0) {\n            result *= -1;\n            sum\
    \ += std::abs(i);\n        } else {\n            result *= 0;\n        }\n   \
    \ }\n    return result * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpaftg_x5g: /tmp/tmpaftg_x5g.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    for (auto i: arr) {\n        i = abs(i);\n        sum\
    \ += i;\n        prod *= i == 0 ? 1 : i / i;\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp8r5stwds: /tmp/tmp8r5stwds.cpp:23: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::vector<long> signs;\n\
    \  std::vector<long> magnitudes;\n  if (arr.size() == 0) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  for (auto el : arr) {\n    if (el > 0) {\n      signs.push_back(1);\n\
    \    } else if (el < 0) {\n      signs.push_back(-1);\n    } else {\n      signs.push_back(0);\n\
    \    }\n    magnitudes.push_back(std::abs(el));\n  }\n  for (auto sign : signs)\
    \ {\n    prod *= sign;\n  }\n  long sum = 0;\n  for (auto magn : magnitudes) {\n\
    \    sum += magn;\n  }\n  return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp8n0gq5qc: /tmp/tmp8n0gq5qc.cpp:42: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (const auto a : arr)\
    \ {\n    if (a < 0) product *= -1;\n    else if (a > 0) sum += a;\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpvpzqyfjr: /tmp/tmpvpzqyfjr.cpp:23: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long s = 1;\n  long sum = 0;\n  for (auto a : arr) {\n    if\
    \ (a != 0) {\n      s *= (a / abs(a));\n      sum += abs(a);\n    }\n  }\n  return\
    \ std::make_optional(s * sum);\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp5raivdsz: /tmp/tmp5raivdsz.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long sum = 0;\n    long long product = 1;\n \
    \   for (long x : arr) {\n        if (x > 0) sum += x;\n        else if (x < 0)\
    \ {\n            sum -= x;\n            product *= -1;\n        }\n    }\n   \
    \ return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpavnsxpkl: /tmp/tmpavnsxpkl.cpp:27: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n\
    \    for (auto n : arr) {\n        sum += abs(n);\n        prod *= (n > 0) - (n\
    \ < 0);\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp_uyfkgzz: /tmp/tmp_uyfkgzz.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return arr.empty()\
    \ ? std::nullopt : std::accumulate(\n      arr.begin(), arr.end(), 1L,\n     \
    \ [](long acc, long item) { return acc * std::copysign(1, item); });\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp57os7l34.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp57os7l34.cpp:12:22: error: operands to \u2018?:\u2019\
    \ have different types \u2018const std::nullopt_t\u2019 and \u2018long int\u2019\
    \n   12 |   return arr.empty() ? std::nullopt : std::accumulate(\n      |    \
    \      ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   13 |       arr.begin(),\
    \ arr.end(), 1L,\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   14 |       [](long\
    \ acc, long item) { return acc * std::copysign(1, item); });\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  auto sum = 0;\n  auto prod = 1;\n  for (auto\
    \ i : arr) {\n    auto sign = i == 0 ? 0 : i > 0 ? 1 : -1;\n    prod *= sign;\n\
    \    sum += std::abs(i);\n  }\n  return prod * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpq_b31b1k: /tmp/tmpq_b31b1k.cpp:29: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // return None\n  if\
    \ (arr.empty()) return std::nullopt;\n  // get sum of all magnitudes\n  unsigned\
    \ long long sum = 0;\n  // get product of all signs\n  int sign = 1;\n  for (auto&\
    \ x : arr) {\n    sum += abs(x);\n    sign *= (x == 0 ? 1 : (x < 0 ? -1 : 1));\n\
    \  }\n  return sign * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpj6gce_s3: /tmp/tmpj6gce_s3.cpp:27: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long long prod_signs\
    \ = 1;\n    long long sum_magnitudes = 0;\n    if (arr.size() == 0) {\n      \
    \  return std::nullopt;\n    }\n    for (auto e : arr) {\n        prod_signs *=\
    \ std::signbit(e);\n        sum_magnitudes += std::abs(e);\n    }\n    return\
    \ sum_magnitudes * prod_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpdwqztcoq: /tmp/tmpdwqztcoq.cpp:25: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpvw6tvbm5: /tmp/tmpvw6tvbm5.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    std::vector<long> signs;\n   \
    \ std::vector<long> magnitudes;\n    for (const auto& elem : arr) {\n        if\
    \ (elem > 0) {\n            signs.push_back(1);\n            magnitudes.push_back(elem);\n\
    \        } else if (elem < 0) {\n            signs.push_back(-1);\n          \
    \  magnitudes.push_back(-elem);\n        } else {\n            signs.push_back(0);\n\
    \            magnitudes.push_back(0);\n        }\n    }\n\n    const auto prod\
    \ = std::accumulate(signs.begin(), signs.end(), 1,\n                         \
    \               std::multiplies<long>());\n    const auto sum = std::accumulate(magnitudes.begin(),\
    \ magnitudes.end(), 0);\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp8bm__4ez: /tmp/tmp8bm__4ez.cpp:41: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp46h3crbm: /tmp/tmp46h3crbm.cpp:16: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // write your code\
    \ here\n    long prod=1;\n    long sum=0;\n    if(arr.size()==0)\n        return\
    \ {};\n    else\n    {\n        for(int i=0;i<arr.size();i++)\n        {\n   \
    \         if(arr[i]>0)\n                prod*=1;\n            else if(arr[i]<0)\n\
    \                prod*=-1;\n            else\n                prod*=0;\n     \
    \       sum+=abs(arr[i]);\n        }\n        return sum*prod;\n    }\n\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmph4hze276: /tmp/tmph4hze276.cpp:38: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 1;\n\
    \    int counter = 0;\n    for (auto x : arr) {\n        if (x == 0) {\n     \
    \       counter++;\n        }\n        else {\n            result *= x / abs(x);\n\
    \        }\n    }\n    if (counter == arr.size()) {\n        return {};\n    }\n\
    \    return std::accumulate(arr.begin(), arr.end(), 0, [](long &acc, long &x)\
    \ { return acc + abs(x); }) * result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "In file included from /usr/include/c++/11/numeric:62,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:84,\n             \
    \    from /tmp/tmp2n0iteu_.cpp:2:\n/usr/include/c++/11/bits/stl_numeric.h: In\
    \ instantiation of \u2018_Tp std::accumulate(_InputIterator, _InputIterator, _Tp,\
    \ _BinaryOperation) [with _InputIterator = __gnu_cxx::__normal_iterator<long int*,\
    \ std::vector<long int> >; _Tp = int; _BinaryOperation = prod_signs(std::vector<long\
    \ int>)::<lambda(long int&, long int&)>]\u2019:\n/tmp/tmp2n0iteu_.cpp:25:27: \
    \  required from here\n/usr/include/c++/11/bits/stl_numeric.h:169:29: error: no\
    \ match for call to \u2018(prod_signs(std::vector<long int>)::<lambda(long int&,\
    \ long int&)>) (int&, long int&)\u2019\n  169 |         __init = __binary_op(_GLIBCXX_MOVE_IF_20(__init),\
    \ *__first);\n      |                  ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/11/bits/stl_numeric.h:169:29: note: candidate: \u2018long int\
    \ (*)(long int&, long int&)\u2019 (conversion)\n/usr/include/c++/11/bits/stl_numeric.h:169:29:\
    \ note:   conversion of argument 2 would be ill-formed:\n/usr/include/c++/11/bits/stl_numeric.h:169:30:\
    \ error: cannot bind non-const lvalue reference of type \u2018long int&\u2019\
    \ to a value of type \u2018int\u2019\n  169 |         __init = __binary_op(_GLIBCXX_MOVE_IF_20(__init),\
    \ *__first);\n      |                              ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2n0iteu_.cpp:25:55:\
    \ note: candidate: \u2018prod_signs(std::vector<long int>)::<lambda(long int&,\
    \ long int&)>\u2019 (near match)\n   25 |     return std::accumulate(arr.begin(),\
    \ arr.end(), 0, [](long &acc, long &x) { return acc + abs(x); }) * result;\n \
    \     |                                                       ^\n/tmp/tmp2n0iteu_.cpp:25:55:\
    \ note:   conversion of argument 1 would be ill-formed:\nIn file included from\
    \ /usr/include/c++/11/numeric:62,\n                 from /usr/include/x86_64-linux-gnu/c++/11/bits/stdc++.h:84,\n\
    \                 from /tmp/tmp2n0iteu_.cpp:2:\n/usr/include/c++/11/bits/stl_numeric.h:169:30:\
    \ error: cannot bind non-const lvalue reference of type \u2018long int&\u2019\
    \ to a value of"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long prod_signs\
    \ = 1;\n  for (long elem : arr) {\n    sum_magnitudes += std::abs(elem);\n   \
    \ prod_signs *= (elem != 0) ? elem / std::abs(elem) : 1;\n  }\n  return sum_magnitudes\
    \ * prod_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpmgw9gkr_: /tmp/tmpmgw9gkr_.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    if (arr.size() == 0)\n        return std::nullopt;\n \
    \   for (auto i : arr) {\n        if (i == 0)\n            return 0;\n       \
    \ else if (i > 0)\n            sum += i;\n        else\n            sum -= i;\n\
    \        prod *= (i > 0) ? 1 : -1;\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpdh2qrpj0: /tmp/tmpdh2qrpj0.cpp:32: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto it : arr) {\n      \
    \  if (it < 0) prod *= -1;\n        else if (it == 0) prod = 0;\n    }\n    long\
    \ mag_sum = 0;\n    for (auto it : arr) mag_sum += std::abs(it);\n    return prod\
    \ * mag_sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpalyiql8a: /tmp/tmpalyiql8a.cpp:27: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int len = arr.size();\n\
    \    if(len == 0) return std::nullopt;\n    long ret = 1;\n    long sum = 0;\n\
    \    for(int i = 0; i < len; i++) {\n        if(arr[i] == 0) {\n            ret\
    \ = 0;\n            break;\n        }\n        if(arr[i] < 0) ret *= -1;\n   \
    \     sum += std::abs(arr[i]);\n    }\n    return ret * sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpsnxf86ym: /tmp/tmpsnxf86ym.cpp:31: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        sum += std::abs(arr[i]);\n\
    \        if (arr[i] < 0) {\n            prod *= -1;\n        } else if (arr[i]\
    \ == 0) {\n            prod = 0;\n        }\n    }\n    return prod * sum;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmphxymjlyg: /tmp/tmphxymjlyg.cpp:32: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long product = 1;\n    bool has_positive = false;\n    bool has_negative =\
    \ false;\n    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        if\
    \ (*it > 0) {\n            has_positive = true;\n            sum += *it;\n   \
    \         product *= 1;\n        } else if (*it < 0) {\n            has_negative\
    \ = true;\n            sum += *it * -1;\n            product *= -1;\n        }\n\
    \    }\n    if (arr.size() == 0) {\n        return std::nullopt;\n    } else if\
    \ (has_positive && has_negative) {\n        return sum * product;\n    } else\
    \ {\n        return 0;\n    }\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpksg99y80: /tmp/tmpksg99y80.cpp:40: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sums = 0;\n  long mults = 1;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    mults *= arr[i] > 0 ? 1 : arr[i] < 0 ? -1\
    \ : 0;\n    sums += std::abs(arr[i]);\n  }\n  return sums * mults;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp3epxu6sp: /tmp/tmp3epxu6sp.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (const\
    \ auto& num : arr) {\n        if (num > 0) {\n            prod *= 1;\n       \
    \     sum += num;\n        } else if (num < 0) {\n            prod *= -1;\n  \
    \          sum += abs(num);\n        } else {\n            return 0;\n       \
    \ }\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpq1l55ppa: /tmp/tmpq1l55ppa.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t// TODO: implement\n\
    \t//#1\n\t// if (arr.size() == 0)\n\t// \treturn std::nullopt;\n\t// int sum =\
    \ 0;\n\t// int n = arr.size();\n\t// for (int i = 0; i < n; i++)\n\t// {\n\t//\
    \ \tsum += std::abs(arr[i]);\n\t// }\n\t// if (arr[0] == 0)\n\t// \treturn 0;\n\
    \t// int prod = arr[0] / std::abs(arr[0]);\n\t// for (int i = 1; i < n; i++)\n\
    \t// {\n\t// \tif (arr[i] != 0)\n\t// \t\tprod *= arr[i] / std::abs(arr[i]);\n\
    \t// }\n\t// return prod * sum;\n\t\n\t//#2\n\tif (arr.size() == 0)\n\t\treturn\
    \ std::nullopt;\n\tint sum = 0;\n\tint prod = 1;\n\tfor (int& x : arr)\n\t{\n\t\
    \tsum += std::abs(x);\n\t\tif (x != 0)\n\t\t\tprod *= x / std::abs(x);\n\t}\n\t\
    return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpav9x8aru.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpav9x8aru.cpp:37:23: error: cannot bind non-const lvalue\
    \ reference of type \u2018int&\u2019 to a value of type \u2018long int\u2019\n\
    \   37 |         for (int& x : arr)\n      |                       ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long res = 1;\n  long\
    \ sum = 0;\n  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  else {\n\
    \    for (long i = 0; i < arr.size(); i++) {\n      if (arr[i] > 0) {\n      \
    \  res *= 1;\n        sum += arr[i];\n      }\n      else if (arr[i] < 0) {\n\
    \        res *= -1;\n        sum += abs(arr[i]);\n      }\n      else {\n    \
    \    return 0;\n      }\n    }\n    return res * sum;\n  }\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpl9gp6qln: /tmp/tmpl9gp6qln.cpp:39: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::cout << \"Input:\
    \ \";\n    for (const auto& num : arr) {\n        std::cout << num << \" \";\n\
    \    }\n    std::cout << \"\\n\";\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (const auto& num : arr) {\n  \
    \      if (num < 0) {\n            prod *= -1;\n        } else if (num == 0) {\n\
    \            return 0;\n        }\n        sum += std::abs(num);\n    }\n    return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp_1fevhor: /tmp/tmp_1fevhor.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // int sum = 0;\n\
    \    // for (auto i : arr) {\n    //     sum += i;\n    // }\n    // return sum;\n\
    \    return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmplueqb8qx: /tmp/tmplueqb8qx.cpp:21: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code goes\
    \ here\n    long sum=0;\n    long count =0;\n    if(arr.size() == 0)\n       \
    \ return std::nullopt;\n    else{\n        for(int i=0;i<arr.size();i++){\n  \
    \          if(arr[i]>0)\n                sum+=arr[i];\n            else if(arr[i]<0)\n\
    \                sum+=arr[i]*-1;\n            else if(arr[i]==0)\n           \
    \     count++;\n        }\n        if(count == arr.size())\n            return\
    \ 0;\n        else\n            return sum;\n    }\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp88gedhqn: /tmp/tmp88gedhqn.cpp:34: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sum = 0;\n\tlong sign_product = 1;\n\tfor (long n : arr)\
    \ {\n\t\tsum += std::abs(n);\n\t\tif (n > 0) sign_product *= 1;\n\t\telse if (n\
    \ < 0) sign_product *= -1;\n\t\telse sign_product *= 0;\n\t}\n\treturn sum * sign_product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpfkl061za: /tmp/tmpfkl061za.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  // your code\n  long prod = 1;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    prod *= arr[i] > 0 ? 1 : (arr[i] < 0 ? -1 : 0);\n  }\n  long sum\
    \ = 0;\n  for (long i = 0; i < arr.size(); i++) {\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpbjniohkr: /tmp/tmpbjniohkr.cpp:29: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long result = 1;\n    long sum_magnitudes = 0;\n \
    \   for (int i = 0; i < arr.size(); i++) {\n        sum_magnitudes += std::abs(arr[i]);\n\
    \        if (arr[i] != 0) {\n            result *= (arr[i] < 0 ? -1 : 1);\n  \
    \      }\n    }\n    return result * sum_magnitudes;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpxj1rgdcn: /tmp/tmpxj1rgdcn.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result;\n  \
    \  if (arr.size() != 0) {\n        result = 1;\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            result *= arr[i] / abs(arr[i]);\n        }\n        long\
    \ sum = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            sum +=\
    \ abs(arr[i]);\n        }\n        result *= sum;\n        return result;\n  \
    \  }\n    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return 0;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpl0eg0c8o: /tmp/tmpl0eg0c8o.cpp:16: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (int a : arr) {\n\
    \    if (a > 0) product *= 1;\n    else if (a < 0) product *= -1;\n    else product\
    \ *= 0;\n    sum += std::abs(a);\n  }\n  return sum * product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpu3e3743_: /tmp/tmpu3e3743_.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong magnitude = 1;\n\tlong sign = 1;\n\tfor\
    \ (auto x : arr) {\n\t\tmagnitude *= std::abs(x);\n\t\tsign *= x < 0 ? -1 : x\
    \ == 0 ? 0 : 1;\n\t}\n\treturn sign * magnitude;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpchvnijxf: /tmp/tmpchvnijxf.cpp:25: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::vector<long>\
    \ arr_sign;\n    long sum = 0;\n    for (auto number : arr) {\n        long n\
    \ = std::abs(number);\n        sum += n;\n        if (number == 0) {\n       \
    \     arr_sign.push_back(0);\n        } else if (number > 0) {\n            arr_sign.push_back(1);\n\
    \        } else {\n            arr_sign.push_back(-1);\n        }\n    }\n   \
    \ if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    long prod =\
    \ 1;\n    for (auto number : arr_sign) {\n        prod *= number;\n    }\n   \
    \ return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp_pds8vhn: /tmp/tmp_pds8vhn.cpp:39: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong sum = 0;\n\tlong\
    \ product = 1;\n\tfor (auto num : arr) {\n\t\tsum += abs(num);\n\t\tif (num >\
    \ 0) {\n\t\t\tproduct *= 1;\n\t\t} else if (num < 0) {\n\t\t\tproduct *= -1;\n\
    \t\t} else {\n\t\t\tproduct *= 0;\n\t\t}\n\t}\n\tif (arr.size() == 0) {\n\t\t\
    return {};\n\t}\n\treturn sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpvsdegzux: /tmp/tmpvsdegzux.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int sign_prod = 1;\n  int sum_abs = 0;\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    sum_abs += std::abs(arr[i]);\n    sign_prod\
    \ *= (arr[i] == 0) ? 1 : arr[i] / std::abs(arr[i]);\n  }\n  return sum_abs * sign_prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp5yqhtow2: /tmp/tmp5yqhtow2.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum_of_magnitudes = 0;\n  long product_of_signs = 1;\n\
    \  for (auto& i : arr) {\n    sum_of_magnitudes += std::abs(i);\n    if (i !=\
    \ 0) product_of_signs *= (i > 0 ? 1 : -1);\n  }\n  return sum_of_magnitudes *\
    \ product_of_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpgkplzagx: /tmp/tmpgkplzagx.cpp:24: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long magnitude = 0;\n    int sign\
    \ = 1;\n    for (auto a : arr) {\n        magnitude += std::abs(a);\n        sign\
    \ *= (a < 0) ? -1 : ((a > 0) ? 1 : 0);\n    }\n    return magnitude * sign;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpuxgxap29: /tmp/tmpuxgxap29.cpp:29: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong product = 0;\n\tlong sum = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tproduct += 1;\n\t\
    \t}\n\t\telse if (arr[i] < 0) {\n\t\t\tproduct -= 1;\n\t\t}\n\t\tsum += std::abs(arr[i]);\n\
    \t}\n\treturn product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpj948q6qq: /tmp/tmpj948q6qq.cpp:30: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long result = 1;\n  for (auto i : arr) {\n\
    \    long sign = std::copysign(1, i);\n    result *= sign * std::abs(i);\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpbu14_t1m: /tmp/tmpbu14_t1m.cpp:25: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sum = 0;\n\tlong sign = 1;\n\tfor (long x : arr) {\n\t\
    \tsum += abs(x);\n\t\tif (x != 0) {\n\t\t\tsign *= x / abs(x);\n\t\t}\n\t}\n\t\
    return sum * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp0elzr4nm: /tmp/tmp0elzr4nm.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpb5_e6j1d: /tmp/tmpb5_e6j1d.cpp:16: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  auto prod = std::accumulate(arr.begin(),\
    \ arr.end(), 1,\n    [](long acc, long val) {\n      auto prod = (val > 0 ? 1\
    \ : -1);\n      return acc * prod;\n    });\n  if (prod == 0) return std::nullopt;\n\
    \  auto sum = std::accumulate(arr.begin(), arr.end(), 0,\n    [](long acc, long\
    \ val) {\n      auto val1 = (val > 0 ? val : -val);\n      return acc + val1;\n\
    \    });\n  auto result = sum * prod;\n  return result;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpezodbr99: /tmp/tmpezodbr99.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\n\t// TODO:\n\n\treturn std::nullopt;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp67lxjnq8: /tmp/tmp67lxjnq8.cpp:22: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n\
    \    for (auto i : arr) {\n        if (i == 0) {\n            continue;\n    \
    \    }\n        sum += std::abs(i);\n        prod *= (i < 0) ? -1 : 1;\n    }\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpj1oai33v: /tmp/tmpj1oai33v.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long res = 1;\n \
    \   long sum = 0;\n    if (arr.size() == 0)\n        return {};\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        long val = arr[i];\n        if (val >\
    \ 0)\n            res *= 1;\n        else if (val < 0)\n            res *= -1;\n\
    \        else if (val == 0)\n            res *= 0;\n        sum += std::abs(val);\n\
    \    }\n    return sum * res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpcdxbfr6f: /tmp/tmpcdxbfr6f.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code goes\
    \ here\n    long sum = 0;\n    long product = 1;\n    for(auto i: arr){\n    \
    \    if(i>0){\n            sum += i;\n            product *= 1;\n        }\n \
    \       else if(i<0){\n            sum += i*-1;\n            product *= -1;\n\
    \        }\n        else{\n            product *= 0;\n        }\n    }\n    if(arr.size()\
    \ == 0){\n        return {};\n    }\n    return sum*product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpzozjqso6: /tmp/tmpzozjqso6.cpp:38: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int negatives = 0;\n    long product = 1;\n    for\
    \ (auto& i : arr) {\n        if (i < 0) negatives++;\n        if (i != 0) product\
    \ *= i;\n    }\n    if (negatives % 2 == 0) product *= 1;\n    else product *=\
    \ -1;\n    long sum = 0;\n    for (auto& i : arr) sum += std::abs(i);\n    return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpdma5eb_7: /tmp/tmpdma5eb_7.cpp:27: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int len = arr.size();\n\
    \    if (len == 0) {\n        return std::nullopt;\n    }\n    int sign = 1;\n\
    \    long sum = 0;\n    for (int i = 0; i < len; i++) {\n        long a = arr[i];\n\
    \        if (a < 0) {\n            sign *= -1;\n            a *= -1;\n       \
    \ } else if (a == 0) {\n            sign = 0;\n        }\n        sum += a;\n\
    \    }\n    return sum * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpl44rss41: /tmp/tmpl44rss41.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    for (long num\
    \ : arr) {\n        prod *= (num > 0) - (num < 0);\n    }\n    long sum = 0;\n\
    \    for (long num : arr) {\n        sum += std::abs(num);\n    }\n    return\
    \ prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp9s89a1wb: /tmp/tmp9s89a1wb.cpp:30: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong sign = 1;\n\tlong sum = 0;\n\tfor (const\
    \ auto& el : arr) {\n\t\tif (el != 0) {\n\t\t\tsign *= (el > 0) ? 1 : -1;\n\t\t\
    \tsum += abs(el);\n\t\t}\n\t}\n\treturn sign * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp91e4k8z1: /tmp/tmp91e4k8z1.cpp:28: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  for (auto &i : arr) {\n    sum += abs(i);\n\
    \  }\n  long prod = 1;\n  for (auto &i : arr) {\n    if (i < 0) {\n      prod\
    \ *= -1;\n    } else if (i == 0) {\n      prod = 0;\n      break;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpk0_bn677: /tmp/tmpk0_bn677.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long ans = 0;\n    long prod = 1;\n\
    \    for (long el : arr) {\n        if (el == 0) {\n            continue;\n  \
    \      }\n        ans += abs(el);\n        prod *= (el > 0) ? 1 : -1;\n    }\n\
    \    return ans * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmptu7u_07p: /tmp/tmptu7u_07p.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long signs_product\
    \ = 1;\n    long magnitudes_sum = 0;\n    if (arr.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    for (long item : arr) {\n        if (item > 0) {\n\
    \            signs_product *= 1;\n        } else if (item < 0) {\n           \
    \ signs_product *= -1;\n        } else {\n            signs_product *= 0;\n  \
    \      }\n        magnitudes_sum += std::abs(item);\n    }\n    return magnitudes_sum\
    \ * signs_product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpxb6yb50y: /tmp/tmpxb6yb50y.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (long\
    \ i = 0; i < arr.size(); i++) {\n    sum += std::abs(arr[i]);\n    if (arr[i]\
    \ < 0) {\n      prod *= -1;\n    } else if (arr[i] > 0) {\n      prod *= 1;\n\
    \    }\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp_h_e8tan: /tmp/tmp_h_e8tan.cpp:30: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long sum = 0;\n  long product = 1;\n  for\
    \ (const auto& n : arr) {\n    if (n > 0) {\n      sum += n;\n      product *=\
    \ 1;\n    } else if (n < 0) {\n      sum += abs(n);\n      product *= -1;\n  \
    \  } else {\n      product *= 0;\n    }\n  }\n\n  return sum * product;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpn7b04wv3: /tmp/tmpn7b04wv3.cpp:37: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ value = {};\n  if (arr.size() == 0) {\n    return value;\n  }\n  int prod =\
    \ 1;\n  long sum = 0;\n  for (auto it = arr.begin(); it != arr.end(); it++) {\n\
    \    if (*it < 0) {\n      prod *= -1;\n    } else if (*it > 0) {\n      prod\
    \ *= 1;\n    } else {\n      prod *= 0;\n    }\n    sum += std::abs(*it);\n  }\n\
    \  long ans = prod * sum;\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp4il93ehk: /tmp/tmp4il93ehk.cpp:36: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod_signs =\
    \ 0;\n    for (auto const& i : arr) {\n        if (i > 0)\n            prod_signs++;\n\
    \        else if (i < 0)\n            prod_signs--;\n    }\n    long res = 0;\n\
    \    for (auto const& i : arr) {\n        if (prod_signs > 0)\n            res\
    \ += std::abs(i);\n        else if (prod_signs < 0)\n            res -= std::abs(i);\n\
    \    }\n    if (arr.size() == 0)\n        return std::nullopt;\n    return res;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp7t06rptx: /tmp/tmp7t06rptx.cpp:32: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong sum = 0;\n\tlong pro = 1;\n\tfor (auto a\
    \ : arr) {\n\t\tsum += std::abs(a);\n\t\tif (a != 0) {\n\t\t\tpro *= a < 0 ? -1\
    \ : 1;\n\t\t}\n\t}\n\treturn sum * pro;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpgo492wky: /tmp/tmpgo492wky.cpp:28: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t//store signs\n\tstd::vector<long>\
    \ signStore;\n\t//store magnitudes\n\tstd::vector<long> magStore;\n\t//product\
    \ of all signs\n\tlong productSigns;\n\t//sum of all magnitudes\n\tlong sumMag;\n\
    \t//loop through array\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\t//check\
    \ if greater than zero\n\t\tif (arr[i] > 0) {\n\t\t\t//if so product of signs\
    \ is\n\t\t\tproductSigns = 1;\n\t\t\t//magnitude is current element\n\t\t\tsumMag\
    \ = arr[i];\n\t\t\t//add to both stores\n\t\t\tsignStore.push_back(productSigns);\n\
    \t\t\tmagStore.push_back(sumMag);\n\t\t}\n\t\t//else if less than zero\n\t\telse\
    \ if (arr[i] < 0) {\n\t\t\t//product of signs is\n\t\t\tproductSigns = -1;\n\t\
    \t\t//magnitude is positive value of current element\n\t\t\tsumMag = std::abs(arr[i]);\n\
    \t\t\t//add to both stores\n\t\t\tsignStore.push_back(productSigns);\n\t\t\tmagStore.push_back(sumMag);\n\
    \t\t}\n\t\t//else zero\n\t\telse {\n\t\t\t//product of signs is zero\n\t\t\tproductSigns\
    \ = 0;\n\t\t\t//magnitude is zero\n\t\t\tsumMag = 0;\n\t\t\t//add to both stores\n\
    \t\t\tsignStore.push_back(productSigns);\n\t\t\tmagStore.push_back(sumMag);\n\t\
    \t}\n\t}\n\t//if no elements in array\n\tif (arr.size() == 0) {\n\t\t//return\
    \ 0\n\t\treturn {};\n\t}\n\t//check if all values are 0\n\t//loop through array\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\t//if any values are not zero\n\t\
    \tif (arr[i] != 0) {\n\t\t\t//break\n\t\t\tbreak;\n\t\t}\n\t\t//\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpadxjg4jt.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpadxjg4jt.cpp:68:9: warning: empty parentheses were disambiguated\
    \ as a function declaration [-Wvexing-parse]\n   68 | int main() {\n      |  \
    \       ^~\n/tmp/tmpadxjg4jt.cpp:68:9: note: remove parentheses to default-initialize\
    \ a variable\n   68 | int main() {\n      |         ^~\n      |         --\n/tmp/tmpadxjg4jt.cpp:68:9:\
    \ note: or replace parentheses with braces to value-initialize a variable\n/tmp/tmpadxjg4jt.cpp:68:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   68 | int main() {\n      |            ^\n/tmp/tmpadxjg4jt.cpp:78:2: error:\
    \ expected \u2018}\u2019 at end of input\n   78 | }\n      |  ^\n/tmp/tmpadxjg4jt.cpp:11:55:\
    \ note: to match this \u2018{\u2019\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |                                                       ^\n/tmp/tmpadxjg4jt.cpp:78:2:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   78 | }\n\
    \      |  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long positive = 0;\n  long negative = 0;\n  long zeros = 0;\n\
    \  for (auto i : arr) {\n    if (i == 0) {\n      zeros++;\n    } else if (i >\
    \ 0) {\n      positive++;\n    } else {\n      negative++;\n    }\n  }\n  long\
    \ product = 1;\n  for (int i = 0; i < negative; i++) {\n    product *= -1;\n \
    \ }\n  for (int i = 0; i < zeros; i++) {\n    product *= 0;\n  }\n  return product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpbldr2758: /tmp/tmpbldr2758.cpp:36: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for (auto\
    \ i : arr) {\n    product *= (i < 0) ? -1 : (i == 0) ? 0 : 1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp41wqo41u: /tmp/tmp41wqo41u.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  //your code goes here\n\
    \    if(arr.size()==0)\n    {\n        return {};\n    }\n    long sum=0;\n  \
    \  long prod=1;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]>0)\n\
    \        {\n            sum=sum+arr[i];\n            prod=prod*1;\n        }\n\
    \        else if(arr[i]<0)\n        {\n            sum=sum+abs(arr[i]);\n    \
    \        prod=prod*(-1);\n        }\n        else\n        {\n            prod=prod*0;\n\
    \        }\n    }\n    return sum*prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpjuwis580: /tmp/tmpjuwis580.cpp:43: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod_signs = 1;\n    long sum_magnitudes\
    \ = 0;\n    for (auto n : arr) {\n        sum_magnitudes += std::abs(n);\n   \
    \     if (n < 0) {\n            prod_signs *= -1;\n        } else if (n > 0) {\n\
    \            prod_signs *= 1;\n        }\n    }\n    return sum_magnitudes * prod_signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpi0uu0lmp: /tmp/tmpi0uu0lmp.cpp:30: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if(n == 0)\n        return std::nullopt;\n    long prod = 1;\n    long sum\
    \ = 0;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > 0)\n           \
    \ prod *= 1;\n        else if(arr[i] < 0)\n            prod *= -1;\n        else\n\
    \            prod *= 0;\n        sum += std::abs(arr[i]);\n    }\n    return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp8d1wmcf2: /tmp/tmp8d1wmcf2.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int len = arr.size();\n    int sum = 0;\n    int ans\
    \ = 1;\n    for (int i = 0; i < len; i++) {\n        long num = arr[i];\n    \
    \    int sign = 0;\n        if (num > 0) {\n            sign = 1;\n        } else\
    \ if (num < 0) {\n            sign = -1;\n        }\n        ans *= sign;\n  \
    \      sum += abs(num);\n    }\n    long final = sum * ans;\n    return final;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpakitbbb6: /tmp/tmpakitbbb6.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long result = 0;\n  for\
    \ (auto n : arr) {\n    if (n > 0) {\n      product *= 1;\n    } else if (n <\
    \ 0) {\n      product *= -1;\n    } else {\n      product *= 0;\n    }\n    result\
    \ += std::abs(n);\n  }\n  return result * product;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpfhu3ge1o: /tmp/tmpfhu3ge1o.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sign_prod = 1;\n\tlong total = 0;\n\tfor (auto x : arr)\
    \ {\n\t\tif (x != 0) {\n\t\t\tsign_prod *= x > 0 ? 1 : -1;\n\t\t\ttotal += std::abs(x);\n\
    \t\t}\n\t}\n\treturn total * sign_prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpvlandyyp: /tmp/tmpvlandyyp.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long prod = 1;\n  long sum = 0;\n  for (long\
    \ num : arr) {\n    if (num < 0) {\n      prod *= -1;\n    } else if (num > 0)\
    \ {\n      sum += num;\n    }\n  }\n  return prod * sum;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpkhmhdirn: /tmp/tmpkhmhdirn.cpp:29: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long total = 1;\n    long sum = 0;\n    for (auto\
    \ i : arr) {\n        if (i > 0) {\n            total *= 1;\n            sum +=\
    \ i;\n        } else if (i < 0) {\n            total *= -1;\n            sum +=\
    \ abs(i);\n        } else if (i == 0) {\n            return 0;\n        }\n  \
    \  }\n    return total * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpvf_bvx4k: /tmp/tmpvf_bvx4k.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::sort(arr.begin(),\
    \ arr.end());\n    if (arr.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    std::optional<long> result = 1;\n    int counter = 0;\n    while (arr[counter]\
    \ == 0) {\n        counter++;\n    }\n    for (int i = counter; i < arr.size();\
    \ i++) {\n        if (arr[i] > 0) {\n            result = result.value() * arr[i];\n\
    \        } else {\n            result = result.value() * (-1) * arr[i];\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp_0rlfl6h: /tmp/tmp_0rlfl6h.cpp:32: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sign = 1;\n  for (auto i : arr) {\n    if (i > 0)\n  \
    \    sign *= 1;\n    else if (i < 0)\n      sign *= -1;\n    else\n      sign\
    \ *= 0;\n  }\n  long sum = 0;\n  for (auto i : arr) {\n    sum += abs(i);\n  }\n\
    \  return sign * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpbd7n_d1t: /tmp/tmpbd7n_d1t.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long sign = 1;\n    long sum = 0;\n    for (long i\
    \ = 0; i < arr.size(); i++) {\n        long num = arr[i];\n        if (num < 0)\
    \ sign *= -1;\n        if (num != 0) sum += abs(num);\n    }\n    return sum *\
    \ sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpf75rhw4r: /tmp/tmpf75rhw4r.cpp:25: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 1;\n\
    \    int counter = 0;\n    for (auto el : arr) {\n        result *= el > 0 ? 1\
    \ : (el < 0 ? -1 : 0);\n        if (el == 0) {\n            counter++;\n     \
    \   }\n    }\n    return counter > 0 ? std::nullopt : result;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0glfd_wh.cpp: In function \u2018std::optional<long int> prod_signs(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp0glfd_wh.cpp:20:24: error: operands to \u2018?:\u2019\
    \ have different types \u2018const std::nullopt_t\u2019 and \u2018long int\u2019\
    \n   20 |     return counter > 0 ? std::nullopt : result;\n      |           \
    \ ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long product = 1;\n  for (auto&\
    \ elem : arr) {\n    sum += std::abs(elem);\n    if (elem > 0) {\n      product\
    \ *= 1;\n    } else if (elem < 0) {\n      product *= -1;\n    } else {\n    \
    \  product *= 0;\n    }\n  }\n  return sum * product;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpnmezbh8b: /tmp/tmpnmezbh8b.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long sum_magnitudes = 0;\n   \
    \ long prod_signs = 1;\n    for (auto n : arr) {\n        sum_magnitudes += std::abs(n);\n\
    \        if (n > 0) {\n            prod_signs *= 1;\n        } else if (n < 0)\
    \ {\n            prod_signs *= -1;\n        } else {\n            prod_signs *=\
    \ 0;\n        }\n    }\n    return sum_magnitudes * prod_signs;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpi4qbem73: /tmp/tmpi4qbem73.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto product_of_signs = std::accumulate(arr.begin(),\
    \ arr.end(), 1, [](long lhs, long rhs) {\n        return lhs * (rhs < 0 ? -1 :\
    \ (rhs > 0 ? 1 : 0));\n    });\n    auto sum_of_magnitudes = std::accumulate(arr.begin(),\
    \ arr.end(), 0, [](long lhs, long rhs) {\n        return lhs + std::abs(rhs);\n\
    \    });\n    return product_of_signs * sum_of_magnitudes;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmphsnna1_i: /tmp/tmphsnna1_i.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ &&num : arr) {\n    if (num == 0) {\n      continue;\n    }\n    if (num > 0)\
    \ {\n      prod *= 1;\n    } else {\n      prod *= -1;\n    }\n    sum += std::abs(num);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpjfab_cvk: /tmp/tmpjfab_cvk.cpp:33: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong p = 1;\n\tlong s = 0;\n\tfor (auto n : arr)\
    \ {\n\t\tif (n == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tp *= -1;\n\
    \t\t}\n\t\ts += std::abs(n);\n\t}\n\treturn p * s;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmppo06yplr: /tmp/tmppo06yplr.cpp:31: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long prod = 1;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] > 0) {\n      prod *= 1;\n    } else if (arr[i] < 0)\
    \ {\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  long sum\
    \ = 0;\n  for (long i = 0; i < arr.size(); i++) {\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp2qjfgc1h: /tmp/tmp2qjfgc1h.cpp:36: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    long sum = 0;\n    for (const\
    \ auto& elem : arr) {\n        int sign = 1;\n        if (elem == 0) {\n     \
    \       continue;\n        } else if (elem < 0) {\n            sign = -1;\n  \
    \      }\n        product *= sign;\n        sum += std::abs(elem);\n    }\n  \
    \  return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpj3o2qlne: /tmp/tmpj3o2qlne.cpp:30: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n\
    \    for (auto i : arr) {\n        sum += std::abs(i);\n        if (i != 0) {\n\
    \            prod *= i > 0 ? 1 : -1;\n        }\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmphzdz2al0: /tmp/tmphzdz2al0.cpp:28: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here.\n\
    \    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp4d2dzwn6: /tmp/tmp4d2dzwn6.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long res = 1;\n \
    \   long sum = 0;\n    for (auto i : arr) {\n        if (i > 0) {\n          \
    \  res *= 1;\n            sum += i;\n        } else if (i < 0) {\n           \
    \ res *= -1;\n            sum += -i;\n        } else {\n            res *= 0;\n\
    \        }\n    }\n    return res * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here!\n\
    \    if(arr.size() == 0) return std::nullopt;\n    else if(arr.size() == 1) return\
    \ arr[0];\n    long sum = 0;\n    long prod = 1;\n    for(auto& i : arr){\n  \
    \      if(i>0) {\n            sum += i;\n            prod *= 1;\n        }\n \
    \       else if(i<0) {\n            sum += -i;\n            prod *= -1;\n    \
    \    }\n        else prod *= 0;\n    }\n    return sum*prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp0bmqlcz9: /tmp/tmp0bmqlcz9.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  int\
    \ prod = 1;\n  for (auto a : arr) {\n    if (a > 0) {\n      sum += a;\n     \
    \ prod *= 1;\n    } else if (a < 0) {\n      sum += abs(a);\n      prod *= -1;\n\
    \    } else {\n      prod *= 0;\n    }\n  }\n  if (arr.size() == 0) {\n    return\
    \ {};\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp70f9a7qy: /tmp/tmp70f9a7qy.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod_signs = 1;\n    long sum_magnitudes = 0;\n\
    \    for (const auto& val : arr) {\n        switch (val) {\n            case 0:\n\
    \                break;\n            case 1:\n            case -1:\n         \
    \       prod_signs *= val;\n                break;\n            default:\n   \
    \             prod_signs *= (val > 0 ? 1 : -1);\n                sum_magnitudes\
    \ += abs(val);\n        }\n    }\n    return sum_magnitudes * prod_signs;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpa7fz9ttg: /tmp/tmpa7fz9ttg.cpp:32: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  if(arr.size()<1)\n    return {};\n  long sum = 0;\n  long product = 1;\n  for(int\
    \ i = 0; i < arr.size(); i++){\n    if(arr[i] < 0)\n      product *= -1;\n   \
    \ else if(arr[i] == 0)\n      product *= 0;\n    sum += abs(arr[i]);\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpkw_3nbhm: /tmp/tmpkw_3nbhm.cpp:31: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n\
    \    for (const auto& i : arr) {\n        auto sign = (i == 0) ? 0 : i / std::abs(i);\n\
    \        prod *= sign;\n        sum += std::abs(i);\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpkg4th0og: /tmp/tmpkg4th0og.cpp:29: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // If the array is\
    \ empty return None\n    if (arr.empty()) {\n        return std::nullopt;\n  \
    \  }\n    // We need to find the product of all signs of each element in the array\n\
    \    // and the sum of magnitudes of integers.\n    // We can do that by making\
    \ use of the reduce function.\n    // We multiply each element in the array by\
    \ it's sign which will tell us\n    // what is the sign of the current element.\n\
    \    // Then we take the product of all the elements which will give us the\n\
    \    // product of all signs of each element in the array.\n    long product_of_signs\
    \ = std::reduce(arr.begin(), arr.end(), 1,\n        [](long a, long b) { return\
    \ a * std::copysign(1, b); });\n    // We also take the sum of all the absolute\
    \ values of the array.\n    long sum_of_magnitudes = std::reduce(arr.begin(),\
    \ arr.end(), 0,\n        [](long a, long b) { return a + std::abs(b); });\n  \
    \  // We return the product of the sum and the product.\n    return product_of_signs\
    \ * sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpiz7hyyga: /tmp/tmpiz7hyyga.cpp:34: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long magnitude = 0;\n\
    \  long sign = 1;\n  for (auto number : arr) {\n    magnitude += std::abs(number);\n\
    \    if (number > 0) {\n      sign *= 1;\n    } else if (number < 0) {\n     \
    \ sign *= -1;\n    } else {\n      sign *= 0;\n    }\n  }\n  if (arr.size() ==\
    \ 0) {\n    return std::nullopt;\n  }\n  return magnitude * sign;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpwnxctv6i: /tmp/tmpwnxctv6i.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long product = 1;\n\
    \  long sum = 0;\n  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  for\
    \ (long i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      product =\
    \ product * 0;\n    } else if (arr[i] > 0) {\n      product = product * 1;\n \
    \     sum = sum + arr[i];\n    } else {\n      product = product * -1;\n     \
    \ sum = sum + -arr[i];\n    }\n  }\n  return product * sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpplb2_owh: /tmp/tmpplb2_owh.cpp:35: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if(n == 0)\n    return std::nullopt;\n  long p = 1;\n  long s = 0;\n  for(int\
    \ i = 0; i < n; i++) {\n    if(arr[i] == 0) {\n      continue;\n    }\n    if(arr[i]\
    \ < 0) {\n      s++;\n    }\n    p *= arr[i];\n  }\n  if(s % 2 == 0) {\n    return\
    \ p;\n  }\n  return -p;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpg8n7l9r4: /tmp/tmpg8n7l9r4.cpp:33: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    if (arr.size() == 1) return arr[0];\n    if (arr.size()\
    \ == 2) return arr[0] * arr[1];\n    long prod = 1;\n    for (const auto& el :\
    \ arr) {\n        if (el > 0) prod *= 1;\n        else if (el < 0) prod *= -1;\n\
    \        else prod *= 0;\n    }\n    long result = 0;\n    for (const auto& el\
    \ : arr) {\n        result += std::abs(el);\n    }\n    return result * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpi2wnl_fd: /tmp/tmpi2wnl_fd.cpp:32: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long product = 1;\n  for (auto\
    \ a : arr) {\n    a > 0 ? sum += a : sum += -a;\n    a > 0 ? product *= 1 : a\
    \ < 0 ? product *= -1 : product *= 0;\n  }\n  return sum * product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpbmc8yutt: /tmp/tmpbmc8yutt.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code here\n\
    \    return 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpnobl6ak4: /tmp/tmpnobl6ak4.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpi54_pqc7: /tmp/tmpi54_pqc7.cpp:16: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto x : arr) {\n        if (x > 0) {\n            product *=\
    \ 1;\n        } else if (x < 0) {\n            product *= -1;\n        } else\
    \ {\n            product *= 0;\n        }\n        sum += std::abs(x);\n    }\n\
    \    return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpji7anthl: /tmp/tmpji7anthl.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long result = 1;\n    long sum =\
    \ 0;\n    for (auto const &item : arr) {\n        sum += std::abs(item);\n   \
    \     if (item != 0) {\n            result *= item / std::abs(item);\n       \
    \ }\n    }\n    return sum * result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmphzkh8_0o: /tmp/tmphzkh8_0o.cpp:28: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto i : arr) {\n        if (i < 0) {\n            product *=\
    \ -1;\n        } else if (i == 0) {\n            return 0;\n        }\n      \
    \  sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpunnnifs4: /tmp/tmpunnnifs4.cpp:32: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  int\
    \ prod = 1;\n  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  for (long\
    \ i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      return 0;\n   \
    \ }\n    sum += abs(arr[i]);\n    if (arr[i] < 0) {\n      prod *= -1;\n    }\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpr3alqql8: /tmp/tmpr3alqql8.cpp:33: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod_sign =\
    \ 1;\n    long sum_magn = 0;\n    for (int el: arr) {\n        int abs_el = abs(el);\n\
    \        if (el == 0)\n            continue;\n        else\n            prod_sign\
    \ *= el / abs_el;\n        sum_magn += abs_el;\n    }\n    if (arr.size() == 0)\n\
    \        return std::nullopt;\n    else\n        return sum_magn * prod_sign;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpj87j3yrs: /tmp/tmpj87j3yrs.cpp:30: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long signProd = 1;\n    long sum\
    \ = 0;\n    for (const auto& i : arr) {\n        if (i > 0) {\n            signProd\
    \ *= 1;\n        } else if (i < 0) {\n            signProd *= -1;\n        } else\
    \ {\n            signProd *= 0;\n        }\n        sum += std::abs(i);\n    }\n\
    \    return signProd * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmpmqvvk26f: /tmp/tmpmqvvk26f.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::vector<long>\
    \ signs;\n    std::vector<long> mags;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] < 0) {\n            signs.push_back(-1);\n           \
    \ mags.push_back(arr[i] * -1);\n        } else if (arr[i] > 0) {\n           \
    \ signs.push_back(1);\n            mags.push_back(arr[i]);\n        } else {\n\
    \            signs.push_back(0);\n            mags.push_back(0);\n        }\n\
    \    }\n    if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    long\
    \ prod = std::accumulate(signs.begin(), signs.end(), 1, std::multiplies<>());\n\
    \    long sum = std::accumulate(mags.begin(), mags.end(), 0);\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmplvsia89w: /tmp/tmplvsia89w.cpp:38: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // TODO\n    if(arr.size()\
    \ == 0)\n        return {};\n    else\n    {\n        long prod_signs_var = 1;\n\
    \        long prod_magnitude_var = 0;\n        for(int i = 0; i < arr.size();\
    \ i++)\n        {\n            if(arr[i] == 0)\n                return 0;\n  \
    \          else if(arr[i] > 0)\n                prod_signs_var *= 1;\n       \
    \     else\n                prod_signs_var *= -1;\n            prod_magnitude_var\
    \ += abs(arr[i]);\n        }\n        return prod_signs_var * prod_magnitude_var;\n\
    \    }\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpqfrwgjjj: /tmp/tmpqfrwgjjj.cpp:37: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Enter your code\
    \ here\n  int prod = 1;\n  long sum = 0;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    if (arr[i] > 0) {\n      prod *= 1;\n      sum += arr[i];\n    } else\
    \ if (arr[i] < 0) {\n      prod *= -1;\n      sum += arr[i];\n    } else {\n \
    \     prod *= 0;\n    }\n  }\n  return prod * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmplpmy5wv8: /tmp/tmplpmy5wv8.cpp:30: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpkeckistd: /tmp/tmpkeckistd.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sign_prod = 1;\n  long sum_of_magnitudes\
    \ = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n      sign_prod *= 1;\n    }\
    \ else if (i < 0) {\n      sign_prod *= -1;\n    } else {\n      sign_prod *=\
    \ 0;\n    }\n    sum_of_magnitudes += std::abs(i);\n  }\n  return sign_prod *\
    \ sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpugmw6v1t: /tmp/tmpugmw6v1t.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int positive = 0;\n  int negative = 0;\n  long count = 1;\n\
    \  for (auto i : arr) {\n    count *= std::abs(i);\n    if (i > 0)\n      positive++;\n\
    \    else if (i < 0)\n      negative++;\n  }\n  long sum = 0;\n  if (positive\
    \ % 2 == 0)\n    sum = count;\n  else\n    sum = -count;\n  return sum;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpjkb9rleh: /tmp/tmpjkb9rleh.cpp:32: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // placeholder\n  return\
    \ 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpctwbvx3j: /tmp/tmpctwbvx3j.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long sums = 0;\n  long prod = 1;\n  for (const\
    \ auto& num : arr) {\n    if (num == 0) {\n      continue;\n    }\n\n    if (num\
    \ > 0) {\n      sums += num;\n    } else {\n      sums -= num;\n      prod *=\
    \ -1;\n    }\n  }\n\n  return sums * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp_ezopv9d: /tmp/tmp_ezopv9d.cpp:36: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong product = 1;\n\tlong sum = 0;\n\tstd::vector<long>\
    \ signs;\n\tfor (auto it = arr.begin(); it != arr.end(); ++it) {\n\t\tif (*it\
    \ < 0) {\n\t\t\tproduct *= -1;\n\t\t\tsigns.push_back(-1);\n\t\t} else if (*it\
    \ > 0) {\n\t\t\tsigns.push_back(1);\n\t\t} else {\n\t\t\tsigns.push_back(0);\n\
    \t\t}\n\t\tsum += std::abs(*it);\n\t}\n\tstd::vector<long> all_zeros = {0, 0,\
    \ 0};\n\tfor (auto it = signs.begin(); it != signs.end(); ++it) {\n\t\tif (std::equal(signs.begin(),\
    \ signs.end(), all_zeros.begin())) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpynjofbom: /tmp/tmpynjofbom.cpp:40: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ ret(0);\n    // test case\n    if (arr.size() == 0) {\n        return ret;\n\
    \    }\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    return ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpmvgky90g: /tmp/tmpmvgky90g.cpp:30: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::vector<int> signs;\n\
    \  long sum = 0;\n  for (auto& num : arr) {\n    if (num < 0) {\n      signs.push_back(-1);\n\
    \      sum += abs(num);\n    } else if (num > 0) {\n      signs.push_back(1);\n\
    \      sum += abs(num);\n    } else {\n      signs.push_back(0);\n    }\n  }\n\
    \  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  long result = sum;\n\
    \  for (auto& sign : signs) {\n    result *= sign;\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpsxg6qz4c: /tmp/tmpsxg6qz4c.cpp:39: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sum = 0;\n    for (auto x : arr) {\n        sum += std::abs(x);\n  \
    \      if (x == 0) continue;\n        if (x > 0) {\n            prod *= 1;\n \
    \       } else {\n            prod *= -1;\n        }\n    }\n    if (sum == 0)\
    \ {\n        return std::nullopt;\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp1qg8na7z: /tmp/tmp1qg8na7z.cpp:31: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpv1hhfm3z: /tmp/tmpv1hhfm3z.cpp:16: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong sum=0;\n\tlong\
    \ product=1;\n\tfor(int i=0;i<arr.size();i++){\n\t\tif(arr[i]<0){\n\t\t\tsum +=\
    \ arr[i]*(-1);\n\t\t\tproduct *= -1;\n\t\t}\n\t\telse if(arr[i]>0){\n\t\t\tsum\
    \ += arr[i];\n\t\t\tproduct *= 1;\n\t\t}\n\t\telse if(arr[i]==0){\n\t\t\tcontinue;\n\
    \t\t}\n\t}\n\treturn product*sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp4mn_lr8z: /tmp/tmp4mn_lr8z.cpp:32: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod_signs = 1;\n    long sum_magnitude\
    \ = 0;\n    for (auto elem : arr) {\n        if (elem == 0) {\n            continue;\n\
    \        }\n        prod_signs *= elem < 0 ? -1 : 1;\n        sum_magnitude +=\
    \ std::abs(elem);\n    }\n    return sum_magnitude * prod_signs;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp5y1tm_xw: /tmp/tmp5y1tm_xw.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long result = 0;\n    long prod\
    \ = 1;\n    for (auto i : arr) {\n        i < 0 ? prod *= -1 : prod;\n       \
    \ result += std::abs(i);\n    }\n    return result * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp00rmrwg4: /tmp/tmp00rmrwg4.cpp:27: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long sign = 1;\n    long magnitude\
    \ = 0;\n    for (auto &num : arr) {\n        if (num < 0) {\n            sign\
    \ *= -1;\n        }\n        magnitude += std::abs(num);\n    }\n    return magnitude\
    \ * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp2ewnxibl: /tmp/tmp2ewnxibl.cpp:29: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    long sum = 0;\n    for (auto\
    \ x : arr) {\n        sum += std::abs(x);\n        if (x > 0) {\n            product\
    \ *= 1;\n        } else if (x < 0) {\n            product *= -1;\n        } else\
    \ {\n            product *= 0;\n        }\n    }\n    return sum * product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpby8rdt85: /tmp/tmpby8rdt85.cpp:32: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(arr.size()\
    \ < 6);\n    long result = 0;\n    long prodsigns = 1;\n    for (auto i : arr)\
    \ {\n        prodsigns *= std::copysign(1, i);\n        result += std::abs(i);\n\
    \    }\n    if (arr.size() == 0)\n        return std::nullopt;\n    return result\
    \ * prodsigns;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp_h6auuf0: /tmp/tmp_h6auuf0.cpp:26: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int sign = 0;\n  long product = 1;\n  long sum\
    \ = 0;\n  for (auto elem : arr) {\n    sign = std::signbit(elem) ? -1 : 1;\n \
    \   if (sign == 0) {\n      product = product * 0;\n    } else {\n      product\
    \ = product * sign;\n    }\n    sum = sum + std::abs(elem);\n  }\n  return product\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpchafy0mf: /tmp/tmpchafy0mf.cpp:32: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // TODO: your code\
    \ here\n    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp_yqkbrjt: /tmp/tmp_yqkbrjt.cpp:17: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (const\
    \ auto &item : arr) {\n    long sign = std::signbit(item) ? -1 : (item > 0) ?\
    \ 1 : 0;\n    sum += std::abs(item);\n    prod *= sign;\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp886y1qpb: /tmp/tmp886y1qpb.cpp:29: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::vector<long> signs(arr.size());\n\
    \    std::transform(arr.begin(), arr.end(), signs.begin(), [](long a) { return\
    \ (a < 0) ? -1 : ((a > 0) ? 1 : 0); });\n    std::vector<long> abs_arr(arr.size());\n\
    \    std::transform(arr.begin(), arr.end(), abs_arr.begin(), [](long a) { return\
    \ std::abs(a); });\n    long prod = std::accumulate(signs.begin(), signs.end(),\
    \ 1, std::multiplies<long>());\n    long sum = std::accumulate(abs_arr.begin(),\
    \ abs_arr.end(), 0L);\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "tmp9amr1urf: /tmp/tmp9amr1urf.cpp:28: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long signProd = 1;\n    long magSum\
    \ = 0;\n    for (long num : arr) {\n        if (num == 0) {\n            signProd\
    \ = 0;\n            magSum = 0;\n            break;\n        }\n        if (num\
    \ > 0) {\n            signProd *= 1;\n        } else {\n            signProd *=\
    \ -1;\n        }\n        magSum += std::abs(num);\n    }\n    return signProd\
    \ * magSum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpqubo49x2: /tmp/tmpqubo49x2.cpp:37: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n\
    \    for (auto i : arr) {\n        sum += std::abs(i);\n        if (i == 0) {\n\
    \            prod = 0;\n        } else if (i > 0) {\n            prod *= 1;\n\
    \        } else {\n            prod *= -1;\n        }\n    }\n    return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpcqqxyeup: /tmp/tmpcqqxyeup.cpp:34: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto product = [](long acc, auto\
    \ item) {\n        if (item < 0) {\n            return acc * -1;\n        } else\
    \ if (item > 0) {\n            return acc * 1;\n        } else {\n           \
    \ return acc * 0;\n        }\n    };\n    auto prod = std::accumulate(arr.begin(),\
    \ arr.end(), 1L, product);\n    auto magnitude = [](long acc, auto item) {\n \
    \       return acc + abs(item);\n    };\n    auto mag = std::accumulate(arr.begin(),\
    \ arr.end(), 0L, magnitude);\n    return std::make_optional(prod * mag);\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmpyz003oip: /tmp/tmpyz003oip.cpp:36: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::optional<long>({}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (auto&\
    \ e : arr) {\n        if (e > 0) {\n            prod *= 1;\n            sum +=\
    \ e;\n        } else if (e < 0) {\n            prod *= -1;\n            sum +=\
    \ -e;\n        } else {\n            sum += 0;\n        }\n    }\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp18nah6in: /tmp/tmp18nah6in.cpp:31: int main(): Assertion `candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   int prod = 1;\n    std::vector<long> positive;\n    std::vector<long> negative;\n\
    \    if (arr.size() == 0) {\n        return {};\n    }\n    for (int i = 0; i\
    \ < arr.size(); i++) {\n        if (arr[i] == 0) {\n            return 0;\n  \
    \      }\n        if (arr[i] > 0) {\n            positive.push_back(arr[i]);\n\
    \        }\n        if (arr[i] < 0) {\n            negative.push_back(arr[i]);\n\
    \        }\n    }\n    for (int i = 0; i < positive.size(); i++) {\n        sum\
    \ += positive[i];\n    }\n    for (int i = 0; i < negative.size(); i++) {\n  \
    \      sum += abs(negative[i]);\n    }\n    if (positive.size() > 0 && negative.size()\
    \ > 0) {\n        return sum;\n    }\n    else if (positive.size() > 0 && negative.size()\
    \ == 0) {\n        return prod * sum;\n    }\n    else if (positive.size() ==\
    \ 0 && negative.size() > 0) {\n        return prod * sum;\n    }\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "tmp55_h4j0q: /tmp/tmp55_h4j0q.cpp:48: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9))' failed.\n"
  exit_code: -6
  status: Exception
