name: HumanEval_128_prod_signs
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // iterate arr\n\
    \    //   sum magnitudes\n    //   iterate signs\n    //     prod signs\n    if\
    \ (arr.empty()) {\n        return std::nullopt;\n    }\n    long sum = 0;\n  \
    \  long product = 1;\n    for (auto const val : arr) {\n        sum += std::abs(val);\n\
    \        product *= std::signbit(val) ? -1 : 1;\n    }\n    return sum * product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgjx88fx3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgjx88fx3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgjx88fx3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgjx88fx3.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgjx88fx3.cpp:2:\n/tmp/tmpgjx88fx3.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgjx88fx3.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgjx88fx3.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgjx88fx3.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgjx88fx3.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgjx88fx3.cpp:2:\n/tmp/tmpgjx88fx3.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int pos = 0;\n  \
    \  int neg = 0;\n    long sum = 0;\n    if (arr.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    for (int i = 0; i < arr.size(); i++) {\n        if\
    \ (arr[i] < 0) {\n            neg++;\n        }\n        if (arr[i] > 0) {\n \
    \           pos++;\n        }\n        sum += abs(arr[i]);\n    }\n    int prod\
    \ = (neg % 2 == 0) ? 1 : -1;\n    prod *= (pos > 0) ? 1 : 0;\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps6en77bk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmps6en77bk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmps6en77bk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmps6en77bk.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps6en77bk.cpp:2:\n/tmp/tmps6en77bk.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmps6en77bk.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmps6en77bk.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmps6en77bk.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmps6en77bk.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps6en77bk.cpp:2:\n/tmp/tmps6en77bk.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Implement me!\n\
    \  int count = 0;\n  long mul = 1;\n  for(int i = 0; i < arr.size(); i++){\n \
    \   if(arr[i] == 0){\n      return 0;\n    }\n    else if(arr[i] < 0){\n     \
    \ mul *= -1;\n      count++;\n    }\n  }\n  if(count % 2 == 0){\n    return mul;\n\
    \  }\n  else {\n    return mul * -1;\n  }\n  return 0;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpibsxvf2b.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpibsxvf2b.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpibsxvf2b.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpibsxvf2b.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpibsxvf2b.cpp:2:\n/tmp/tmpibsxvf2b.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpibsxvf2b.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpibsxvf2b.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpibsxvf2b.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpibsxvf2b.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpibsxvf2b.cpp:2:\n/tmp/tmpibsxvf2b.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long result = 0;\n    long signs\
    \ = 1;\n    for (auto num : arr) {\n        signs *= num < 0 ? -1 : num == 0 ?\
    \ 0 : 1;\n        result += std::abs(num);\n    }\n    return result * signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3_9b9_mc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3_9b9_mc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3_9b9_mc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3_9b9_mc.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3_9b9_mc.cpp:2:\n/tmp/tmp3_9b9_mc.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3_9b9_mc.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3_9b9_mc.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3_9b9_mc.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3_9b9_mc.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3_9b9_mc.cpp:2:\n/tmp/tmp3_9b9_mc.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long long int sum\
    \ = 0;\n    long long int prod = 1;\n    for (auto i = arr.begin(); i != arr.end();\
    \ i++) {\n        if (*i != 0) {\n            if (*i > 0)\n                prod\
    \ *= 1;\n            else\n                prod *= -1;\n            sum += std::abs(*i);\n\
    \        }\n    }\n    if (sum == 0) {\n        return {};\n    }\n    return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptawm4txt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptawm4txt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptawm4txt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptawm4txt.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptawm4txt.cpp:2:\n/tmp/tmptawm4txt.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptawm4txt.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptawm4txt.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptawm4txt.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptawm4txt.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptawm4txt.cpp:2:\n/tmp/tmptawm4txt.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  // your code here\n  long sign = 1;\n  long\
    \ res = 0;\n  for (int i : arr) {\n    res += i * sign;\n    sign *= (i == 0 ?\
    \ 1 : i / abs(i));\n  }\n  return res;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpll85dwxl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpll85dwxl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpll85dwxl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpll85dwxl.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpll85dwxl.cpp:2:\n/tmp/tmpll85dwxl.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpll85dwxl.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpll85dwxl.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpll85dwxl.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpll85dwxl.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpll85dwxl.cpp:2:\n/tmp/tmpll85dwxl.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // return std::nullopt;\n\
    \    // return std::make_optional(0L);\n    long sum = 0;\n    for (auto it =\
    \ arr.begin(); it != arr.end(); it++) {\n        sum += *it;\n    }\n    return\
    \ std::make_optional(sum);\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcnpnh1gu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcnpnh1gu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcnpnh1gu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcnpnh1gu.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcnpnh1gu.cpp:2:\n/tmp/tmpcnpnh1gu.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcnpnh1gu.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcnpnh1gu.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcnpnh1gu.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcnpnh1gu.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcnpnh1gu.cpp:2:\n/tmp/tmpcnpnh1gu.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    long sum = 0;\n    if (arr.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    for (int x : arr) {\n        if (x < 0) {\n            product *=\
    \ -1;\n        } else if (x > 0) {\n            product *= 1;\n        } else\
    \ {\n            product *= 0;\n        }\n        sum += std::abs(x);\n    }\n\
    \    return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvlwwgf0k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvlwwgf0k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvlwwgf0k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvlwwgf0k.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvlwwgf0k.cpp:2:\n/tmp/tmpvlwwgf0k.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvlwwgf0k.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvlwwgf0k.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvlwwgf0k.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvlwwgf0k.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvlwwgf0k.cpp:2:\n/tmp/tmpvlwwgf0k.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long mult = 1;\n  long sum = 0;\n  for (auto\
    \ n : arr) {\n    if (n < 0) {\n      mult *= -1;\n    } else if (n > 0) {\n \
    \     sum += std::abs(n);\n    }\n  }\n  return mult * sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptf7j_hiq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptf7j_hiq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptf7j_hiq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptf7j_hiq.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptf7j_hiq.cpp:2:\n/tmp/tmptf7j_hiq.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptf7j_hiq.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptf7j_hiq.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptf7j_hiq.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptf7j_hiq.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptf7j_hiq.cpp:2:\n/tmp/tmptf7j_hiq.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long prod = 1;\n  long sum = 0;\n  for (auto\
    \ num : arr) {\n    if (num > 0) {\n      prod *= 1;\n    } else if (num < 0)\
    \ {\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n    sum += std::abs(num);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpht4dp5_p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpht4dp5_p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpht4dp5_p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpht4dp5_p.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpht4dp5_p.cpp:2:\n/tmp/tmpht4dp5_p.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpht4dp5_p.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpht4dp5_p.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpht4dp5_p.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpht4dp5_p.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpht4dp5_p.cpp:2:\n/tmp/tmpht4dp5_p.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  if\
    \ (arr.size() == 0) {\n    return std::nullopt;\n  }\n  else {\n    for (int i\
    \ = 0; i < arr.size(); i++) {\n      if (arr[i] < 0) {\n        sum += arr[i];\n\
    \      }\n      else if (arr[i] > 0) {\n        sum += arr[i];\n      }\n    }\n\
    \    return sum;\n  }\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjwfz6ibj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjwfz6ibj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjwfz6ibj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjwfz6ibj.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwfz6ibj.cpp:2:\n/tmp/tmpjwfz6ibj.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjwfz6ibj.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjwfz6ibj.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjwfz6ibj.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjwfz6ibj.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwfz6ibj.cpp:2:\n/tmp/tmpjwfz6ibj.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    long sum = 0;\n    for (auto it = arr.begin(); it != arr.end(); it++) {\n\
    \        if (*it > 0) {\n            product *= 1;\n            sum += *it;\n\
    \        } else if (*it < 0) {\n            product *= -1;\n            sum +=\
    \ *it * -1;\n        } else {\n            product *= 0;\n        }\n    }\n \
    \   if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    return sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp4xziro5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp4xziro5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp4xziro5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp4xziro5.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp4xziro5.cpp:2:\n/tmp/tmpp4xziro5.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp4xziro5.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp4xziro5.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp4xziro5.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp4xziro5.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp4xziro5.cpp:2:\n/tmp/tmpp4xziro5.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  long sum=0;\n  long prod=1;\n  if(arr.size()==0)\n    return {};\n  else\n\
    \  {\n    for(int i=0;i<arr.size();i++)\n    {\n      if(arr[i]>0)\n        prod=prod*1;\n\
    \      else if(arr[i]<0)\n        prod=prod*-1;\n      else\n        prod=prod*0;\n\
    \      sum=sum+abs(arr[i]);\n    }\n    sum=sum*prod;\n    return sum;\n  }\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp19oine5e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp19oine5e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp19oine5e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp19oine5e.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp19oine5e.cpp:2:\n/tmp/tmp19oine5e.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp19oine5e.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp19oine5e.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp19oine5e.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp19oine5e.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp19oine5e.cpp:2:\n/tmp/tmp19oine5e.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (long e : arr) {\n \
    \   if (e == 0) {\n      prod = 0;\n      break;\n    }\n    prod *= (e < 0 ?\
    \ -1 : 1);\n    sum += std::abs(e);\n  }\n  return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk96en3zc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpk96en3zc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpk96en3zc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpk96en3zc.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk96en3zc.cpp:2:\n/tmp/tmpk96en3zc.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpk96en3zc.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpk96en3zc.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpk96en3zc.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpk96en3zc.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk96en3zc.cpp:2:\n/tmp/tmpk96en3zc.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long sum = 0;\n    long product = 1;\n    for (const\
    \ auto& n : arr) {\n        product *= n < 0 ? -1 : n > 0 ? 1 : 0;\n        sum\
    \ += std::abs(n);\n    }\n    return product * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnyq2kj1f.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnyq2kj1f.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnyq2kj1f.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnyq2kj1f.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnyq2kj1f.cpp:2:\n/tmp/tmpnyq2kj1f.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnyq2kj1f.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnyq2kj1f.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnyq2kj1f.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnyq2kj1f.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnyq2kj1f.cpp:2:\n/tmp/tmpnyq2kj1f.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // iterate over input\
    \ vector\n    int i = 0;\n    long sign_product = 1;\n    long sum_magnitudes\
    \ = 0;\n    for (auto val : arr) {\n        if (val == 0) {\n            sign_product\
    \ = 0;\n            sum_magnitudes += 0;\n        } else if (val > 0) {\n    \
    \        sign_product *= 1;\n            sum_magnitudes += val;\n        } else\
    \ {\n            sign_product *= -1;\n            sum_magnitudes += val * -1;\n\
    \        }\n    }\n    if (sign_product == 0) {\n        return sign_product;\n\
    \    } else {\n        return sum_magnitudes * sign_product;\n    }\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpumrzs47h.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpumrzs47h.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpumrzs47h.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpumrzs47h.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpumrzs47h.cpp:2:\n/tmp/tmpumrzs47h.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpumrzs47h.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpumrzs47h.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpumrzs47h.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpumrzs47h.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpumrzs47h.cpp:2:\n/tmp/tmpumrzs47h.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tstd::optional<long>\
    \ arr_size = arr.size();\n\tif (arr_size == 0) {\n\t\treturn {};\n\t}\n\tint signs\
    \ = 0;\n\tint magnitudes = 0;\n\tfor (auto const& it : arr) {\n\t\tif (it > 0)\
    \ {\n\t\t\tsigns += 1;\n\t\t\tmagnitudes += it;\n\t\t}\n\t\telse if (it < 0) {\n\
    \t\t\tsigns -= 1;\n\t\t\tmagnitudes += it;\n\t\t}\n\t}\n\tif (signs == 0) {\n\t\
    \treturn 0;\n\t}\n\treturn signs * magnitudes;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpuwrpp0ok.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpuwrpp0ok.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpuwrpp0ok.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpuwrpp0ok.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuwrpp0ok.cpp:2:\n/tmp/tmpuwrpp0ok.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpuwrpp0ok.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpuwrpp0ok.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpuwrpp0ok.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpuwrpp0ok.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuwrpp0ok.cpp:2:\n/tmp/tmpuwrpp0ok.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long mul = 1;\n \
    \   long sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ > 0) {\n            mul *= 1;\n            sum += arr[i];\n        } else if\
    \ (arr[i] < 0) {\n            mul *= -1;\n            sum += std::abs(arr[i]);\n\
    \        } else {\n            mul *= 0;\n        }\n    }\n    if (mul == 0)\
    \ {\n        return std::nullopt;\n    }\n    return mul * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfcod79f9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfcod79f9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfcod79f9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfcod79f9.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfcod79f9.cpp:2:\n/tmp/tmpfcod79f9.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfcod79f9.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfcod79f9.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfcod79f9.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfcod79f9.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfcod79f9.cpp:2:\n/tmp/tmpfcod79f9.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 1;\n    for (auto i : arr) {\n        res\
    \ *= (i > 0) - (i < 0);\n    }\n    return res * std::accumulate(arr.begin(),\
    \ arr.end(), 0l,\n        [](long a, long b) { return std::abs(a) + std::abs(b);\
    \ });\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb8ro6z7h.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb8ro6z7h.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb8ro6z7h.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb8ro6z7h.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb8ro6z7h.cpp:2:\n/tmp/tmpb8ro6z7h.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb8ro6z7h.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb8ro6z7h.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb8ro6z7h.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb8ro6z7h.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb8ro6z7h.cpp:2:\n/tmp/tmpb8ro6z7h.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int sign = 1;\n  long result = 0;\n  for (const auto& elem\
    \ : arr) {\n    if (elem == 0) {\n      sign = 0;\n      continue;\n    }\n  \
    \  result += std::abs(elem);\n    sign *= elem < 0 ? -1 : 1;\n  }\n  return result\
    \ * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7t3rm62k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7t3rm62k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7t3rm62k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7t3rm62k.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7t3rm62k.cpp:2:\n/tmp/tmp7t3rm62k.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7t3rm62k.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7t3rm62k.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7t3rm62k.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7t3rm62k.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7t3rm62k.cpp:2:\n/tmp/tmp7t3rm62k.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    const int magnitudes = std::accumulate(arr.begin(),\
    \ arr.end(), 0,\n        [](const int accumulator, const int current) {\n    \
    \        return accumulator + std::abs(current);\n        });\n\n    const int\
    \ signs = std::accumulate(arr.begin(), arr.end(), 1,\n        [](const int accumulator,\
    \ const int current) {\n            return accumulator * ((current < 0) ? -1 :\
    \ (current > 0) ? 1 : 0);\n        });\n\n    return magnitudes * signs;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpik8utrhq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpik8utrhq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpik8utrhq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpik8utrhq.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpik8utrhq.cpp:2:\n/tmp/tmpik8utrhq.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpik8utrhq.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpik8utrhq.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpik8utrhq.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpik8utrhq.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpik8utrhq.cpp:2:\n/tmp/tmpik8utrhq.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        int n = arr[i];\n       \
    \ if (n < 0) {\n            prod *= -1;\n        } else if (n > 0) {\n       \
    \     prod *= 1;\n        } else {\n            prod *= 0;\n        }\n      \
    \  sum += std::abs(n);\n    }\n    return prod * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8ghtp1nm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp8ghtp1nm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp8ghtp1nm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp8ghtp1nm.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ghtp1nm.cpp:2:\n/tmp/tmp8ghtp1nm.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp8ghtp1nm.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp8ghtp1nm.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp8ghtp1nm.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp8ghtp1nm.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ghtp1nm.cpp:2:\n/tmp/tmp8ghtp1nm.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int mul = 1;\n    long sum = 0;\n\
    \    for (const auto& element : arr) {\n        if (element < 0) {\n         \
    \   mul *= -1;\n        } else if (element > 0) {\n            mul *= 1;\n   \
    \     } else {\n            mul *= 0;\n        }\n        sum += std::abs(element);\n\
    \    }\n    return mul * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnzoar2a2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnzoar2a2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnzoar2a2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnzoar2a2.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnzoar2a2.cpp:2:\n/tmp/tmpnzoar2a2.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnzoar2a2.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnzoar2a2.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnzoar2a2.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnzoar2a2.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnzoar2a2.cpp:2:\n/tmp/tmpnzoar2a2.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long long prod = 1;\n\
    \  long long sum = 0;\n  for (long num : arr) {\n    sum += abs(num);\n    prod\
    \ *= (num > 0) - (num < 0);\n  }\n  return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1zclz1mj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1zclz1mj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1zclz1mj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1zclz1mj.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1zclz1mj.cpp:2:\n/tmp/tmp1zclz1mj.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1zclz1mj.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1zclz1mj.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1zclz1mj.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1zclz1mj.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1zclz1mj.cpp:2:\n/tmp/tmp1zclz1mj.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int product = 1;\n\
    \    long sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ > 0) {\n            product *= 1;\n            sum += arr[i];\n        } else\
    \ if (arr[i] < 0) {\n            product *= -1;\n            sum += arr[i];\n\
    \        } else {\n            product *= 0;\n        }\n    }\n    if (arr.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    sum *= product;\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp26rwohq8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp26rwohq8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp26rwohq8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp26rwohq8.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp26rwohq8.cpp:2:\n/tmp/tmp26rwohq8.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp26rwohq8.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp26rwohq8.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp26rwohq8.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp26rwohq8.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp26rwohq8.cpp:2:\n/tmp/tmp26rwohq8.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long acc = 0;\n    for (long& l : arr) acc += abs(l);\n\
    \    long prod = 1;\n    for (long& l : arr) {\n        if (l == 0) continue;\n\
    \        if (l > 0) prod *= 1;\n        else prod *= -1;\n    }\n    return acc\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmqgvxf37.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmqgvxf37.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmqgvxf37.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmqgvxf37.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmqgvxf37.cpp:2:\n/tmp/tmpmqgvxf37.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmqgvxf37.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmqgvxf37.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmqgvxf37.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmqgvxf37.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmqgvxf37.cpp:2:\n/tmp/tmpmqgvxf37.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sum = 0;\n    if (arr.size() == 0)\n        return std::nullopt;\n \
    \   for (auto &i : arr) {\n        if (i < 0) {\n            prod *= -1;\n   \
    \         sum += std::abs(i);\n        } else if (i > 0) {\n            sum +=\
    \ i;\n        }\n    }\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptnlwjulh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptnlwjulh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptnlwjulh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptnlwjulh.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptnlwjulh.cpp:2:\n/tmp/tmptnlwjulh.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptnlwjulh.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptnlwjulh.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptnlwjulh.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptnlwjulh.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptnlwjulh.cpp:2:\n/tmp/tmptnlwjulh.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong product = 1;\n\
    \tlong sum = 0;\n\tfor (auto i = arr.begin(); i != arr.end(); i++) {\n\t\tif (*i\
    \ > 0) {\n\t\t\tproduct *= 1;\n\t\t\tsum += *i;\n\t\t}\n\t\telse if (*i < 0) {\n\
    \t\t\tproduct *= -1;\n\t\t\tsum += *i;\n\t\t}\n\t\telse if (*i == 0) {\n\t\t\t\
    product *= 0;\n\t\t}\n\t}\n\tif (arr.size() == 0) {\n\t\treturn {};\n\t}\n\treturn\
    \ { product * sum };\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ii6l230.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9ii6l230.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9ii6l230.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9ii6l230.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ii6l230.cpp:2:\n/tmp/tmp9ii6l230.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9ii6l230.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9ii6l230.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9ii6l230.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9ii6l230.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ii6l230.cpp:2:\n/tmp/tmp9ii6l230.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  long product = 1;\n  long sum = 0;\n  int count = 0;\n  for(int i = 0; i <\
    \ arr.size(); i++){\n    if(arr[i] > 0){\n      count++;\n      product *= 1;\n\
    \      sum += arr[i];\n    }\n    else if(arr[i] < 0){\n      count++;\n     \
    \ product *= -1;\n      sum += arr[i];\n    }\n    else if(arr[i] == 0){\n   \
    \   count++;\n      product *= 0;\n      sum += arr[i];\n    }\n  }\n  if(count\
    \ != 0){\n    return product * sum;\n  }\n  else{\n    return std::nullopt;\n\
    \  }\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0estrrj0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0estrrj0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0estrrj0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0estrrj0.cpp:41:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   41 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0estrrj0.cpp:2:\n/tmp/tmp0estrrj0.cpp:42:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0estrrj0.cpp:42:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0estrrj0.cpp:42:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0estrrj0.cpp:42:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0estrrj0.cpp:42:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0estrrj0.cpp:2:\n/tmp/tmp0estrrj0.cpp:42:5: note:\
    \ to match this \u2018(\u2019\n   42 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(arr.size()\
    \ <= 50);\n    long sum_magnitudes = 0;\n    long product_signs = 1;\n    for\
    \ (auto num : arr) {\n        sum_magnitudes += std::abs(num);\n        product_signs\
    \ *= std::copysign(1, num);\n    }\n    return sum_magnitudes * product_signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2qphko3q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2qphko3q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2qphko3q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2qphko3q.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2qphko3q.cpp:2:\n/tmp/tmp2qphko3q.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2qphko3q.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2qphko3q.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2qphko3q.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2qphko3q.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2qphko3q.cpp:2:\n/tmp/tmp2qphko3q.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ it : arr) {\n    if (it < 0) {\n      prod *= -1;\n    } else if (it > 0) {\n\
    \      sum += it;\n    }\n  }\n  return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdpl80a40.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdpl80a40.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdpl80a40.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdpl80a40.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdpl80a40.cpp:2:\n/tmp/tmpdpl80a40.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdpl80a40.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdpl80a40.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdpl80a40.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdpl80a40.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdpl80a40.cpp:2:\n/tmp/tmpdpl80a40.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Vectors are dynamically\
    \ sized arrays.\n    if (arr.size() == 0) {\n        return std::nullopt;\n  \
    \  }\n    long sum = 0;\n    long prod = 1;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n            prod\
    \ *= 1;\n        } else if (arr[i] < 0) {\n            sum += arr[i];\n      \
    \      prod *= -1;\n        } else {\n            prod *= 0;\n        }\n    }\n\
    \    if (prod == 0) {\n        return std::nullopt;\n    }\n    return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_s31g861.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_s31g861.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_s31g861.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_s31g861.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_s31g861.cpp:2:\n/tmp/tmp_s31g861.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_s31g861.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_s31g861.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_s31g861.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_s31g861.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_s31g861.cpp:2:\n/tmp/tmp_s31g861.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n\
    \    for (long elem : arr) {\n        if (elem < 0) {\n            prod *= -1;\n\
    \        } else if (elem > 0) {\n            sum += elem;\n        }\n    }\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3_1viopn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3_1viopn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3_1viopn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3_1viopn.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3_1viopn.cpp:2:\n/tmp/tmp3_1viopn.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3_1viopn.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3_1viopn.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3_1viopn.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3_1viopn.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3_1viopn.cpp:2:\n/tmp/tmp3_1viopn.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong product = 0;\n\tlong sum = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tlong prod = 0;\n\t\tif (arr[i] < 0) {\n\t\
    \t\tprod = 1;\n\t\t} else if (arr[i] > 0) {\n\t\t\tprod = -1;\n\t\t}\n\t\tproduct\
    \ *= prod;\n\t\tsum += std::abs(arr[i]);\n\t}\n\tlong ans = product * sum;\n\t\
    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9elud7j2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9elud7j2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9elud7j2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9elud7j2.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9elud7j2.cpp:2:\n/tmp/tmp9elud7j2.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9elud7j2.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9elud7j2.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9elud7j2.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9elud7j2.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9elud7j2.cpp:2:\n/tmp/tmp9elud7j2.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tint sum = 0;\n\tint\
    \ count = 0;\n\tint sum1 = 0;\n\tint product = 1;\n\tfor (auto& x : arr) {\n\t\
    \tif (x > 0) {\n\t\t\tcount++;\n\t\t\tsum = sum + x;\n\t\t}\n\t\telse if (x <\
    \ 0) {\n\t\t\tcount++;\n\t\t\tsum1 = sum1 + x;\n\t\t}\n\t\telse {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\tif (count == 0) {\n\t\treturn {};\n\t}\n\tproduct = product * count;\n\
    \treturn sum * sum1 * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcfucps2o.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcfucps2o.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcfucps2o.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcfucps2o.cpp:36:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   36 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcfucps2o.cpp:2:\n/tmp/tmpcfucps2o.cpp:37:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcfucps2o.cpp:37:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcfucps2o.cpp:37:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcfucps2o.cpp:37:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcfucps2o.cpp:37:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcfucps2o.cpp:2:\n/tmp/tmpcfucps2o.cpp:37:5: note:\
    \ to match this \u2018(\u2019\n   37 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code here\n\
    \    if(arr.size()==0) return {};\n    long mults = 1;\n    long sum = 0;\n  \
    \  for(auto x: arr){\n        int s = 1;\n        if(x<0) s = -1;\n        mults\
    \ *= s;\n        sum += abs(x);\n    }\n    return sum*mults;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppj4n59zt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppj4n59zt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppj4n59zt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppj4n59zt.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppj4n59zt.cpp:2:\n/tmp/tmppj4n59zt.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppj4n59zt.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppj4n59zt.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppj4n59zt.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppj4n59zt.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppj4n59zt.cpp:2:\n/tmp/tmppj4n59zt.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long result = 0;\n    long sign = 1;\n    for (long\
    \ num : arr) {\n        result += std::abs(num);\n        if (num > 0) sign *=\
    \ 1;\n        else if (num < 0) sign *= -1;\n        else sign *= 0;\n    }\n\
    \    return sign * result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1hlfsfdx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1hlfsfdx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1hlfsfdx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1hlfsfdx.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1hlfsfdx.cpp:2:\n/tmp/tmp1hlfsfdx.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1hlfsfdx.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1hlfsfdx.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1hlfsfdx.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1hlfsfdx.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1hlfsfdx.cpp:2:\n/tmp/tmp1hlfsfdx.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // I have no idea what\
    \ this function does.\n  // I don't think it's possible to write an accurate function,\n\
    \  // or at least any effort would require far more information than\n  // is\
    \ given to us in the problem.\n  long count=0;\n  int neg = 0;\n  int zero = 0;\n\
    \  long total = 1;\n  if(arr.size()==0){\n    return {};\n  }\n  for(long num:\
    \ arr){\n    if(num<0){\n      count += num;\n      neg += 1;\n    }else if(num==0){\n\
    \      zero += 1;\n    }else{\n      count += num;\n    }\n  }\n  if(neg>0 &&\
    \ zero == 0){\n    return {-count};\n  }else if(neg>0 && zero > 0){\n    return\
    \ {0};\n  }else{\n    return {count};\n  }\n  // return {};\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4xhm62w2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4xhm62w2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4xhm62w2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4xhm62w2.cpp:43:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   43 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4xhm62w2.cpp:2:\n/tmp/tmp4xhm62w2.cpp:44:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   44 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4xhm62w2.cpp:44:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4xhm62w2.cpp:44:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   44 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4xhm62w2.cpp:44:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4xhm62w2.cpp:44:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   44 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4xhm62w2.cpp:2:\n/tmp/tmp4xhm62w2.cpp:44:5: note:\
    \ to match this \u2018(\u2019\n   44 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int number_of_negatives = 0;\n  int number_of_zeros\
    \ = 0;\n  for (auto element : arr) {\n    if (element == 0) {\n      number_of_zeros++;\n\
    \    } else if (element < 0) {\n      number_of_negatives++;\n    }\n  }\n  if\
    \ (number_of_zeros > 0) {\n    return 0;\n  }\n  if (number_of_negatives % 2 ==\
    \ 0) {\n    return 1;\n  }\n  return -1;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprm5xje_d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprm5xje_d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprm5xje_d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprm5xje_d.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprm5xje_d.cpp:2:\n/tmp/tmprm5xje_d.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprm5xje_d.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprm5xje_d.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprm5xje_d.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprm5xje_d.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprm5xje_d.cpp:2:\n/tmp/tmprm5xje_d.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long val = 1;\n  long sum = 0;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    val *= std::signbit(arr[i]) ? -1 : 1;\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * val;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_tzjh443.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_tzjh443.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_tzjh443.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_tzjh443.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_tzjh443.cpp:2:\n/tmp/tmp_tzjh443.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_tzjh443.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_tzjh443.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_tzjh443.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_tzjh443.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_tzjh443.cpp:2:\n/tmp/tmp_tzjh443.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ctr=0;\n   \
    \ long ctr0=0;\n    for(long i=0;i<arr.size();i++){\n        if(arr[i]>0){\n \
    \           ctr+=1;\n        }\n        else if(arr[i]<0){\n            ctr+=-1;\n\
    \        }\n        else{\n            ctr0+=1;\n        }\n    }\n    if(ctr0==arr.size()){\n\
    \        return std::nullopt;\n    }\n    long sum=0;\n    for(long i=0;i<arr.size();i++){\n\
    \        if(arr[i]>0){\n            sum+=arr[i];\n        }\n        else if(arr[i]<0){\n\
    \            sum+=-arr[i];\n        }\n    }\n    return sum*ctr;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplds393ou.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplds393ou.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplds393ou.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplds393ou.cpp:40:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   40 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplds393ou.cpp:2:\n/tmp/tmplds393ou.cpp:41:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   41 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplds393ou.cpp:41:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplds393ou.cpp:41:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   41 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplds393ou.cpp:41:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplds393ou.cpp:41:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   41 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplds393ou.cpp:2:\n/tmp/tmplds393ou.cpp:41:5: note:\
    \ to match this \u2018(\u2019\n   41 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum=0;\n   \
    \ long prod=1;\n    for(auto i:arr){\n        if(i==0){\n            continue;\n\
    \        }\n        else if(i>0){\n            sum+=i;\n            prod*=1;\n\
    \        }\n        else{\n            sum+=abs(i);\n            prod*=-1;\n \
    \       }\n    }\n    if(arr.size()==0){\n        return std::nullopt;\n    }\n\
    \    else{\n        return sum*prod;\n    }\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpht5xzypz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpht5xzypz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpht5xzypz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpht5xzypz.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpht5xzypz.cpp:2:\n/tmp/tmpht5xzypz.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpht5xzypz.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpht5xzypz.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpht5xzypz.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpht5xzypz.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpht5xzypz.cpp:2:\n/tmp/tmpht5xzypz.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto& item : arr) {\n        if (item == 0) {\n            continue;\n\
    \        }\n        product *= item / std::abs(item);\n        sum += std::abs(item);\n\
    \    }\n    return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpia5_uqd7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpia5_uqd7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpia5_uqd7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpia5_uqd7.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpia5_uqd7.cpp:2:\n/tmp/tmpia5_uqd7.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpia5_uqd7.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpia5_uqd7.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpia5_uqd7.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpia5_uqd7.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpia5_uqd7.cpp:2:\n/tmp/tmpia5_uqd7.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long prod = 1;\n  int\
    \ count = 0;\n  for (long x : arr) {\n    count += 1;\n    if (x > 0) {\n    \
    \  prod *= 1;\n    } else if (x < 0) {\n      prod *= -1;\n    } else {\n    \
    \  prod *= 0;\n    }\n  }\n  if (count > 0) {\n    long result = 0;\n    for (long\
    \ x : arr) {\n      result += std::abs(x);\n    }\n    return result * prod;\n\
    \  } else {\n    return std::nullopt;\n  }\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu4s5fnqr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu4s5fnqr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu4s5fnqr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu4s5fnqr.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu4s5fnqr.cpp:2:\n/tmp/tmpu4s5fnqr.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu4s5fnqr.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu4s5fnqr.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu4s5fnqr.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu4s5fnqr.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu4s5fnqr.cpp:2:\n/tmp/tmpu4s5fnqr.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ a : arr) {\n    if (a > 0) {\n      sum += a;\n      prod *= 1;\n    } else\
    \ if (a < 0) {\n      sum += -a;\n      prod *= -1;\n    } else {\n      prod\
    \ *= 0;\n    }\n  }\n  return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpun61wiu3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpun61wiu3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpun61wiu3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpun61wiu3.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpun61wiu3.cpp:2:\n/tmp/tmpun61wiu3.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpun61wiu3.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpun61wiu3.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpun61wiu3.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpun61wiu3.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpun61wiu3.cpp:2:\n/tmp/tmpun61wiu3.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong prod = 1;\n\t\
    long sum = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] < 0)\n\
    \t\t\tprod *= -1;\n\t\telse if (arr[i] > 0)\n\t\t\tprod *= 1;\n\t\telse\n\t\t\t\
    prod *= 0;\n\t\tsum += abs(arr[i]);\n\t}\n\treturn sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpawqrokld.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpawqrokld.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpawqrokld.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpawqrokld.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpawqrokld.cpp:2:\n/tmp/tmpawqrokld.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpawqrokld.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpawqrokld.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpawqrokld.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpawqrokld.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpawqrokld.cpp:2:\n/tmp/tmpawqrokld.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto result = 1LL;\n    auto sum\
    \ = 0LL;\n    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        auto\
    \ cur = *it;\n        sum += std::abs(cur);\n        if (cur > 0) {\n        \
    \    result *= 1;\n        } else if (cur < 0) {\n            result *= -1;\n\
    \        } else {\n            result *= 0;\n        }\n    }\n    return result\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmdcfqkl2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmdcfqkl2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmdcfqkl2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmdcfqkl2.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmdcfqkl2.cpp:2:\n/tmp/tmpmdcfqkl2.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmdcfqkl2.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmdcfqkl2.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmdcfqkl2.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmdcfqkl2.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmdcfqkl2.cpp:2:\n/tmp/tmpmdcfqkl2.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    \    return 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3rcyw_l8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3rcyw_l8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3rcyw_l8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3rcyw_l8.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3rcyw_l8.cpp:2:\n/tmp/tmp3rcyw_l8.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3rcyw_l8.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3rcyw_l8.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3rcyw_l8.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3rcyw_l8.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3rcyw_l8.cpp:2:\n/tmp/tmp3rcyw_l8.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // replace with your\
    \ solution\n    std::optional<long> result;\n    int prod = 1;\n    long sum =\
    \ 0;\n    for (int i = 0; i < arr.size(); i++) {\n        int sign = 0;\n    \
    \    if (arr[i] < 0) {\n            prod *= -1;\n            sign = -1;\n    \
    \    } else if (arr[i] > 0) {\n            sign = 1;\n        }\n        sum +=\
    \ sign * arr[i];\n    }\n    result = sum * prod;\n    return result;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplg630zvh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplg630zvh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplg630zvh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplg630zvh.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplg630zvh.cpp:2:\n/tmp/tmplg630zvh.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplg630zvh.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplg630zvh.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplg630zvh.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplg630zvh.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplg630zvh.cpp:2:\n/tmp/tmplg630zvh.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code goes here\n\
    \  std::optional<long> result;\n  for (auto element : arr) {\n    if (result)\
    \ {\n      result = result.value() + element;\n    } else {\n      result = element;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprvlhim7a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprvlhim7a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprvlhim7a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprvlhim7a.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprvlhim7a.cpp:2:\n/tmp/tmprvlhim7a.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprvlhim7a.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprvlhim7a.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprvlhim7a.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprvlhim7a.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprvlhim7a.cpp:2:\n/tmp/tmprvlhim7a.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sign_product = 1;\n  for (auto i : arr)\
    \ {\n    if (i < 0) {\n      sign_product *= -1;\n    } else if (i > 0) {\n  \
    \    sign_product *= 1;\n    } else {\n      sign_product *= 0;\n    }\n  }\n\
    \  long sum = 0;\n  for (auto i : arr) {\n    sum += std::abs(i);\n  }\n  return\
    \ sign_product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb30bnotc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb30bnotc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb30bnotc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb30bnotc.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb30bnotc.cpp:2:\n/tmp/tmpb30bnotc.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb30bnotc.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb30bnotc.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb30bnotc.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb30bnotc.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb30bnotc.cpp:2:\n/tmp/tmpb30bnotc.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here.\n\
    \    int product = 1;\n    int sum = 0;\n    if(arr.size() == 0)\n        return\
    \ {};\n    for(int i = 0; i < arr.size(); i++)\n    {\n        if(arr[i] < 0)\n\
    \        {\n            product *= -1;\n            sum += -1 * arr[i];\n    \
    \    }\n        else if(arr[i] > 0)\n        {\n            sum += arr[i];\n \
    \       }\n        else\n        {\n            product = 0;\n        }\n    }\n\
    \    return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_wlmcyau.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_wlmcyau.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_wlmcyau.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_wlmcyau.cpp:36:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   36 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_wlmcyau.cpp:2:\n/tmp/tmp_wlmcyau.cpp:37:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_wlmcyau.cpp:37:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_wlmcyau.cpp:37:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_wlmcyau.cpp:37:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_wlmcyau.cpp:37:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_wlmcyau.cpp:2:\n/tmp/tmp_wlmcyau.cpp:37:5: note:\
    \ to match this \u2018(\u2019\n   37 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int zeroFlag = 0;\n\
    \    int negativeCount = 0;\n    long product = 1;\n    long sum = 0;\n    if(arr.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    for(long i : arr) {\n    \
    \    if(i == 0) {\n            zeroFlag = 1;\n        }\n        if(i < 0) {\n\
    \            negativeCount++;\n        }\n        sum += abs(i);\n    }\n    product\
    \ = pow(-1, negativeCount);\n    if(zeroFlag == 1) {\n        return std::nullopt;\n\
    \    }\n    return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwqthmadx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwqthmadx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwqthmadx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwqthmadx.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwqthmadx.cpp:2:\n/tmp/tmpwqthmadx.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwqthmadx.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwqthmadx.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwqthmadx.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwqthmadx.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwqthmadx.cpp:2:\n/tmp/tmpwqthmadx.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long result = 1;\n  long magnitude_sum = 0;\n  for (auto x\
    \ : arr) {\n    if (x == 0) continue;\n    magnitude_sum += std::abs(x);\n   \
    \ result *= std::copysign(1, x);\n  }\n  return magnitude_sum * result;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph67klx0p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmph67klx0p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmph67klx0p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmph67klx0p.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph67klx0p.cpp:2:\n/tmp/tmph67klx0p.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmph67klx0p.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmph67klx0p.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmph67klx0p.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmph67klx0p.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph67klx0p.cpp:2:\n/tmp/tmph67klx0p.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  std::array<int, 3> signs_cnt = {0, 0, 0};\n\
    \  long prod = 1;\n  for (long l : arr) {\n    if (l == 0) {\n      signs_cnt[0]++;\n\
    \    } else if (l > 0) {\n      signs_cnt[1]++;\n    } else {\n      signs_cnt[2]++;\n\
    \    }\n    prod *= std::abs(l);\n  }\n  assert(signs_cnt[0] >= 0);\n  // For\
    \ more than 1 zero, return is 0\n  if (signs_cnt[0] > 1) {\n    return 0;\n  }\n\
    \  // For 1 zero, return = 0\n  if (signs_cnt[0] == 1) {\n    return 0;\n  }\n\
    \  // For 0 zeros, return = prod\n  if (signs_cnt[0] == 0) {\n    return prod;\n\
    \  }\n  // For number of -ve even, return = prod\n  if (signs_cnt[2] % 2 == 0)\
    \ {\n    return prod;\n  }\n  // For number of -ve odd, return = -prod\n  if (signs_cnt[2]\
    \ % 2 == 1) {\n    return -prod;\n  }\n  // This should never be reached\n  assert(false);\n\
    \  return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp67z1liie.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp67z1liie.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp67z1liie.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp67z1liie.cpp:53:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   53 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67z1liie.cpp:2:\n/tmp/tmp67z1liie.cpp:54:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   54 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp67z1liie.cpp:54:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp67z1liie.cpp:54:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   54 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp67z1liie.cpp:54:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp67z1liie.cpp:54:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   54 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp67z1liie.cpp:2:\n/tmp/tmp67z1liie.cpp:54:5: note:\
    \ to match this \u2018(\u2019\n   54 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sum = 0;\n\tint prod = 1;\n\tfor (auto &e : arr) {\n\t\
    \tif (e < 0) prod *= -1;\n\t\tsum += abs(e);\n\t}\n\treturn sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi_mbz8ob.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpi_mbz8ob.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpi_mbz8ob.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpi_mbz8ob.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi_mbz8ob.cpp:2:\n/tmp/tmpi_mbz8ob.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpi_mbz8ob.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpi_mbz8ob.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpi_mbz8ob.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpi_mbz8ob.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi_mbz8ob.cpp:2:\n/tmp/tmpi_mbz8ob.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  auto product = 1;\n  auto sum = 0;\n  for\
    \ (auto i = 0; i < arr.size(); i++) {\n    auto sign = arr[i] == 0 ? 0 : arr[i]\
    \ / std::abs(arr[i]);\n    product *= sign;\n    sum += std::abs(arr[i]);\n  }\n\
    \  return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpg7a1clc7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpg7a1clc7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpg7a1clc7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpg7a1clc7.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg7a1clc7.cpp:2:\n/tmp/tmpg7a1clc7.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpg7a1clc7.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpg7a1clc7.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpg7a1clc7.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpg7a1clc7.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg7a1clc7.cpp:2:\n/tmp/tmpg7a1clc7.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  int sign_multiply = 1;\n  int sum_magnitude\
    \ = 0;\n  for (long & number : arr) {\n    if (number == 0) {\n      continue;\n\
    \    }\n    sign_multiply *= number / std::abs(number);\n    sum_magnitude +=\
    \ std::abs(number);\n  }\n  return sign_multiply * sum_magnitude;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjowzpxfe.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjowzpxfe.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjowzpxfe.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjowzpxfe.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjowzpxfe.cpp:2:\n/tmp/tmpjowzpxfe.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjowzpxfe.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjowzpxfe.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjowzpxfe.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjowzpxfe.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjowzpxfe.cpp:2:\n/tmp/tmpjowzpxfe.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    if(arr.size() == 0)\n        return std::nullopt;\n    int pos = 0,\
    \ neg = 0, zero = 0;\n    for(int i = 0; i < arr.size(); i++){\n        if(arr[i]\
    \ > 0)\n            pos++;\n        else if(arr[i] < 0)\n            neg++;\n\
    \        else\n            zero++;\n    }\n    int pos_neg = pos*neg;\n    if(pos_neg\
    \ == 0)\n        return 0;\n    if(zero > 0)\n        return -1;\n    long answer\
    \ = 0;\n    for(int i = 0; i < arr.size(); i++){\n        answer += std::abs(arr[i]);\n\
    \    }\n    return answer;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvlg0a6sm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvlg0a6sm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvlg0a6sm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvlg0a6sm.cpp:36:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   36 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvlg0a6sm.cpp:2:\n/tmp/tmpvlg0a6sm.cpp:37:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvlg0a6sm.cpp:37:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvlg0a6sm.cpp:37:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvlg0a6sm.cpp:37:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvlg0a6sm.cpp:37:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvlg0a6sm.cpp:2:\n/tmp/tmpvlg0a6sm.cpp:37:5: note:\
    \ to match this \u2018(\u2019\n   37 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tint sign_sum = 0;\n\tfor (const auto& x : arr) {\n\t\tif (x\
    \ > 0) sign_sum++;\n\t\telse if (x < 0) sign_sum--;\n\t}\n\tlong magn_sum = 0;\n\
    \tfor (const auto& x : arr) {\n\t\tmagn_sum += std::abs(x);\n\t}\n\treturn magn_sum\
    \ * sign_sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjexkkk2i.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjexkkk2i.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjexkkk2i.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjexkkk2i.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjexkkk2i.cpp:2:\n/tmp/tmpjexkkk2i.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjexkkk2i.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjexkkk2i.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjexkkk2i.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjexkkk2i.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjexkkk2i.cpp:2:\n/tmp/tmpjexkkk2i.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int sum = 0;\n  \
    \  long prod = 1;\n    for (const auto& num : arr) {\n        if (num == 0) {\n\
    \            continue;\n        } else if (num > 0) {\n            sum += num;\n\
    \            prod *= 1;\n        } else {\n            sum += std::abs(num);\n\
    \            prod *= -1;\n        }\n    }\n    if (sum == 0) {\n        return\
    \ std::nullopt;\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpx15hf6k3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpx15hf6k3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpx15hf6k3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpx15hf6k3.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx15hf6k3.cpp:2:\n/tmp/tmpx15hf6k3.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpx15hf6k3.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpx15hf6k3.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpx15hf6k3.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpx15hf6k3.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx15hf6k3.cpp:2:\n/tmp/tmpx15hf6k3.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  double prod_of_signs = 1;\n  double sum_of_magnitudes\
    \ = 0;\n  for (const auto& el : arr) {\n    prod_of_signs *= std::signbit(el)\
    \ ? -1 : 1;\n    sum_of_magnitudes += std::abs(el);\n  }\n\n  return prod_of_signs\
    \ * sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4q6izv19.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4q6izv19.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4q6izv19.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4q6izv19.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4q6izv19.cpp:2:\n/tmp/tmp4q6izv19.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4q6izv19.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4q6izv19.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4q6izv19.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4q6izv19.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4q6izv19.cpp:2:\n/tmp/tmp4q6izv19.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong long ans = 1;\n\
    \tlong long sum = 0;\n\tfor (long n : arr) {\n\t\tsum += std::abs(n);\n\t\tif\
    \ (n < 0) ans *= -1;\n\t}\n\tif (arr.size() == 0) return {};\n\treturn {sum *\
    \ ans};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpahmd6cvl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpahmd6cvl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpahmd6cvl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpahmd6cvl.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpahmd6cvl.cpp:2:\n/tmp/tmpahmd6cvl.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpahmd6cvl.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpahmd6cvl.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpahmd6cvl.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpahmd6cvl.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpahmd6cvl.cpp:2:\n/tmp/tmpahmd6cvl.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  auto sign_prod = 1;\n  auto mag_sum = 0;\n \
    \ for (auto x : arr) {\n    if (x > 0) {\n      sign_prod *= 1;\n    } else if\
    \ (x < 0) {\n      sign_prod *= -1;\n    } else {\n      sign_prod *= 0;\n   \
    \ }\n    mag_sum += std::abs(x);\n  }\n  return sign_prod * mag_sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphubzp_yq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphubzp_yq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphubzp_yq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphubzp_yq.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphubzp_yq.cpp:2:\n/tmp/tmphubzp_yq.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphubzp_yq.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphubzp_yq.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphubzp_yq.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphubzp_yq.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphubzp_yq.cpp:2:\n/tmp/tmphubzp_yq.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long result{1};\n  for (auto elem : arr) {\n    if (elem >\
    \ 0) result *= 1;\n    else if (elem < 0) result *= -1;\n    else result *= 0;\n\
    \  }\n  for (auto elem : arr) {\n    result *= abs(elem);\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp53oui_hk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp53oui_hk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp53oui_hk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp53oui_hk.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp53oui_hk.cpp:2:\n/tmp/tmp53oui_hk.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp53oui_hk.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp53oui_hk.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp53oui_hk.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp53oui_hk.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp53oui_hk.cpp:2:\n/tmp/tmp53oui_hk.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (auto el : arr) {\n\
    \    if (el < 0) prod *= -1;\n    if (el > 0) sum += el;\n  }\n  return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppm_u2jkc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppm_u2jkc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppm_u2jkc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppm_u2jkc.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppm_u2jkc.cpp:2:\n/tmp/tmppm_u2jkc.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppm_u2jkc.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppm_u2jkc.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppm_u2jkc.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppm_u2jkc.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppm_u2jkc.cpp:2:\n/tmp/tmppm_u2jkc.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long result = 1;\n    long sum = 0;\n    for (auto\
    \ i : arr) {\n        if (i > 0) {\n            result *= 1;\n            sum\
    \ += i;\n        } else if (i < 0) {\n            result *= -1;\n            sum\
    \ += std::abs(i);\n        } else {\n            result *= 0;\n        }\n   \
    \ }\n    return result * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpe16yrhlp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpe16yrhlp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpe16yrhlp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpe16yrhlp.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe16yrhlp.cpp:2:\n/tmp/tmpe16yrhlp.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpe16yrhlp.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpe16yrhlp.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpe16yrhlp.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpe16yrhlp.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe16yrhlp.cpp:2:\n/tmp/tmpe16yrhlp.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    for (auto i: arr) {\n        i = abs(i);\n        sum\
    \ += i;\n        prod *= i == 0 ? 1 : i / i;\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4_425dst.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4_425dst.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4_425dst.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4_425dst.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4_425dst.cpp:2:\n/tmp/tmp4_425dst.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4_425dst.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4_425dst.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4_425dst.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4_425dst.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4_425dst.cpp:2:\n/tmp/tmp4_425dst.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::vector<long> signs;\n\
    \  std::vector<long> magnitudes;\n  if (arr.size() == 0) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  for (auto el : arr) {\n    if (el > 0) {\n      signs.push_back(1);\n\
    \    } else if (el < 0) {\n      signs.push_back(-1);\n    } else {\n      signs.push_back(0);\n\
    \    }\n    magnitudes.push_back(std::abs(el));\n  }\n  for (auto sign : signs)\
    \ {\n    prod *= sign;\n  }\n  long sum = 0;\n  for (auto magn : magnitudes) {\n\
    \    sum += magn;\n  }\n  return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6y2afn3l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6y2afn3l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6y2afn3l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6y2afn3l.cpp:38:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   38 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6y2afn3l.cpp:2:\n/tmp/tmp6y2afn3l.cpp:39:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   39 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6y2afn3l.cpp:39:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6y2afn3l.cpp:39:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   39 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6y2afn3l.cpp:39:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6y2afn3l.cpp:39:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   39 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6y2afn3l.cpp:2:\n/tmp/tmp6y2afn3l.cpp:39:5: note:\
    \ to match this \u2018(\u2019\n   39 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (const auto a : arr)\
    \ {\n    if (a < 0) product *= -1;\n    else if (a > 0) sum += a;\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmhn8ck0v.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmhn8ck0v.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmhn8ck0v.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmhn8ck0v.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmhn8ck0v.cpp:2:\n/tmp/tmpmhn8ck0v.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmhn8ck0v.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmhn8ck0v.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmhn8ck0v.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmhn8ck0v.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmhn8ck0v.cpp:2:\n/tmp/tmpmhn8ck0v.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long s = 1;\n  long sum = 0;\n  for (auto a : arr) {\n    if\
    \ (a != 0) {\n      s *= (a / abs(a));\n      sum += abs(a);\n    }\n  }\n  return\
    \ std::make_optional(s * sum);\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpe5hdr7ch.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpe5hdr7ch.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpe5hdr7ch.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpe5hdr7ch.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe5hdr7ch.cpp:2:\n/tmp/tmpe5hdr7ch.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpe5hdr7ch.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpe5hdr7ch.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpe5hdr7ch.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpe5hdr7ch.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe5hdr7ch.cpp:2:\n/tmp/tmpe5hdr7ch.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long sum = 0;\n    long long product = 1;\n \
    \   for (long x : arr) {\n        if (x > 0) sum += x;\n        else if (x < 0)\
    \ {\n            sum -= x;\n            product *= -1;\n        }\n    }\n   \
    \ return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpq97ypvac.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpq97ypvac.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpq97ypvac.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpq97ypvac.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq97ypvac.cpp:2:\n/tmp/tmpq97ypvac.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpq97ypvac.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpq97ypvac.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpq97ypvac.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpq97ypvac.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq97ypvac.cpp:2:\n/tmp/tmpq97ypvac.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n\
    \    for (auto n : arr) {\n        sum += abs(n);\n        prod *= (n > 0) - (n\
    \ < 0);\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfgjrqsfy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfgjrqsfy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfgjrqsfy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfgjrqsfy.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgjrqsfy.cpp:2:\n/tmp/tmpfgjrqsfy.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfgjrqsfy.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfgjrqsfy.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfgjrqsfy.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfgjrqsfy.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgjrqsfy.cpp:2:\n/tmp/tmpfgjrqsfy.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return arr.empty()\
    \ ? std::nullopt : std::accumulate(\n      arr.begin(), arr.end(), 1L,\n     \
    \ [](long acc, long item) { return acc * std::copysign(1, item); });\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxzgfhfc5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxzgfhfc5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxzgfhfc5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxzgfhfc5.cpp:17:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   17 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxzgfhfc5.cpp:2:\n/tmp/tmpxzgfhfc5.cpp:18:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxzgfhfc5.cpp:18:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxzgfhfc5.cpp:18:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxzgfhfc5.cpp:18:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxzgfhfc5.cpp:18:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxzgfhfc5.cpp:2:\n/tmp/tmpxzgfhfc5.cpp:18:5: note:\
    \ to match this \u2018(\u2019\n   18 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  auto sum = 0;\n  auto prod = 1;\n  for (auto\
    \ i : arr) {\n    auto sign = i == 0 ? 0 : i > 0 ? 1 : -1;\n    prod *= sign;\n\
    \    sum += std::abs(i);\n  }\n  return prod * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzdta_hxr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzdta_hxr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzdta_hxr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzdta_hxr.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdta_hxr.cpp:2:\n/tmp/tmpzdta_hxr.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzdta_hxr.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzdta_hxr.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzdta_hxr.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzdta_hxr.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdta_hxr.cpp:2:\n/tmp/tmpzdta_hxr.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // return None\n  if\
    \ (arr.empty()) return std::nullopt;\n  // get sum of all magnitudes\n  unsigned\
    \ long long sum = 0;\n  // get product of all signs\n  int sign = 1;\n  for (auto&\
    \ x : arr) {\n    sum += abs(x);\n    sign *= (x == 0 ? 1 : (x < 0 ? -1 : 1));\n\
    \  }\n  return sign * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwqm_rz3a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwqm_rz3a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwqm_rz3a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwqm_rz3a.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwqm_rz3a.cpp:2:\n/tmp/tmpwqm_rz3a.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwqm_rz3a.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwqm_rz3a.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwqm_rz3a.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwqm_rz3a.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwqm_rz3a.cpp:2:\n/tmp/tmpwqm_rz3a.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long long prod_signs\
    \ = 1;\n    long long sum_magnitudes = 0;\n    if (arr.size() == 0) {\n      \
    \  return std::nullopt;\n    }\n    for (auto e : arr) {\n        prod_signs *=\
    \ std::signbit(e);\n        sum_magnitudes += std::abs(e);\n    }\n    return\
    \ sum_magnitudes * prod_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpewman0q2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpewman0q2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpewman0q2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpewman0q2.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpewman0q2.cpp:2:\n/tmp/tmpewman0q2.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpewman0q2.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpewman0q2.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpewman0q2.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpewman0q2.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpewman0q2.cpp:2:\n/tmp/tmpewman0q2.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphhtuyt0y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphhtuyt0y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphhtuyt0y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphhtuyt0y.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphhtuyt0y.cpp:2:\n/tmp/tmphhtuyt0y.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphhtuyt0y.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphhtuyt0y.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphhtuyt0y.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphhtuyt0y.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphhtuyt0y.cpp:2:\n/tmp/tmphhtuyt0y.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    std::vector<long> signs;\n   \
    \ std::vector<long> magnitudes;\n    for (const auto& elem : arr) {\n        if\
    \ (elem > 0) {\n            signs.push_back(1);\n            magnitudes.push_back(elem);\n\
    \        } else if (elem < 0) {\n            signs.push_back(-1);\n          \
    \  magnitudes.push_back(-elem);\n        } else {\n            signs.push_back(0);\n\
    \            magnitudes.push_back(0);\n        }\n    }\n\n    const auto prod\
    \ = std::accumulate(signs.begin(), signs.end(), 1,\n                         \
    \               std::multiplies<long>());\n    const auto sum = std::accumulate(magnitudes.begin(),\
    \ magnitudes.end(), 0);\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpq1v73h9i.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpq1v73h9i.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpq1v73h9i.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpq1v73h9i.cpp:37:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   37 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq1v73h9i.cpp:2:\n/tmp/tmpq1v73h9i.cpp:38:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpq1v73h9i.cpp:38:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpq1v73h9i.cpp:38:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpq1v73h9i.cpp:38:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpq1v73h9i.cpp:38:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq1v73h9i.cpp:2:\n/tmp/tmpq1v73h9i.cpp:38:5: note:\
    \ to match this \u2018(\u2019\n   38 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcpb31mhp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcpb31mhp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcpb31mhp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcpb31mhp.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcpb31mhp.cpp:2:\n/tmp/tmpcpb31mhp.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcpb31mhp.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcpb31mhp.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcpb31mhp.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcpb31mhp.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcpb31mhp.cpp:2:\n/tmp/tmpcpb31mhp.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // write your code\
    \ here\n    long prod=1;\n    long sum=0;\n    if(arr.size()==0)\n        return\
    \ {};\n    else\n    {\n        for(int i=0;i<arr.size();i++)\n        {\n   \
    \         if(arr[i]>0)\n                prod*=1;\n            else if(arr[i]<0)\n\
    \                prod*=-1;\n            else\n                prod*=0;\n     \
    \       sum+=abs(arr[i]);\n        }\n        return sum*prod;\n    }\n\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5wq_ew3q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5wq_ew3q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5wq_ew3q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5wq_ew3q.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5wq_ew3q.cpp:2:\n/tmp/tmp5wq_ew3q.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5wq_ew3q.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5wq_ew3q.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5wq_ew3q.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5wq_ew3q.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5wq_ew3q.cpp:2:\n/tmp/tmp5wq_ew3q.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 1;\n\
    \    int counter = 0;\n    for (auto x : arr) {\n        if (x == 0) {\n     \
    \       counter++;\n        }\n        else {\n            result *= x / abs(x);\n\
    \        }\n    }\n    if (counter == arr.size()) {\n        return {};\n    }\n\
    \    return std::accumulate(arr.begin(), arr.end(), 0, [](long &acc, long &x)\
    \ { return acc + abs(x); }) * result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpn648rlry.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpn648rlry.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpn648rlry.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpn648rlry.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn648rlry.cpp:2:\n/tmp/tmpn648rlry.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpn648rlry.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpn648rlry.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpn648rlry.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpn648rlry.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn648rlry.cpp:2:\n/tmp/tmpn648rlry.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long prod_signs\
    \ = 1;\n  for (long elem : arr) {\n    sum_magnitudes += std::abs(elem);\n   \
    \ prod_signs *= (elem != 0) ? elem / std::abs(elem) : 1;\n  }\n  return sum_magnitudes\
    \ * prod_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0omgm9yk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0omgm9yk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0omgm9yk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0omgm9yk.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0omgm9yk.cpp:2:\n/tmp/tmp0omgm9yk.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0omgm9yk.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0omgm9yk.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0omgm9yk.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0omgm9yk.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0omgm9yk.cpp:2:\n/tmp/tmp0omgm9yk.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long prod = 1;\n    if (arr.size() == 0)\n        return std::nullopt;\n \
    \   for (auto i : arr) {\n        if (i == 0)\n            return 0;\n       \
    \ else if (i > 0)\n            sum += i;\n        else\n            sum -= i;\n\
    \        prod *= (i > 0) ? 1 : -1;\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcql2bnvg.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcql2bnvg.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcql2bnvg.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcql2bnvg.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcql2bnvg.cpp:2:\n/tmp/tmpcql2bnvg.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcql2bnvg.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcql2bnvg.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcql2bnvg.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcql2bnvg.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcql2bnvg.cpp:2:\n/tmp/tmpcql2bnvg.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto it : arr) {\n      \
    \  if (it < 0) prod *= -1;\n        else if (it == 0) prod = 0;\n    }\n    long\
    \ mag_sum = 0;\n    for (auto it : arr) mag_sum += std::abs(it);\n    return prod\
    \ * mag_sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0uqzxm7g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0uqzxm7g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0uqzxm7g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0uqzxm7g.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0uqzxm7g.cpp:2:\n/tmp/tmp0uqzxm7g.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0uqzxm7g.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0uqzxm7g.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0uqzxm7g.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0uqzxm7g.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0uqzxm7g.cpp:2:\n/tmp/tmp0uqzxm7g.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int len = arr.size();\n\
    \    if(len == 0) return std::nullopt;\n    long ret = 1;\n    long sum = 0;\n\
    \    for(int i = 0; i < len; i++) {\n        if(arr[i] == 0) {\n            ret\
    \ = 0;\n            break;\n        }\n        if(arr[i] < 0) ret *= -1;\n   \
    \     sum += std::abs(arr[i]);\n    }\n    return ret * sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp76mgp7oq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp76mgp7oq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp76mgp7oq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp76mgp7oq.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp76mgp7oq.cpp:2:\n/tmp/tmp76mgp7oq.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp76mgp7oq.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp76mgp7oq.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp76mgp7oq.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp76mgp7oq.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp76mgp7oq.cpp:2:\n/tmp/tmp76mgp7oq.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        sum += std::abs(arr[i]);\n\
    \        if (arr[i] < 0) {\n            prod *= -1;\n        } else if (arr[i]\
    \ == 0) {\n            prod = 0;\n        }\n    }\n    return prod * sum;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp60ob682a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp60ob682a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp60ob682a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp60ob682a.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp60ob682a.cpp:2:\n/tmp/tmp60ob682a.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp60ob682a.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp60ob682a.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp60ob682a.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp60ob682a.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp60ob682a.cpp:2:\n/tmp/tmp60ob682a.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   long product = 1;\n    bool has_positive = false;\n    bool has_negative =\
    \ false;\n    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        if\
    \ (*it > 0) {\n            has_positive = true;\n            sum += *it;\n   \
    \         product *= 1;\n        } else if (*it < 0) {\n            has_negative\
    \ = true;\n            sum += *it * -1;\n            product *= -1;\n        }\n\
    \    }\n    if (arr.size() == 0) {\n        return std::nullopt;\n    } else if\
    \ (has_positive && has_negative) {\n        return sum * product;\n    } else\
    \ {\n        return 0;\n    }\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpsxfvuks4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpsxfvuks4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpsxfvuks4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpsxfvuks4.cpp:36:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   36 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsxfvuks4.cpp:2:\n/tmp/tmpsxfvuks4.cpp:37:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpsxfvuks4.cpp:37:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpsxfvuks4.cpp:37:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpsxfvuks4.cpp:37:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpsxfvuks4.cpp:37:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsxfvuks4.cpp:2:\n/tmp/tmpsxfvuks4.cpp:37:5: note:\
    \ to match this \u2018(\u2019\n   37 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sums = 0;\n  long mults = 1;\n  for (int\
    \ i = 0; i < arr.size(); i++) {\n    mults *= arr[i] > 0 ? 1 : arr[i] < 0 ? -1\
    \ : 0;\n    sums += std::abs(arr[i]);\n  }\n  return sums * mults;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpheydau0g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpheydau0g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpheydau0g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpheydau0g.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpheydau0g.cpp:2:\n/tmp/tmpheydau0g.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpheydau0g.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpheydau0g.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpheydau0g.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpheydau0g.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpheydau0g.cpp:2:\n/tmp/tmpheydau0g.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (const\
    \ auto& num : arr) {\n        if (num > 0) {\n            prod *= 1;\n       \
    \     sum += num;\n        } else if (num < 0) {\n            prod *= -1;\n  \
    \          sum += abs(num);\n        } else {\n            return 0;\n       \
    \ }\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4invvn56.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4invvn56.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4invvn56.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4invvn56.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4invvn56.cpp:2:\n/tmp/tmp4invvn56.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4invvn56.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4invvn56.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4invvn56.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4invvn56.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4invvn56.cpp:2:\n/tmp/tmp4invvn56.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t// TODO: implement\n\
    \t//#1\n\t// if (arr.size() == 0)\n\t// \treturn std::nullopt;\n\t// int sum =\
    \ 0;\n\t// int n = arr.size();\n\t// for (int i = 0; i < n; i++)\n\t// {\n\t//\
    \ \tsum += std::abs(arr[i]);\n\t// }\n\t// if (arr[0] == 0)\n\t// \treturn 0;\n\
    \t// int prod = arr[0] / std::abs(arr[0]);\n\t// for (int i = 1; i < n; i++)\n\
    \t// {\n\t// \tif (arr[i] != 0)\n\t// \t\tprod *= arr[i] / std::abs(arr[i]);\n\
    \t// }\n\t// return prod * sum;\n\t\n\t//#2\n\tif (arr.size() == 0)\n\t\treturn\
    \ std::nullopt;\n\tint sum = 0;\n\tint prod = 1;\n\tfor (int& x : arr)\n\t{\n\t\
    \tsum += std::abs(x);\n\t\tif (x != 0)\n\t\t\tprod *= x / std::abs(x);\n\t}\n\t\
    return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpef88bv7z.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpef88bv7z.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpef88bv7z.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpef88bv7z.cpp:46:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   46 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpef88bv7z.cpp:2:\n/tmp/tmpef88bv7z.cpp:47:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   47 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpef88bv7z.cpp:47:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpef88bv7z.cpp:47:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   47 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpef88bv7z.cpp:47:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpef88bv7z.cpp:47:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   47 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpef88bv7z.cpp:2:\n/tmp/tmpef88bv7z.cpp:47:5: note:\
    \ to match this \u2018(\u2019\n   47 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long res = 1;\n  long\
    \ sum = 0;\n  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  else {\n\
    \    for (long i = 0; i < arr.size(); i++) {\n      if (arr[i] > 0) {\n      \
    \  res *= 1;\n        sum += arr[i];\n      }\n      else if (arr[i] < 0) {\n\
    \        res *= -1;\n        sum += abs(arr[i]);\n      }\n      else {\n    \
    \    return 0;\n      }\n    }\n    return res * sum;\n  }\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppdr2_8pu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppdr2_8pu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppdr2_8pu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppdr2_8pu.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppdr2_8pu.cpp:2:\n/tmp/tmppdr2_8pu.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppdr2_8pu.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppdr2_8pu.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppdr2_8pu.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppdr2_8pu.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppdr2_8pu.cpp:2:\n/tmp/tmppdr2_8pu.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::cout << \"Input:\
    \ \";\n    for (const auto& num : arr) {\n        std::cout << num << \" \";\n\
    \    }\n    std::cout << \"\\n\";\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (const auto& num : arr) {\n  \
    \      if (num < 0) {\n            prod *= -1;\n        } else if (num == 0) {\n\
    \            return 0;\n        }\n        sum += std::abs(num);\n    }\n    return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxsmb5z7x.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxsmb5z7x.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxsmb5z7x.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxsmb5z7x.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxsmb5z7x.cpp:2:\n/tmp/tmpxsmb5z7x.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxsmb5z7x.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxsmb5z7x.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxsmb5z7x.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxsmb5z7x.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxsmb5z7x.cpp:2:\n/tmp/tmpxsmb5z7x.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // int sum = 0;\n\
    \    // for (auto i : arr) {\n    //     sum += i;\n    // }\n    // return sum;\n\
    \    return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5wi1n8q_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5wi1n8q_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5wi1n8q_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5wi1n8q_.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5wi1n8q_.cpp:2:\n/tmp/tmp5wi1n8q_.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5wi1n8q_.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5wi1n8q_.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5wi1n8q_.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5wi1n8q_.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5wi1n8q_.cpp:2:\n/tmp/tmp5wi1n8q_.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code goes\
    \ here\n    long sum=0;\n    long count =0;\n    if(arr.size() == 0)\n       \
    \ return std::nullopt;\n    else{\n        for(int i=0;i<arr.size();i++){\n  \
    \          if(arr[i]>0)\n                sum+=arr[i];\n            else if(arr[i]<0)\n\
    \                sum+=arr[i]*-1;\n            else if(arr[i]==0)\n           \
    \     count++;\n        }\n        if(count == arr.size())\n            return\
    \ 0;\n        else\n            return sum;\n    }\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp76ya2408.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp76ya2408.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp76ya2408.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp76ya2408.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp76ya2408.cpp:2:\n/tmp/tmp76ya2408.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp76ya2408.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp76ya2408.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp76ya2408.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp76ya2408.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp76ya2408.cpp:2:\n/tmp/tmp76ya2408.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sum = 0;\n\tlong sign_product = 1;\n\tfor (long n : arr)\
    \ {\n\t\tsum += std::abs(n);\n\t\tif (n > 0) sign_product *= 1;\n\t\telse if (n\
    \ < 0) sign_product *= -1;\n\t\telse sign_product *= 0;\n\t}\n\treturn sum * sign_product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmjgj6td8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmjgj6td8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmjgj6td8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmjgj6td8.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmjgj6td8.cpp:2:\n/tmp/tmpmjgj6td8.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmjgj6td8.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmjgj6td8.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmjgj6td8.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmjgj6td8.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmjgj6td8.cpp:2:\n/tmp/tmpmjgj6td8.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  // your code\n  long prod = 1;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    prod *= arr[i] > 0 ? 1 : (arr[i] < 0 ? -1 : 0);\n  }\n  long sum\
    \ = 0;\n  for (long i = 0; i < arr.size(); i++) {\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpz_aiuroh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpz_aiuroh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpz_aiuroh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpz_aiuroh.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz_aiuroh.cpp:2:\n/tmp/tmpz_aiuroh.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpz_aiuroh.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpz_aiuroh.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpz_aiuroh.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpz_aiuroh.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz_aiuroh.cpp:2:\n/tmp/tmpz_aiuroh.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long result = 1;\n    long sum_magnitudes = 0;\n \
    \   for (int i = 0; i < arr.size(); i++) {\n        sum_magnitudes += std::abs(arr[i]);\n\
    \        if (arr[i] != 0) {\n            result *= (arr[i] < 0 ? -1 : 1);\n  \
    \      }\n    }\n    return result * sum_magnitudes;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp901frwj9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp901frwj9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp901frwj9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp901frwj9.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp901frwj9.cpp:2:\n/tmp/tmp901frwj9.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp901frwj9.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp901frwj9.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp901frwj9.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp901frwj9.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp901frwj9.cpp:2:\n/tmp/tmp901frwj9.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result;\n  \
    \  if (arr.size() != 0) {\n        result = 1;\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            result *= arr[i] / abs(arr[i]);\n        }\n        long\
    \ sum = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            sum +=\
    \ abs(arr[i]);\n        }\n        result *= sum;\n        return result;\n  \
    \  }\n    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwb4sc230.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwb4sc230.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwb4sc230.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwb4sc230.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwb4sc230.cpp:2:\n/tmp/tmpwb4sc230.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwb4sc230.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwb4sc230.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwb4sc230.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwb4sc230.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwb4sc230.cpp:2:\n/tmp/tmpwb4sc230.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return 0;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpir34xv28.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpir34xv28.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpir34xv28.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpir34xv28.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpir34xv28.cpp:2:\n/tmp/tmpir34xv28.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpir34xv28.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpir34xv28.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpir34xv28.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpir34xv28.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpir34xv28.cpp:2:\n/tmp/tmpir34xv28.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (int a : arr) {\n\
    \    if (a > 0) product *= 1;\n    else if (a < 0) product *= -1;\n    else product\
    \ *= 0;\n    sum += std::abs(a);\n  }\n  return sum * product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp323vja_t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp323vja_t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp323vja_t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp323vja_t.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp323vja_t.cpp:2:\n/tmp/tmp323vja_t.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp323vja_t.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp323vja_t.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp323vja_t.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp323vja_t.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp323vja_t.cpp:2:\n/tmp/tmp323vja_t.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong magnitude = 1;\n\tlong sign = 1;\n\tfor\
    \ (auto x : arr) {\n\t\tmagnitude *= std::abs(x);\n\t\tsign *= x < 0 ? -1 : x\
    \ == 0 ? 0 : 1;\n\t}\n\treturn sign * magnitude;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpah_gxpcv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpah_gxpcv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpah_gxpcv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpah_gxpcv.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpah_gxpcv.cpp:2:\n/tmp/tmpah_gxpcv.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpah_gxpcv.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpah_gxpcv.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpah_gxpcv.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpah_gxpcv.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpah_gxpcv.cpp:2:\n/tmp/tmpah_gxpcv.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::vector<long>\
    \ arr_sign;\n    long sum = 0;\n    for (auto number : arr) {\n        long n\
    \ = std::abs(number);\n        sum += n;\n        if (number == 0) {\n       \
    \     arr_sign.push_back(0);\n        } else if (number > 0) {\n            arr_sign.push_back(1);\n\
    \        } else {\n            arr_sign.push_back(-1);\n        }\n    }\n   \
    \ if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    long prod =\
    \ 1;\n    for (auto number : arr_sign) {\n        prod *= number;\n    }\n   \
    \ return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphywk0zvy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphywk0zvy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphywk0zvy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphywk0zvy.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphywk0zvy.cpp:2:\n/tmp/tmphywk0zvy.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphywk0zvy.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphywk0zvy.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphywk0zvy.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphywk0zvy.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphywk0zvy.cpp:2:\n/tmp/tmphywk0zvy.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong sum = 0;\n\tlong\
    \ product = 1;\n\tfor (auto num : arr) {\n\t\tsum += abs(num);\n\t\tif (num >\
    \ 0) {\n\t\t\tproduct *= 1;\n\t\t} else if (num < 0) {\n\t\t\tproduct *= -1;\n\
    \t\t} else {\n\t\t\tproduct *= 0;\n\t\t}\n\t}\n\tif (arr.size() == 0) {\n\t\t\
    return {};\n\t}\n\treturn sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4csuma9r.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4csuma9r.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4csuma9r.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4csuma9r.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4csuma9r.cpp:2:\n/tmp/tmp4csuma9r.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4csuma9r.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4csuma9r.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4csuma9r.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4csuma9r.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4csuma9r.cpp:2:\n/tmp/tmp4csuma9r.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int sign_prod = 1;\n  int sum_abs = 0;\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    sum_abs += std::abs(arr[i]);\n    sign_prod\
    \ *= (arr[i] == 0) ? 1 : arr[i] / std::abs(arr[i]);\n  }\n  return sum_abs * sign_prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6yy7a99p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6yy7a99p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6yy7a99p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6yy7a99p.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6yy7a99p.cpp:2:\n/tmp/tmp6yy7a99p.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6yy7a99p.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6yy7a99p.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6yy7a99p.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6yy7a99p.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6yy7a99p.cpp:2:\n/tmp/tmp6yy7a99p.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum_of_magnitudes = 0;\n  long product_of_signs = 1;\n\
    \  for (auto& i : arr) {\n    sum_of_magnitudes += std::abs(i);\n    if (i !=\
    \ 0) product_of_signs *= (i > 0 ? 1 : -1);\n  }\n  return sum_of_magnitudes *\
    \ product_of_signs;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa8ix9htr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa8ix9htr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa8ix9htr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa8ix9htr.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa8ix9htr.cpp:2:\n/tmp/tmpa8ix9htr.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa8ix9htr.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa8ix9htr.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa8ix9htr.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa8ix9htr.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa8ix9htr.cpp:2:\n/tmp/tmpa8ix9htr.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long magnitude = 0;\n    int sign\
    \ = 1;\n    for (auto a : arr) {\n        magnitude += std::abs(a);\n        sign\
    \ *= (a < 0) ? -1 : ((a > 0) ? 1 : 0);\n    }\n    return magnitude * sign;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6o5kptuq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6o5kptuq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6o5kptuq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6o5kptuq.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6o5kptuq.cpp:2:\n/tmp/tmp6o5kptuq.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6o5kptuq.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6o5kptuq.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6o5kptuq.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6o5kptuq.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6o5kptuq.cpp:2:\n/tmp/tmp6o5kptuq.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong product = 0;\n\tlong sum = 0;\n\tfor (int\
    \ i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tproduct += 1;\n\t\
    \t}\n\t\telse if (arr[i] < 0) {\n\t\t\tproduct -= 1;\n\t\t}\n\t\tsum += std::abs(arr[i]);\n\
    \t}\n\treturn product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9yxh154d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9yxh154d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9yxh154d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9yxh154d.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9yxh154d.cpp:2:\n/tmp/tmp9yxh154d.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9yxh154d.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9yxh154d.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9yxh154d.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9yxh154d.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9yxh154d.cpp:2:\n/tmp/tmp9yxh154d.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long result = 1;\n  for (auto i : arr) {\n\
    \    long sign = std::copysign(1, i);\n    result *= sign * std::abs(i);\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6i3wv5wv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6i3wv5wv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6i3wv5wv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6i3wv5wv.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6i3wv5wv.cpp:2:\n/tmp/tmp6i3wv5wv.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6i3wv5wv.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6i3wv5wv.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6i3wv5wv.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6i3wv5wv.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6i3wv5wv.cpp:2:\n/tmp/tmp6i3wv5wv.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sum = 0;\n\tlong sign = 1;\n\tfor (long x : arr) {\n\t\
    \tsum += abs(x);\n\t\tif (x != 0) {\n\t\t\tsign *= x / abs(x);\n\t\t}\n\t}\n\t\
    return sum * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa0qbqn8p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa0qbqn8p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa0qbqn8p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa0qbqn8p.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa0qbqn8p.cpp:2:\n/tmp/tmpa0qbqn8p.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa0qbqn8p.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa0qbqn8p.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa0qbqn8p.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa0qbqn8p.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa0qbqn8p.cpp:2:\n/tmp/tmpa0qbqn8p.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  return {};\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6aml3odh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6aml3odh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6aml3odh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6aml3odh.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6aml3odh.cpp:2:\n/tmp/tmp6aml3odh.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6aml3odh.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6aml3odh.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6aml3odh.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6aml3odh.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6aml3odh.cpp:2:\n/tmp/tmp6aml3odh.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  auto prod = std::accumulate(arr.begin(),\
    \ arr.end(), 1,\n    [](long acc, long val) {\n      auto prod = (val > 0 ? 1\
    \ : -1);\n      return acc * prod;\n    });\n  if (prod == 0) return std::nullopt;\n\
    \  auto sum = std::accumulate(arr.begin(), arr.end(), 0,\n    [](long acc, long\
    \ val) {\n      auto val1 = (val > 0 ? val : -val);\n      return acc + val1;\n\
    \    });\n  auto result = sum * prod;\n  return result;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwww_ry5e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwww_ry5e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwww_ry5e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwww_ry5e.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwww_ry5e.cpp:2:\n/tmp/tmpwww_ry5e.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwww_ry5e.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwww_ry5e.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwww_ry5e.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwww_ry5e.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwww_ry5e.cpp:2:\n/tmp/tmpwww_ry5e.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\n\t// TODO:\n\n\treturn std::nullopt;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr1upwfww.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpr1upwfww.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpr1upwfww.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpr1upwfww.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr1upwfww.cpp:2:\n/tmp/tmpr1upwfww.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpr1upwfww.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpr1upwfww.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpr1upwfww.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpr1upwfww.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr1upwfww.cpp:2:\n/tmp/tmpr1upwfww.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n\
    \    for (auto i : arr) {\n        if (i == 0) {\n            continue;\n    \
    \    }\n        sum += std::abs(i);\n        prod *= (i < 0) ? -1 : 1;\n    }\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwkdtqhg5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwkdtqhg5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwkdtqhg5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwkdtqhg5.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwkdtqhg5.cpp:2:\n/tmp/tmpwkdtqhg5.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwkdtqhg5.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwkdtqhg5.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwkdtqhg5.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwkdtqhg5.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwkdtqhg5.cpp:2:\n/tmp/tmpwkdtqhg5.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long res = 1;\n \
    \   long sum = 0;\n    if (arr.size() == 0)\n        return {};\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        long val = arr[i];\n        if (val >\
    \ 0)\n            res *= 1;\n        else if (val < 0)\n            res *= -1;\n\
    \        else if (val == 0)\n            res *= 0;\n        sum += std::abs(val);\n\
    \    }\n    return sum * res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_iv5oa1c.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_iv5oa1c.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_iv5oa1c.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_iv5oa1c.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_iv5oa1c.cpp:2:\n/tmp/tmp_iv5oa1c.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_iv5oa1c.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_iv5oa1c.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_iv5oa1c.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_iv5oa1c.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_iv5oa1c.cpp:2:\n/tmp/tmp_iv5oa1c.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code goes\
    \ here\n    long sum = 0;\n    long product = 1;\n    for(auto i: arr){\n    \
    \    if(i>0){\n            sum += i;\n            product *= 1;\n        }\n \
    \       else if(i<0){\n            sum += i*-1;\n            product *= -1;\n\
    \        }\n        else{\n            product *= 0;\n        }\n    }\n    if(arr.size()\
    \ == 0){\n        return {};\n    }\n    return sum*product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwwz28e49.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwwz28e49.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwwz28e49.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwwz28e49.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwwz28e49.cpp:2:\n/tmp/tmpwwz28e49.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwwz28e49.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwwz28e49.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwwz28e49.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwwz28e49.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwwz28e49.cpp:2:\n/tmp/tmpwwz28e49.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int negatives = 0;\n    long product = 1;\n    for\
    \ (auto& i : arr) {\n        if (i < 0) negatives++;\n        if (i != 0) product\
    \ *= i;\n    }\n    if (negatives % 2 == 0) product *= 1;\n    else product *=\
    \ -1;\n    long sum = 0;\n    for (auto& i : arr) sum += std::abs(i);\n    return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_88qvyah.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_88qvyah.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_88qvyah.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_88qvyah.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_88qvyah.cpp:2:\n/tmp/tmp_88qvyah.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_88qvyah.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_88qvyah.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_88qvyah.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_88qvyah.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_88qvyah.cpp:2:\n/tmp/tmp_88qvyah.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int len = arr.size();\n\
    \    if (len == 0) {\n        return std::nullopt;\n    }\n    int sign = 1;\n\
    \    long sum = 0;\n    for (int i = 0; i < len; i++) {\n        long a = arr[i];\n\
    \        if (a < 0) {\n            sign *= -1;\n            a *= -1;\n       \
    \ } else if (a == 0) {\n            sign = 0;\n        }\n        sum += a;\n\
    \    }\n    return sum * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmph063zivn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmph063zivn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmph063zivn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmph063zivn.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph063zivn.cpp:2:\n/tmp/tmph063zivn.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmph063zivn.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmph063zivn.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmph063zivn.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmph063zivn.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph063zivn.cpp:2:\n/tmp/tmph063zivn.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    for (long num\
    \ : arr) {\n        prod *= (num > 0) - (num < 0);\n    }\n    long sum = 0;\n\
    \    for (long num : arr) {\n        sum += std::abs(num);\n    }\n    return\
    \ prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgfwqtjxw.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgfwqtjxw.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgfwqtjxw.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgfwqtjxw.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgfwqtjxw.cpp:2:\n/tmp/tmpgfwqtjxw.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgfwqtjxw.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgfwqtjxw.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgfwqtjxw.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgfwqtjxw.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgfwqtjxw.cpp:2:\n/tmp/tmpgfwqtjxw.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong sign = 1;\n\tlong sum = 0;\n\tfor (const\
    \ auto& el : arr) {\n\t\tif (el != 0) {\n\t\t\tsign *= (el > 0) ? 1 : -1;\n\t\t\
    \tsum += abs(el);\n\t\t}\n\t}\n\treturn sign * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnq7c_2e3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnq7c_2e3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnq7c_2e3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnq7c_2e3.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnq7c_2e3.cpp:2:\n/tmp/tmpnq7c_2e3.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnq7c_2e3.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnq7c_2e3.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnq7c_2e3.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnq7c_2e3.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnq7c_2e3.cpp:2:\n/tmp/tmpnq7c_2e3.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  for (auto &i : arr) {\n    sum += abs(i);\n\
    \  }\n  long prod = 1;\n  for (auto &i : arr) {\n    if (i < 0) {\n      prod\
    \ *= -1;\n    } else if (i == 0) {\n      prod = 0;\n      break;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpg8mxfcx1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpg8mxfcx1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpg8mxfcx1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpg8mxfcx1.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg8mxfcx1.cpp:2:\n/tmp/tmpg8mxfcx1.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpg8mxfcx1.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpg8mxfcx1.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpg8mxfcx1.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpg8mxfcx1.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg8mxfcx1.cpp:2:\n/tmp/tmpg8mxfcx1.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long ans = 0;\n    long prod = 1;\n\
    \    for (long el : arr) {\n        if (el == 0) {\n            continue;\n  \
    \      }\n        ans += abs(el);\n        prod *= (el > 0) ? 1 : -1;\n    }\n\
    \    return ans * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu51eayha.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu51eayha.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu51eayha.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu51eayha.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu51eayha.cpp:2:\n/tmp/tmpu51eayha.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu51eayha.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu51eayha.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu51eayha.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu51eayha.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu51eayha.cpp:2:\n/tmp/tmpu51eayha.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long signs_product\
    \ = 1;\n    long magnitudes_sum = 0;\n    if (arr.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    for (long item : arr) {\n        if (item > 0) {\n\
    \            signs_product *= 1;\n        } else if (item < 0) {\n           \
    \ signs_product *= -1;\n        } else {\n            signs_product *= 0;\n  \
    \      }\n        magnitudes_sum += std::abs(item);\n    }\n    return magnitudes_sum\
    \ * signs_product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgxtmdp5n.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgxtmdp5n.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgxtmdp5n.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgxtmdp5n.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgxtmdp5n.cpp:2:\n/tmp/tmpgxtmdp5n.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgxtmdp5n.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgxtmdp5n.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgxtmdp5n.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgxtmdp5n.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgxtmdp5n.cpp:2:\n/tmp/tmpgxtmdp5n.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (long\
    \ i = 0; i < arr.size(); i++) {\n    sum += std::abs(arr[i]);\n    if (arr[i]\
    \ < 0) {\n      prod *= -1;\n    } else if (arr[i] > 0) {\n      prod *= 1;\n\
    \    }\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9ylrsa1j.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9ylrsa1j.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9ylrsa1j.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9ylrsa1j.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ylrsa1j.cpp:2:\n/tmp/tmp9ylrsa1j.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9ylrsa1j.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9ylrsa1j.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9ylrsa1j.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9ylrsa1j.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ylrsa1j.cpp:2:\n/tmp/tmp9ylrsa1j.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long sum = 0;\n  long product = 1;\n  for\
    \ (const auto& n : arr) {\n    if (n > 0) {\n      sum += n;\n      product *=\
    \ 1;\n    } else if (n < 0) {\n      sum += abs(n);\n      product *= -1;\n  \
    \  } else {\n      product *= 0;\n    }\n  }\n\n  return sum * product;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4mqobq8a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4mqobq8a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4mqobq8a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4mqobq8a.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4mqobq8a.cpp:2:\n/tmp/tmp4mqobq8a.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4mqobq8a.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4mqobq8a.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4mqobq8a.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4mqobq8a.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4mqobq8a.cpp:2:\n/tmp/tmp4mqobq8a.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ value = {};\n  if (arr.size() == 0) {\n    return value;\n  }\n  int prod =\
    \ 1;\n  long sum = 0;\n  for (auto it = arr.begin(); it != arr.end(); it++) {\n\
    \    if (*it < 0) {\n      prod *= -1;\n    } else if (*it > 0) {\n      prod\
    \ *= 1;\n    } else {\n      prod *= 0;\n    }\n    sum += std::abs(*it);\n  }\n\
    \  long ans = prod * sum;\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmponugmdn1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmponugmdn1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmponugmdn1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmponugmdn1.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmponugmdn1.cpp:2:\n/tmp/tmponugmdn1.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmponugmdn1.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmponugmdn1.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmponugmdn1.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmponugmdn1.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmponugmdn1.cpp:2:\n/tmp/tmponugmdn1.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod_signs =\
    \ 0;\n    for (auto const& i : arr) {\n        if (i > 0)\n            prod_signs++;\n\
    \        else if (i < 0)\n            prod_signs--;\n    }\n    long res = 0;\n\
    \    for (auto const& i : arr) {\n        if (prod_signs > 0)\n            res\
    \ += std::abs(i);\n        else if (prod_signs < 0)\n            res -= std::abs(i);\n\
    \    }\n    if (arr.size() == 0)\n        return std::nullopt;\n    return res;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp5g6uu82.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp5g6uu82.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp5g6uu82.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp5g6uu82.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5g6uu82.cpp:2:\n/tmp/tmpp5g6uu82.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp5g6uu82.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp5g6uu82.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp5g6uu82.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp5g6uu82.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5g6uu82.cpp:2:\n/tmp/tmpp5g6uu82.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong sum = 0;\n\tlong pro = 1;\n\tfor (auto a\
    \ : arr) {\n\t\tsum += std::abs(a);\n\t\tif (a != 0) {\n\t\t\tpro *= a < 0 ? -1\
    \ : 1;\n\t\t}\n\t}\n\treturn sum * pro;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6s9chp_a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6s9chp_a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6s9chp_a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6s9chp_a.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6s9chp_a.cpp:2:\n/tmp/tmp6s9chp_a.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6s9chp_a.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6s9chp_a.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6s9chp_a.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6s9chp_a.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6s9chp_a.cpp:2:\n/tmp/tmp6s9chp_a.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\t//store signs\n\tstd::vector<long>\
    \ signStore;\n\t//store magnitudes\n\tstd::vector<long> magStore;\n\t//product\
    \ of all signs\n\tlong productSigns;\n\t//sum of all magnitudes\n\tlong sumMag;\n\
    \t//loop through array\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\t//check\
    \ if greater than zero\n\t\tif (arr[i] > 0) {\n\t\t\t//if so product of signs\
    \ is\n\t\t\tproductSigns = 1;\n\t\t\t//magnitude is current element\n\t\t\tsumMag\
    \ = arr[i];\n\t\t\t//add to both stores\n\t\t\tsignStore.push_back(productSigns);\n\
    \t\t\tmagStore.push_back(sumMag);\n\t\t}\n\t\t//else if less than zero\n\t\telse\
    \ if (arr[i] < 0) {\n\t\t\t//product of signs is\n\t\t\tproductSigns = -1;\n\t\
    \t\t//magnitude is positive value of current element\n\t\t\tsumMag = std::abs(arr[i]);\n\
    \t\t\t//add to both stores\n\t\t\tsignStore.push_back(productSigns);\n\t\t\tmagStore.push_back(sumMag);\n\
    \t\t}\n\t\t//else zero\n\t\telse {\n\t\t\t//product of signs is zero\n\t\t\tproductSigns\
    \ = 0;\n\t\t\t//magnitude is zero\n\t\t\tsumMag = 0;\n\t\t\t//add to both stores\n\
    \t\t\tsignStore.push_back(productSigns);\n\t\t\tmagStore.push_back(sumMag);\n\t\
    \t}\n\t}\n\t//if no elements in array\n\tif (arr.size() == 0) {\n\t\t//return\
    \ 0\n\t\treturn {};\n\t}\n\t//check if all values are 0\n\t//loop through array\n\
    \tfor (int i = 0; i < arr.size(); i++) {\n\t\t//if any values are not zero\n\t\
    \tif (arr[i] != 0) {\n\t\t\t//break\n\t\t\tbreak;\n\t\t}\n\t\t//\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp28sm9l9t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp28sm9l9t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long positive = 0;\n  long negative = 0;\n  long zeros = 0;\n\
    \  for (auto i : arr) {\n    if (i == 0) {\n      zeros++;\n    } else if (i >\
    \ 0) {\n      positive++;\n    } else {\n      negative++;\n    }\n  }\n  long\
    \ product = 1;\n  for (int i = 0; i < negative; i++) {\n    product *= -1;\n \
    \ }\n  for (int i = 0; i < zeros; i++) {\n    product *= 0;\n  }\n  return product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgps4jzar.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgps4jzar.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgps4jzar.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgps4jzar.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgps4jzar.cpp:2:\n/tmp/tmpgps4jzar.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgps4jzar.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgps4jzar.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgps4jzar.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgps4jzar.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgps4jzar.cpp:2:\n/tmp/tmpgps4jzar.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for (auto\
    \ i : arr) {\n    product *= (i < 0) ? -1 : (i == 0) ? 0 : 1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpps597ch4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpps597ch4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpps597ch4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpps597ch4.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpps597ch4.cpp:2:\n/tmp/tmpps597ch4.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpps597ch4.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpps597ch4.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpps597ch4.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpps597ch4.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpps597ch4.cpp:2:\n/tmp/tmpps597ch4.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  //your code goes here\n\
    \    if(arr.size()==0)\n    {\n        return {};\n    }\n    long sum=0;\n  \
    \  long prod=1;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]>0)\n\
    \        {\n            sum=sum+arr[i];\n            prod=prod*1;\n        }\n\
    \        else if(arr[i]<0)\n        {\n            sum=sum+abs(arr[i]);\n    \
    \        prod=prod*(-1);\n        }\n        else\n        {\n            prod=prod*0;\n\
    \        }\n    }\n    return sum*prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpa8zy5d11.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa8zy5d11.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa8zy5d11.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa8zy5d11.cpp:39:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   39 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa8zy5d11.cpp:2:\n/tmp/tmpa8zy5d11.cpp:40:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   40 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa8zy5d11.cpp:40:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa8zy5d11.cpp:40:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   40 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa8zy5d11.cpp:40:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa8zy5d11.cpp:40:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   40 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa8zy5d11.cpp:2:\n/tmp/tmpa8zy5d11.cpp:40:5: note:\
    \ to match this \u2018(\u2019\n   40 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod_signs = 1;\n    long sum_magnitudes\
    \ = 0;\n    for (auto n : arr) {\n        sum_magnitudes += std::abs(n);\n   \
    \     if (n < 0) {\n            prod_signs *= -1;\n        } else if (n > 0) {\n\
    \            prod_signs *= 1;\n        }\n    }\n    return sum_magnitudes * prod_signs;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy1kl0q2k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpy1kl0q2k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpy1kl0q2k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpy1kl0q2k.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy1kl0q2k.cpp:2:\n/tmp/tmpy1kl0q2k.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpy1kl0q2k.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpy1kl0q2k.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpy1kl0q2k.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpy1kl0q2k.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy1kl0q2k.cpp:2:\n/tmp/tmpy1kl0q2k.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if(n == 0)\n        return std::nullopt;\n    long prod = 1;\n    long sum\
    \ = 0;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > 0)\n           \
    \ prod *= 1;\n        else if(arr[i] < 0)\n            prod *= -1;\n        else\n\
    \            prod *= 0;\n        sum += std::abs(arr[i]);\n    }\n    return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmytg8ikz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmytg8ikz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmytg8ikz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmytg8ikz.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmytg8ikz.cpp:2:\n/tmp/tmpmytg8ikz.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmytg8ikz.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmytg8ikz.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmytg8ikz.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmytg8ikz.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmytg8ikz.cpp:2:\n/tmp/tmpmytg8ikz.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int len = arr.size();\n    int sum = 0;\n    int ans\
    \ = 1;\n    for (int i = 0; i < len; i++) {\n        long num = arr[i];\n    \
    \    int sign = 0;\n        if (num > 0) {\n            sign = 1;\n        } else\
    \ if (num < 0) {\n            sign = -1;\n        }\n        ans *= sign;\n  \
    \      sum += abs(num);\n    }\n    long final = sum * ans;\n    return final;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2ubwxam0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2ubwxam0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2ubwxam0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2ubwxam0.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ubwxam0.cpp:2:\n/tmp/tmp2ubwxam0.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2ubwxam0.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2ubwxam0.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2ubwxam0.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2ubwxam0.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ubwxam0.cpp:2:\n/tmp/tmp2ubwxam0.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long result = 0;\n  for\
    \ (auto n : arr) {\n    if (n > 0) {\n      product *= 1;\n    } else if (n <\
    \ 0) {\n      product *= -1;\n    } else {\n      product *= 0;\n    }\n    result\
    \ += std::abs(n);\n  }\n  return result * product;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt844nkrr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpt844nkrr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpt844nkrr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpt844nkrr.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt844nkrr.cpp:2:\n/tmp/tmpt844nkrr.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpt844nkrr.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpt844nkrr.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpt844nkrr.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpt844nkrr.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt844nkrr.cpp:2:\n/tmp/tmpt844nkrr.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) return\
    \ std::nullopt;\n\tlong sign_prod = 1;\n\tlong total = 0;\n\tfor (auto x : arr)\
    \ {\n\t\tif (x != 0) {\n\t\t\tsign_prod *= x > 0 ? 1 : -1;\n\t\t\ttotal += std::abs(x);\n\
    \t\t}\n\t}\n\treturn total * sign_prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkcvve1j8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkcvve1j8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkcvve1j8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkcvve1j8.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkcvve1j8.cpp:2:\n/tmp/tmpkcvve1j8.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkcvve1j8.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkcvve1j8.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkcvve1j8.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkcvve1j8.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkcvve1j8.cpp:2:\n/tmp/tmpkcvve1j8.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long prod = 1;\n  long sum = 0;\n  for (long\
    \ num : arr) {\n    if (num < 0) {\n      prod *= -1;\n    } else if (num > 0)\
    \ {\n      sum += num;\n    }\n  }\n  return prod * sum;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdbz00bad.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdbz00bad.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdbz00bad.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdbz00bad.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdbz00bad.cpp:2:\n/tmp/tmpdbz00bad.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdbz00bad.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdbz00bad.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdbz00bad.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdbz00bad.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdbz00bad.cpp:2:\n/tmp/tmpdbz00bad.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long total = 1;\n    long sum = 0;\n    for (auto\
    \ i : arr) {\n        if (i > 0) {\n            total *= 1;\n            sum +=\
    \ i;\n        } else if (i < 0) {\n            total *= -1;\n            sum +=\
    \ abs(i);\n        } else if (i == 0) {\n            return 0;\n        }\n  \
    \  }\n    return total * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb0e4ti_t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb0e4ti_t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb0e4ti_t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb0e4ti_t.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb0e4ti_t.cpp:2:\n/tmp/tmpb0e4ti_t.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb0e4ti_t.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb0e4ti_t.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb0e4ti_t.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb0e4ti_t.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb0e4ti_t.cpp:2:\n/tmp/tmpb0e4ti_t.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::sort(arr.begin(),\
    \ arr.end());\n    if (arr.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    std::optional<long> result = 1;\n    int counter = 0;\n    while (arr[counter]\
    \ == 0) {\n        counter++;\n    }\n    for (int i = counter; i < arr.size();\
    \ i++) {\n        if (arr[i] > 0) {\n            result = result.value() * arr[i];\n\
    \        } else {\n            result = result.value() * (-1) * arr[i];\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4x1366ly.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4x1366ly.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4x1366ly.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4x1366ly.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4x1366ly.cpp:2:\n/tmp/tmp4x1366ly.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4x1366ly.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4x1366ly.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4x1366ly.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4x1366ly.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4x1366ly.cpp:2:\n/tmp/tmp4x1366ly.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sign = 1;\n  for (auto i : arr) {\n    if (i > 0)\n  \
    \    sign *= 1;\n    else if (i < 0)\n      sign *= -1;\n    else\n      sign\
    \ *= 0;\n  }\n  long sum = 0;\n  for (auto i : arr) {\n    sum += abs(i);\n  }\n\
    \  return sign * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3qvyat_1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3qvyat_1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3qvyat_1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3qvyat_1.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3qvyat_1.cpp:2:\n/tmp/tmp3qvyat_1.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3qvyat_1.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3qvyat_1.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3qvyat_1.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3qvyat_1.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3qvyat_1.cpp:2:\n/tmp/tmp3qvyat_1.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long sign = 1;\n    long sum = 0;\n    for (long i\
    \ = 0; i < arr.size(); i++) {\n        long num = arr[i];\n        if (num < 0)\
    \ sign *= -1;\n        if (num != 0) sum += abs(num);\n    }\n    return sum *\
    \ sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8iorexom.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp8iorexom.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp8iorexom.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp8iorexom.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8iorexom.cpp:2:\n/tmp/tmp8iorexom.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp8iorexom.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp8iorexom.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp8iorexom.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp8iorexom.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8iorexom.cpp:2:\n/tmp/tmp8iorexom.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 1;\n\
    \    int counter = 0;\n    for (auto el : arr) {\n        result *= el > 0 ? 1\
    \ : (el < 0 ? -1 : 0);\n        if (el == 0) {\n            counter++;\n     \
    \   }\n    }\n    return counter > 0 ? std::nullopt : result;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe52asem_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpe52asem_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpe52asem_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpe52asem_.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe52asem_.cpp:2:\n/tmp/tmpe52asem_.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpe52asem_.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpe52asem_.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpe52asem_.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpe52asem_.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe52asem_.cpp:2:\n/tmp/tmpe52asem_.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long product = 1;\n  for (auto&\
    \ elem : arr) {\n    sum += std::abs(elem);\n    if (elem > 0) {\n      product\
    \ *= 1;\n    } else if (elem < 0) {\n      product *= -1;\n    } else {\n    \
    \  product *= 0;\n    }\n  }\n  return sum * product;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3xfi6kif.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3xfi6kif.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3xfi6kif.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3xfi6kif.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3xfi6kif.cpp:2:\n/tmp/tmp3xfi6kif.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3xfi6kif.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3xfi6kif.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3xfi6kif.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3xfi6kif.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3xfi6kif.cpp:2:\n/tmp/tmp3xfi6kif.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long sum_magnitudes = 0;\n   \
    \ long prod_signs = 1;\n    for (auto n : arr) {\n        sum_magnitudes += std::abs(n);\n\
    \        if (n > 0) {\n            prod_signs *= 1;\n        } else if (n < 0)\
    \ {\n            prod_signs *= -1;\n        } else {\n            prod_signs *=\
    \ 0;\n        }\n    }\n    return sum_magnitudes * prod_signs;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdy8uis2y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdy8uis2y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdy8uis2y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdy8uis2y.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdy8uis2y.cpp:2:\n/tmp/tmpdy8uis2y.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdy8uis2y.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdy8uis2y.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdy8uis2y.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdy8uis2y.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdy8uis2y.cpp:2:\n/tmp/tmpdy8uis2y.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto product_of_signs = std::accumulate(arr.begin(),\
    \ arr.end(), 1, [](long lhs, long rhs) {\n        return lhs * (rhs < 0 ? -1 :\
    \ (rhs > 0 ? 1 : 0));\n    });\n    auto sum_of_magnitudes = std::accumulate(arr.begin(),\
    \ arr.end(), 0, [](long lhs, long rhs) {\n        return lhs + std::abs(rhs);\n\
    \    });\n    return product_of_signs * sum_of_magnitudes;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzt65lx01.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzt65lx01.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzt65lx01.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzt65lx01.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzt65lx01.cpp:2:\n/tmp/tmpzt65lx01.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzt65lx01.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzt65lx01.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzt65lx01.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzt65lx01.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzt65lx01.cpp:2:\n/tmp/tmpzt65lx01.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (auto\
    \ &&num : arr) {\n    if (num == 0) {\n      continue;\n    }\n    if (num > 0)\
    \ {\n      prod *= 1;\n    } else {\n      prod *= -1;\n    }\n    sum += std::abs(num);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpd4zd1fkt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpd4zd1fkt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpd4zd1fkt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpd4zd1fkt.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd4zd1fkt.cpp:2:\n/tmp/tmpd4zd1fkt.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpd4zd1fkt.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpd4zd1fkt.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpd4zd1fkt.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpd4zd1fkt.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd4zd1fkt.cpp:2:\n/tmp/tmpd4zd1fkt.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong p = 1;\n\tlong s = 0;\n\tfor (auto n : arr)\
    \ {\n\t\tif (n == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tp *= -1;\n\
    \t\t}\n\t\ts += std::abs(n);\n\t}\n\treturn p * s;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp3o17c1g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp3o17c1g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp3o17c1g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp3o17c1g.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp3o17c1g.cpp:2:\n/tmp/tmpp3o17c1g.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp3o17c1g.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp3o17c1g.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp3o17c1g.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp3o17c1g.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp3o17c1g.cpp:2:\n/tmp/tmpp3o17c1g.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long prod = 1;\n  for (long i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] > 0) {\n      prod *= 1;\n    } else if (arr[i] < 0)\
    \ {\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  long sum\
    \ = 0;\n  for (long i = 0; i < arr.size(); i++) {\n    sum += std::abs(arr[i]);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppvxz8bqs.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppvxz8bqs.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppvxz8bqs.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppvxz8bqs.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvxz8bqs.cpp:2:\n/tmp/tmppvxz8bqs.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppvxz8bqs.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppvxz8bqs.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppvxz8bqs.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppvxz8bqs.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvxz8bqs.cpp:2:\n/tmp/tmppvxz8bqs.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    long sum = 0;\n    for (const\
    \ auto& elem : arr) {\n        int sign = 1;\n        if (elem == 0) {\n     \
    \       continue;\n        } else if (elem < 0) {\n            sign = -1;\n  \
    \      }\n        product *= sign;\n        sum += std::abs(elem);\n    }\n  \
    \  return product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpona1bhzr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpona1bhzr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpona1bhzr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpona1bhzr.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpona1bhzr.cpp:2:\n/tmp/tmpona1bhzr.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpona1bhzr.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpona1bhzr.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpona1bhzr.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpona1bhzr.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpona1bhzr.cpp:2:\n/tmp/tmpona1bhzr.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n\
    \    for (auto i : arr) {\n        sum += std::abs(i);\n        if (i != 0) {\n\
    \            prod *= i > 0 ? 1 : -1;\n        }\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_pozsd7w.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_pozsd7w.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_pozsd7w.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_pozsd7w.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_pozsd7w.cpp:2:\n/tmp/tmp_pozsd7w.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_pozsd7w.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_pozsd7w.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_pozsd7w.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_pozsd7w.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_pozsd7w.cpp:2:\n/tmp/tmp_pozsd7w.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here.\n\
    \    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8qppbrr4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp8qppbrr4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp8qppbrr4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp8qppbrr4.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8qppbrr4.cpp:2:\n/tmp/tmp8qppbrr4.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp8qppbrr4.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp8qppbrr4.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp8qppbrr4.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp8qppbrr4.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8qppbrr4.cpp:2:\n/tmp/tmp8qppbrr4.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long res = 1;\n \
    \   long sum = 0;\n    for (auto i : arr) {\n        if (i > 0) {\n          \
    \  res *= 1;\n            sum += i;\n        } else if (i < 0) {\n           \
    \ res *= -1;\n            sum += -i;\n        } else {\n            res *= 0;\n\
    \        }\n    }\n    return res * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjwa9usu6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjwa9usu6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjwa9usu6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjwa9usu6.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwa9usu6.cpp:2:\n/tmp/tmpjwa9usu6.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjwa9usu6.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjwa9usu6.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjwa9usu6.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjwa9usu6.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwa9usu6.cpp:2:\n/tmp/tmpjwa9usu6.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here!\n\
    \    if(arr.size() == 0) return std::nullopt;\n    else if(arr.size() == 1) return\
    \ arr[0];\n    long sum = 0;\n    long prod = 1;\n    for(auto& i : arr){\n  \
    \      if(i>0) {\n            sum += i;\n            prod *= 1;\n        }\n \
    \       else if(i<0) {\n            sum += -i;\n            prod *= -1;\n    \
    \    }\n        else prod *= 0;\n    }\n    return sum*prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3r0q6q40.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3r0q6q40.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3r0q6q40.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3r0q6q40.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3r0q6q40.cpp:2:\n/tmp/tmp3r0q6q40.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3r0q6q40.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3r0q6q40.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3r0q6q40.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3r0q6q40.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3r0q6q40.cpp:2:\n/tmp/tmp3r0q6q40.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  int\
    \ prod = 1;\n  for (auto a : arr) {\n    if (a > 0) {\n      sum += a;\n     \
    \ prod *= 1;\n    } else if (a < 0) {\n      sum += abs(a);\n      prod *= -1;\n\
    \    } else {\n      prod *= 0;\n    }\n  }\n  if (arr.size() == 0) {\n    return\
    \ {};\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvyfvrgi6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvyfvrgi6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvyfvrgi6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvyfvrgi6.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvyfvrgi6.cpp:2:\n/tmp/tmpvyfvrgi6.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvyfvrgi6.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvyfvrgi6.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvyfvrgi6.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvyfvrgi6.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvyfvrgi6.cpp:2:\n/tmp/tmpvyfvrgi6.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod_signs = 1;\n    long sum_magnitudes = 0;\n\
    \    for (const auto& val : arr) {\n        switch (val) {\n            case 0:\n\
    \                break;\n            case 1:\n            case -1:\n         \
    \       prod_signs *= val;\n                break;\n            default:\n   \
    \             prod_signs *= (val > 0 ? 1 : -1);\n                sum_magnitudes\
    \ += abs(val);\n        }\n    }\n    return sum_magnitudes * prod_signs;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphihq1qi7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphihq1qi7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphihq1qi7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphihq1qi7.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphihq1qi7.cpp:2:\n/tmp/tmphihq1qi7.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphihq1qi7.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphihq1qi7.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphihq1qi7.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphihq1qi7.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphihq1qi7.cpp:2:\n/tmp/tmphihq1qi7.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  if(arr.size()<1)\n    return {};\n  long sum = 0;\n  long product = 1;\n  for(int\
    \ i = 0; i < arr.size(); i++){\n    if(arr[i] < 0)\n      product *= -1;\n   \
    \ else if(arr[i] == 0)\n      product *= 0;\n    sum += abs(arr[i]);\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvqqgzq6z.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvqqgzq6z.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvqqgzq6z.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvqqgzq6z.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvqqgzq6z.cpp:2:\n/tmp/tmpvqqgzq6z.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvqqgzq6z.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvqqgzq6z.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvqqgzq6z.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvqqgzq6z.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvqqgzq6z.cpp:2:\n/tmp/tmpvqqgzq6z.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n\
    \    for (const auto& i : arr) {\n        auto sign = (i == 0) ? 0 : i / std::abs(i);\n\
    \        prod *= sign;\n        sum += std::abs(i);\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4nzdoq8p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4nzdoq8p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4nzdoq8p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4nzdoq8p.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4nzdoq8p.cpp:2:\n/tmp/tmp4nzdoq8p.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4nzdoq8p.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4nzdoq8p.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4nzdoq8p.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4nzdoq8p.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4nzdoq8p.cpp:2:\n/tmp/tmp4nzdoq8p.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // If the array is\
    \ empty return None\n    if (arr.empty()) {\n        return std::nullopt;\n  \
    \  }\n    // We need to find the product of all signs of each element in the array\n\
    \    // and the sum of magnitudes of integers.\n    // We can do that by making\
    \ use of the reduce function.\n    // We multiply each element in the array by\
    \ it's sign which will tell us\n    // what is the sign of the current element.\n\
    \    // Then we take the product of all the elements which will give us the\n\
    \    // product of all signs of each element in the array.\n    long product_of_signs\
    \ = std::reduce(arr.begin(), arr.end(), 1,\n        [](long a, long b) { return\
    \ a * std::copysign(1, b); });\n    // We also take the sum of all the absolute\
    \ values of the array.\n    long sum_of_magnitudes = std::reduce(arr.begin(),\
    \ arr.end(), 0,\n        [](long a, long b) { return a + std::abs(b); });\n  \
    \  // We return the product of the sum and the product.\n    return product_of_signs\
    \ * sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpyih0k3a2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpyih0k3a2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpyih0k3a2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpyih0k3a2.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyih0k3a2.cpp:2:\n/tmp/tmpyih0k3a2.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpyih0k3a2.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpyih0k3a2.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpyih0k3a2.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpyih0k3a2.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyih0k3a2.cpp:2:\n/tmp/tmpyih0k3a2.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long magnitude = 0;\n\
    \  long sign = 1;\n  for (auto number : arr) {\n    magnitude += std::abs(number);\n\
    \    if (number > 0) {\n      sign *= 1;\n    } else if (number < 0) {\n     \
    \ sign *= -1;\n    } else {\n      sign *= 0;\n    }\n  }\n  if (arr.size() ==\
    \ 0) {\n    return std::nullopt;\n  }\n  return magnitude * sign;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0g_z8n3g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0g_z8n3g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0g_z8n3g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0g_z8n3g.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0g_z8n3g.cpp:2:\n/tmp/tmp0g_z8n3g.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0g_z8n3g.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0g_z8n3g.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0g_z8n3g.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0g_z8n3g.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0g_z8n3g.cpp:2:\n/tmp/tmp0g_z8n3g.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long product = 1;\n\
    \  long sum = 0;\n  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  for\
    \ (long i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      product =\
    \ product * 0;\n    } else if (arr[i] > 0) {\n      product = product * 1;\n \
    \     sum = sum + arr[i];\n    } else {\n      product = product * -1;\n     \
    \ sum = sum + -arr[i];\n    }\n  }\n  return product * sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp384vmm5p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp384vmm5p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp384vmm5p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp384vmm5p.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp384vmm5p.cpp:2:\n/tmp/tmp384vmm5p.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp384vmm5p.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp384vmm5p.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp384vmm5p.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp384vmm5p.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp384vmm5p.cpp:2:\n/tmp/tmp384vmm5p.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if(n == 0)\n    return std::nullopt;\n  long p = 1;\n  long s = 0;\n  for(int\
    \ i = 0; i < n; i++) {\n    if(arr[i] == 0) {\n      continue;\n    }\n    if(arr[i]\
    \ < 0) {\n      s++;\n    }\n    p *= arr[i];\n  }\n  if(s % 2 == 0) {\n    return\
    \ p;\n  }\n  return -p;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpic1qxmi7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpic1qxmi7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpic1qxmi7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpic1qxmi7.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpic1qxmi7.cpp:2:\n/tmp/tmpic1qxmi7.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpic1qxmi7.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpic1qxmi7.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpic1qxmi7.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpic1qxmi7.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpic1qxmi7.cpp:2:\n/tmp/tmpic1qxmi7.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    if (arr.size() == 1) return arr[0];\n    if (arr.size()\
    \ == 2) return arr[0] * arr[1];\n    long prod = 1;\n    for (const auto& el :\
    \ arr) {\n        if (el > 0) prod *= 1;\n        else if (el < 0) prod *= -1;\n\
    \        else prod *= 0;\n    }\n    long result = 0;\n    for (const auto& el\
    \ : arr) {\n        result += std::abs(el);\n    }\n    return result * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp07aec46q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp07aec46q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp07aec46q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp07aec46q.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp07aec46q.cpp:2:\n/tmp/tmp07aec46q.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp07aec46q.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp07aec46q.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp07aec46q.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp07aec46q.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp07aec46q.cpp:2:\n/tmp/tmp07aec46q.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long product = 1;\n  for (auto\
    \ a : arr) {\n    a > 0 ? sum += a : sum += -a;\n    a > 0 ? product *= 1 : a\
    \ < 0 ? product *= -1 : product *= 0;\n  }\n  return sum * product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpffps47r8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpffps47r8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpffps47r8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpffps47r8.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpffps47r8.cpp:2:\n/tmp/tmpffps47r8.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpffps47r8.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpffps47r8.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpffps47r8.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpffps47r8.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpffps47r8.cpp:2:\n/tmp/tmpffps47r8.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code here\n\
    \    return 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy7pvu6h1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpy7pvu6h1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpy7pvu6h1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpy7pvu6h1.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy7pvu6h1.cpp:2:\n/tmp/tmpy7pvu6h1.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpy7pvu6h1.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpy7pvu6h1.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpy7pvu6h1.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpy7pvu6h1.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy7pvu6h1.cpp:2:\n/tmp/tmpy7pvu6h1.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    return std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgogvma3g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgogvma3g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgogvma3g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgogvma3g.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgogvma3g.cpp:2:\n/tmp/tmpgogvma3g.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgogvma3g.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgogvma3g.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgogvma3g.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgogvma3g.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgogvma3g.cpp:2:\n/tmp/tmpgogvma3g.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto x : arr) {\n        if (x > 0) {\n            product *=\
    \ 1;\n        } else if (x < 0) {\n            product *= -1;\n        } else\
    \ {\n            product *= 0;\n        }\n        sum += std::abs(x);\n    }\n\
    \    return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp10x4kgko.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp10x4kgko.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp10x4kgko.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp10x4kgko.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp10x4kgko.cpp:2:\n/tmp/tmp10x4kgko.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp10x4kgko.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp10x4kgko.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp10x4kgko.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp10x4kgko.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp10x4kgko.cpp:2:\n/tmp/tmp10x4kgko.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long result = 1;\n    long sum =\
    \ 0;\n    for (auto const &item : arr) {\n        sum += std::abs(item);\n   \
    \     if (item != 0) {\n            result *= item / std::abs(item);\n       \
    \ }\n    }\n    return sum * result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1dboeies.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1dboeies.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1dboeies.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1dboeies.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1dboeies.cpp:2:\n/tmp/tmp1dboeies.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1dboeies.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1dboeies.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1dboeies.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1dboeies.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1dboeies.cpp:2:\n/tmp/tmp1dboeies.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    long sum\
    \ = 0;\n    for (auto i : arr) {\n        if (i < 0) {\n            product *=\
    \ -1;\n        } else if (i == 0) {\n            return 0;\n        }\n      \
    \  sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpixpxphv3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpixpxphv3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpixpxphv3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpixpxphv3.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpixpxphv3.cpp:2:\n/tmp/tmpixpxphv3.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpixpxphv3.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpixpxphv3.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpixpxphv3.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpixpxphv3.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpixpxphv3.cpp:2:\n/tmp/tmpixpxphv3.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  int\
    \ prod = 1;\n  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  for (long\
    \ i = 0; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      return 0;\n   \
    \ }\n    sum += abs(arr[i]);\n    if (arr[i] < 0) {\n      prod *= -1;\n    }\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4gnyij0n.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4gnyij0n.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4gnyij0n.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4gnyij0n.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4gnyij0n.cpp:2:\n/tmp/tmp4gnyij0n.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4gnyij0n.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4gnyij0n.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4gnyij0n.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4gnyij0n.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4gnyij0n.cpp:2:\n/tmp/tmp4gnyij0n.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod_sign =\
    \ 1;\n    long sum_magn = 0;\n    for (int el: arr) {\n        int abs_el = abs(el);\n\
    \        if (el == 0)\n            continue;\n        else\n            prod_sign\
    \ *= el / abs_el;\n        sum_magn += abs_el;\n    }\n    if (arr.size() == 0)\n\
    \        return std::nullopt;\n    else\n        return sum_magn * prod_sign;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuk489mx9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpuk489mx9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpuk489mx9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpuk489mx9.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuk489mx9.cpp:2:\n/tmp/tmpuk489mx9.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpuk489mx9.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpuk489mx9.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpuk489mx9.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpuk489mx9.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuk489mx9.cpp:2:\n/tmp/tmpuk489mx9.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long signProd = 1;\n    long sum\
    \ = 0;\n    for (const auto& i : arr) {\n        if (i > 0) {\n            signProd\
    \ *= 1;\n        } else if (i < 0) {\n            signProd *= -1;\n        } else\
    \ {\n            signProd *= 0;\n        }\n        sum += std::abs(i);\n    }\n\
    \    return signProd * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkluy8k9b.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkluy8k9b.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkluy8k9b.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkluy8k9b.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkluy8k9b.cpp:2:\n/tmp/tmpkluy8k9b.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkluy8k9b.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkluy8k9b.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkluy8k9b.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkluy8k9b.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkluy8k9b.cpp:2:\n/tmp/tmpkluy8k9b.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::vector<long>\
    \ signs;\n    std::vector<long> mags;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] < 0) {\n            signs.push_back(-1);\n           \
    \ mags.push_back(arr[i] * -1);\n        } else if (arr[i] > 0) {\n           \
    \ signs.push_back(1);\n            mags.push_back(arr[i]);\n        } else {\n\
    \            signs.push_back(0);\n            mags.push_back(0);\n        }\n\
    \    }\n    if (arr.size() == 0) {\n        return std::nullopt;\n    }\n    long\
    \ prod = std::accumulate(signs.begin(), signs.end(), 1, std::multiplies<>());\n\
    \    long sum = std::accumulate(mags.begin(), mags.end(), 0);\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplrmwfbcv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplrmwfbcv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplrmwfbcv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplrmwfbcv.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplrmwfbcv.cpp:2:\n/tmp/tmplrmwfbcv.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplrmwfbcv.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplrmwfbcv.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplrmwfbcv.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplrmwfbcv.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplrmwfbcv.cpp:2:\n/tmp/tmplrmwfbcv.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // TODO\n    if(arr.size()\
    \ == 0)\n        return {};\n    else\n    {\n        long prod_signs_var = 1;\n\
    \        long prod_magnitude_var = 0;\n        for(int i = 0; i < arr.size();\
    \ i++)\n        {\n            if(arr[i] == 0)\n                return 0;\n  \
    \          else if(arr[i] > 0)\n                prod_signs_var *= 1;\n       \
    \     else\n                prod_signs_var *= -1;\n            prod_magnitude_var\
    \ += abs(arr[i]);\n        }\n        return prod_signs_var * prod_magnitude_var;\n\
    \    }\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9c253few.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9c253few.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9c253few.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9c253few.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9c253few.cpp:2:\n/tmp/tmp9c253few.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9c253few.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9c253few.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9c253few.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9c253few.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9c253few.cpp:2:\n/tmp/tmp9c253few.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Enter your code\
    \ here\n  int prod = 1;\n  long sum = 0;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    if (arr[i] > 0) {\n      prod *= 1;\n      sum += arr[i];\n    } else\
    \ if (arr[i] < 0) {\n      prod *= -1;\n      sum += arr[i];\n    } else {\n \
    \     prod *= 0;\n    }\n  }\n  return prod * sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphi_qosqw.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphi_qosqw.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphi_qosqw.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphi_qosqw.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphi_qosqw.cpp:2:\n/tmp/tmphi_qosqw.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphi_qosqw.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphi_qosqw.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphi_qosqw.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphi_qosqw.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphi_qosqw.cpp:2:\n/tmp/tmphi_qosqw.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    \  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzazspuex.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzazspuex.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzazspuex.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzazspuex.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzazspuex.cpp:2:\n/tmp/tmpzazspuex.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzazspuex.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzazspuex.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzazspuex.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzazspuex.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzazspuex.cpp:2:\n/tmp/tmpzazspuex.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sign_prod = 1;\n  long sum_of_magnitudes\
    \ = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n      sign_prod *= 1;\n    }\
    \ else if (i < 0) {\n      sign_prod *= -1;\n    } else {\n      sign_prod *=\
    \ 0;\n    }\n    sum_of_magnitudes += std::abs(i);\n  }\n  return sign_prod *\
    \ sum_of_magnitudes;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6rjk0_k6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6rjk0_k6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6rjk0_k6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6rjk0_k6.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6rjk0_k6.cpp:2:\n/tmp/tmp6rjk0_k6.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6rjk0_k6.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6rjk0_k6.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6rjk0_k6.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6rjk0_k6.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6rjk0_k6.cpp:2:\n/tmp/tmp6rjk0_k6.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int positive = 0;\n  int negative = 0;\n  long count = 1;\n\
    \  for (auto i : arr) {\n    count *= std::abs(i);\n    if (i > 0)\n      positive++;\n\
    \    else if (i < 0)\n      negative++;\n  }\n  long sum = 0;\n  if (positive\
    \ % 2 == 0)\n    sum = count;\n  else\n    sum = -count;\n  return sum;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj26ajw7t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpj26ajw7t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpj26ajw7t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpj26ajw7t.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj26ajw7t.cpp:2:\n/tmp/tmpj26ajw7t.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpj26ajw7t.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpj26ajw7t.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpj26ajw7t.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpj26ajw7t.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj26ajw7t.cpp:2:\n/tmp/tmpj26ajw7t.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // placeholder\n  return\
    \ 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzzmsbgo9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzzmsbgo9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzzmsbgo9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzzmsbgo9.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzzmsbgo9.cpp:2:\n/tmp/tmpzzmsbgo9.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzzmsbgo9.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzzmsbgo9.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzzmsbgo9.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzzmsbgo9.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzzmsbgo9.cpp:2:\n/tmp/tmpzzmsbgo9.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  long sums = 0;\n  long prod = 1;\n  for (const\
    \ auto& num : arr) {\n    if (num == 0) {\n      continue;\n    }\n\n    if (num\
    \ > 0) {\n      sums += num;\n    } else {\n      sums -= num;\n      prod *=\
    \ -1;\n    }\n  }\n\n  return sums * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpa6hokp1l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa6hokp1l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa6hokp1l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa6hokp1l.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa6hokp1l.cpp:2:\n/tmp/tmpa6hokp1l.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa6hokp1l.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa6hokp1l.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa6hokp1l.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa6hokp1l.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa6hokp1l.cpp:2:\n/tmp/tmpa6hokp1l.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.empty()) {\n\
    \t\treturn std::nullopt;\n\t}\n\tlong product = 1;\n\tlong sum = 0;\n\tstd::vector<long>\
    \ signs;\n\tfor (auto it = arr.begin(); it != arr.end(); ++it) {\n\t\tif (*it\
    \ < 0) {\n\t\t\tproduct *= -1;\n\t\t\tsigns.push_back(-1);\n\t\t} else if (*it\
    \ > 0) {\n\t\t\tsigns.push_back(1);\n\t\t} else {\n\t\t\tsigns.push_back(0);\n\
    \t\t}\n\t\tsum += std::abs(*it);\n\t}\n\tstd::vector<long> all_zeros = {0, 0,\
    \ 0};\n\tfor (auto it = signs.begin(); it != signs.end(); ++it) {\n\t\tif (std::equal(signs.begin(),\
    \ signs.end(), all_zeros.begin())) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8vpy5esw.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp8vpy5esw.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp8vpy5esw.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp8vpy5esw.cpp:38:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   38 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8vpy5esw.cpp:2:\n/tmp/tmp8vpy5esw.cpp:39:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   39 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp8vpy5esw.cpp:39:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp8vpy5esw.cpp:39:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   39 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp8vpy5esw.cpp:39:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp8vpy5esw.cpp:39:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   39 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8vpy5esw.cpp:2:\n/tmp/tmp8vpy5esw.cpp:39:5: note:\
    \ to match this \u2018(\u2019\n   39 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ ret(0);\n    // test case\n    if (arr.size() == 0) {\n        return ret;\n\
    \    }\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    return ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiy4fbdup.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpiy4fbdup.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpiy4fbdup.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpiy4fbdup.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiy4fbdup.cpp:2:\n/tmp/tmpiy4fbdup.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpiy4fbdup.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpiy4fbdup.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpiy4fbdup.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpiy4fbdup.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiy4fbdup.cpp:2:\n/tmp/tmpiy4fbdup.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::vector<int> signs;\n\
    \  long sum = 0;\n  for (auto& num : arr) {\n    if (num < 0) {\n      signs.push_back(-1);\n\
    \      sum += abs(num);\n    } else if (num > 0) {\n      signs.push_back(1);\n\
    \      sum += abs(num);\n    } else {\n      signs.push_back(0);\n    }\n  }\n\
    \  if (arr.size() == 0) {\n    return std::nullopt;\n  }\n  long result = sum;\n\
    \  for (auto& sign : signs) {\n    result *= sign;\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpis93al0e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpis93al0e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpis93al0e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpis93al0e.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpis93al0e.cpp:2:\n/tmp/tmpis93al0e.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpis93al0e.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpis93al0e.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpis93al0e.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpis93al0e.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpis93al0e.cpp:2:\n/tmp/tmpis93al0e.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sum = 0;\n    for (auto x : arr) {\n        sum += std::abs(x);\n  \
    \      if (x == 0) continue;\n        if (x > 0) {\n            prod *= 1;\n \
    \       } else {\n            prod *= -1;\n        }\n    }\n    if (sum == 0)\
    \ {\n        return std::nullopt;\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmar8jzak.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmar8jzak.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmar8jzak.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmar8jzak.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmar8jzak.cpp:2:\n/tmp/tmpmar8jzak.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmar8jzak.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmar8jzak.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmar8jzak.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmar8jzak.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmar8jzak.cpp:2:\n/tmp/tmpmar8jzak.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu0hn7nkd.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu0hn7nkd.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu0hn7nkd.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu0hn7nkd.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu0hn7nkd.cpp:2:\n/tmp/tmpu0hn7nkd.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu0hn7nkd.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu0hn7nkd.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu0hn7nkd.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu0hn7nkd.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu0hn7nkd.cpp:2:\n/tmp/tmpu0hn7nkd.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tlong sum=0;\n\tlong\
    \ product=1;\n\tfor(int i=0;i<arr.size();i++){\n\t\tif(arr[i]<0){\n\t\t\tsum +=\
    \ arr[i]*(-1);\n\t\t\tproduct *= -1;\n\t\t}\n\t\telse if(arr[i]>0){\n\t\t\tsum\
    \ += arr[i];\n\t\t\tproduct *= 1;\n\t\t}\n\t\telse if(arr[i]==0){\n\t\t\tcontinue;\n\
    \t\t}\n\t}\n\treturn product*sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpeqwz520q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpeqwz520q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpeqwz520q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpeqwz520q.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeqwz520q.cpp:2:\n/tmp/tmpeqwz520q.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpeqwz520q.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpeqwz520q.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpeqwz520q.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpeqwz520q.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeqwz520q.cpp:2:\n/tmp/tmpeqwz520q.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod_signs = 1;\n    long sum_magnitude\
    \ = 0;\n    for (auto elem : arr) {\n        if (elem == 0) {\n            continue;\n\
    \        }\n        prod_signs *= elem < 0 ? -1 : 1;\n        sum_magnitude +=\
    \ std::abs(elem);\n    }\n    return sum_magnitude * prod_signs;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbi95xcnt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbi95xcnt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbi95xcnt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbi95xcnt.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbi95xcnt.cpp:2:\n/tmp/tmpbi95xcnt.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbi95xcnt.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbi95xcnt.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbi95xcnt.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbi95xcnt.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbi95xcnt.cpp:2:\n/tmp/tmpbi95xcnt.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long result = 0;\n    long prod\
    \ = 1;\n    for (auto i : arr) {\n        i < 0 ? prod *= -1 : prod;\n       \
    \ result += std::abs(i);\n    }\n    return result * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmes1s6qu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmes1s6qu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmes1s6qu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmes1s6qu.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmes1s6qu.cpp:2:\n/tmp/tmpmes1s6qu.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmes1s6qu.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmes1s6qu.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmes1s6qu.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmes1s6qu.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmes1s6qu.cpp:2:\n/tmp/tmpmes1s6qu.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long sign = 1;\n    long magnitude\
    \ = 0;\n    for (auto &num : arr) {\n        if (num < 0) {\n            sign\
    \ *= -1;\n        }\n        magnitude += std::abs(num);\n    }\n    return magnitude\
    \ * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsoz4hmxy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpsoz4hmxy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpsoz4hmxy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpsoz4hmxy.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsoz4hmxy.cpp:2:\n/tmp/tmpsoz4hmxy.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpsoz4hmxy.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpsoz4hmxy.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpsoz4hmxy.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpsoz4hmxy.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsoz4hmxy.cpp:2:\n/tmp/tmpsoz4hmxy.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    long sum = 0;\n    for (auto\
    \ x : arr) {\n        sum += std::abs(x);\n        if (x > 0) {\n            product\
    \ *= 1;\n        } else if (x < 0) {\n            product *= -1;\n        } else\
    \ {\n            product *= 0;\n        }\n    }\n    return sum * product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfgcmjuwd.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfgcmjuwd.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfgcmjuwd.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfgcmjuwd.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgcmjuwd.cpp:2:\n/tmp/tmpfgcmjuwd.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfgcmjuwd.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfgcmjuwd.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfgcmjuwd.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfgcmjuwd.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgcmjuwd.cpp:2:\n/tmp/tmpfgcmjuwd.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(arr.size()\
    \ < 6);\n    long result = 0;\n    long prodsigns = 1;\n    for (auto i : arr)\
    \ {\n        prodsigns *= std::copysign(1, i);\n        result += std::abs(i);\n\
    \    }\n    if (arr.size() == 0)\n        return std::nullopt;\n    return result\
    \ * prodsigns;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy1sj7h4d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpy1sj7h4d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpy1sj7h4d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpy1sj7h4d.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy1sj7h4d.cpp:2:\n/tmp/tmpy1sj7h4d.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpy1sj7h4d.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpy1sj7h4d.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpy1sj7h4d.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpy1sj7h4d.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy1sj7h4d.cpp:2:\n/tmp/tmpy1sj7h4d.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  int sign = 0;\n  long product = 1;\n  long sum\
    \ = 0;\n  for (auto elem : arr) {\n    sign = std::signbit(elem) ? -1 : 1;\n \
    \   if (sign == 0) {\n      product = product * 0;\n    } else {\n      product\
    \ = product * sign;\n    }\n    sum = sum + std::abs(elem);\n  }\n  return product\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpth5w5qrs.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpth5w5qrs.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpth5w5qrs.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpth5w5qrs.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpth5w5qrs.cpp:2:\n/tmp/tmpth5w5qrs.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpth5w5qrs.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpth5w5qrs.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpth5w5qrs.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpth5w5qrs.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpth5w5qrs.cpp:2:\n/tmp/tmpth5w5qrs.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // TODO: your code\
    \ here\n    return {};\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpi4jnk70w.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpi4jnk70w.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpi4jnk70w.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpi4jnk70w.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi4jnk70w.cpp:2:\n/tmp/tmpi4jnk70w.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpi4jnk70w.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpi4jnk70w.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpi4jnk70w.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpi4jnk70w.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi4jnk70w.cpp:2:\n/tmp/tmpi4jnk70w.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return std::nullopt;\n  }\n  long sum = 0;\n  long prod = 1;\n  for (const\
    \ auto &item : arr) {\n    long sign = std::signbit(item) ? -1 : (item > 0) ?\
    \ 1 : 0;\n    sum += std::abs(item);\n    prod *= sign;\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpleopz8rg.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpleopz8rg.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpleopz8rg.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpleopz8rg.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpleopz8rg.cpp:2:\n/tmp/tmpleopz8rg.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpleopz8rg.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpleopz8rg.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpleopz8rg.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpleopz8rg.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpleopz8rg.cpp:2:\n/tmp/tmpleopz8rg.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::vector<long> signs(arr.size());\n\
    \    std::transform(arr.begin(), arr.end(), signs.begin(), [](long a) { return\
    \ (a < 0) ? -1 : ((a > 0) ? 1 : 0); });\n    std::vector<long> abs_arr(arr.size());\n\
    \    std::transform(arr.begin(), arr.end(), abs_arr.begin(), [](long a) { return\
    \ std::abs(a); });\n    long prod = std::accumulate(signs.begin(), signs.end(),\
    \ 1, std::multiplies<long>());\n    long sum = std::accumulate(abs_arr.begin(),\
    \ abs_arr.end(), 0L);\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpc7ngx9i7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpc7ngx9i7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpc7ngx9i7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpc7ngx9i7.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc7ngx9i7.cpp:2:\n/tmp/tmpc7ngx9i7.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpc7ngx9i7.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpc7ngx9i7.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpc7ngx9i7.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpc7ngx9i7.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc7ngx9i7.cpp:2:\n/tmp/tmpc7ngx9i7.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long signProd = 1;\n    long magSum\
    \ = 0;\n    for (long num : arr) {\n        if (num == 0) {\n            signProd\
    \ = 0;\n            magSum = 0;\n            break;\n        }\n        if (num\
    \ > 0) {\n            signProd *= 1;\n        } else {\n            signProd *=\
    \ -1;\n        }\n        magSum += std::abs(num);\n    }\n    return signProd\
    \ * magSum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl9tc5p79.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl9tc5p79.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl9tc5p79.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl9tc5p79.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl9tc5p79.cpp:2:\n/tmp/tmpl9tc5p79.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl9tc5p79.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl9tc5p79.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl9tc5p79.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl9tc5p79.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl9tc5p79.cpp:2:\n/tmp/tmpl9tc5p79.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n\
    \    for (auto i : arr) {\n        sum += std::abs(i);\n        if (i == 0) {\n\
    \            prod = 0;\n        } else if (i > 0) {\n            prod *= 1;\n\
    \        } else {\n            prod *= -1;\n        }\n    }\n    return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7i0isup4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7i0isup4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7i0isup4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7i0isup4.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7i0isup4.cpp:2:\n/tmp/tmp7i0isup4.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7i0isup4.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7i0isup4.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7i0isup4.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7i0isup4.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7i0isup4.cpp:2:\n/tmp/tmp7i0isup4.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    auto product = [](long acc, auto\
    \ item) {\n        if (item < 0) {\n            return acc * -1;\n        } else\
    \ if (item > 0) {\n            return acc * 1;\n        } else {\n           \
    \ return acc * 0;\n        }\n    };\n    auto prod = std::accumulate(arr.begin(),\
    \ arr.end(), 1L, product);\n    auto magnitude = [](long acc, auto item) {\n \
    \       return acc + abs(item);\n    };\n    auto mag = std::accumulate(arr.begin(),\
    \ arr.end(), 0L, magnitude);\n    return std::make_optional(prod * mag);\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeish8jny.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpeish8jny.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpeish8jny.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpeish8jny.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeish8jny.cpp:2:\n/tmp/tmpeish8jny.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpeish8jny.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpeish8jny.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpeish8jny.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpeish8jny.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeish8jny.cpp:2:\n/tmp/tmpeish8jny.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n    for (auto&\
    \ e : arr) {\n        if (e > 0) {\n            prod *= 1;\n            sum +=\
    \ e;\n        } else if (e < 0) {\n            prod *= -1;\n            sum +=\
    \ -e;\n        } else {\n            sum += 0;\n        }\n    }\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1fgazscf.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1fgazscf.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1fgazscf.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1fgazscf.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1fgazscf.cpp:2:\n/tmp/tmp1fgazscf.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1fgazscf.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1fgazscf.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1fgazscf.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1fgazscf.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1fgazscf.cpp:2:\n/tmp/tmp1fgazscf.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   int prod = 1;\n    std::vector<long> positive;\n    std::vector<long> negative;\n\
    \    if (arr.size() == 0) {\n        return {};\n    }\n    for (int i = 0; i\
    \ < arr.size(); i++) {\n        if (arr[i] == 0) {\n            return 0;\n  \
    \      }\n        if (arr[i] > 0) {\n            positive.push_back(arr[i]);\n\
    \        }\n        if (arr[i] < 0) {\n            negative.push_back(arr[i]);\n\
    \        }\n    }\n    for (int i = 0; i < positive.size(); i++) {\n        sum\
    \ += positive[i];\n    }\n    for (int i = 0; i < negative.size(); i++) {\n  \
    \      sum += abs(negative[i]);\n    }\n    if (positive.size() > 0 && negative.size()\
    \ > 0) {\n        return sum;\n    }\n    else if (positive.size() > 0 && negative.size()\
    \ == 0) {\n        return prod * sum;\n    }\n    else if (positive.size() ==\
    \ 0 && negative.size() > 0) {\n        return prod * sum;\n    }\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6mfsyfz5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6mfsyfz5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6mfsyfz5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6mfsyfz5.cpp:47:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   47 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6mfsyfz5.cpp:2:\n/tmp/tmp6mfsyfz5.cpp:48:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   48 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6mfsyfz5.cpp:48:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6mfsyfz5.cpp:48:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   48 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6mfsyfz5.cpp:48:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6mfsyfz5.cpp:48:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   48 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6mfsyfz5.cpp:2:\n/tmp/tmp6mfsyfz5.cpp:48:5: note:\
    \ to match this \u2018(\u2019\n   48 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
