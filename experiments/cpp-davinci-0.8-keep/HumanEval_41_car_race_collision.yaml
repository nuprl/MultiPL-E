name: HumanEval_41_car_race_collision
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly\
  \ straight infinitely long line.\n// n cars are driving left to right;  simultaneously,\
  \ a different set of n cars\n// are driving right to left.   The two sets of cars\
  \ start out being very far from\n// each other.  All cars move in the same speed.\
  \  Two cars are said to collide\n// when a car that's moving left to right hits\
  \ a car that's moving right to left.\n// However, the cars are infinitely sturdy\
  \ and strong; as a result, they continue moving\n// in their trajectory as if they\
  \ did not collide.\n// This function outputs the number of such collisions.\nlong\
  \ car_race_collision(long n) {\n"
tests: "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2))\
  \ == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n\
  \    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
completions: ["  // TODO:\n  int count = 0;\n  while( n > 0) {\n    count += n;\n\
    \    n--;\n  }\n  return count;", "    if (n == 0) return 0;\n    std::cout <<\
    \ \"n = \" << n << \"\\n\";\n    long count = 0;\n    std::priority_queue<long,\
    \ std::vector<long>, std::greater<long>> q_left, q_right;\n    for (long i = 0;\
    \ i < n; ++i) {\n        q_left.push(2 * i + 1);\n        q_right.push(2 * i);\n\
    \    }\n    while (!q_left.empty() && !q_right.empty()) {\n        std::cout <<\
    \ \"left: \" << q_left.top() << \", right: \" << q_right.top() << \"\\n\";\n \
    \       if (q_left.top() < q_right.top()) {\n            q_left.pop();\n     \
    \       count++;\n        } else {\n            q_right.pop();\n        }\n  \
    \  }\n    return count;", "  long ans = 0;\n  // Write your code here\n  return\
    \ ans;", '  return (n * (n - 1)) / 2;', "    // DP[i] = number of collisions when\
    \ there are i cars on the right.\n    std::vector<long> DP(n + 1, 0);\n    //\
    \ We will have an invariant that DP[i] is always n choose i.\n    // This is clear\
    \ because we are simply doing the i-th of the n possibilities\n    // of collision.\n\
    \    DP[0] = 1;\n    for (long i = 1; i <= n; i++) {\n        // DP[i] = n choose\
    \ i\n        DP[i] = DP[i - 1] * (n - i + 1) / i;\n    }\n    // If we consider\
    \ the two sets of cars, each of size n,\n    // and then pair all cars in the\
    \ left set with all cars in the right set,\n    // then the number of collisions\
    \ is the number of pairs where\n    // the car on the left is moving faster than\
    \ the car on the right.\n    // If the car on the left is i, the car on the right\
    \ is n-i+1,\n    // and the two cars have the same speed.\n    // This is because\
    \ the left car is at position n - i and the right car is at position n - i + 1.\n\
    \    // The left car has to move one block to the right to collide, while the\
    \ right car has to move\n    // one block to the left to collide.\n    // So the\
    \ speed of the two cars must be equal.\n    // If the car on the left is moving\
    \ faster than the car on the right,\n    // then the car on the right is moving\
    \ slower than the car on the left,\n    // which would mean that the car on the\
    \ right is moving left to right.\n    // Similarly, if the car on the right is\
    \ moving faster than the car on the left,\n    // then the car on the left is\
    \ moving right to left.\n    // So we can just loop through all pairs of cars,\
    \ and check if the left car is moving\n    // faster than the right car.\n   \
    \ long collisions = 0;\n    for (long i = 1; i <= n; i++) {\n        if (i > n\
    \ - i + 1) {\n            collisions += DP[i];\n        }\n    }\n    return collisions;",
  '  return 0;', '    return n * (n - 1) / 2;', "\treturn 0;", '    return n*(n-1)/2;',
  "    assert(n > 0);\n    return n * (n - 1) / 2;", "    assert(n > 0);\n    return\
    \ n * (n - 1) / 2;", "    long *cars = new long[n];\n    std::cin >> cars[0];\n\
    \    for (long i = 1; i < n; i++) {\n        std::cin >> cars[i];\n        if\
    \ (cars[i] == cars[i - 1]) {\n            return -1;\n        }\n    }\n    long\
    \ coll = 0;\n    long *right = new long[n];\n    right[0] = cars[0];\n    for\
    \ (long i = 1; i < n; i++) {\n        if (cars[i] > right[i - 1]) {\n        \
    \    right[i] = cars[i];\n        } else {\n            coll++;\n            right[i]\
    \ = right[i - 1];\n        }\n    }\n    long *left = new long[n];\n    left[n\
    \ - 1] = cars[n - 1];\n    for (long i = n - 2; i >= 0; i--) {\n        if (cars[i]\
    \ < left[i + 1]) {\n            left[i] = cars[i];\n        } else {\n       \
    \     coll++;\n            left[i] = left[i + 1];\n        }\n    }\n    long\
    \ *l = new long[n];\n    long *r = new long[n];\n    l[0] = cars[0];\n    r[n\
    \ - 1] = cars[n - 1];\n    for (long i = 1; i < n; i++) {\n        if (cars[i]\
    \ > l[i - 1]) {\n            l[i] = cars[i];\n        } else {\n            l[i]\
    \ = l[i - 1];\n        }\n    }\n    for (long i = n - 2; i >= 0; i--) {\n   \
    \     if (cars[i] < r[i + 1]) {\n            r[i] = cars[i];\n        } else {\n\
    \            r[i] = r[i + 1];\n        }\n    }\n    for (long i = 0; i < n; i++)\
    \ {\n        if (left[i] >= right[i]) {\n            coll++;\n        }\n    }\n\
    \    return coll;", "\treturn n * (n - 1) / 2;", "    long max_right = n, max_left\
    \ = n;\n    long count = 0;\n    while (max_right > 0 || max_left > 0) {\n   \
    \     if (max_right > 0) {\n            count += max_left;\n            max_right--;\n\
    \        }\n        if (max_left > 0) {\n            count += max_right;\n   \
    \         max_left--;\n        }\n    }\n    return count;", "\tassert(n >= 0);\n\
    \tlong temp = 0;\n\tlong count = 0;\n\twhile (n > 0) {\n\t\ttemp = 2 * temp +\
    \ 2;\n\t\tcount = count + temp;\n\t\tn--;\n\t}\n\treturn count;", "\tlong collisions\
    \ = 0;\n\tfor (long i = 0; i < n; i++) {\n\t\tfor (long j = 0; j < n; j++) {\n\
    \t\t\tcollisions++;\n\t\t}\n\t}\n\treturn collisions;", "    // Make a vector\
    \ to hold the indexes of the cars that are moving left to right\n    std::vector<long>\
    \ left_to_right;\n    // fill in the vector with the indexes of the cars that\
    \ are moving left to right\n    // Assume that the indexes of the cars that are\
    \ moving left to right are\n    // 0, 1, 2, ... , (n-1).\n    for (long i = 0;\
    \ i < n; i++) {\n        left_to_right.push_back(i);\n    }\n    // Make a vector\
    \ to hold the indexes of the cars that are moving right to left\n    std::vector<long>\
    \ right_to_left;\n    // fill in the vector with the indexes of the cars that\
    \ are moving right to left\n    // Assume that the indexes of the cars that are\
    \ moving right to left are\n    // (n-1), (n-2), (n-3), ... , 0.\n    for (long\
    \ i = n-1; i >= 0; i--) {\n        right_to_left.push_back(i);\n    }\n    //\
    \ Declare and initialize the counter for the number of collisions to 0.\n    long\
    \ number_of_collisions = 0;\n    // Loop over all the cars that are moving left\
    \ to right\n    for (long i = 0; i < left_to_right.size(); i++) {\n        //\
    \ Obtain the index of the car that is moving left to right\n        long index_of_car_moving_left_to_right\
    \ = left_to_right[i];\n        // Loop over all the cars that are moving right\
    \ to left\n        for (long j = 0; j < right_to_left.size(); j++) {\n       \
    \     // Obtain the index of the car that is moving right to left\n          \
    \  long index_of_car_moving_right_to_left = right_to_left[j];\n            //\
    \ if the indexes of the two cars are the same (i.e., the cars are in the same\
    \ place),\n            // increase the counter for the number of collisions by\
    \ 1.\n            if (index_of_car_moving_left_to_right == index_of_car_moving_right_to_left)\
    \ {\n                number_of_collisions++;", "\treturn n*(n-1)/2;", '  return
    n * (n - 1) / 2;', "\tif (n == 0) return 0;\n\tlong distance = 0;\n\tfor (long\
    \ i = 0; i < n; i++) {\n\t\tdistance += (n - i) * 2 - 1;\n\t}\n\treturn distance;",
  "  // Implement this function.  Do not modify the print statements.\n  return n\
    \ * n;", "  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j\
    \ = 0; j < n; j++) {\n      count++;\n    }\n  }\n  return count;", "    // error\
    \ checking\n    if (n < 1) {\n        return 0;\n    }\n    if (n == 1) {\n  \
    \      return 1;\n    }\n    if (n == 2) {\n        return 3;\n    }\n    // recursion\n\
    \    return (n * (n - 1) / 2 + car_race_collision(n - 1));", "  // Create a vector\
    \ of the positions of the cars\n  std::vector<long> right_to_left;\n  std::vector<long>\
    \ left_to_right;\n  for (long i = 0; i < n; i++) {\n    right_to_left.push_back(i);\n\
    \    left_to_right.push_back(i);\n  }\n  // Now sort the two vectors.\n  std::sort(right_to_left.begin(),\
    \ right_to_left.end());\n  std::sort(left_to_right.begin(), left_to_right.end());\n\
    \  // Now traverse the two vectors and see how many collisions there are.\n  long\
    \ i = 0;\n  long j = 0;\n  long retval = 0;\n  while (i < n && j < n) {\n    if\
    \ (right_to_left[i] == left_to_right[j]) {\n      retval++;\n      i++;\n    \
    \  j++;\n    } else if (right_to_left[i] < left_to_right[j]) {\n      i++;\n \
    \   } else {\n      j++;\n    }\n  }\n  return retval;", "\treturn n*(n-1);",
  "    std::vector<bool> v1(n);\n    std::vector<bool> v2(n);\n    for (long i = 0;\
    \ i < n; i++) {\n        v1[i] = false;\n        v2[i] = false;\n    }\n    long\
    \ count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j <\
    \ n; j++) {\n            if (v1[i] == false && v2[j] == false) {\n           \
    \     v1[i] = true;\n                v2[j] = true;\n                count++;\n\
    \            }\n        }\n    }\n    return count;", "  /*\n   * WRITE YOUR CODE\
    \ HERE.\n   */\n  long result = 0;\n  long car_num = n * 2;\n  for (long i = 1;\
    \ i <= car_num; i++) {\n    for (long j = i + 1; j <= car_num; j++) {\n      result\
    \ += n - abs(i - j) + 1;\n    }\n  }\n  return result;", "\tlong count = 0;\n\t\
    for (long i = 0; i < n; i++) {\n\t\tfor (long j = 0; j < n; j++) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;", "    // I used a hashmap to see how many cars are\
    \ on the left of a specific car\n    // (mapping the car number to the number\
    \ of cars on its left).\n    // In every iteration, I add the number of cars on\
    \ the left of the current car\n    // to the collision counter.\n    // For example,\
    \ let's say the cars moving left to right are ordered as follows:\n    // 1 2\
    \ 3 4 5 6 7 8 9 10\n    // Then the hashmap would look like this:\n    // {1:0,\
    \ 2:1, 3:2, 4:3, 5:4, 6:5, 7:6, 8:7, 9:8, 10:9}\n    // All cars have 0 cars on\
    \ their left, and so forth.\n    // The cars moving right to left are ordered\
    \ as follows:\n    // 10 9 8 7 6 5 4 3 2 1\n    // Then the iteration would look\
    \ like this:\n    // collisions += map[10] = 9\n    // collisions += map[9] =\
    \ 8\n    // collisions += map[8] = 7\n    // collisions += map[7] = 6\n    //\
    \ collisions += map[6] = 5\n    // collisions += map[5] = 4\n    // collisions\
    \ += map[4] = 3\n    // collisions += map[3] = 2\n    // collisions += map[2]\
    \ = 1\n    // collisions += map[1] = 0\n    // So the total number of collisions\
    \ is 45, which is the sum of the integers\n    // from 1 to 9.\n    std::unordered_map<long,\
    \ long> map;\n    long collisions = 0;\n    for (long i = 1; i <= n; i++)\n  \
    \      map[i] = i - 1;\n    for (long i = n; i >= 1; i--)\n        collisions\
    \ += map[i];\n    return collisions;", "\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\t\
    long long res = n;\n\tlong long offset = 2;\n\twhile (n >= 2) {\n\t\tres += n\
    \ * offset;\n\t\toffset *= 2;\n\t\tn /= 2;\n\t}\n\treturn res;", "    long sum\
    \ = 0;\n    for (long i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return\
    \ sum;", "    long counter = 0;\n    for (long i = 1; i <= n; i++) {\n       \
    \ for (long j = 1; j <= n; j++) {\n            if (i < j) {\n                counter++;\n\
    \            }\n        }\n    }\n    return counter;", "    // long i,s,j,b;\n\
    \    long i;\n    long count = 0;\n    long arr[n];\n    for(i=0;i<n;i++)\n  \
    \  {\n      scanf(\"%ld\",&arr[i]);\n    }\n     for(i=0;i<n;i++)\n     {\n  \
    \      if(arr[i]==1)\n        {\n          count++;\n        }\n     }\n    //\
    \ std::sort(arr,arr+n);\n    // for(i=0;i<n;i++)\n    // {\n    //   if(arr[i]==1)\n\
    \    //   {\n    //     count++;\n    //   }\n    // }\n    \n    \n   return\
    \ count;\n    ", "\t// NOTE:  You are not allowed to use any sort function, no\
    \ built-in sort,\n\t//  no qsort, no merge sort.  However, you may use a hash\
    \ table.\n\t// Your solution should run in time O(n*log n)\n\t// This function\
    \ may not use more than a few kbytes of memory\n\n\tlong *left = new long[n];\
    \ // Create array left\n\tlong *right = new long[n]; // Create array right\n\t\
    for (long i = 0; i < n; i++) {\n\t\tleft[i] = rand() % 100 + 1; // Generate random\
    \ numbers between 1 and 100\n\t\tright[i] = rand() % 100 + 1; // Generate random\
    \ numbers between 1 and 100\n\t}\n\tlong r = 0;\n\tstd::sort(left, left + n);\
    \ // Sort left array\n\tstd::sort(right, right + n); // Sort right array\n\tlong\
    \ i = 0;\n\tlong j = 0;\n\twhile (i < n && j < n) {\n\t\tif (left[i] < right[j])\
    \ {\n\t\t\ti++;\n\t\t}\n\t\telse if (left[i] > right[j]) {\n\t\t\tj++;\n\t\t}\n\
    \t\telse {\n\t\t\tr++;\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;", '    return
    0;', "    long answer = 0;\n    long remaining = n;\n    std::unordered_map<long,\
    \ long> ltr;\n    std::unordered_map<long, long> rtl;\n    std::cin >> remaining;\n\
    \    while (remaining > 0) {\n        long pos;\n        std::cin >> pos;\n  \
    \      ltr[pos]++;\n        remaining--;\n    }\n    remaining = n;\n    while\
    \ (remaining > 0) {\n        long pos;\n        std::cin >> pos;\n        rtl[pos]++;\n\
    \        remaining--;\n    }\n    auto it = ltr.begin();\n    while (it != ltr.end())\
    \ {\n        long pos = it->first;\n        answer += it->second * rtl[-pos];\n\
    \        it++;\n    }\n    return answer;", "    // Write your code here\n   \
    \ // To debug: cerr << \"Debug messages...\" << endl;\n    long num=0;\n    if(n<2)\
    \ return 0;\n    long* a=new long[n];\n    long* b=new long[n];\n    for(long\
    \ i=0;i<n;i++)\n    {\n        cin>>a[i];\n    }\n    for(long i=0;i<n;i++)\n\
    \    {\n        cin>>b[i];\n    }\n    sort(a,a+n);\n    sort(b,b+n);\n    for(long\
    \ i=0;i<n;i++)\n    {\n        for(long j=0;j<n;j++)\n        {\n            if(a[i]>b[j])\
    \ num++;\n            else break;\n        }\n    }\n    return num;", "    //\
    \ pick a random number between 0 and n - 1.\n    long randomNum = rand() % n;\n\
    \    // calculate the factors of this number.\n    std::vector<long> factors =\
    \ prime_factors(randomNum);\n    // the number of collisions is equal to the sum\
    \ of the factors of this number.\n    return std::accumulate(factors.begin(),\
    \ factors.end(), 0);", '    return 0;', "  long collisions = 0;\n  long counter\
    \ = 0;\n  std::vector<long> rightToLeft(n,0);\n  std::vector<long> leftToRight(n,0);\n\
    \  for(int i = 0; i < n; i++){\n    leftToRight[i] = i;\n  }\n  for(int i = 0;\
    \ i < n; i++){\n    rightToLeft[i] = n - i - 1;\n  }\n  for(int i = 0; i < n;\
    \ i++){\n    for(int j = 0; j < n; j++){\n      if(rightToLeft[i] == leftToRight[j]){\n\
    \        collisions++;\n      }\n    }\n  }\n  return collisions;", "    assert(n\
    \ >= 0);\n    if (n == 0) {\n        return 0;\n    }\n    return n + n - 2 +\
    \ car_race_collision(n - 1);", "    if (n == 0) return 0;\n    long s = 0;\n \
    \   for (long i = 1; i <= n; i++) {\n        s += i;\n    }\n    return s;", '    return
    (n*(n-1))/2;', "\tlong a1 = n;\n\tlong a2 = n;\n\tlong total = 0;\n\tfor (int\
    \ i = 0; i < n; i++) {\n\t\ttotal += a1;\n\t\ta1--;\n\t\ta2--;\n\t}\n\treturn\
    \ total;", "\t// 2n cars are passing each other\n\t// each car collides with each\
    \ car\n\n\t// 2n*(2n-1) = 4n^2 - 2n\n\t// since it is a function of n\n\t// and\
    \ the result is finite\n\t// when n is infinite, the result is 2(n^2)\n\n\t//\
    \ my answer is:\n\t// 2n*(2n-1)/2 = 2n^2 - n\n\t// since it is a function of n\n\
    \t// and the result is finite\n\t// when n is infinite, the result is n^2\n\t\
    // which is the correct answer.\n\t// I think it is because I simplified the process\
    \ of collisions.\n\t// In fact, each n cars pass each other twice.\n\t// When\
    \ n cars pass each other twice, it means there are n*(n-1) collisions.\n\t// Hence,\
    \ there are 4n*(n-1) collisions in total.\n\t// It is like the case of selecting\
    \ two students from n students.\n\t// If the order of selection matters, the total\
    \ number of selection is n*(n-1).\n\t// If the order of selection does not matter,\
    \ the total number of selection is n*(n-1)/2.\n\t// To avoid the confusion, we\
    \ can give 2n*(2n-1) collisions a more intuitive name:\n\t// \"number of pairs\
    \ of cars passing each other twice\".\n\treturn n*n;", '  return n*(n-1);', " \
    \   std::vector<long> A(n, 0);\n    std::vector<long> B(n, 0);\n    for (long\
    \ i = 0; i < n; i++)\n        A[i] = i + 1;\n    for (long i = 0; i < n; i++)\n\
    \        B[i] = -i - 1;\n    long c = 0;\n    for (long i = 0; i < n; i++) {\n\
    \        for (long j = 0; j < n; j++) {\n            if (A[i] == B[j])\n     \
    \           c++;\n        }\n    }\n    return c;", "    //since the cars are\
    \ so strong, the collisions only happen if the two cars are\n    //in the same\
    \ position\n    //for each car, find the position where it is at time t = 0. Then\
    \ find the\n    //position for all other cars at time t = 0. See if there are\
    \ any collisions\n    //here.\n    //initialize the positions of the first set\
    \ of cars to be from 0 to n - 1\n    //and the second set of cars to be from -1\
    \ to -n. we are using this set\n    //of positions to simulate the cars moving\
    \ left to right and right to left.\n    long left[n], right[n];\n    for (long\
    \ i = 0; i < n; i++) {\n        left[i] = i;\n        right[i] = -i - 1;\n   \
    \ }\n    //iterate through the first set of cars. For each car, check if there\
    \ is\n    //a collision in this position with any of the cars in the second set.\n\
    \    //if there is a collision, increment the number of collisions.\n    long\
    \ num_collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j\
    \ = 0; j < n; j++) {\n            if (left[i] == right[j]) {\n               \
    \ num_collisions++;\n            }\n        }\n    }\n    return num_collisions;",
  "  // Sum of the first n odd numbers\n  return n * (n-1) / 2;", '    return 0;',
  "    long* cars = new long[n];\n    long* cars2 = new long[n];\n    long collision_count\
    \ = 0;\n    for (long i = 0; i < n; i++) {\n        cars[i] = i;\n        cars2[i]\
    \ = n - i - 1;\n    }\n    // Write your solution here.\n    // You may leave\
    \ the following line commented out, but you must use it in your solution.\n  \
    \  for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n  \
    \          if (cars[i] == cars2[j]) {\n                collision_count++;\n  \
    \          }\n        }\n    }\n    return collision_count;", "  long cur_place=1;\n\
    \  long current_collisions=0;\n  bool left_to_right_cars[n];\n  for(long i=0;i<n;i++){\n\
    \    long car_position=0;\n    std::cin>>car_position;\n    left_to_right_cars[i]=car_position<cur_place;\n\
    \    if(left_to_right_cars[i])\n      current_collisions++;\n    else if(car_position==cur_place)\n\
    \      current_collisions++;\n    else\n      cur_place=car_position;\n  }\n \
    \ long cars_passed=0;\n  for(long i=0;i<n;i++){\n    long car_position=0;\n  \
    \  std::cin>>car_position;\n    if(left_to_right_cars[i]){\n      if(car_position>cur_place){\n\
    \        current_collisions+=car_position-cur_place;\n        cur_place=car_position;\n\
    \      }\n      cars_passed++;\n    }\n    else if(car_position<cur_place){\n\
    \      current_collisions-=n-cars_passed;\n      cur_place=car_position;\n   \
    \ }\n  }\n  return current_collisions;", "  assert(n > 0);\n  return n * (n -\
    \ 1) / 2;", "\treturn n * (n - 1) / 2;", "    long collision = 0;\n    long total\
    \ = 0;\n    if (n > 0) {\n        long left = 1;\n        long right = 1;\n  \
    \      while (n > 0) {\n            if (left < right) {\n                collision\
    \ += right - left;\n                left += 1;\n            } else {\n       \
    \         right += 1;\n            }\n            n -= 1;\n        }\n    }\n\
    \    total = collision;\n    return total;", "    // edge cases:\n    if (n <=\
    \ 0) {\n        return 0;\n    }\n\n    // helper variables:\n    std::vector<int>\
    \ my_vec;\n    long counter = 0;\n\n    // fill vector with same elements to keep\
    \ count of number of collisions\n    for (long i = 0; i < n; i++) {\n        my_vec.push_back(i);\n\
    \    }\n\n    // for each element of the vector, check to see if there is a number\
    \ to its right\n    // in the vector that is less than the element itself. If\
    \ so, we have a collision.\n    for (long i = 0; i < n; i++) {\n        for (long\
    \ j = i+1; j < n; j++) {\n            if (my_vec[i] > my_vec[j]) {\n         \
    \       counter++;\n            }\n        }\n    }\n\n    return counter;", " \
    \   assert(n >= 0);\n    return n * (n - 1) / 2;", "    long numcollisions = 0;\n\
    \    numcollisions = n*(n-1)/2;\n    return numcollisions;", '    return n * (n
    - 1) / 2;', "  // We will increment count by 1 each time two cars crash.\n  long\
    \ count = 0;\n  // When we're considering the ith car from the left, we want to\n\
    \  // consider only the cars from the ith car from the right to the\n  // last\
    \ car from the right.\n  for (long i = 0; i < n; i++) {\n    for (long j = i;\
    \ j < n; j++) {\n      count += 1;\n    }\n  }\n  return count;", "    int *a,*b;\n\
    \    long i,count=0;\n    a=(int *)malloc(n*sizeof(int));\n    b=(int *)malloc(n*sizeof(int));\n\
    \    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    for(i=0;i<n;i++)\n\
    \    {\n        scanf(\"%d\",&b[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n   \
    \     for(int j=0;j<n;j++)\n        {\n            if(a[i]==b[j])\n          \
    \  {\n                count++;\n            }\n        }\n    }\n    return count;",
  "    long a[n];\n    long b[n];\n    for(long i=0;i<n;i++)\n    {\n        cin>>a[i];\n\
    \    }\n    for(long i=0;i<n;i++)\n    {\n        cin>>b[i];\n    }\n    // Write\
    \ your code here.\n    sort(a,a+n);\n    sort(b,b+n);\n    vector<long> v1(a,a+n);\n\
    \    vector<long> v2(b,b+n);\n    long ret=0;\n    while(v1.size()!=0 && v2.size()!=0)\n\
    \    {\n        if(v1[0]>v2[0])\n        {\n            ret++;\n            v1.erase(v1.begin());\n\
    \            v2.erase(v2.begin());\n        }\n        else\n        {\n     \
    \       v1.erase(v1.begin());\n        }\n    }\n    return ret;", "    // Write\
    \ your code here\n    return n*(n-1);", "    // compute the number of collisions\
    \ based on the number of cars.\n    // number of collisions = sum of first n odd\
    \ numbers.\n    if(n==0)\n        return 0;\n    long odd = 1;\n    long sum =\
    \ 0;\n    for(long i=0;i<n;i++){\n        sum += odd;\n        odd += 2;\n   \
    \ }\n    return sum;", "// \tassert(n>=1);\n\treturn n*(n-1)/2;", "    // int\
    \ collisions = 0;\n    // for (int i = 0; i < n; i++) {\n    //     for (int j\
    \ = 0; j < n; j++) {\n    //         if (i < j) {\n    //             collisions++;\n\
    \    //         }\n    //     }\n    // }\n    // return collisions;\n    // return\
    \ n*(n-1)/2;\n    return (long)(n*(n-1)/2);", '  return (n * (n - 1)) / 2;', '  return
    n * (n - 1) / 2;', "    long x1 = 0;\n    long x2 = n;\n    long i = 0;\n    long\
    \ j = 0;\n    long count = 0;\n    while (j < n) {\n        // advance x1, x2\
    \ to their next collisions\n        while (x1 < x2) {\n            x1 += i;\n\
    \            i++;\n        }\n        while (x2 < x1) {\n            x2 += j;\n\
    \            j++;\n        }\n        count++;\n    }\n    return count;", " \
    \   assert(n > 0);\n    // your solution here\n    long numberOfPairs = (n*(n-1))/2;\n\
    \    return numberOfPairs;", "\treturn (n*(n-1))/2;", "\tlong long* a = new long\
    \ long[n];\n\tlong long* b = new long long[n];\n\tfor (long i = 0; i < n; i++)\
    \ {\n\t\tstd::cin >> a[i];\n\t}\n\tfor (long i = 0; i < n; i++) {\n\t\tstd::cin\
    \ >> b[i];\n\t}\n\tlong long count = 0;\n\tsort(a, a + n);\n\tsort(b, b + n);\n\
    \tint i = 0, j = 0;\n\twhile (i < n && j < n) {\n\t\tif (a[i] <= b[j]) {\n\t\t\
    \tcount += j;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tj++;\n\t\t}\n\t}\n\tcount\
    \ += j * (n - i);\n\treturn count;", "\tassert(n >= 0);\n\treturn n * (n - 1)\
    \ / 2;", "    long collisions = 0;\n    if (n == 0 || n == 1) {\n        return\
    \ collisions;\n    }\n    long *leftToRight = new long[n];\n    long *rightToLeft\
    \ = new long[n];\n    for (long i = 0; i < n; i++) {\n        leftToRight[i] =\
    \ n - i;\n        rightToLeft[i] = i + 1;\n    }\n    for (long i = 0; i < n;\
    \ i++) {\n        for (long j = 0; j < n; j++) {\n            if (leftToRight[i]\
    \ == rightToLeft[j]) {\n                collisions++;\n            }\n       \
    \ }\n    }\n    return collisions;", "\t//initialize the array\n\tlong* a = new\
    \ long[n];\n\tlong* b = new long[n];\n\tfor (long i = 0; i < n; i++) {\n\t\ta[i]\
    \ = i + 1;\n\t\tb[i] = n - i;\n\t}\n\t// count the number of collisions by traversing\
    \ the arrays and comparing them\n\tlong count = 0;\n\tfor (long i = 0; i < n;\
    \ i++) {\n\t\tfor (long j = 0; j < n; j++) {\n\t\t\tif (a[i] == b[j])\n\t\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;", "  assert(n >= 0);\n  // TODO: Implement\
    \ the function using only C++ constructs\n  //  no need to worry about overflows\n\
    \  return n*(n-1)/2;", '  return n*(n-1)/2;', "    assert(n >= 1);\n    // pre:\
    \ n >= 1\n    // post: We return the number of collisions.\n    if (n==1) return\
    \ 0;\n    return n*n-n;\n    // We'll develop a formal inductive proof for this\
    \ in the future.\n    // But for now, we'll do a heuristic argument.\n    // Think\
    \ of the number of cars as n.  Each car on the left moves\n    // forward, one-by-one,\
    \ colliding with all n cars on the right.\n    // In total, there are n collisions,\
    \ the first car on the left\n    // collides with n cars on the right, then the\
    \ second car on the left\n    // collides with n-1 cars on the right, etc.\n \
    \   // This is a geometric series with sum n(n+1)/2, or (n^2+n)/2.\n    // But\
    \ we counted each collision twice, so the answer is (n^2+n)/2 - n = (n^2-n)/2.",
  "\tlong count = 0;\n\tfor (long i = 0; i < n; i++) {\n\t\tfor (long j = n - 1; j\
    \ >= 0; j--) {\n\t\t\tif (i == j) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\
    \t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;", "    long collisions =\
    \ 0;\n    // WRITE YOUR CODE HERE\n    return collisions;", "    std::vector<long>\
    \ left;\n    for (int i = 0; i < n; i++) {\n        left.push_back(i);\n    }\n\
    \    std::vector<long> right;\n    for (int i = 0; i < n; i++) {\n        right.push_back(n\
    \ + i);\n    }\n    long collision = 0;\n    std::map<long, long> left_to_right;\n\
    \    std::map<long, long> right_to_left;\n    for (int i = 0; i < n; i++) {\n\
    \        left_to_right[left[i]] = right[i];\n        right_to_left[right[i]] =\
    \ left[i];\n    }\n    long pos = 0;\n    while (pos < n) {\n        if (left_to_right.find(pos)\
    \ != left_to_right.end()) {\n            long collision_pos = left_to_right[pos];\n\
    \            if (right_to_left.find(collision_pos) != right_to_left.end()) {\n\
    \                long collision_pos2 = right_to_left[collision_pos];\n       \
    \         if (collision_pos2 == pos) {\n                    collision++;\n   \
    \             }\n            }\n        }\n        pos++;\n    }\n    return collision;",
  "  std::vector<int> right_car(n, 0);\n  std::vector<int> left_car(n, 0);\n  std::unordered_map<int,\
    \ int> right_map;\n  std::unordered_map<int, int> left_map;\n  for (int i = 0;\
    \ i < n; i++) {\n    std::cin >> right_car[i];\n    right_map[right_car[i]] =\
    \ i;\n  }\n  for (int i = 0; i < n; i++) {\n    std::cin >> left_car[i];\n   \
    \ left_map[left_car[i]] = i;\n  }\n  long count = 0;\n  std::sort(right_car.begin(),\
    \ right_car.end());\n  std::sort(left_car.begin(), left_car.end());\n  // int\
    \ j = 0;\n  // for (int i = 0; i < n; i++) {\n  //   while (j < n && right_car[i]\
    \ > left_car[j]) {\n  //     j++;\n  //   }\n  //   if (j == n) {\n  //     break;\n\
    \  //   }\n  //   if (right_car[i] == left_car[j]) {\n  //     count++;\n  //\
    \   }\n  // }\n  int j = 0;\n  for (int i = 0; i < n; i++) {\n    if (right_map[right_car[i]]\
    \ > left_map[right_car[i]]) {\n      count++;\n    }\n  }\n  return count;", " \
    \   // replace the following line with your solution\n    return n*(n-1)/2;",
  "\t// long cars[n];\n\n\t// for (int i = 0; i < n; i++) {\n\t// \tcars[i] = n;\n\
    \t// }\n\n\t// for (int i = 0; i < n; i++) {\n\t// \tfor (int j = 0; j < n; j++)\
    \ {\n\t// \t\tif (i < j) {\n\t// \t\t\tif (cars[i] > cars[j]) {\n\t// \t\t\t\t\
    cars[i] = cars[j];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// for (int\
    \ i = 0; i < n; i++) {\n\t// \tfor (int j = 0; j < n; j++) {\n\t// \t\tif (i >\
    \ j) {\n\t// \t\t\tif (cars[i] > cars[j]) {\n\t// \t\t\t\tcars[i] = cars[j];\n\
    \t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// long count = 0;\n\t// for (int\
    \ i = 0; i < n; i++) {\n\t// \tif (cars[i] != n) {\n\t// \t\tcount++;\n\t// \t\
    }\n\t// }\n\n\t// return count;\n\n\tstd::vector<int> cars;\n\tint count = 0;\n\
    \tfor (int i = 0; i < n; i++) {\n\t\tcars.push_back(n);\n\t}\n\n\tfor (int i =\
    \ 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i < j) {\n\t\t\
    \t\tif (cars[i] > cars[j]) {\n\t\t\t\t\tcars[i] = cars[j];\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\
    \ {\n\t\t\tif (i > j) {\n\t", "\tlong double left[n], right[n];\n\n\tfor (long\
    \ i = 0; i < n; i++) {\n\t\tscanf(\"%Lf\", &left[i]);\n\t}\n\n\tfor (long i =\
    \ 0; i < n; i++) {\n\t\tscanf(\"%Lf\", &right[i]);\n\t}\n\n\tsort(left, left +\
    \ n);\n\tsort(right, right + n);\n\n\tlong ans = 0;\n\tfor (long i = 0; i < n;\
    \ i++) {\n\t\tfor (long j = 0; j < n; j++) {\n\t\t\tif (right[j] < left[i]) {\n\
    \t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;", "    // write your solution\
    \ here\n    // you may leave all of the below as it is, if you wish\n    return\
    \ 0;", "  long car_left_right = n;\n  long car_right_left = n;\n  long collision\
    \ = 0;\n  while (car_left_right > 0 && car_right_left > 0) {\n    if (car_left_right\
    \ == car_right_left) {\n      collision += 1;\n      car_left_right -= 1;\n  \
    \    car_right_left -= 1;\n    } else if (car_left_right > car_right_left) {\n\
    \      car_left_right -= car_right_left;\n      car_right_left = 0;\n    } else\
    \ {\n      car_right_left -= car_left_right;\n      car_left_right = 0;\n    }\n\
    \  }\n  return collision;", "    assert(n>=0);\n    // TODO - you fill in here.\n\
    \    return (n*(n-1))/2;", "  long  a[n],b[n];\n  for(long i=0;i<n;i++)\n  {\n\
    \    std::cin>>a[i];\n  }\n  for(long i=0;i<n;i++)\n  {\n    std::cin>>b[i];\n\
    \  }\n  long count=0;\n  for(long i=0;i<n;i++)\n  {\n    for(long j=0;j<n;j++)\n\
    \    {\n      if(a[i]==b[j])\n      {\n        count++;\n      }\n    }\n  }\n\
    \  return count;\n  // Implement this function.", '  return n*(n-1)/2;', "  long\
    \ result = 0;\n  long i = 0;\n  std::vector<long> cars;\n  for (i = 0; i < n;\
    \ i++) {\n    cars.push_back(1);\n  }\n  for (i = 0; i < n; i++) {\n    cars.push_back(-1);\n\
    \  }\n  for (i = 0; i < cars.size(); i++) {\n    if (cars[i] == 1) {\n      for\
    \ (int j = i+1; j < cars.size(); j++) {\n        if (cars[j] == -1) {\n      \
    \    result++;\n        }\n      }\n    }\n  }\n  return result;", "  // Your\
    \ code here\n  return 0;", "  long collisions = 0;\n  if (n <= 1) return collisions;\n\
    \  std::map<long, long> mapOfCars;\n  std::map<long, long>::iterator itr;\n  for\
    \ (long i = 0; i < n; i++) {\n    long carPosition;\n    std::cin >> carPosition;\n\
    \    mapOfCars.insert(std::pair<long, long>(carPosition, 1));\n  }\n  for (long\
    \ i = 0; i < n; i++) {\n    long carPosition;\n    std::cin >> carPosition;\n\
    \    itr = mapOfCars.find(carPosition);\n    if (itr != mapOfCars.end()) collisions++;\n\
    \  }\n  return collisions;", "\tint count = 0;\n\tfor (int i = 1; i <= n; i++)\
    \ {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;", '    return (n*(n-1))/2;', "\tif (n == 0) {\n\t\treturn 0;\n\t}\n\t\
    if (n == 1) {\n\t\treturn 0;\n\t}\n\tif (n == 2) {\n\t\treturn 1;\n\t}\n\treturn\
    \ car_race_collision(n - 1) + n - 1;\n", "    //    Write your code here\n\tif(n\
    \ == 0) return 0;\n\treturn n + car_race_collision(n-1);", "    assert(n>=0);\n\
    \    if(n<=1)\n        return 0;\n    return n*(n-1);", "    // when we look from\
    \ left to right, a car going from left to right appears to be\n    // increasing\
    \ in position, and a car going from right to left appears to be decreasing\n \
    \   // in position.\n    // we use a hash table to store the range of positions\
    \ occcupied by each left-to-right\n    // car.\n    // for each right-to-left\
    \ car, we check whether it collides with any of the left-to-right\n    // cars\
    \ in the hash table.  if the right-to-left car collides with a left-to-right car,\n\
    \    // we increment the number of collisions by 1.\n    // we iterate this entire\
    \ process until all right-to-left cars are checked.\n    // in order to check\
    \ how far we have to go to check all right-to-left cars,\n    // we keep track\
    \ of the right-most left-to-right car and the left-most right-to-left car.\n \
    \   std::map<long, long> map;\n    long l = 0;\n    long r = 0;\n    long collisions\
    \ = 0;\n    for (long i = 0; i < n; i++) {\n        l += i + 1;\n        r +=\
    \ n - i;\n        for (long j = 0; j < n; j++) {\n            // if there are\
    \ collisions between the ith car going left to right and the jth car\n       \
    \     // going right to left, then we increment the number of collisions by 1.\n\
    \            if (map.find(j + 1) != map.end() && map[j + 1] >= r - j) {\n    \
    \            collisions++;\n            }\n        }\n        // add the range\
    \ of positions occupied by the ith car going left to right.\n        map[i + 1]\
    \ = l + i;\n    }\n    return collisions;", '  return -1;', "    // 1.  First,\
    \ allocate an array to store the cars, where car[i] is the position of the ith\
    \ car.\n    //     The first n cars are moving left to right, and the next n cars\
    \ are moving right to left.\n    //     Think of cars[i] as the distance from\
    \ the beginning of the road to the car.\n    //     For example, if i = 0, then\
    \ cars[i] is the distance from the beginning of the road to the first car.\n \
    \   long *cars = new long[2*n];\n\n    // 2.  Write code that writes 2n numbers\
    \ into the array, with the first n numbers\n    //     being the distances of\
    \ the cars moving left to right,\n    //     and the next n numbers being the\
    \ distances of the cars moving right to left.\n    //     IMPORTANT: The cars\
    \ are infinitely long.  So, we can only infer the distance\n    //     from the\
    \ beginning of the road to the first car.  For example, if we set\n    //    \
    \ cars[0] = 100, we don't know where the end of the car is.  It could be\n   \
    \ //     anything beyond 100.\n    //     DO NOT USE A RANDOM NUMBER GENERATOR!!!\
    \  It is important that we have\n    //     the same test cases in order to verify\
    \ that our algorithm works.  So,\n    //     do not use a random number generator.\
    \  You can assume that the cars can\n    //     start anywhere in the road.  That\
    \ is, they can start anywhere in\n    //     the range [-10^9, 10^9].\n    cars[0]\
    \ = -5;\n    cars[1] = 8;\n    cars[2] = 11;\n    cars[3] = 13;\n    cars[4] =\
    \ 20;\n    cars[5] = 30;\n    cars[6] = 50;\n    cars[7] = 70;\n    cars[8] =\
    \ 100;\n    cars[9] = 110;\n    cars[10] = 120;\n    cars[11] = 130;\n    cars[12]\
    \ = 140;\n    cars[13] = 150;\n    cars[14] = 160;\n    cars[15] = 170;\n    cars[16]\
    \ = 180;\n   ", "  /*\n  // this is a correct solution, but fails\n  // on testcase\
    \ #5 (which is a testcase\n  // for correctness)\n  if (n == 0) return 0;\n  std::vector<long>\
    \ cars(n);\n  for (long i = 0; i < n; i++) {\n    cars[i] = i + 1;\n  }\n  long\
    \ ans = 0;\n  while (cars.size() > 1) {\n    std::vector<long> next;\n    for\
    \ (long i = 0; i < cars.size(); i += 2) {\n      if (i + 1 < cars.size()) {\n\
    \        if (cars[i] < cars[i + 1]) {\n          next.push_back(cars[i]);\n  \
    \      } else {\n          next.push_back(cars[i + 1]);\n        }\n      } else\
    \ {\n        next.push_back(cars[i]);\n      }\n    }\n    cars = next;\n    ans++;\n\
    \  }\n  return ans;\n  */\n  long ans = 0;\n  for (long i = 0; i < n; i++) {\n\
    \    for (long j = 0; j < n; j++) {\n      if (i < j) ans++;\n    }\n  }\n  return\
    \ ans;", '  return (n*(n-1))/2;', "\treturn n*(n - 1) / 2;", "\tlong leftToRightCounter\
    \ = 0;\n\tlong rightToLeftCounter = 0;\n\tlong counter = 0;\n\tlong max = 0;\n\
    \tlong total = 0;\n\tlong totalCar = 2 * n;\n\tlong *time = new long[totalCar];\n\
    \tfor (long i = 0; i < n; i++) {\n\t\ttime[i] = i;\n\t}\n\tfor (long i = n; i\
    \ < totalCar; i++) {\n\t\ttime[i] = totalCar - i;\n\t}\n\tfor (long i = 0; i <\
    \ totalCar; i++) {\n\t\tif (time[i] > max) {\n\t\t\tmax = time[i];\n\t\t}\n\t\
    }\n\tlong *array = new long[max + 1];\n\tfor (long i = 0; i < max + 1; i++) {\n\
    \t\tarray[i] = 0;\n\t}\n\tfor (long i = 0; i < totalCar; i++) {\n\t\tarray[time[i]]++;\n\
    \t}\n\tfor (long i = 0; i < max + 1; i++) {\n\t\tif (array[i] == 1) {\n\t\t\t\
    leftToRightCounter++;\n\t\t}\n\t\telse if (array[i] == 2) {\n\t\t\tcounter++;\n\
    \t\t}\n\t\telse if (array[i] == 3) {\n\t\t\tcounter++;\n\t\t\tleftToRightCounter++;\n\
    \t\t}\n\t\telse if (array[i] == 4) {\n\t\t\tcounter += 2;\n\t\t}\n\t\telse if\
    \ (array[i] == 5) {\n\t\t\tcounter += 2;\n\t\t\tleftToRightCounter++;\n\t\t}\n\
    \t\telse if (array[i] == 6) {\n\t\t\tcounter += 3;\n\t\t}\n\t\telse if (array[i]\
    \ == 7) {\n\t\t\tcounter += 3;\n\t\t\tleftToRightCounter++;\n\t\t}\n\t\telse if\
    \ (array[i] == 8) {\n\t\t\tcounter += 4;\n\t\t}\n\t\telse if (array[i] == 9) {\n\
    \t\t", "  if (n < 0) {\n    return 0;\n  }\n  if (n == 0) {\n    return 0;\n \
    \ }\n  if (n == 1) {\n    return 0;\n  }\n  long sum = 0;\n  for (long i = 1;\
    \ i < n; i++) {\n    sum += (i * (n - i));\n  }\n  return sum;", '  return n*(n-1)/2;',
  "  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = 0; j < n;\
    \ j++) {\n      count++;\n    }\n  }\n  return count;", '    return 0;', '  return
    n*(n-1)/2;', "    vector<pair<long,long>> left;\n    vector<pair<long,long>> right;\n\
    \    vector<long> result;\n    long collision = 0;\n    for(long i = 0; i < n;\
    \ i++) {\n        left.push_back(make_pair(i,i));\n        right.push_back(make_pair(i,-i));\n\
    \    }\n    for(long i = 0; i < n; i++) {\n        for(long j = 0; j < n; j++)\
    \ {\n            if(right[i].first == left[j].first) {\n                if(right[i].second\
    \ < left[j].second) {\n                    collision++;\n                }\n \
    \           }\n        }\n    }\n    return collision;", "    long count = 0;\n\
    \    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n\
    \            if (i < j) {\n                count++;\n            }\n        }\n\
    \    }\n    return count;", "  // --------------\n  // Efficiently compute the\
    \ number of collisions between left to right and right to left cars\n  // i.e.\
    \ the number of collisions where car i from the left-to-right direction and car\
    \ j from\n  // the right-to-left direction collide.  The program must be able\
    \ to handle large values of n.\n  // The function must run in O(n) time.\n  //\n\
    \  // Hint: Use a set or priority queue to find the closest collision.\n  // --------------\n\
    \  std::set<long> left_to_right;\n  std::set<long> right_to_left;\n  long distance\
    \ = (1 << 30);\n  // Compute the left to right cars\n  for (long i = 0; i < n;\
    \ i++) {\n    left_to_right.insert(distance - (i + 1));\n  }\n  // Compute the\
    \ right to left cars\n  for (long i = 0; i < n; i++) {\n    right_to_left.insert((i\
    \ + 1) - distance);\n  }\n  // Compute the number of collisions\n  std::set<long>::iterator\
    \ left_iter = left_to_right.begin();\n  std::set<long>::iterator right_iter =\
    \ right_to_left.begin();\n  long answer = 0;\n  while (left_iter != left_to_right.end()\
    \ && right_iter != right_to_left.end()) {\n    long left_car = *left_iter;\n \
    \   long right_car = *right_iter;\n    if (left_car < right_car) {\n      left_iter++;\n\
    \    } else if (left_car > right_car) {\n      right_iter++;\n    } else {\n \
    \     left_iter++;\n      right_iter++;\n      answer++;\n    }\n  }\n  return\
    \ answer;", "\t// long n;\n\t// std::cin >> n;\n\tlong col = 0;\n\tstd::map<long,\
    \ long> cars;\n\tfor (long i = 0; i < n; i++) {\n\t\tlong car;\n\t\tstd::cin >>\
    \ car;\n\t\tcars[car] = 1;\n\t}\n\tfor (long i = 0; i < n; i++) {\n\t\tlong car;\n\
    \t\tstd::cin >> car;\n\t\tif (cars.find(car) != cars.end()) {\n\t\t\tcol++;\n\t\
    \t}\n\t}\n\treturn col;", '  return n*(n-1);', '  return 0;', "\t// your code\
    \ here\n\tlong long res = 0;\n\tfor (long i = 0; i < n; i++) {\n\t\tres += i;\n\
    \t}\n\treturn res;", "\tstd::vector<long> left(n), right(n);\n\tfor (long i =\
    \ 0; i < n; i++) {\n\t\tstd::cin >> left[i];\n\t}\n\tfor (long i = 0; i < n; i++)\
    \ {\n\t\tstd::cin >> right[i];\n\t}\n\tsort(left.begin(), left.end());\n\tsort(right.begin(),\
    \ right.end());\n\tlong count = 0;\n\tfor (long i = 0; i < n; i++) {\n\t\tfor\
    \ (long j = 0; j < n; j++) {\n\t\t\tif (left[i] == right[j]) {\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;", '    return n*(n-1);', "    //std::cout\
    \ << \"n is \" << n << \"\\n\";\n    // n is odd\n    if (n%2 != 0) {\n      \
    \  //std::cout << \"n is odd: \" << n << \"\\n\";\n        //std::cout << \"n/2\
    \ is \" << n/2 << \"\\n\";\n        //std::cout << \"collisions = \" << (1+n/2)*(n/2)\
    \ << \"\\n\";\n        return (1+n/2)*(n/2);\n    }\n    // n is even\n    else\
    \ {\n        //std::cout << \"n is even: \" << n << \"\\n\";\n        //std::cout\
    \ << \"n/2 is \" << n/2 << \"\\n\";\n        //std::cout << \"collisions = \"\
    \ << (n/2)*(n/2) << \"\\n\";\n        return (n/2)*(n/2);\n    }", "\t// // Complete\
    \ this function\n\t// // You can add more functions to this file.\n\t// // Although,\
    \ the functions in this file will NOT be\n\t// // tested directly, the functions\
    \ in the file\n\t// // that you submit will be tested.\n\t// // You must provide\
    \ a correct solution for this entire\n\t// // function.\n\t// // If you do not\
    \ do so, 0 marks will be awarded.\n\t// return 0;\n\tif(n==0 || n==1){\n\t\treturn\
    \ 0;\n\t}\n\tlong sum=0;\n\tsum+= n*(n-1);\n\treturn sum;", "  long *left = new\
    \ long[n];\n  long *right = new long[n];\n  for (long i = 0; i < n; i++) {\n \
    \   left[i] = i + 1;\n    right[i] = n - i;\n  }\n  long mid = (left[n - 1] +\
    \ right[0]) / 2;\n  long collision = 0;\n  for (long i = 0; i < n; i++) {\n  \
    \  if (left[i] >= mid) {\n      for (long j = 0; j < n; j++) {\n        if (right[j]\
    \ <= mid) {\n          if (right[j] > left[i]) {\n            collision++;\n \
    \         }\n        }\n      }\n    }\n  }\n  return collision;", "    // Complete\
    \ this function\n    if(n==1)\n        return 0;\n    long*a=new long[n];\n  \
    \  long*b=new long[n];\n    for(long i=0;i<n;i++)\n    {\n        a[i]=i;\n  \
    \      b[i]=n-i-1;\n    }\n    long count=0;\n    for(long i=0;i<n;i++)\n    {\n\
    \        for(long j=0;j<n;j++)\n        {\n            if(a[i]==b[j])\n      \
    \          count++;\n        }\n    }\n    return count;", '    return n * (n-1)
    / 2;', "    if (n < 1) {\n        return 0;\n    }\n    if (n == 1) {\n      \
    \  return 1;\n    }\n    long long num = 1;\n    long long den = 1;\n    long\
    \ long frac = 0;\n    for (long i = n - 1; i > 0; i--) {\n        num *= (i +\
    \ n);\n        den *= i;\n        while ((num % 2 == 0) && (den % 2 == 0)) {\n\
    \            num /= 2;\n            den /= 2;\n        }\n        frac += (num\
    \ / den);\n    }\n    return frac;", "  long i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z;\n\
    \  return 0;", "    std::vector<long> cars(n);\n    for (long i = 0; i < n; i++)\
    \ {\n        cars[i] = i + 1;\n    }\n    std::sort(cars.begin(), cars.end());\n\
    \    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        collisions\
    \ += i - cars[i] + 1;\n    }\n    return collisions;", "    long x,y;\n    std::set<long>\
    \ s;\n    for(long i=0;i<n;i++) {\n        std::cin>>x;\n        s.insert(x);\n\
    \    }\n    for(long i=0;i<n;i++) {\n        std::cin>>y;\n        s.insert(y);\n\
    \    }\n    return s.size()-n;", "// Write your code here\n    long count =0;\n\
    \    for(long i=0;i<n;i++){\n        for(long j=0;j<n;j++){\n            if(i==j){\n\
    \                count++;\n            }\n        }\n    }\n    return count;",
  "  // TODO - you fill in here.\n  return 0;", "    long collisions = 0;\n    //\
    \ Write your code here\n    return collisions;", '    return n*(n-1)/2;', "  long\
    \ ret=0;\n  std::map<long,long> map;\n  for(long i=0;i<n;i++) {\n    std::cin>>p[i].x>>p[i].y;\n\
    \    p[i].x*=-1;\n    p[i].y*=-1;\n    map[p[i].x]++;\n  }\n  for(long i=0;i<n;i++)\
    \ {\n    ret+=map[p[i].y];\n    if(p[i].x==p[i].y) ret--;\n  }\n  return ret/2;",
  "    // Assume n >= 1\n    if (n == 1) {\n        return 0;\n    }\n    // Assume\
    \ n >= 2\n    // Left to right cars, e.g. {L1, L2, L3, ...}\n    // Right to left\
    \ cars, e.g. {R1, R2, R3, ...}\n    // For the i-th left to right car, the j-th\
    \ right to left car\n    // collides with it only if j <= i+1, because for j >\
    \ i+1,\n    // the right to left car has not yet started.\n    // The i-th left\
    \ to right car collides with j = i+1 right to left car\n    // and also collides\
    \ with j = i left to right car.\n    // Therefore, a left to right car collides\
    \ with i right to left cars.\n    // A right to left car, similarly, collides\
    \ with i left to right cars.\n    //\n    // Therefore, the total number of collisions\
    \ is\n    // Sum(i = 1, n) i = n(n+1)/2 = O(n^2)\n    return n * (n - 1) / 2;",
  "\tint left[n];\n\tint right[n];\n\tint collisions = 0;\n\tfor (int i = 0; i < n;\
    \ i++) {\n\t\tleft[i] = i;\n\t\tright[i] = n - i - 1;\n\t}\n\tfor (int i = 0;\
    \ i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (right[j] < left[i])\n\
    \t\t\t\tcollisions++;\n\t\t}\n\t}\n\treturn collisions;", "    // Corner case.\n\
    \    if (n == 0) {\n        return 0;\n    }\n    // Initialize a vector that\
    \ stores the position of cars moving left to right.\n    std::vector<long> pos_left_to_right;\n\
    \    for (long i = 0; i < n; i++) {\n        pos_left_to_right.push_back(i);\n\
    \    }\n    // Initialize a vector that stores the position of cars moving right\
    \ to left.\n    std::vector<long> pos_right_to_left;\n    for (long i = -n + 1;\
    \ i < 0; i++) {\n        pos_right_to_left.push_back(i);\n    }\n    // Initialize\
    \ a vector that stores the number of collisions.\n    std::vector<long> num_collisions;\n\
    \    // Initialize the number of collisions to 0.\n    num_collisions.push_back(0);\n\
    \    // Iterate through the positions of all cars moving left to right.\n    for\
    \ (long i = 0; i < n; i++) {\n        // Iterate through the positions of all\
    \ cars moving right to left.\n        for (long j = 0; j < n; j++) {\n       \
    \     // If the cars are in the same position, there is a collision.\n       \
    \     if (pos_left_to_right[i] == pos_right_to_left[j]) {\n                //\
    \ Increment the number of collisions by 1.\n                num_collisions[0]++;\n\
    \            }\n        }\n    }\n    // Return the number of collisions.\n  \
    \  return num_collisions[0];", "\tlong *r = new long[n];\n\tlong *l = new long[n];\n\
    \tfor (long i = 0; i < n; i++) {\n\t\tr[i] = i;\n\t\tl[i] = i;\n\t}\n\tfor (long\
    \ i = 0; i < n; i++) {\n\t\tfor (long j = 0; j < n; j++) {\n\t\t\tif (r[i] ==\
    \ l[j]) {\n\t\t\t\tstd::cout << r[i] << \":\" << l[j] << std::endl;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn 0;", '  return n*(n-1);', '    return n*(n-1)/2;', "    //\
    \ IMPLEMENT ME\n    if(n==0) return 0;\n    return n*(n-1);", "\tlong n_car =\
    \ n;\n\tlong collisions = 0;\n\tlong n_collisions = 0;\n\twhile (n_car > 0) {\n\
    \t\tn_collisions = n_car * (n_car - 1) / 2;\n\t\tcollisions += n_collisions;\n\
    \t\tn_car--;\n\t}\n\treturn collisions;", "    //list<long> list_of_longs;\n \
    \   long left[n];\n    long right[n];\n    for(long i = 0; i < n; i++) {\n   \
    \     left[i] = i;\n        right[i] = i + 1;\n    }\n    //list_of_longs.insert(list_of_longs.begin(),\
    \ left, left + sizeof(left) / sizeof(long));\n    //list_of_longs.insert(list_of_longs.begin(),\
    \ right, right + sizeof(right) / sizeof(long));\n    int count = 0;\n    for(long\
    \ i = 0; i < n; i++) {\n        if(left[i] > right[i]) {\n            count +=\
    \ 1;\n        }\n    }\n    return count;", "  long collisions = 0;\n  //map<long,long>\
    \ cars_coming_left;\n  //std::unordered_map<long,long> cars_coming_left;\n  std::set<long>\
    \ cars_coming_left;\n  long current_position = -1 * (std::numeric_limits<long>::max()\
    \ / 2);\n  for (long i = 0; i < n; i++) {\n    //cars_coming_left[current_position]\
    \ = 0;\n    //cars_coming_left.insert(std::make_pair(current_position,0));\n \
    \   cars_coming_left.insert(current_position);\n    current_position--;\n  }\n\
    \  current_position = std::numeric_limits<long>::max() / 2;\n  for (long i = 0;\
    \ i < n; i++) {\n    auto iter = cars_coming_left.lower_bound(current_position);\n\
    \    collisions += cars_coming_left.size() - std::distance(cars_coming_left.begin(),iter);\n\
    \    current_position++;\n  }\n  return collisions;", "  long m_c[2] = {0, 0};\n\
    \  long res = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"\
    %d %d\", &x, &y);\n    m_c[y > 0]++;\n    res += y == 0 ? m_c[0] : (m_c[1] - y\
    \ < 0 ? y : m_c[1]);\n  }\n  return res;", "\t// YOUR CODE HERE\n\tint sum = 0;\n\
    \tlong order[n] = {0};\n\tfor (int i = 0; i < n; i++) {\n\t\torder[i] = i;\n\t\
    }\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (order[i] !=\
    \ 0) {\n\t\t\t\torder[i]--;\n\t\t\t}\n\t\t}\n\t\tbool found = false;\n\t\tfor\
    \ (int i = n - 1; i >= 0; i--) {\n\t\t\tif (order[i] == 0) {\n\t\t\t\tsum++;\n\
    \t\t\t\tfound = true;\n\t\t\t\torder[i] = n - 1;\n\t\t\t}\n\t\t}\n\t\tif (!found)\
    \ {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum;", "    long collisons = 0;\n    return\
    \ collisons;", "    std::vector<int> right(n);\n    std::vector<int> left(n);\n\
    \    // std::iota(right.begin(), right.end(), 1);\n    // std::iota(left.begin(),\
    \ left.end(), 1);\n    for (int i = 0; i < n; i++) {\n        right[i] = n - i;\n\
    \        left[i] = i + 1;\n    }\n    std::map<int, int> collisions;\n    // Do\
    \ a merge operation between two sorted arrays.\n    int l = 0;\n    int r = 0;\n\
    \    while (l < n && r < n) {\n        if (left[l] < right[r]) {\n           \
    \ l++;\n        } else if (left[l] > right[r]) {\n            r++;\n        }\
    \ else {\n            // Collision!\n            if (collisions.find(left[l])\
    \ == collisions.end()) {\n                collisions[left[l]] = 1;\n         \
    \   } else {\n                collisions[left[l]]++;\n            }\n        \
    \    l++;\n            r++;\n        }\n    }\n    long ret = 0;\n    for (auto\
    \ iter = collisions.begin(); iter != collisions.end(); iter++) {\n        ret\
    \ += (iter->second - 1);\n    }\n    return ret;", "\tlong cars[n];\n\tlong cars1[n];\n\
    \tfor (long i = 0; i < n; i++) {\n\t\tcars[i] = i;\n\t\tcars1[i] = n - i - 1;\n\
    \t}\n\tlong result = 0;\n\tlong i = 0;\n\tlong j = 0;\n\twhile (i < n && j < n)\
    \ {\n\t\tif (cars[i] < cars1[j]) {\n\t\t\ti++;\n\t\t}\n\t\telse if (cars[i] >\
    \ cars1[j]) {\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tresult++;\n\t\t\ti++;\n\t\t\
    \tj++;\n\t\t}\n\t}\n\treturn result;", "    // remove the line below and implement\
    \ the function.\n    return 0;", "    long count = 0;\n    long i = 0;\n    while\
    \ (i < n) {\n        long j = 0;\n        while (j < n) {\n            if (j !=\
    \ i) {\n                count += 1;\n            }\n            j += 1;\n    \
    \    }\n        i += 1;\n    }\n    return count;", "  // If a car is moving right\
    \ to left, then its x coordinate is decreasing at a rate of 1 per second.\n  //\
    \ If a car is moving left to right, then its x coordinate is increasing at a rate\
    \ of 1 per second.\n  //  If we have n cars moving right to left and n cars moving\
    \ left to right,\n  // then we can number the cars from 0 through 2n-1.  The n\
    \ cars moving right to left will have\n  // left to right will have numbers 0\
    \ to n-1.  The n cars moving left to right will have numbers\n  // n to 2n-1.\
    \  For example, car 0 will be at position 0 at time 0 and will be at position\
    \ -10\n  // at time 10.  Car 1 will be at position 0 at time 0 and will be at\
    \ position -10 at time 10.\n  // Car 2 will be at position 0 at time 0 and will\
    \ be at position -10 at time 10.  Car n will be\n  // at position n at time 0\
    \ and will be at position n - 10 at time 10.  Car n+1 will be at position\n  //\
    \ n+1 at time 0 and will be at position n+1 - 10 at time 10.  Car 2n-1 will be\
    \ at position 2n-1\n  // at time 0 and will be at position 2n-1 - 10 at time 10.\n\
    \  // Then at time 10, car 0 will be at position -10.  Car 1 will be at position\
    \ -10.  Car 2 will be\n  // at position -10.  Car n will be at position n - 10.\
    \  Car n+1 will be at position n+1 - 10.\n  // Car 2n-1 will be at position 2n-1\
    \ - 10.\n  //\n  // If we have n cars moving right to left and n cars moving left\
    \ to right,\n  // then we can number the cars from 0 through 2n-1.  The n cars\
    \ moving right to left will have\n  // left to right will have numbers 0 to n-1.\
    \  The n cars moving left to right will have numbers\n  // n to 2n-1.  For example,\
    \ car 0 will be at position 0 at time 0 and will be at position -10\n  // at time\
    \ 10.  Car 1 will be at position 0 at time", "   // This function writes the number\
    \ of collisions to the standard output.\n    //\n    // WRITE YOUR CODE HERE\n\
    \    //\n    // You may use the standard input and output to report the number\
    \ of collisions.\n    //\n    // Your solution may not use any additional memory\
    \ outside the string s and\n    // the standard input and output.\n    //\n  \
    \  // You may use any of the standard library functions, for example:\n    //\n\
    \    //    std::count\n    //    std::cout\n    //    std::cin\n    //    std::endl\n\
    \    //    std::max\n    //    std::min\n    //    std::sort\n    //    std::stringstream\n\
    \    //    std::string\n    //    std::vector\n    //\n    // You may also use\
    \ all of the following STL container classes:\n    //\n    //    std::array\n\
    \    //    std::deque\n    //    std::forward_list\n    //    std::list\n    //\
    \    std::map\n    //    std::queue\n    //    std::set\n    //    std::stack\n\
    \    //    std::unordered_map\n    //    std::unordered_set\n    //    std::vector\n\
    \    //\n    // But note that, other than the standard input and output, your\
    \ solution\n    // may not use any global variables.\n    //\n    // Restrictions:\n\
    \    //\n    //    You may not use recursion.\n    //    You may not use multithreading.\n\
    \    //    You may not use any external libraries.\n    //    You may not temper\
    \ with the standard input or output.\n    //    You may not declare any new functions\
    \ (other than main).\n    //    You may not use goto.\n    //    You may not use\
    \ longjmp or setjmp.\n    //    You may not throw or catch exceptions.\n    //\
    \    You may not dynamically allocate memory (with malloc or new).\n    //\n \
    \   // You may declare additional variables in this function, but note that\n\
    \    // your solution may not use any global variables.\n    //\n    // HINT:\
    \ the input will be very large, so you need to use efficient algorithms\n    //\
    \ that are fast.\n    //\n    // Good luck!\n    long left", "    long i, j, ans\
    \ = 0;\n    std::vector<long> left_to_right(n), right_to_left(n);\n    for (i\
    \ = 0; i < n; i++) {\n        std::cin >> left_to_right[i];\n    }\n    for (i\
    \ = 0; i < n; i++) {\n        std::cin >> right_to_left[i];\n    }\n    std::sort(left_to_right.begin(),\
    \ left_to_right.end());\n    std::sort(right_to_left.begin(), right_to_left.end());\n\
    \    i = 0;\n    j = 0;\n    while (i < n && j < n) {\n        if (left_to_right[i]\
    \ < right_to_left[j]) {\n            ans++;\n            i++;\n        } else\
    \ {\n            j++;\n        }\n    }\n    return ans;", '  return n * (n -
    1) / 2;', "    long num_collisions = 0;\n    // TODO: Implement this function.\n\
    \    std::vector<long> left;\n    std::vector<long> right;\n    long temp;\n \
    \   for(long i = 0; i < n; i++) {\n        std::cin >> temp;\n        left.push_back(temp);\n\
    \    }\n    for(long i = 0; i < n; i++) {\n        std::cin >> temp;\n       \
    \ right.push_back(temp);\n    }\n    std::sort(left.begin(), left.end());\n  \
    \  std::sort(right.begin(), right.end());\n    for(long i = 0; i < n; i++) {\n\
    \        for(long j = 0; j < n; j++) {\n            if(right[j] > left[i]) {\n\
    \                num_collisions += n - j;\n                break;\n          \
    \  }\n        }\n    }\n    return num_collisions;", "\treturn 0;", "    long\
    \ collisions = 0;\n    //compute the number of collisions\n    for(long i = 0;\
    \ i < n; i++) {\n      for(long j = 0; j < n; j++) {\n        if(i == j) {\n \
    \         collisions += 1;\n        }\n      }\n    }\n    return collisions;",
  "    // Write your solution here\n    int ret = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (i < j) {\n       \
    \         ret++;\n            }\n        }\n    }\n    return ret;", "  // TODO:\
    \  fill in this function.  You may make calls to other\n  // functions that you\
    \ write.\n  //   Please feel free to comment out the code below that\n  // generates\
    \ a random arrangement of cars, and test your function\n  // on those sets of\
    \ cars.  But please turn the code back on and test it\n  // again to make sure\
    \ that it works in the general case.\n  /*\n  std::vector<long> left_to_right;\n\
    \  std::vector<long> right_to_left;\n  for (long i = 0; i < n; ++i) {\n    left_to_right.push_back(random()\
    \ % n);\n    right_to_left.push_back(random() % n);\n  }\n  */\n  return n * n;",
  "    // Implement me\n    return 0;", "    // Here, you must use long longs to store\
    \ the positions of the cars.\n    // Otherwise, you will get a wrong answer.\n\
    \    long long positions_left[n], positions_right[n];\n    // since there is no\
    \ instruction on how the cars are ordered,\n    // we assume that the left-to-right\
    \ cars are ordered by positions,\n    // and the right-to-left cars are ordered\
    \ by reverse positions.\n    for (long i = 0; i < n; i++) {\n        positions_left[i]\
    \ = i;\n        positions_right[i] = n + i;\n    }\n    // We should also keep\
    \ track of the number of cars on each side.\n    long num_cars_left = n, num_cars_right\
    \ = n;\n    // This is the last position that a car from the left has reached.\n\
    \    long long last_left = 0;\n    // This is the last position that a car from\
    \ the right has reached.\n    long long last_right = 2 * n;\n    // In this loop,\
    \ we move the cars one unit of distance at a time.\n    for (long long t = 0;\
    \ t < 2 * n; t++) {\n        // We move every car one unit of distance.\n    \
    \    for (long i = 0; i < n; i++) {\n            positions_left[i]++;\n      \
    \      positions_right[i]--;\n        }\n        // Then, we move the leftmost\
    \ car from the left side to the right side.\n        if (positions_left[0] > last_left)\
    \ {\n            // We shift all the cars over one index in the array.\n     \
    \       for (long i = 0; i < n - 1; i++) {\n                positions_left[i]\
    \ = positions_left[i + 1];\n            }\n            // Now we update the array\
    \ of right-to-left cars.\n            positions_right[num_cars_right - 1] = last_left\
    \ + 1;\n            num_cars_right++;\n            num_cars_left--;\n        \
    \    last_left++;\n        }\n        // Next, we move the rightmost car from\
    \ the right side to the left side.\n        if (positions_right[0] < last_right)\
    \ {\n           ", '    return (n*(n-1))/2;', "    // Assume n is never zero\n\
    \    long collisions = 0;\n    int cars1[n];\n    int cars2[n];\n    cars1[0]\
    \ = 0;\n    cars2[0] = n;\n    for (int i = 1; i < n; i++) {\n        cars1[i]\
    \ = cars1[i-1] + 1;\n        cars2[i] = cars2[i-1] - 1;\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        if (cars1[i] >= cars2[i]) {\n            collisions++;\n\
    \        }\n    }\n    return collisions;", "    // Write your code here.\n  \
    \  std::vector<long> a;\n    std::vector<long> b;\n    a.push_back(1);\n    b.push_back(n);\n\
    \    while (b.back() < n) {\n        b.push_back(b.back() + b.size());\n     \
    \   a.push_back(a.back() + a.size());\n    }\n    long ans = 0;\n    for (long\
    \ i = 0; i < b.size(); i++) {\n        if (b[i] > n)\n            break;\n   \
    \     ans += n - b[i];\n    }\n    for (long i = 0; i < a.size(); i++) {\n   \
    \     if (a[i] > n)\n            break;\n        ans += n - a[i];\n    }\n   \
    \ return ans;", '    return (n*(n-1))/2;', "    int nb_collision = 0;\n    std::vector<bool>\
    \ visited(n);\n    for (long i = 0; i < n; i++) {\n        long actual_car = i;\n\
    \        while (actual_car < n) {\n            long next_car = (actual_car + n)\
    \ / 2;\n            if (next_car == actual_car) break;\n            if (visited[next_car])\
    \ break;\n            actual_car = next_car;\n            visited[actual_car]\
    \ = true;\n            nb_collision++;\n        }\n    }\n    return nb_collision;",
  '    return n * (n - 1) / 2;', "  // YOUR CODE HERE\n  long ans = n;\n  for (long\
    \ i = 2; i <= n; i++) {\n    ans += (i - 1);\n  }\n  return ans;", "    long count=0;\n\
    \    while(n--)\n    {\n        count=count+n;\n    }\n    return count;", " \
    \   long collisions = 0;\n    long *left = new long[n];\n    long *right = new\
    \ long[n];\n    for (long i = 0; i < n; i++) {\n        left[i] = i;\n       \
    \ right[i] = n-i-1;\n    }\n    std::sort(left, left+n);\n    std::sort(right,\
    \ right+n);\n    for (long i = 0; i < n; i++) {\n        if (left[i] > right[i])\
    \ {\n            collisions++;\n        }\n    }\n    return collisions;", " \
    \ // Write your code here\n  long total = 0;\n  while(n>0){\n      total = total\
    \ + n;\n      n--;\n  }\n  return total;", "\tlong res = 0;\n\tif (n <= 1) return\
    \ res;\n\tlong num;\n\twhile (n > 1) {\n\t\tres += n;\n\t\tnum = n / 2;\n\t\t\
    n -= num;\n\t}\n\treturn res;", '    return n*(n-1)/2;', "\tlong res = 0;\n\t\
    long i = 1;\n\twhile (n > 0) {\n\t\tres += i * n;\n\t\tn--;\n\t\ti++;\n\t}\n\t\
    return res;", "    // This is your job. :)\n    long count =0;\n    for(long i=0;i<n;i++)\n\
    \        for(long j=0;j<n;j++)\n            if(i+j ==n-1)\n                count++;\n\
    \    return count;", "\tlong tp = 2*n;\n\tlong ar[tp];\n\tfor(long i=0;i<tp;i++)\n\
    \t\tar[i] = 0;\n\tlong carpos = 0;\n\tlong collision = 0;\n\tlong nv;\n\tfor(long\
    \ i=0;i<n;i++) {\n\t\tscanf(\"%ld\",&nv);\n\t\tif(ar[nv-1] == 0) {\n\t\t\tar[nv-1]\
    \ = 1;\n\t\t\tcarpos++;\n\t\t}\n\t\telse\n\t\t\tcollision++;\n\t}\n\t\n\tfor(long\
    \ i=0;i<n;i++) {\n\t\tscanf(\"%ld\",&nv);\n\t\tif(ar[nv-1] == 0) {\n\t\t\tar[nv-1]\
    \ = 1;\n\t\t\tcarpos++;\n\t\t}\n\t\telse\n\t\t\tcollision++;\n\t}\n\t\n\tassert(carpos\
    \ == tp);\n\t\n\treturn collision;", "    assert(n > 0);\n    return 0;", "  long\
    \ collisions = 0;\n  long i;\n  long* left_to_right = new long[n];\n  long* right_to_left\
    \ = new long[n];\n  for (i = 0; i < n; i++) {\n    left_to_right[i] = i;\n   \
    \ right_to_left[i] = n - i - 1;\n  }\n  for (i = 0; i < n; i++) {\n    collisions\
    \ += left_to_right[i] - right_to_left[i];\n  }\n  delete[] left_to_right;\n  delete[]\
    \ right_to_left;\n  return collisions;", "    assert(n > 0);\n    return n * (n\
    \ - 1) / 2;", "   long int count = 0;\n   long int i;\n   long int* a = new long\
    \ int[n];\n   long int* b = new long int[n];\n   long int* c = new long int[n];\n\
    \   for(i=0;i<n;i++)\n   {\n      std::cin>>a[i];\n   }\n   for(i=0;i<n;i++)\n\
    \   {\n      std::cin>>b[i];\n   }\n   for(i=0;i<n;i++)\n   {\n      c[i] = a[i]\
    \ - b[i];\n   }\n   for(i=0;i<n;i++)\n   {\n      for(long int j=i+1;j<n;j++)\n\
    \      {\n         if(c[i]>0&&c[j]<0)\n         {\n            count++;\n    \
    \     }\n      }\n   }\n   return count;", '    return 0;', "    long ans = n\
    \ * (n - 1) / 2;\n    return ans;", "    // A possible implementation:  sort the\
    \ two sets of cars based on their starting positions.\n    // Then, for each pair\
    \ of cars one from the left-to-right group and the other from the\n    // right-to-left\
    \ group, count the number of pairs whose starting positions are on the same side\n\
    \    // of the midpoint.\n\treturn ((n * (n-1)) / 2);", "    long count = 0;\n\
    \    // to get the number of cars coming from the left\n    for (long i = 1; i\
    \ <= n; i++) {\n        // to get the number of cars coming from the right\n \
    \       for (long j = 1; j <= n; j++) {\n            // if i crosses j, then we\
    \ have an increment\n            if (i < j) {\n                count++;\n    \
    \        }\n        }\n    }\n    return count;", "    long sum = 0;\n    for\
    \ (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n       \
    \     sum++;\n        }\n    }\n    return sum;", "    //assert(n>0);\n    //assert(n<=1e+5);\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "\tif (n <\
    \ 1) {\n\t\treturn 0;\n\t}\n\n\tif (n == 1) {\n\t\treturn 0;\n\t}\n\n\tif (n ==\
    \ 2) {\n\t\treturn 1;\n\t}\n\n\tint colls = 0;\n\tlong a = 1;\n\tlong b = 1;\n\
    \tlong c = 0;\n\twhile (n >= 3) {\n\t\tc = a + b;\n\t\tcolls += c;\n\t\ta = b;\n\
    \t\tb = c;\n\t\tn--;\n\t}\n\n\treturn colls;", "  std::vector<long> arr(n, 0);\n\
    \  for (long i = 0; i < n; i++) {\n    arr[i] = i + 1;\n  }\n  long count = 0;\n\
    \  for (long i = 0; i < n; i++) {\n    for (long j = 0; j < n; j++) {\n      if\
    \ (arr[i] == arr[j]) {\n        continue;\n      }\n      if (arr[i] > arr[j])\
    \ {\n        count++;\n      }\n    }\n  }\n  return count;", "    // Let us use\
    \ a priority queue to simulate the process. The priority queue\n    // will store\
    \ pairs (L, R) where L is the time that it takes the car to travel\n    // the\
    \ distance from starting point to the point where it is going to meet the\n  \
    \  // other car; R is the time it takes the other car to travel the same distance.\n\
    \    std::priority_queue<std::pair<long, long>> Q;\n    // At first all cars are\
    \ far far away from each other.\n    // It takes 0 second for each car to cover\
    \ this distance.\n    for (long i = 0; i < n; ++i) {\n        Q.push(std::make_pair(0,\
    \ 0));\n    }\n    // Pop two elements at a time from the priority queue. The\
    \ first element\n    // represents a car moving left to right; the second element\
    \ represents\n    // a car moving right to left. If the two cars meet each other\
    \ at the\n    // same time, then this counts as a collision.\n    long count =\
    \ 0;\n    for (long i = 0; i < n; ++i) {\n        long L = Q.top().first; Q.pop();\n\
    \        long R = Q.top().second; Q.pop();\n        // The new distance to cover\
    \ is twice of the old distance.\n        L *= 2; R *= 2;\n        // Push the\
    \ new elements back into the priority queue.\n        Q.push(std::make_pair(L,\
    \ R));\n        Q.push(std::make_pair(L + 1, R + 1));\n        // If the two elements\
    \ are equal, then the two cars collided.\n        count += (L == R);\n    }\n\
    \    return count;", "  assert(n > 0);\n  return n*(n-1);", "    // Write your\
    \ code here\n    // To debug: cerr << \"Debug messages...\" << endl;\n    long\
    \ long total_collision = 0;\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < n; j++) {\n            if(i < j) {\n                total_collision\
    \ += i + 1;\n            }\n            else {\n                total_collision\
    \ += j + 1;\n            }\n        }\n    }\n    return total_collision;", '  return
    0;', "    // In the following code, an \"index\" is the index of a car.\n    //\
    \ An \"index\" is an integer between 0 and n-1.\n    //\n    // For example, suppose\
    \ n = 5.\n    // Then the possible indices are 0, 1, 2, 3, 4.\n    // When I say\
    \ that \"some index\", I mean some index among those possible indices.\n    //\
    \ When I say that \"some index between 0 and n-1\", I mean some index among those\
    \ possible indices.\n    //\n    // Furthermore, here's how we can think of the\
    \ cars:\n    // Car #0 is the first car driving left to right.\n    // Car #1\
    \ is the second car driving left to right.\n    // And so on.\n    // The cars\
    \ driving right to left are the mirror image of the cars driving left to right.\n\
    \    //\n    // For example, suppose that n = 5.\n    // Then, the cars going\
    \ left to right are as follows:\n    // Car #0 is the first car going left to\
    \ right.\n    // Car #1 is the second car going left to right.\n    // Car #2\
    \ is the third car going left to right.\n    // Car #3 is the fourth car going\
    \ left to right.\n    // Car #4 is the fifth car going left to right.\n    //\n\
    \    // The cars going right to left are the mirror image of the cars going left\
    \ to right.\n    // Car #0 is the first car going right to left.\n    // Car #1\
    \ is the second car going right to left.\n    // Car #2 is the third car going\
    \ right to left.\n    // Car #3 is the fourth car going right to left.\n    //\
    \ Car #4 is the fifth car going right to left.\n    //\n    // The first car going\
    \ left to right meets the first car going right to left when they\n    // collide.\n\
    \    // The second car going left to right meets the second car going right to\
    \ left when they\n    // collide.\n    // The third car going left to right meets\
    \ the third car going right to left when they\n    // collide.\n    // The fourth\
    \ car going left to right meets the fourth car going right to left when they\n\
    \    // collide.\n    // The fifth car going left to right meets the fifth car\
    \ going", "    // invalid input\n    if (n < 0) {\n        return -1;\n    }\n\
    \    // when n equals to 0\n    else if (n == 0) {\n        return 0;\n    }\n\
    \    // when n equals to 1\n    else if (n == 1) {\n        return 1;\n    }\n\
    \    // when n >= 2\n    else {\n        long result = n;\n        for (long i\
    \ = 2; i <= n; i++) {\n            result += n - i + 1;\n        }\n        return\
    \ result;\n    }", '    return n * (n-1);', "    // std::vector<double> left_to_right_velocity;\n\
    \    // std::vector<double> right_to_left_velocity;\n    // std::vector<double>\
    \ time_taken_to_reach_line;\n    // std::vector<double> time_taken_to_reach_infinity;\n\
    \    // for(long i = 0; i < n; i++) {\n    //     double x = (double)rand() /\
    \ RAND_MAX;\n    //     left_to_right_velocity.push_back(x);\n    //     double\
    \ y = (double)rand() / RAND_MAX;\n    //     right_to_left_velocity.push_back(y);\n\
    \    //     double time_taken_by_left_to_right = x * 20 * 2;\n    //     time_taken_to_reach_line.push_back(time_taken_by_left_to_right);\n\
    \    //     double time_taken_by_right_to_left = y * 20 * 2;\n    //     time_taken_to_reach_infinity.push_back(time_taken_by_right_to_left);\n\
    \    // }\n    // auto max_time_by_left_to_right = std::max_element(time_taken_to_reach_line.begin(),\
    \ time_taken_to_reach_line.end());\n    // auto max_time_by_right_to_left = std::max_element(time_taken_to_reach_infinity.begin(),\
    \ time_taken_to_reach_infinity.end());\n    // long collsions = 0;\n    // for(long\
    \ i = 0; i < n; i++) {\n    //     double x = left_to_right_velocity[i];\n   \
    \ //     double left_to_right_time = 20 * 2 / x;\n    //     double y = right_to_left_velocity[i];\n\
    \    //     double right_to_left_time = 20 * 2 / y;\n    //     if(left_to_right_time\
    \ > right_to_left_time) {\n    //         collsions", '    return (n - 1) * n
    / 2;', "\tlong c=0;\n\tfor(long i=1;i<=n;i++)\n\t{\n\t\tfor(long j=1;j<=n;j++)\n\
    \t\t{\n\t\t\tc++;\n\t\t}\n\t}\n\treturn c;", "  // We're going to have n cars\
    \ moving left to right, and n cars moving right to left.\n  // Let's call the\
    \ left-to-right cars \"A\", and the right-to-left cars \"B\".\n  // As we have\
    \ n cars of each type, we can label them A1, A2, A3, ..., An and B1, B2, B3, ...,\
    \ Bn.\n  //\n  // We are going to represent a car with a tuple [start, end, speed],\
    \ where \"start\" is the\n  // position of the car when we start, \"end\" is the\
    \ position of the car when we stop, and\n  // \"speed\" is the speed of the car.\n\
    \  //\n  // For example, let's say that A1 starts out at start=1 and ends at end=100;\
    \ and B1 starts\n  // out at start=100 and ends at end=1.  Then, the time taken\
    \ for A1 to travel from start=1\n  // to end=100 is (100-1)/1 = 99.  Similarly,\
    \ the time taken for B1 to travel from start=100\n  // to end=1 is (100-1)/1 =\
    \ 99.  So, A1 and B1 end up colliding at position 1+99 = 100.\n  //\n  // Hence,\
    \ for this problem, we can use the formula\n  //   A.start + A.speed * t = B.start\
    \ + B.speed * t\n  // to find the intersection point.  We can convert this formula\
    \ to\n  //   t = (B.start - A.start) / (A.speed - B.speed)\n  //\n  // Now, let's\
    \ use a hash map to represent the cars in each set.  We can represent car A1 as\n\
    \  //   \"1\" -> [1, 100, 1]\n  // and car B1 as\n  //   \"1\" -> [100, 1, 1]\n\
    \  // Since we have n cars of each type, we can fill in the hash map for A and\
    \ B as follows:\n  //\n  // For A:\n  //   A[\"1\"] = [1, 1+n, 1]\n  //   A[\"\
    2\"] = [2, 2+n, 1]\n", "  long count = 0;\n  for (long i = 0; i < n; i++) {\n\
    \    for (long j = 0; j < n; j++) {\n      count++;\n    }\n  }\n  return count;"]
stop_tokens:
- "\n}"
