name: HumanEval_78_hex_key
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong total = 0;\n\t// check\
    \ which digits are primes\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tif\
    \ (num[i] == '2' || num[i] == '3' || num[i] == '5'\n\t\t\t|| num[i] == '7' ||\
    \ num[i] == 'B' || num[i] == 'D') {\n\t\t\ttotal++;\n\t\t}\n\t}\n\treturn total;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // string\n    // convert\
    \ to base 10\n    // find out the number of digits in num\n    // find the last\
    \ digit\n    // find the first digit\n    // find out how many zeros are at the\
    \ end\n    // remove zeros from the end\n    // find the last prime digit\n  \
    \  // find the first prime digit\n    // find out how many primes there are in\
    \ num\n    std::string s = \"0123456789ABCDEF\";\n    std::map<char, int> hex_dec;\n\
    \    int j = 0;\n    for (int i = 0; i < s.length(); i++) {\n        hex_dec[s[i]]\
    \ = j;\n        j++;\n    }\n    long sum = 0;\n    int k = num.length() - 1;\n\
    \    for (int i = 0; i < num.length(); i++) {\n        sum += hex_dec[num[i]]\
    \ * std::pow(16, k);\n        k--;\n    }\n    // std::cout << sum << std::endl;\n\
    \    int count = 0;\n    for (int i = 3; i <= sum; i++) {\n        if (sum % i\
    \ == 0) {\n            count++;\n        }\n    }\n    // std::cout << count <<\
    \ std::endl;\n    if (count == 0) {\n        return sum;\n    }\n    else {\n\
    \        return count;\n    }\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmprm1zi6p6: /tmp/tmprm1zi6p6.cpp:60: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long sum = 0;\n  if (num ==\
    \ \"\") {\n    return 0;\n  }\n  long length = num.length();\n  for (long i =\
    \ 0; i < length; i++) {\n    if (num[i] == 'A' || num[i] == 'B' || num[i] == 'D')\
    \ {\n      sum += 1;\n    }\n    if (num[i] == '2' || num[i] == '3' || num[i]\
    \ == '5' ||\n      num[i] == '7') {\n      sum += 1;\n    }\n  }\n  return sum;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpb2u7u5c8: /tmp/tmpb2u7u5c8.cpp:38: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong sum = 0;\n\tfor (char\
    \ ch : num) {\n\t\tif (ch == 'A' || ch == 'B' || ch == 'D') sum++;\n\t}\n\treturn\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpytg9vqfe: /tmp/tmpytg9vqfe.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tchar key[] = { '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\tlong hex_key_num\
    \ = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tfor (int j = 0; j < sizeof(key);\
    \ j++) {\n\t\t\tif (num[i] == key[j]) {\n\t\t\t\thex_key_num = j + 1;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t}\n\treturn hex_key_num;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp8kvzd049: /tmp/tmp8kvzd049.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sum = 0;\n    for (auto\
    \ x : num) {\n        if (x >= '0' && x <= '9')\n            sum += (x - '0');\n\
    \        else if (x >= 'A' && x <= 'F')\n            sum += (x - 'A' + 10);\n\
    \    }\n    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp345huh40: /tmp/tmp345huh40.cpp:31: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpydcqexzz: /tmp/tmpydcqexzz.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong long res = 0;\n\tfor (int\
    \ i = 0; i < num.size(); i++) {\n\t\tif (num[i] >= '0' && num[i] <= '9') {\n\t\
    \t\tres = res * 16 + num[i] - '0';\n\t\t}\n\t\telse {\n\t\t\tres = res * 16 +\
    \ num[i] - 'A' + 10;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpxu5dv3pc: /tmp/tmpxu5dv3pc.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpcq8rvl9c: /tmp/tmpcq8rvl9c.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // hex_key => number of hex\
    \ numbers that are primes\n  long hex_key = 0;\n  // split => split string by\
    \ individual characters\n  std::vector<char> split;\n  // primes => prime numbers\n\
    \  std::vector<int> primes = {2, 3, 5, 7, 11, 13};\n  // create vector of split\
    \ characters\n  for (int i = 0; i < num.length(); i++) {\n    split.push_back(num[i]);\n\
    \  }\n  // loop through split characters\n  for (int i = 0; i < split.size();\
    \ i++) {\n    // loop through primes\n    for (int j = 0; j < primes.size(); j++)\
    \ {\n      // char -> digit for switch statement\n      char digit = (char)primes[j];\n\
    \      // check if prime number\n      switch (digit) {\n        case '2':\n \
    \         if (split[i] == '2') {\n            hex_key++;\n          }\n      \
    \    break;\n        case '3':\n          if (split[i] == '3') {\n           \
    \ hex_key++;\n          }\n          break;\n        case '5':\n          if (split[i]\
    \ == '5') {\n            hex_key++;\n          }\n          break;\n        case\
    \ '7':\n          if (split[i] == '7') {\n            hex_key++;\n          }\n\
    \          break;\n        case 'B':\n          if (split[i] == 'B') {\n     \
    \       hex_key++;\n          }\n          break;\n        case 'D':\n       \
    \   if (split[i] == 'D') {\n            hex_key++;\n          }\n          break;\n\
    \        default:\n          break;\n      }\n    }\n  }\n  return hex_key;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp09bweuft: /tmp/tmp09bweuft.cpp:77: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::map<char, int> hexKey;\n\
    \thexKey['0'] = 0;\n\thexKey['1'] = 1;\n\thexKey['2'] = 2;\n\thexKey['3'] = 3;\n\
    \thexKey['4'] = 4;\n\thexKey['5'] = 5;\n\thexKey['6'] = 6;\n\thexKey['7'] = 7;\n\
    \thexKey['8'] = 8;\n\thexKey['9'] = 9;\n\thexKey['A'] = 10;\n\thexKey['B'] = 11;\n\
    \thexKey['C'] = 12;\n\thexKey['D'] = 13;\n\thexKey['E'] = 14;\n\thexKey['F'] =\
    \ 15;\n\tint dec = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tdec = dec\
    \ * 16 + hexKey[num[i]];\n\t}\n\treturn dec;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpl832_esb: /tmp/tmpl832_esb.cpp:45: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    const static std::string\
    \ hex_values = \"0123456789ABCDEF\";\n    const static std::vector<int> primes\
    \ = {2, 3, 5, 7, 11, 13};\n    long key = 0;\n    for (auto c : num) {\n     \
    \   int i = hex_values.find(c);\n        key = 16 * key + i;\n    }\n    return\
    \ key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp6fwf6n_v: /tmp/tmp6fwf6n_v.cpp:31: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long count = 0;\n    int\
    \ primes[] = {2, 3, 5, 7, 11, 13};\n    for (int i = 0; i < 6; i++) {\n      \
    \  if (num.find(std::to_string(primes[i])) != std::string::npos) {\n         \
    \   count++;\n        }\n        if (num.find(std::to_string(primes[i]).at(0))\
    \ != std::string::npos) {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpo2pr0jb8: /tmp/tmpo2pr0jb8.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong count = 0;\n\tstd::string\
    \ primes = \"2357BD\";\n\tstd::set<char> set;\n\tfor (auto c : primes) {\n\t\t\
    set.insert(c);\n\t}\n\tfor (auto c : num) {\n\t\tif (set.find(c) != set.end())\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int n = num.size();\n   \
    \ // c++11\n    // static std::unordered_map<char, int> char_to_int = {\n    //\
    \     {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4}, {'5', 5}, {'6', 6}, {'7',\
    \ 7}, {'8', 8}, {'9', 9},\n    //     {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13},\
    \ {'E', 14}, {'F', 15},\n    // };\n    static std::map<char, int> char_to_int\
    \ = {\n        {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4}, {'5', 5}, {'6',\
    \ 6}, {'7', 7}, {'8', 8}, {'9', 9},\n        {'A', 10}, {'B', 11}, {'C', 12},\
    \ {'D', 13}, {'E', 14}, {'F', 15},\n    };\n    long key = 0;\n    for (int i\
    \ = 0; i < n; i++) {\n        key *= 16;\n        key += char_to_int[num[i]];\n\
    \    }\n    return key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp5tyi_mxz: /tmp/tmp5tyi_mxz.cpp:39: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int total = 0;\n    for (int\
    \ i = 0; i < num.length(); i++) {\n        switch (num[i]) {\n            case\
    \ '0':\n            case '1':\n            case '4':\n            case '6':\n\
    \            case '8':\n            case '9':\n            case 'A':\n       \
    \     case 'C':\n            case 'E':\n                break;\n            case\
    \ '2':\n            case '3':\n            case '5':\n            case '7':\n\
    \            case 'B':\n            case 'D':\n                total++;\n    \
    \            break;\n            default:\n                break;\n        }\n\
    \    }\n    return total;\n}\nint main() {\n    auto candidate = hex_key;\n  \
    \  assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long hex_sum = 0;\n    for\
    \ (int i = 0; i < num.length(); i++) {\n        switch (num[i]) {\n          \
    \  case 'A':\n                hex_sum += 10;\n                break;\n       \
    \     case 'B':\n                hex_sum += 11;\n                break;\n    \
    \        case 'C':\n                hex_sum += 12;\n                break;\n \
    \           case 'D':\n                hex_sum += 13;\n                break;\n\
    \            case 'E':\n                hex_sum += 14;\n                break;\n\
    \            case 'F':\n                hex_sum += 15;\n                break;\n\
    \            default:\n                hex_sum += num[i] - '0';\n            \
    \    break;\n        }\n    }\n    return hex_sum;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmps2x4kelu: /tmp/tmps2x4kelu.cpp:50: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::unordered_map<char,long>\
    \ hex_map;\n    hex_map['0'] = 0;\n    hex_map['1'] = 1;\n    hex_map['2'] = 2;\n\
    \    hex_map['3'] = 3;\n    hex_map['4'] = 4;\n    hex_map['5'] = 5;\n    hex_map['6']\
    \ = 6;\n    hex_map['7'] = 7;\n    hex_map['8'] = 8;\n    hex_map['9'] = 9;\n\
    \    hex_map['A'] = 10;\n    hex_map['B'] = 11;\n    hex_map['C'] = 12;\n    hex_map['D']\
    \ = 13;\n    hex_map['E'] = 14;\n    hex_map['F'] = 15;\n    long sum = 0;\n \
    \   for(int i = 0; i < num.size(); i++) {\n        sum = sum*16 + hex_map[num[i]];\n\
    \    }\n    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp4kckd8dy: /tmp/tmp4kckd8dy.cpp:45: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong count = 0;\n\tfor (int\
    \ i = 0; i < num.length(); i++) {\n\t\tif (num[i] == '2' || num[i] == '3' || num[i]\
    \ == '5' || num[i] == '7' || num[i] == 'B' || num[i] == 'D') {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::map<char,long> hex_digits;\n\
    \thex_digits['0'] = 0;\n\thex_digits['1'] = 1;\n\thex_digits['2'] = 2;\n\thex_digits['3']\
    \ = 3;\n\thex_digits['4'] = 4;\n\thex_digits['5'] = 5;\n\thex_digits['6'] = 6;\n\
    \thex_digits['7'] = 7;\n\thex_digits['8'] = 8;\n\thex_digits['9'] = 9;\n\thex_digits['A']\
    \ = 10;\n\thex_digits['B'] = 11;\n\thex_digits['C'] = 12;\n\thex_digits['D'] =\
    \ 13;\n\thex_digits['E'] = 14;\n\thex_digits['F'] = 15;\n\tlong result = 0;\n\t\
    long multiplier = 1;\n\tlong last = 0;\n\tlong dig = 0;\n\tlong tmp = 0;\n\tlong\
    \ r = 0;\n\tlong rem = 0;\n\tfor(int i = num.size()-1; i >= 0; i--) {\n\t\tdig\
    \ = hex_digits[num[i]];\n\t\tresult += dig * multiplier;\n\t\tmultiplier *= 16;\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpuq_3c8dv: /tmp/tmpuq_3c8dv.cpp:53: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // your code\n    unsigned\
    \ long long dec = 0;\n    int hex_val;\n    int size = num.size();\n    int i\
    \ = 0;\n    while(i < size) {\n        switch(num[i]) {\n            case 'A':\n\
    \                hex_val = 10;\n                break;\n            case 'B':\n\
    \                hex_val = 11;\n                break;\n            case 'C':\n\
    \                hex_val = 12;\n                break;\n            case 'D':\n\
    \                hex_val = 13;\n                break;\n            case 'E':\n\
    \                hex_val = 14;\n                break;\n            case 'F':\n\
    \                hex_val = 15;\n                break;\n            default:\n\
    \                hex_val = num[i] - '0';\n                break;\n        }\n\
    \        dec = dec * 16 + hex_val;\n        i++;\n    }\n    int prime_count =\
    \ 0;\n    while(dec > 0) {\n        int last_dig = dec % 10;\n        if(last_dig\
    \ == 2 || last_dig == 3 || last_dig == 5 || last_dig == 7 || last_dig == 11 ||\
    \ last_dig == 13) {\n            prime_count++;\n        }\n        dec /= 10;\n\
    \    }\n    return prime_count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp9g1eg7tk: /tmp/tmp9g1eg7tk.cpp:68: int main(): Assertion `candidate((\"\
    123456789ABCDEF0\")) == (6)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int res = 0;\n    for (int\
    \ i = 0; i < num.size(); i++) {\n        switch (num[i]) {\n            case '0':\n\
    \            case '1':\n            case '2':\n            case '3':\n       \
    \     case '4':\n            case '5':\n            case '6':\n            case\
    \ '7':\n            case '8':\n            case '9':\n                res += num[i]\
    \ - '0';\n                break;\n            case 'A':\n            case 'B':\n\
    \            case 'D':\n            case 'E':\n                res += 11;\n  \
    \              break;\n            case 'C':\n            case 'F':\n        \
    \        res += 17;\n                break;\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp7rn98tg0: /tmp/tmp7rn98tg0.cpp:51: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::map<char, long> hex_map\
    \ = {{'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15}};\n\tlong\
    \ output = 0;\n\tfor (char& c : num) {\n\t\tif (c >= 'A' && c <= 'F') {\n\t\t\t\
    if (hex_map[c] == 2 || hex_map[c] == 3 || hex_map[c] == 5 || hex_map[c] == 7 ||\
    \ hex_map[c] == 11 || hex_map[c] == 13) {\n\t\t\t\toutput++;\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\tif (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c ==\
    \ 'D') {\n\t\t\t\toutput++;\n\t\t\t}\n\t\t}\n\t}\n\treturn output;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long count = 0;\n  if (num.length()\
    \ == 0) {\n    return 0;\n  }\n  for (int i = 0; i < num.length(); i++) {\n  \
    \  if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || num[i]\
    \ == 'B' || num[i] == 'D') {\n      count++;\n    }\n  }\n  return count;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long res = 0;\n    long p\
    \ = 1;\n    for (int i = num.size() - 1; i >= 0; i--) {\n        char c = num[i];\n\
    \        int d = c >= 'A' ? (10 + c - 'A') : (c - '0');\n        res += d * p;\n\
    \        p *= 16;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpybfzzsbb: /tmp/tmpybfzzsbb.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong count = 0;\n\tfor (auto\
    \ x : num) {\n\t\tswitch (x) {\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '5':\n\t\
    \tcase '7':\n\t\tcase 'B':\n\t\tcase 'D':\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t\
    default:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long out = 0;\n  long j = 0;\n\
    \  for (auto i : num) {\n    if (isdigit(i)) {\n      out += (i - '0')*pow(16,\
    \ num.size() - 1 - j);\n    } else {\n      switch (i) {\n        case 'A':\n\
    \          out += 10*pow(16, num.size() - 1 - j);\n          break;\n        case\
    \ 'B':\n          out += 11*pow(16, num.size() - 1 - j);\n          break;\n \
    \       case 'C':\n          out += 12*pow(16, num.size() - 1 - j);\n        \
    \  break;\n        case 'D':\n          out += 13*pow(16, num.size() - 1 - j);\n\
    \          break;\n        case 'E':\n          out += 14*pow(16, num.size() -\
    \ 1 - j);\n          break;\n        case 'F':\n          out += 15*pow(16, num.size()\
    \ - 1 - j);\n          break;\n        default:\n          break;\n      }\n \
    \   }\n    j++;\n  }\n  return out;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpja5hu429: /tmp/tmpja5hu429.cpp:55: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\t// Convert string num to a\
    \ long\n\tlong long num_ll = std::stoll(num,nullptr,16);\n\tstd::cout << num_ll\
    \ << \"\\n\";\n\treturn num_ll;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: "171\n"
  stderr: "tmpyncshz17: /tmp/tmpyncshz17.cpp:27: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong long key = 0;\n\tfor (int\
    \ i = 0; i < num.size(); i++) {\n\t\tif (isdigit(num[i])) {\n\t\t\tkey = key *\
    \ 16 + (num[i] - '0');\n\t\t}\n\t\telse {\n\t\t\tkey = key * 16 + (num[i] - 'A'\
    \ + 10);\n\t\t}\n\t}\n\treturn key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp73z70x8y: /tmp/tmp73z70x8y.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long hex_sum=0;\n    int\
    \ power=0;\n    long hex_number=0;\n    std::string hex={\"0123456789ABCDEF\"\
    };\n    int hex_array[16]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n    for(int\
    \ i=num.size()-1;i>=0;i--){\n        auto x=num[i];\n        int index = hex.find(x);\n\
    \        hex_sum+=hex_array[index]*pow(16,power);\n        power++;\n    }\n \
    \   return hex_sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp08k3d448: /tmp/tmp08k3d448.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\t// Store the valid hex characters\
    \ in a std::set\n\tstd::set<char> valid_chars {'0', '1', '2', '3', '4', '5', '6',\
    \ '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\tstd::set<char> :: iterator\
    \ itr;\n\t// Store the prime hex characters in a std::set\n\tstd::set<char> prime_chars\
    \ {'2', '3', '5', '7', 'B', 'D'};\n\tstd::set<char> :: iterator itr1;\n\tlong\
    \ count = 0;\n\tfor(int i = 0; i < num.length(); i++) {\n\t\t// Find if the character\
    \ is a valid hex character using std::set\n\t\titr = valid_chars.find(num[i]);\n\
    \t\tif(itr != valid_chars.end()) {\n\t\t\t// If yes, then find if the character\
    \ is a prime hex character\n\t\t\titr1 = prime_chars.find(num[i]);\n\t\t\tif(itr1\
    \ != prime_chars.end()) {\n\t\t\t\t// If yes, then increment the count\n\t\t\t\
    \tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::set<long> primes{2,3,5,7,11,13};\n\
    \    long out = 0;\n    for (char c : num) {\n        if (std::isdigit(c)) {\n\
    \            if (primes.find(c-'0') != primes.end())\n                out++;\n\
    \        } else {\n            if (primes.find(c-'7') != primes.end())\n     \
    \           out++;\n        }\n    }\n    return out;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  int i = 0;\n  long key = 0;\n\
    \  while (num[i] != '\\0') {\n    if (num[i] == '2' || num[i] == '3' || num[i]\
    \ == '5' || num[i] == '7' ||\n    num[i] == 'B' || num[i] == 'D') {\n      key\
    \ = (key*10) + 1;\n    }\n    i++;\n  }\n  return key;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpo1y5_0wn: /tmp/tmpo1y5_0wn.cpp:34: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  const char* hex_chars = \"\
    0123456789ABCDEF\";\n  const char* hex_vals = \"\\x00\\x01\\x02\\x03\\x04\\x05\\\
    x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\";\n  std::unordered_map<char,\
    \ int> hex_map(16);\n  for (int i = 0; i < 16; i++) {\n    hex_map[hex_chars[i]]\
    \ = hex_vals[i];\n  }\n  long val = 0;\n  for (int i = 0; i < num.size(); i++)\
    \ {\n    val *= 16;\n    val += hex_map[num[i]];\n  }\n  return val;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmprhza7ys3: /tmp/tmprhza7ys3.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long n = 0;\n  std::string\
    \ key = \"0123456789ABCDEF\";\n  long length = num.length();\n  for (long i =\
    \ 0; i < length; i++) {\n    n = n * 16 + key.find(num[i]);\n  }\n  return n;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp3yyd6y07: /tmp/tmp3yyd6y07.cpp:30: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::vector<long> v;\n  \
    \  for (int i = 0; i < num.size(); i++) {\n        if (num[i] >= '0' && num[i]\
    \ <= '9') {\n            v.push_back(num[i] - '0');\n        } else if (num[i]\
    \ >= 'A' && num[i] <= 'F') {\n            v.push_back(num[i] - 'A' + 10);\n  \
    \      }\n    }\n    long long r = 0;\n    for (int i = 0; i < v.size(); i++)\
    \ {\n        r = r * 16 + v[i];\n    }\n    return r;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp7ybm0aly: /tmp/tmp7ybm0aly.cpp:36: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpvbn7jszm: /tmp/tmpvbn7jszm.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    if (num.size() == 0) return\
    \ 0;\n    long count = 0;\n    // your code\n    std::cout << num << std::endl;\n\
    \    for (long i = 0; i < num.size(); i++) {\n        switch (num[i]) {\n    \
    \        case '2':\n            case '3':\n            case '5':\n           \
    \ case '7':\n            case 'B':\n            case 'D':\n                count++;\n\
    \                break;\n            default:\n                break;\n      \
    \  }\n    }\n    return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: "AB\n1077E\nABED1A33\n2020\n123456789ABCDEF0\n112233445566778899AABBCCDDEEFF00\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long tot = 0;\n    std::cout\
    \ << \"Num is: \" << num << std::endl;\n    for (auto x : num) {\n        if (x\
    \ == '0' || x == '1' || x == '2' || x == '3' || x == '4' || x == '5' || x == '6'\
    \ || x == '7' || x == '8' || x == '9') {\n            int val = std::stoi(std::string(1,\
    \ x));\n            if (val == 2 || val == 3 || val == 5 || val == 7) {\n    \
    \            tot++;\n            }\n        }\n        else if (x == 'A' || x\
    \ == 'B' || x == 'C' || x == 'D' || x == 'E' || x == 'F') {\n            int val\
    \ = int(x);\n            if (val == 65 || val == 66 || val == 67 || val == 68\
    \ || val == 69 || val == 70) {\n                tot++;\n            }\n      \
    \  }\n    }\n    return tot;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: "Num is: AB\n"
  stderr: "tmph5q3kr3p: /tmp/tmph5q3kr3p.cpp:40: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long key = 0;\n    std::stringstream\
    \ ss;\n    ss << std::hex << num;\n    ss >> key;\n    return key;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpcin6dt5d: /tmp/tmpcin6dt5d.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long hex_key = 0;\n    int\
    \ power = 0;\n    for (int i = num.size() - 1; i >= 0; i--) {\n        if (std::isdigit(num[i]))\
    \ {\n            hex_key += (num[i] - '0') * pow(16, power);\n        } else {\n\
    \            hex_key += (num[i] - 'A' + 10) * pow(16, power);\n        }\n   \
    \     power++;\n    }\n    return hex_key;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpaci0y0cb: /tmp/tmpaci0y0cb.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\t// The hex key is a number\
    \ comprised of the elements\n\t// 2, 3, 5, 7, B, D\n\t// the following code converts\
    \ each of these elements\n\t// into a number and returns the key\n\tlong key =\
    \ 0;\n\tint p = 1;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tint c = num[i];\n\
    \t\tif (c == '2') {\n\t\t\tkey += p;\n\t\t}\n\t\telse if (c == '3') {\n\t\t\t\
    key += p * 2;\n\t\t}\n\t\telse if (c == '5') {\n\t\t\tkey += p * 3;\n\t\t}\n\t\
    \telse if (c == '7') {\n\t\t\tkey += p * 4;\n\t\t}\n\t\telse if (c == 'B') {\n\
    \t\t\tkey += p * 5;\n\t\t}\n\t\telse if (c == 'D') {\n\t\t\tkey += p * 6;\n\t\t\
    }\n\t\tp *= 7;\n\t}\n\treturn key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp8lsljszo: /tmp/tmp8lsljszo.cpp:52: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::unordered_map<char, long>\
    \ hex{\n\t\t{'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4},\n\t\t{'5', 5}, {'6',\
    \ 6}, {'7', 7}, {'8', 8}, {'9', 9},\n\t\t{'A', 10}, {'B', 11}, {'C', 12}, {'D',\
    \ 13}, {'E', 14}, {'F', 15}\n\t};\n\tlong result = 0;\n\tfor (char c : num) {\n\
    \t\tresult = result * 16 + hex[c];\n\t}\n\treturn result;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpdig309yf: /tmp/tmpdig309yf.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::string hex_digits =\
    \ \"0123456789ABCDEF\";\n    std::string hex_primes = \"2357BDF\";\n    std::transform(num.begin(),\
    \ num.end(), num.begin(), ::toupper);\n    int count = 0;\n    for (int i = 0;\
    \ i < num.length(); i++) {\n        if (hex_primes.find(num[i]) != std::string::npos)\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpb9x2s5gs: /tmp/tmpb9x2s5gs.cpp:37: int main(): Assertion `candidate((\"\
    123456789ABCDEF0\")) == (6)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long count = 0;\n    for\
    \ (int i = 0; i < num.length(); i++) {\n        if (num[i] == '2' || num[i] ==\
    \ '3' || num[i] == '5' || num[i] == '7'\n            || num[i] == 'B' || num[i]\
    \ == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\treturn 0L;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp5778ugxy: /tmp/tmp5778ugxy.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    return std::stol(num, 0,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmphpdwx75z: /tmp/tmphpdwx75z.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    return std::bitset<16>(num).to_ulong();\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  bitset::_M_copy_from_ptr\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // your code here\n  return\
    \ 0;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp1nngibh7: /tmp/tmp1nngibh7.cpp:25: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong n = 0;\n\tfor (char c\
    \ : num) {\n\t\tn *= 16;\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tn += c - '0';\n\
    \t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tn += c - 'A' + 10;\n\t\t}\n\t}\n\
    \treturn n;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpgvrl7yrz: /tmp/tmpgvrl7yrz.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int res = 0;\n    char c;\n\
    \    int len = num.length();\n    if (len == 0) {\n        return 0;\n    }\n\
    \    for (int i = 0; i < len; i++) {\n        c = num[i];\n        if (c >= '0'\
    \ && c <= '9') {\n            res += (c - '0');\n        } else if (c >= 'A' &&\
    \ c <= 'F') {\n            res += (c - 'A' + 10);\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp09zb79bk: /tmp/tmp09zb79bk.cpp:38: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::unordered_map<char,long>\
    \ dict {\n        {'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},\n\
    \        {'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15},{'G',16},{'H',17},{'I',18},{'J',19},\n\
    \        {'K',20},{'L',21},{'M',22},{'N',23},{'O',24},{'P',25},{'Q',26},{'R',27},{'S',28},{'T',29},\n\
    \        {'U',30},{'V',31},{'W',32},{'X',33},{'Y',34},{'Z',35}\n    };\n    long\
    \ key=0;\n    long power=1;\n    for(long p=num.size()-1;p>=0;p--){\n        key+=(power*dict[num[p]]);\n\
    \        power*=16;\n    }\n    return key;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpd2iokwkc: /tmp/tmpd2iokwkc.cpp:36: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::map<char, long> hex_char_map\
    \ = {\n    {'0', 0},\n    {'1', 1},\n    {'2', 2},\n    {'3', 3},\n    {'4', 4},\n\
    \    {'5', 5},\n    {'6', 6},\n    {'7', 7},\n    {'8', 8},\n    {'9', 9},\n \
    \   {'A', 10},\n    {'B', 11},\n    {'C', 12},\n    {'D', 13},\n    {'E', 14},\n\
    \    {'F', 15}\n  };\n  long key = 0;\n  for (char ch : num) {\n    key = key\
    \ * 16 + hex_char_map[ch];\n  }\n  return key;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp4x87gezz: /tmp/tmp4x87gezz.cpp:46: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  return ((int)num[0] - 48) *\
    \ 16 + ((int)num[1] - 48);\n}\nint main() {\n    auto candidate = hex_key;\n \
    \   assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp6z02gf7b: /tmp/tmp6z02gf7b.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    static const char hex_key[]\
    \ = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 1, 2, 3,\n        4, 5, 6, 7, 8, 9, 0, 0,\
    \ 0, 0,\n        0, 0, 0, 0, 0, 10, 11, 12, 13, 14,\n        15, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\
    \ 0, 10, 11, 12,\n        13, 14, 15, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr8yavqmc.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpr8yavqmc.cpp:45:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018int\u2019\n   45 | int main() {\n      | ^~~\n/tmp/tmpr8yavqmc.cpp:53:1:\
    \ error: expected \u2018}\u2019 at end of input\n   53 | }\n      | ^\n/tmp/tmpr8yavqmc.cpp:19:31:\
    \ note: to match this \u2018{\u2019\n   19 | long hex_key(std::string num) {\n\
    \      |                               ^\n/tmp/tmpr8yavqmc.cpp:53:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   53 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp0b_kdy_h: /tmp/tmp0b_kdy_h.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long key = 0;\n  for (auto\
    \ elem : num) {\n    if (elem <= '9')\n      key += elem - '0';\n    else if (elem\
    \ <= 'F')\n      key += elem - 'A' + 10;\n  }\n  return key;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp5t7ntw6o: /tmp/tmp5t7ntw6o.cpp:31: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong hex_map[26] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25};\n\
    \tlong dec = 0;\n\tlong res = 0;\n\tfor(int i = 0; i < num.length(); i++) {\n\t\
    \tif(num[i] >= 65 && num[i] <= 70) {\n\t\t\tdec += hex_map[num[i] - 65] * pow(16,num.length()\
    \ - i - 1);\n\t\t} else {\n\t\t\tdec += (num[i] - 48) * pow(16,num.length() -\
    \ i - 1);\n\t\t}\n\t}\n\treturn dec;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpxh06mb1i: /tmp/tmpxh06mb1i.cpp:35: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // your code here\n    std::string\
    \ primes = \"2357BD\";\n    long count = 0;\n    for(int i = 0; i < num.length();\
    \ i++){\n        //std::cout << num[i] << std::endl;\n        for(int j = 0; j\
    \ < primes.length(); j++){\n            if(num[i] == primes[j]){\n           \
    \     count++;\n            }\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long count = 0;\n    long\
    \ k = 0;\n    std::vector<long> primes = {2, 3, 5, 7, 11, 13};\n    while (k <\
    \ num.size()) {\n        for (long i = 0; i < primes.size(); i++) {\n        \
    \    if (num[k] == std::to_string(primes[i])[0]) {\n                count++;\n\
    \            }\n        }\n        k++;\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpw6_0tzyt: /tmp/tmpw6_0tzyt.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // create a list of hexadecimal\
    \ digits\n  std::vector<int> hex_nums;\n  // create a list of prime numbers that\
    \ correspond to the hexadecimal digits\n  std::vector<int> prime_nums;\n  // write\
    \ the hexadecimal numbers to the list\n  hex_nums.push_back(0);\n  hex_nums.push_back(1);\n\
    \  hex_nums.push_back(2);\n  hex_nums.push_back(3);\n  hex_nums.push_back(4);\n\
    \  hex_nums.push_back(5);\n  hex_nums.push_back(6);\n  hex_nums.push_back(7);\n\
    \  hex_nums.push_back(8);\n  hex_nums.push_back(9);\n  hex_nums.push_back(10);\n\
    \  hex_nums.push_back(11);\n  hex_nums.push_back(12);\n  hex_nums.push_back(13);\n\
    \  hex_nums.push_back(14);\n  hex_nums.push_back(15);\n  // write the prime numbers\
    \ that correspond to the hexadecimal numbers\n  prime_nums.push_back(2);\n  prime_nums.push_back(3);\n\
    \  prime_nums.push_back(5);\n  prime_nums.push_back(7);\n  prime_nums.push_back(11);\n\
    \  prime_nums.push_back(13);\n  // write a map that contains hexadecimal digits\
    \ as keys and primes as values\n  std::map<int, int> hex_prime;\n  for (size_t\
    \ i = 0; i < hex_nums.size(); i++) {\n    hex_prime[hex_nums[i]] = prime_nums[i];\n\
    \  }\n  // write a list that contains the digits of the hexadecimal number\n \
    \ std::vector<int> hex_list;\n  for (size_t i = 0; i < num.size(); i++) {\n  \
    \  if (std::isdigit(num\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr_nx1bwn.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpr_nx1bwn.cpp:56:25: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   56 |     if (std::isdigit(num\n      |                     ~   ^\n\
    \      |                         )\n   57 | }\n      | ~                     \
    \   \n/tmp/tmpr_nx1bwn.cpp:56:25: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   56 |     if (std::isdigit(num\n      |        ~            \
    \    ^\n      |                         )\n   57 | }\n      | ~              \
    \          \n/tmp/tmpr_nx1bwn.cpp:57:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   57 | }\n      | ^\n/tmp/tmpr_nx1bwn.cpp:58:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   58\
    \ | int main() {\n      |            ^\n/tmp/tmpr_nx1bwn.cpp:66:1: error: expected\
    \ \u2018}\u2019 at end of input\n   66 | }\n      | ^\n/tmp/tmpr_nx1bwn.cpp:19:31:\
    \ note: to match this \u2018{\u2019\n   19 | long hex_key(std::string num) {\n\
    \      |                               ^\n/tmp/tmpr_nx1bwn.cpp:66:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   66 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long int key = 0;\n    for\
    \ (int i = 0; i < num.length(); i++) {\n        char c = num[i];\n        if (c\
    \ >= 'A' && c <= 'F') {\n            c = c - 'A' + '9' + 1;\n        }\n     \
    \   key = key * 16 + (c - '0');\n    }\n    return key;\n}\nint main() {\n   \
    \ auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpmzwdk0rk: /tmp/tmpmzwdk0rk.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  char key[] = {'0', '1', '2',\
    \ '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n  std::unordered_map<char,\
    \ long> hex_keys;\n  for (long i = 0; i < 16; i++) {\n    hex_keys[key[i]] = i;\n\
    \  }\n  long prime_digits = 0;\n  long n = num.size();\n  if (n == 0) {\n    return\
    \ 0;\n  }\n  for (long i = 0; i < n; i++) {\n    if (hex_keys[num[i]] % 2 != 0\
    \ && hex_keys[num[i]] % 3 != 0 && hex_keys[num[i]] % 5 != 0 &&\n        hex_keys[num[i]]\
    \ % 7 != 0 && hex_keys[num[i]] % 11 != 0 && hex_keys[num[i]] % 13 != 0) {\n  \
    \    prime_digits++;\n    }\n  }\n  return prime_digits;\n}\nint main() {\n  \
    \  auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp7gxaa5xs: /tmp/tmp7gxaa5xs.cpp:40: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long n = 0;\n  for (auto digit\
    \ : num) {\n    n *= 16;\n    if ('0' <= digit && digit <= '9') {\n      n +=\
    \ digit - '0';\n    } else {\n      n += digit - 'A' + 10;\n    }\n  }\n  return\
    \ n;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpk9_ohmyq: /tmp/tmpk9_ohmyq.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  if (num.empty()) return 0;\n\
    \  const char *hex_characters = \"0123456789ABCDEF\";\n  long result = 0;\n  while(num.length()\
    \ != 0) {\n    result = result*16;\n    for (int i = 0; i < 16; i++) {\n     \
    \ if (hex_characters[i] == num[0]) {\n        result += i;\n        break;\n \
    \     }\n    }\n    num.erase(0,1);\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpx2x1q2ac: /tmp/tmpx2x1q2ac.cpp:37: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  const char *hex = \"0123456789ABCDEF\"\
    ;\n  const char *p = std::strchr(hex, toupper(num[0]));\n  return p ? p - hex\
    \ : 0;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmph9l84hqn: /tmp/tmph9l84hqn.cpp:26: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long str_size = num.size();\n\
    \  long result = 0;\n  long temp = 0;\n  // hexadecimal digits are 0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n  // Prime numbers are 2, 3, 5, 7, 11,\
    \ 13, 17,...\n  // So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n  // B (=decimal 11), D (=decimal 13).\n  std::vector<char> key\
    \ {'2', '3', '5', '7', 'B', 'D'};\n  for (int i = 0; i < str_size; i++) {\n  \
    \  for (int j = 0; j < key.size(); j++) {\n      if (num[i] == key[j]) {\n   \
    \     temp += 1;\n      }\n    }\n  }\n  // result is a number of the following\
    \ digits: 2, 3, 5, 7, B, D\n  result = temp;\n  return result;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong result = 0;\n\tfor (size_t\
    \ i = 0; i < num.size(); i++) {\n\t\tresult += num[i];\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp_ufget79: /tmp/tmp_ufget79.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong key = 0;\n\tfor (int i\
    \ = 0; i < num.length(); i++) {\n\t\tint val = 0;\n\t\tif (num[i] >= '0' && num[i]\
    \ <= '9') {\n\t\t\tval = num[i] - '0';\n\t\t}\n\t\telse if (num[i] >= 'A' && num[i]\
    \ <= 'F') {\n\t\t\tval = num[i] - 'A' + 10;\n\t\t}\n\t\tkey = key * 16 + val;\n\
    \t}\n\treturn key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpzejnmqex: /tmp/tmpzejnmqex.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  //the list of prime numbers\n\
    \  std::vector<long> primes = {2,3,5,7,11,13};\n  //the counter of primes\n  long\
    \ counter = 0;\n  //the list of primes numbers in string\n  std::vector<std::string>\
    \ primes_in_string = {\"2\",\"3\",\"5\",\"7\",\"B\",\"D\"};\n  //the map of symbols\
    \ to their numerical value\n  std::map<std::string,long> num_primes = {{\"0\"\
    ,0},{\"1\",1},{\"2\",2},{\"3\",3},{\"4\",4},{\"5\",5},{\"6\",6},{\"7\",7},{\"\
    8\",8},{\"9\",9},{\"A\",10},{\"B\",11},{\"C\",12},{\"D\",13},{\"E\",14},{\"F\"\
    ,15}};\n  for(auto& x:num){\n    //if the current symbol is prime\n    if(std::find(primes_in_string.begin(),primes_in_string.end(),std::string(1,x))\
    \ != primes_in_string.end()){\n      counter++;\n    }\n  }\n  return counter;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::unordered_map<char,long>\
    \ um;\n\tum['0'] = 0;\n\tum['1'] = 1;\n\tum['2'] = 2;\n\tum['3'] = 3;\n\tum['4']\
    \ = 4;\n\tum['5'] = 5;\n\tum['6'] = 6;\n\tum['7'] = 7;\n\tum['8'] = 8;\n\tum['9']\
    \ = 9;\n\tum['A'] = 10;\n\tum['B'] = 11;\n\tum['C'] = 12;\n\tum['D'] = 13;\n\t\
    um['E'] = 14;\n\tum['F'] = 15;\n\tlong long base = 1;\n\tlong long result = 0;\n\
    \tfor(long i = num.size()-1; i >= 0; i--) {\n\t\tresult += um[num[i]]*base;\n\t\
    \tbase *= 16;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpelbgii1u: /tmp/tmpelbgii1u.cpp:47: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int hex_key{0};\n    for\
    \ (auto i : num) {\n        switch (i) {\n            case 'A':\n            \
    \    hex_key += 10;\n                break;\n            case 'B':\n         \
    \       hex_key += 11;\n                break;\n            case 'C':\n      \
    \          hex_key += 12;\n                break;\n            case 'D':\n   \
    \             hex_key += 13;\n                break;\n            case 'E':\n\
    \                hex_key += 14;\n                break;\n            case 'F':\n\
    \                hex_key += 15;\n                break;\n            default:\n\
    \                hex_key += i - '0';\n                break;\n        }\n    }\n\
    \    return hex_key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpql2c6v59: /tmp/tmpql2c6v59.cpp:50: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long total = 0;\n  long count\
    \ = 0;\n  for (int i = 0; i < num.length(); i++) {\n    if (num[i] == '2' || num[i]\
    \ == '3' || num[i] == '5' || num[i] == '7' ||\n        num[i] == 'B' || num[i]\
    \ == 'D') {\n      count++;\n    }\n  }\n  return count;\n}\nint main() {\n  \
    \  auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\t// Split string into a set\
    \ of chars\n\tstd::unordered_set<char> hex_set(num.begin(), num.end());\n\t//\
    \ Hash table with the keys of the hex_set mapped to the decimal values of each\
    \ digit\n\tstd::unordered_map<char,long> hex_map({\n\t\t{'0',0},\n\t\t{'1',1},\n\
    \t\t{'2',2},\n\t\t{'3',3},\n\t\t{'4',4},\n\t\t{'5',5},\n\t\t{'6',6},\n\t\t{'7',7},\n\
    \t\t{'8',8},\n\t\t{'9',9},\n\t\t{'A',10},\n\t\t{'B',11},\n\t\t{'C',12},\n\t\t\
    {'D',13},\n\t\t{'E',14},\n\t\t{'F',15}\n\t});\n\t// Count the number of prime\
    \ digits\n\tlong prime_count = 0;\n\tfor (auto hex : hex_set) {\n\t\t// Check\
    \ if digit maps to a prime decimal value\n\t\t// If it does, increase the prime\
    \ count\n\t\tif (hex_map[hex] == 2 || hex_map[hex] == 3 || hex_map[hex] == 5 ||\
    \ hex_map[hex] == 7 || hex_map[hex] == 11 || hex_map[hex] == 13) {\n\t\t\tprime_count++;\n\
    \t\t}\n\t}\n\treturn prime_count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpfvl7mizr: /tmp/tmpfvl7mizr.cpp:55: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong key = 0;\n\tif (num.length()\
    \ == 0) {\n\t\treturn key;\n\t}\n\tfor (size_t i = 0; i < num.length(); i++) {\n\
    \t\tif (num[i] == 'A' || num[i] == 'B' || num[i] == 'D') {\n\t\t\tkey += 1;\n\t\
    \t}\n\t\telse if (num[i] == 'C' || num[i] == 'E' || num[i] == 'F') {\n\t\t\tkey\
    \ += 2;\n\t\t}\n\t}\n\treturn key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpqq4o4qec: /tmp/tmpqq4o4qec.cpp:36: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long result = 0;\n  for (char\
    \ a : num) {\n    if (a >= '0' && a <= '9') {\n      result = result * 16 + a\
    \ - '0';\n    } else {\n      result = result * 16 + a - 'A' + 10;\n    }\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp0sz1laxi: /tmp/tmp0sz1laxi.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong i, p, ans = 0;\n\tstd::string\
    \ upcase_num;\n\tstd::map<char, long> hex_map;\n\thex_map['0'] = 0;\n\thex_map['1']\
    \ = 1;\n\thex_map['2'] = 2;\n\thex_map['3'] = 3;\n\thex_map['4'] = 4;\n\thex_map['5']\
    \ = 5;\n\thex_map['6'] = 6;\n\thex_map['7'] = 7;\n\thex_map['8'] = 8;\n\thex_map['9']\
    \ = 9;\n\thex_map['A'] = 10;\n\thex_map['B'] = 11;\n\thex_map['C'] = 12;\n\thex_map['D']\
    \ = 13;\n\thex_map['E'] = 14;\n\thex_map['F'] = 15;\n\tif (num.length() == 0)\
    \ {\n\t\treturn 0;\n\t}\n\tupcase_num = num;\n\tstd::transform(upcase_num.begin(),\
    \ upcase_num.end(), upcase_num.begin(),\n\t\t::toupper);\n\tfor (i = 0; i < upcase_num.length();\
    \ i++) {\n\t\tp = hex_map[upcase_num[i]];\n\t\tif (p == 2 || p == 3 || p == 5\
    \ || p == 7 || p == 11 || p == 13) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long answer = 0;\n  for (char\
    \ nums : num) {\n    if (nums >= '0' && nums <= '9') {\n      answer += nums -\
    \ '0';\n    } else {\n      answer += nums - 'A' + 10;\n    }\n  }\n  return answer;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp6pi6sye3: /tmp/tmp6pi6sye3.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong count = 0;\n\t\n\tfor\
    \ (int i = 0; i < num.length(); i++) {\n\t\tswitch (num[i]) {\n\t\t\tcase 'B':\n\
    \t\t\tcase 'D':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '5':\n\t\t\tcase\
    \ '7':\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\
    }\n\t}\n\treturn count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    //if(num.length() == 0) return\
    \ 0;\n    return std::bitset<16>(num).to_ulong();\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  bitset::_M_copy_from_ptr\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::map<char,long> map_of_hex_keys;\n\
    \tmap_of_hex_keys['0'] = 0;\n\tmap_of_hex_keys['1'] = 1;\n\tmap_of_hex_keys['2']\
    \ = 2;\n\tmap_of_hex_keys['3'] = 3;\n\tmap_of_hex_keys['4'] = 4;\n\tmap_of_hex_keys['5']\
    \ = 5;\n\tmap_of_hex_keys['6'] = 6;\n\tmap_of_hex_keys['7'] = 7;\n\tmap_of_hex_keys['8']\
    \ = 8;\n\tmap_of_hex_keys['9'] = 9;\n\tmap_of_hex_keys['A'] = 10;\n\tmap_of_hex_keys['B']\
    \ = 11;\n\tmap_of_hex_keys['C'] = 12;\n\tmap_of_hex_keys['D'] = 13;\n\tmap_of_hex_keys['E']\
    \ = 14;\n\tmap_of_hex_keys['F'] = 15;\n\tlong result=0;\n\tfor(auto key: num)\
    \ {\n\t\tresult = result*16 + map_of_hex_keys[key];\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpo0e0ywcs: /tmp/tmpo0e0ywcs.cpp:45: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::map<char, int> m;\n\
    \    int i = 0;\n    for (char c = '0'; c <= '9'; c++) {\n        m[c] = i;\n\
    \        i++;\n    }\n    for (char c = 'A'; c <= 'F'; c++) {\n        m[c] =\
    \ i;\n        i++;\n    }\n    long key = 0;\n    for (int i = 0; i < num.size();\
    \ i++) {\n        key += m[num[i]] * pow(16, i);\n    }\n    return key;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpbalxt486: /tmp/tmpbalxt486.cpp:38: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    char* end;\n    // long value\
    \ = std::strtol(num.c_str(), &end, 16);\n    // assert(*end == 0);\n    long value\
    \ = std::stoi(num, nullptr, 16);\n    // https://www.geeksforgeeks.org/program-to-convert-a-given-number-to-hexadecimal/\n\
    \    return value;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp012brk8w: /tmp/tmp012brk8w.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::set<char> n({'2','3','5','7','B','D'});\n\
    \    int sz = num.size();\n    long cnt = 0;\n    for(int i = 0; i < sz; i++)\n\
    \        if(n.find(num[i]) != n.end())\n            cnt++;\n    return cnt;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong a[]={11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,13\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo_a98dx1.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpo_a98dx1.cpp:22:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018int\u2019\n   22 | int main() {\n      | ^~~\n/tmp/tmpo_a98dx1.cpp:30:1:\
    \ error: expected \u2018}\u2019 at end of input\n   30 | }\n      | ^\n/tmp/tmpo_a98dx1.cpp:19:31:\
    \ note: to match this \u2018{\u2019\n   19 | long hex_key(std::string num) {\n\
    \      |                               ^\n/tmp/tmpo_a98dx1.cpp:30:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   30 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int i;\n    long hex_key_num\
    \ = 0;\n    int limit = num.length();\n    for (i = 0; i < limit; i++) {\n   \
    \     if (num[i] >= '0' && num[i] <= '9')\n            hex_key_num = hex_key_num\
    \ * 16 + num[i] - '0';\n        else if (num[i] >= 'A' && num[i] <= 'F')\n   \
    \         hex_key_num = hex_key_num * 16 + num[i] - 'A' + 10;\n    }\n    return\
    \ hex_key_num;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpmadwu0bz: /tmp/tmpmadwu0bz.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  static std::map<char,int> hex_map;\n\
    \  static std::map<int,int> prime_map;\n  static bool init_flag = false;\n  if(!init_flag)\
    \ {\n    hex_map['0'] = 0;\n    hex_map['1'] = 1;\n    hex_map['2'] = 2;\n   \
    \ hex_map['3'] = 3;\n    hex_map['4'] = 4;\n    hex_map['5'] = 5;\n    hex_map['6']\
    \ = 6;\n    hex_map['7'] = 7;\n    hex_map['8'] = 8;\n    hex_map['9'] = 9;\n\
    \    hex_map['A'] = 10;\n    hex_map['B'] = 11;\n    hex_map['C'] = 12;\n    hex_map['D']\
    \ = 13;\n    hex_map['E'] = 14;\n    hex_map['F'] = 15;\n    prime_map[2] = true;\n\
    \    prime_map[3] = true;\n    prime_map[5] = true;\n    prime_map[7] = true;\n\
    \    prime_map[11] = true;\n    prime_map[13] = true;\n    init_flag = true;\n\
    \  }\n  long key = 0;\n  for(int i = 0; i < num.size(); i++) {\n    key = key\
    \ * 16 + hex_map[num[i]];\n  }\n  return key;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp8_i5h2y3: /tmp/tmp8_i5h2y3.cpp:56: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // the number should always\
    \ be a hexdecimal\n    assert(num.size() > 0);\n    assert(num.size() < 9);\n\
    \    long sum = 0;\n    for (int i = 0; i < num.size(); i++) {\n        switch\
    \ (num[i]) {\n            case '0': sum += 0; break;\n            case '1': sum\
    \ += 1; break;\n            case '2': sum += 2; break;\n            case '3':\
    \ sum += 3; break;\n            case '4': sum += 4; break;\n            case '5':\
    \ sum += 5; break;\n            case '6': sum += 6; break;\n            case '7':\
    \ sum += 7; break;\n            case '8': sum += 8; break;\n            case '9':\
    \ sum += 9; break;\n            case 'A': sum += 10; break;\n            case\
    \ 'B': sum += 11; break;\n            case 'C': sum += 12; break;\n          \
    \  case 'D': sum += 13; break;\n            case 'E': sum += 14; break;\n    \
    \        case 'F': sum += 15; break;\n            default: break;\n        }\n\
    \    }\n    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmptvr8v8zi: /tmp/tmptvr8v8zi.cpp:49: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::map<std::string, int>\
    \ hex_map = {{\"0\", 0}, {\"1\", 1}, {\"2\", 2}, {\"3\", 3}, {\"4\", 4}, {\"5\"\
    , 5}, {\"6\", 6}, {\"7\", 7}, {\"8\", 8}, {\"9\", 9}, {\"A\", 10}, {\"B\", 11},\
    \ {\"C\", 12}, {\"D\", 13}, {\"E\", 14}, {\"F\", 15}};\n  long ans = 0;\n  for\
    \ (size_t i = 0; i < num.size(); i++) {\n    ans += hex_map[std::string(1, num[i])];\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpfkn7czw4: /tmp/tmpfkn7czw4.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long total = 0;\n  for (char\
    \ c : num) {\n    if (c == 'A' || c == 'B' || c == 'D') {\n      total++;\n  \
    \  }\n  }\n  return total;\n}\nint main() {\n    auto candidate = hex_key;\n \
    \   assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpz_73po0c: /tmp/tmpz_73po0c.cpp:30: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    const int HEX_BASE = 16;\n\
    \    const int PRIME_BASE = 10;\n    const int HEX_PRIME_BASE = 5;\n    const\
    \ int HEX_PRIME_BASE_ZERO = 2;\n    long num_value = std::stol(num, nullptr, HEX_BASE);\n\
    \    int counter = 0;\n    while (num_value > 0) {\n        if (num_value % PRIME_BASE\
    \ < HEX_PRIME_BASE &&\n            num_value % PRIME_BASE > HEX_PRIME_BASE_ZERO)\
    \ {\n            counter++;\n        }\n        num_value /= PRIME_BASE;\n   \
    \ }\n    return counter;\n}\nint main() {\n    auto candidate = hex_key;\n   \
    \ assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpxdt7v3a7: /tmp/tmpxdt7v3a7.cpp:37: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long count=0;\n  for(long i=0;i<num.size();i++){\n\
    \    if(num[i]=='2'||num[i]=='3'||num[i]=='5'||num[i]=='7'||num[i]=='B'||num[i]=='D'){\n\
    \      count++;\n    }\n  }\n  return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long long n = 0;\n    int\
    \ len = num.length();\n    for (int i = 0; i < len; i++) {\n        if (num[i]\
    \ > 64) {\n            switch (num[i]) {\n                case 'A':\n        \
    \            n += 10;\n                    break;\n                case 'B':\n\
    \                    n += 11;\n                    break;\n                case\
    \ 'C':\n                    n += 12;\n                    break;\n           \
    \     case 'D':\n                    n += 13;\n                    break;\n  \
    \              case 'E':\n                    n += 14;\n                    break;\n\
    \                case 'F':\n                    n += 15;\n                   \
    \ break;\n            }\n        } else {\n            n += num[i] - 48;\n   \
    \     }\n        n *= 16;\n    }\n    return n / 16;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpn9mwbcjj: /tmp/tmpn9mwbcjj.cpp:53: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::map<char, int> hex_decimals;\n\
    \thex_decimals['0'] = 0;\n\thex_decimals['1'] = 1;\n\thex_decimals['2'] = 2;\n\
    \thex_decimals['3'] = 3;\n\thex_decimals['4'] = 4;\n\thex_decimals['5'] = 5;\n\
    \thex_decimals['6'] = 6;\n\thex_decimals['7'] = 7;\n\thex_decimals['8'] = 8;\n\
    \thex_decimals['9'] = 9;\n\thex_decimals['A'] = 10;\n\thex_decimals['B'] = 11;\n\
    \thex_decimals['C'] = 12;\n\thex_decimals['D'] = 13;\n\thex_decimals['E'] = 14;\n\
    \thex_decimals['F'] = 15;\n\tint number_of_primes = 0;\n\tfor (int i = 0; i <\
    \ num.size(); i++) {\n\t\tif (num[i] == '2' || num[i] == '3' || num[i] == '5'\
    \ || num[i] == '7' || num[i] == 'B' || num[i] == 'D') {\n\t\t\tnumber_of_primes++;\n\
    \t\t}\n\t}\n\treturn number_of_primes;\n}\nint main() {\n    auto candidate =\
    \ hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long result = 0;\n  // put\
    \ your code here\n  std::vector<int> digit_counts(16, 0);\n  for (int i = 0; i\
    \ < num.size(); i++) {\n    int digit = 0;\n    switch (num[i]) {\n      case\
    \ '0': {\n        digit = 0;\n        break;\n      }\n      case '1': {\n   \
    \     digit = 1;\n        break;\n      }\n      case '2': {\n        digit =\
    \ 2;\n        break;\n      }\n      case '3': {\n        digit = 3;\n       \
    \ break;\n      }\n      case '4': {\n        digit = 4;\n        break;\n   \
    \   }\n      case '5': {\n        digit = 5;\n        break;\n      }\n      case\
    \ '6': {\n        digit = 6;\n        break;\n      }\n      case '7': {\n   \
    \     digit = 7;\n        break;\n      }\n      case '8': {\n        digit =\
    \ 8;\n        break;\n      }\n      case '9': {\n        digit = 9;\n       \
    \ break;\n      }\n      case 'A': {\n        digit = 10;\n        break;\n  \
    \    }\n      case 'B': {\n        digit = 11;\n        break;\n      }\n    \
    \  case 'C': {\n        digit = 12;\n        break;\n      }\n      case 'D':\
    \ {\n        digit = 13;\n        break;\n      }\n      case 'E': {\n       \
    \ digit = 14;\n        break;\n      }\n      case 'F': {\n        digit = 15;\n\
    \        break;\n      }\n    }\n    digit_counts[digit]++;\n  }\n  std::vector<int>\
    \ primes = {2, 3, 5, 7, 11, 13};\n  for (int i = 0; i < primes.size(); i++) {\n\
    \    result += digit_counts[primes[i]];\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sum=0;\n    int n =\
    \ num.length();\n    long x=1;\n    int i;\n    for(i=n-1;i>=0;i--)\n    {\n \
    \       if(num[i]>='0' && num[i]<='9')\n        {\n            sum += (num[i]-'0')*x;\n\
    \            x = x*16;\n        }\n        else if(num[i]>='A' && num[i]<='F')\n\
    \        {\n            sum += (num[i]-'A'+10)*x;\n            x = x*16;\n   \
    \     }\n    }\n    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpqx3ab1tn: /tmp/tmpqx3ab1tn.cpp:41: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // create a set of prime numbers\
    \ \n  std::set<int> primes = {2, 3, 5, 7, 11, 13};\n  int count = 0;\n  // loop\
    \ through each character of the string \n  for (char hex : num) {\n    // create\
    \ a map of chars to ints \n    std::map<char, int> hex_to_dec = {{'0', 0},\n \
    \                                     {'1', 1},\n                            \
    \          {'2', 2},\n                                      {'3', 3},\n      \
    \                                {'4', 4},\n                                 \
    \     {'5', 5},\n                                      {'6', 6},\n           \
    \                           {'7', 7},\n                                      {'8',\
    \ 8},\n                                      {'9', 9},\n                     \
    \                 {'A', 10},\n                                      {'B', 11},\n\
    \                                      {'C', 12},\n                          \
    \            {'D', 13},\n                                      {'E', 14},\n  \
    \                                    {'F', 15}};\n    // convert the char to an\
    \ int \n    int decimal = hex_to_dec[hex];\n    // check if the decimal is in\
    \ the primes set \n    if (primes.find(decimal) != primes.end()) {\n      // increment\
    \ the count \n      count++;\n    }\n  }\n  return count;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tunsigned long value = 0;\n\t\
    std::stringstream ss;\n\tss << std::hex << num;\n\tss >> value;\n\treturn value;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp7ldwmxgd: /tmp/tmp7ldwmxgd.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong long key = 0;\n\tstd::stringstream\
    \ ss;\n\tss << std::hex << num;\n\tss >> key;\n\treturn key;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpmqu3azn6: /tmp/tmpmqu3azn6.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  int result = 0;\n  for (const\
    \ auto& n : num) {\n    result += (n == '2' || n == '3' || n == '5' || n == '7'\
    \ || n == 'B' || n == 'D') ? 1 : 0;\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpcitrgqlo: /tmp/tmpcitrgqlo.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong key = 0;\n\tfor (int i\
    \ = 0; i < num.length(); i++) {\n\t\tlong temp;\n\t\tif (num[i] == 'A') {\n\t\t\
    \ttemp = 10;\n\t\t}\n\t\telse if (num[i] == 'B') {\n\t\t\ttemp = 11;\n\t\t}\n\t\
    \telse if (num[i] == 'C') {\n\t\t\ttemp = 12;\n\t\t}\n\t\telse if (num[i] == 'D')\
    \ {\n\t\t\ttemp = 13;\n\t\t}\n\t\telse if (num[i] == 'E') {\n\t\t\ttemp = 14;\n\
    \t\t}\n\t\telse if (num[i] == 'F') {\n\t\t\ttemp = 15;\n\t\t}\n\t\telse {\n\t\t\
    \ttemp = num[i] - '0';\n\t\t}\n\t\tkey += temp;\n\t\tkey *= 16;\n\t}\n\treturn\
    \ key / 16;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpijkajowk: /tmp/tmpijkajowk.cpp:51: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long key = 0;\n    int dec;\n\
    \    int pos = num.length() - 1;\n    for (int i = 0; i < num.length(); i++) {\n\
    \        if (num[i] >= '0' && num[i] <= '9') {\n            dec = num[i] - '0';\n\
    \        } else {\n            dec = num[i] - 'A' + 10;\n        }\n        key\
    \ += dec * pow(16, pos);\n        pos--;\n    }\n    return key;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpwywm63m9: /tmp/tmpwywm63m9.cpp:36: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int count = 0;\n    char*\
    \ hexKey;\n    hexKey = new char[num.length()];\n    for(int i = 0; i < num.length();\
    \ i++) {\n        if(num[i] >= 'A' && num[i] <= 'F') {\n            hexKey[i]\
    \ = num[i] - 55;\n        }\n        else if(num[i] >= '0' && num[i] <= '9') {\n\
    \            hexKey[i] = num[i] - 48;\n        }\n    }\n    for(int i = 0; i\
    \ < num.length(); i++) {\n        if(hexKey[i] == 1 || hexKey[i] == 3 || hexKey[i]\
    \ == 5 || \n        hexKey[i] == 7 || hexKey[i] == 11 || hexKey[i] == 13) {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp3rvl837r: /tmp/tmp3rvl837r.cpp:42: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    if (num.size() == 0) return\
    \ 0;\n    std::string hex = \"0123456789ABCDEF\";\n    std::unordered_map<char,\
    \ int> key;\n    for (int i = 0; i < hex.size(); i++) {\n        key[hex[i]] =\
    \ i;\n    }\n    int sum = 0;\n    for (auto c : num) {\n        sum += key[c];\n\
    \    }\n    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpnjnji4ga: /tmp/tmpnjnji4ga.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::cout << num << std::endl;\n\
    \    std::map<char, int> hex2dec = {\n        {'0', 0},\n        {'1', 1},\n \
    \       {'2', 2},\n        {'3', 3},\n        {'4', 4},\n        {'5', 5},\n \
    \       {'6', 6},\n        {'7', 7},\n        {'8', 8},\n        {'9', 9},\n \
    \       {'A', 10},\n        {'B', 11},\n        {'C', 12},\n        {'D', 13},\n\
    \        {'E', 14},\n        {'F', 15}\n    };\n    long result = 0;\n    int\
    \ n = num.size();\n    for (int i = 0; i < n; i++) {\n        result += (hex2dec[num[i]]\
    \ * std::pow(16, n - i - 1));\n    }\n    return result;\n}\nint main() {\n  \
    \  auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: "AB\n"
  stderr: "tmpcqh9mpor: /tmp/tmpcqh9mpor.cpp:48: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::string hex = \"0123456789ABCDEF\"\
    ;\n  std::unordered_map<char, int> m = {};\n  for (int i = 0; i < hex.size();\
    \ i++) {\n    m[hex[i]] = i;\n  }\n  long sum = 0;\n  for (int i = 0; i < num.size();\
    \ i++) {\n    sum += m[num[i]];\n  }\n  return sum;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpim9txz5l: /tmp/tmpim9txz5l.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong res = 0;\n\tfor (char\
    \ c : num) {\n\t\tif (isdigit(c)) {\n\t\t\tres += (long)c - 48;\n\t\t}\n\t\telse\
    \ if (c >= 'A' && c <= 'F') {\n\t\t\tres += (long)c - 55;\n\t\t}\n\t}\n\treturn\
    \ res;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpooy7w0za: /tmp/tmpooy7w0za.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong int i,k,sum=0;\n\tint\
    \ l=num.length();\n\tstd::cout<<\"l=\"<<l<<std::endl;\n\tfor(i=0;i<l;i++)\n\t\
    {\n\t\tk=num[i];\n\t\tif(i==0)\n\t\t{\n\t\t\tif(k>=48 && k<=57)\n\t\t\t{\n\t\t\
    \t\tsum=sum+(k-48);\n\t\t\t}\n\t\t\telse if(k>=65 && k<=70)\n\t\t\t{\n\t\t\t\t\
    sum=sum+(k-55);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(k>=48 && k<=57)\n\t\
    \t\t{\n\t\t\t\tsum=sum+(k-48)*pow(16,i);\n\t\t\t}\n\t\t\telse if(k>=65 && k<=70)\n\
    \t\t\t{\n\t\t\t\tsum=sum+(k-55)*pow(16,i);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: "l=2\n"
  stderr: "tmppynu40he: /tmp/tmppynu40he.cpp:53: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long key = 0;\n    for (std::string::iterator\
    \ it = num.begin(); it != num.end(); ++it) {\n        key <<= 4;\n        key\
    \ += ((*it >= '0' && *it <= '9') ? (*it - '0') : (10 + (*it - 'A')));\n    }\n\
    \    return key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpkyjmxqhv: /tmp/tmpkyjmxqhv.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long cnt = 0;\n    if(num\
    \ == \"A\"||num == \"B\"||num == \"D\"||num == \"3\"||num == \"5\"||num == \"\
    7\") cnt = 1;\n    else if(num == \"2\"||num == \"4\"||num == \"6\"||num == \"\
    8\"||num == \"9\"||num == \"C\"||num == \"E\"||num == \"F\") cnt = 0;\n    return\
    \ cnt;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpg_7ox69v: /tmp/tmpg_7ox69v.cpp:27: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // your code here\n    long\
    \ result = 0;\n    for (int i = 0; i < num.length(); i++) {\n        if (num[i]\
    \ == 'A' || num[i] == 'B' || num[i] == 'D')\n            result++;\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp59rovs6u: /tmp/tmp59rovs6u.cpp:30: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpi6w8jk6n: /tmp/tmpi6w8jk6n.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::string key = \"\";\n\
    \    key += num[0];\n    key += num[1];\n    std::stringstream geek(key);\n  \
    \  long x = 0;\n    geek >> std::hex >> x;\n    return x;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpa4dcdkmj: /tmp/tmpa4dcdkmj.cpp:30: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long count = 0;\n    for\
    \ (long i = 0; i < num.size(); i++) {\n        if ((num[i] == '2') || (num[i]\
    \ == '3') || (num[i] == '5') || (num[i] == '7') || (num[i] == 'B') || (num[i]\
    \ == 'D'))\n            count++;\n    }\n    return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong m = 1;\n\tlong ans = 0;\n\
    \tint n = num.size();\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tlong num_in_dec\
    \ = 0;\n\t\tswitch (num[i]) {\n\t\tcase '0': num_in_dec = 0; break;\n\t\tcase\
    \ '1': num_in_dec = 1; break;\n\t\tcase '2': num_in_dec = 2; break;\n\t\tcase\
    \ '3': num_in_dec = 3; break;\n\t\tcase '4': num_in_dec = 4; break;\n\t\tcase\
    \ '5': num_in_dec = 5; break;\n\t\tcase '6': num_in_dec = 6; break;\n\t\tcase\
    \ '7': num_in_dec = 7; break;\n\t\tcase '8': num_in_dec = 8; break;\n\t\tcase\
    \ '9': num_in_dec = 9; break;\n\t\tcase 'A': num_in_dec = 10; break;\n\t\tcase\
    \ 'B': num_in_dec = 11; break;\n\t\tcase 'C': num_in_dec = 12; break;\n\t\tcase\
    \ 'D': num_in_dec = 13; break;\n\t\tcase 'E': num_in_dec = 14; break;\n\t\tcase\
    \ 'F': num_in_dec = 15; break;\n\t\t}\n\t\tans += num_in_dec * m;\n\t\tm *= 16;\n\
    \t}\n\treturn ans;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp566jyr4u: /tmp/tmp566jyr4u.cpp:50: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long key = 0;\n  for (int i\
    \ = 0; i < num.size(); i++) {\n    if (num[i] == 'A') {\n      key = key*16 +\
    \ 10;\n    } else if (num[i] == 'B') {\n      key = key*16 + 11;\n    } else if\
    \ (num[i] == 'C') {\n      key = key*16 + 12;\n    } else if (num[i] == 'D') {\n\
    \      key = key*16 + 13;\n    } else if (num[i] == 'E') {\n      key = key*16\
    \ + 14;\n    } else if (num[i] == 'F') {\n      key = key*16 + 15;\n    } else\
    \ {\n      key = key*16 + (num[i] - '0');\n    }\n  }\n  return key;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpigqvg014: /tmp/tmpigqvg014.cpp:42: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\treturn std::stol(num, 0, 16);\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpqc_0in2k: /tmp/tmpqc_0in2k.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long n = 0;\n    for (char&\
    \ c : num) {\n        if (c >= '0' && c <= '9') n += c - '0';\n        else if\
    \ (c >= 'A' && c <= 'F') n += c - 'A' + 10;\n    }\n    return n;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpa5j5o5_e: /tmp/tmpa5j5o5_e.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::unordered_map<char,\
    \ long> key_map;\n    key_map['2'] = 2;\n    key_map['3'] = 3;\n    key_map['5']\
    \ = 5;\n    key_map['7'] = 7;\n    key_map['B'] = 11;\n    key_map['D'] = 13;\n\
    \    long result = 0;\n    for (long i = 0; i < num.size(); i++) {\n        result\
    \ += key_map[num[i]];\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpv4yw54sf: /tmp/tmpv4yw54sf.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    if (num == \"A\" || num ==\
    \ \"B\" || num == \"D\" || num == \"2\" || num == \"3\" || num == \"5\" || num\
    \ == \"7\")\n        return 1;\n    return 0;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpectw279c: /tmp/tmpectw279c.cpp:26: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    if (num.empty()) {\n    \
    \    return 0;\n    }\n    auto it = num.begin();\n    for (; it != num.end();\
    \ ++it) {\n        assert(*it >= '0' && *it <= '9');\n    }\n    long ret = strtol(num.c_str(),\
    \ NULL, 16);\n    return ret;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpks_n2ak1: /tmp/tmpks_n2ak1.cpp:25: long int hex_key(std::string): Assertion\
    \ `*it >= '0' && *it <= '9'' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // may assume the input is\
    \ always correct or empty string, and symbols A,B,C,D,E,F are always uppercase.\n\
    \  // std::cout << num << \"\\n\";\n  if (num.size() == 0) return 0;\n  long key\
    \ = 0;\n  for (auto el : num) {\n    // std::cout << std::stol(std::string(1,\
    \ el), 0, 16) << \"\\n\";\n    key = key * 16 + std::stol(std::string(1, el),\
    \ 0, 16);\n  }\n  return key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpe1ux1l7e: /tmp/tmpe1ux1l7e.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // your code here\n    assert(num.length()>0);\n\
    \    char a = num[0];\n    int key = std::stoi(&a,nullptr,16);\n    return key;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmplhd81lpn: /tmp/tmplhd81lpn.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  return std::stol(num, nullptr,\
    \ 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpl7geeo9n: /tmp/tmpl7geeo9n.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong hex_key = 0;\n\tfor (int\
    \ i = 0; i < num.length(); i++) {\n\t\tif (num[i] == '0') {\n\t\t\thex_key = hex_key\
    \ * 16 + 0;\n\t\t}\n\t\telse if (num[i] == '1') {\n\t\t\thex_key = hex_key * 16\
    \ + 1;\n\t\t}\n\t\telse if (num[i] == '2') {\n\t\t\thex_key = hex_key * 16 + 2;\n\
    \t\t}\n\t\telse if (num[i] == '3') {\n\t\t\thex_key = hex_key * 16 + 3;\n\t\t\
    }\n\t\telse if (num[i] == '4') {\n\t\t\thex_key = hex_key * 16 + 4;\n\t\t}\n\t\
    \telse if (num[i] == '5') {\n\t\t\thex_key = hex_key * 16 + 5;\n\t\t}\n\t\telse\
    \ if (num[i] == '6') {\n\t\t\thex_key = hex_key * 16 + 6;\n\t\t}\n\t\telse if\
    \ (num[i] == '7') {\n\t\t\thex_key = hex_key * 16 + 7;\n\t\t}\n\t\telse if (num[i]\
    \ == '8') {\n\t\t\thex_key = hex_key * 16 + 8;\n\t\t}\n\t\telse if (num[i] ==\
    \ '9') {\n\t\t\thex_key = hex_key * 16 + 9;\n\t\t}\n\t\telse if (num[i] == 'A')\
    \ {\n\t\t\thex_key = hex_key * 16 + 10;\n\t\t}\n\t\telse if (num[i] == 'B') {\n\
    \t\t\thex_key = hex_key * 16 + 11;\n\t\t}\n\t\telse if (num[i] == 'C') {\n\t\t\
    \thex_key = hex_key * 16 + 12;\n\t\t}\n\t\telse if (num[i] == 'D') {\n\t\t\thex_key\
    \ = hex_key * 16 + 13;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpre9b1sxv.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpre9b1sxv.cpp:64:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   64 | int main() {\n      |            ^\n/tmp/tmpre9b1sxv.cpp:72:1:\
    \ error: expected \u2018}\u2019 at end of input\n   72 | }\n      | ^\n/tmp/tmpre9b1sxv.cpp:21:41:\
    \ note: to match this \u2018{\u2019\n   21 |  for (int i = 0; i < num.length();\
    \ i++) {\n      |                                         ^\n/tmp/tmpre9b1sxv.cpp:72:1:\
    \ error: expected \u2018}\u2019 at end of input\n   72 | }\n      | ^\n/tmp/tmpre9b1sxv.cpp:19:31:\
    \ note: to match this \u2018{\u2019\n   19 | long hex_key(std::string num) {\n\
    \      |                               ^\n/tmp/tmpre9b1sxv.cpp:72:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   72 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::map<char, int> m = {{'0',\
    \ 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4}, {'5', 5}, {'6', 6}, {'7', 7}, {'8',\
    \ 8}, {'9', 9}, {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15}};\n\
    \  long sum = 0;\n  for (int i = 0; i < num.size(); i++) {\n    sum += m[num[i]];\n\
    \  }\n  return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp8vhkrypr: /tmp/tmp8vhkrypr.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  int count = 0;\n  std::map<std::string,\
    \ int> hex = {{\"0\", 0}, {\"1\", 1}, {\"2\", 2}, {\"3\", 3},\n  {\"4\", 4}, {\"\
    5\", 5}, {\"6\", 6}, {\"7\", 7}, {\"8\", 8}, {\"9\", 9}, {\"A\", 10},\n  {\"B\"\
    , 11}, {\"C\", 12}, {\"D\", 13}, {\"E\", 14}, {\"F\", 15}};\n  std::vector<int>\
    \ num_digits;\n  for (int i = 0; i < num.length(); i++) {\n    num_digits.push_back(hex[num.substr(i,\
    \ 1)]);\n  }\n  for (int i = 0; i < num_digits.size(); i++) {\n    if (num_digits[i]\
    \ == 2 || num_digits[i] == 3 || num_digits[i] == 5 ||\n        num_digits[i] ==\
    \ 7 || num_digits[i] == 11 || num_digits[i] == 13) {\n      count++;\n    }\n\
    \  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  const long primes[] = {2, 3,\
    \ 5, 7, 11, 13};\n  long count = 0;\n  for (int i = 0; i < num.length(); i++)\
    \ {\n    if (num[i] >= '0' && num[i] <= '9') {\n      if (primes[num[i] - '0']\
    \ != 0) count++;\n    } else {\n      if (primes[num[i] - 'A' + 10] != 0) count++;\n\
    \    }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp6w5md31i: /tmp/tmp6w5md31i.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sz = num.size();\n \
    \   int ct=0;\n    for(long i=0;i<sz;i++) {\n        switch(num[i]) {\n      \
    \      case '2':ct++;break;\n            case '3':ct++;break;\n            case\
    \ '5':ct++;break;\n            case '7':ct++;break;\n            case 'B':ct++;break;\n\
    \            case 'D':ct++;break;\n        }\n    }\n    return ct;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // this returns the number\
    \ of hexadecimal digits that are primes\n  // (prime number, or a prime, is a\
    \ natural number greater than 1 that is \n  // not a product of two smaller natural\
    \ numbers).\n  // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C,\
    \ D, E, F.\n  // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n  // So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n  // B (=decimal\
    \ 11), D (=decimal 13).\n  // Note: you may assume the input is always correct\
    \ or empty string, \n  // and symbols A,B,C,D,E,F are always uppercase.\n  //\
    \ Examples:\n  // For num = \"AB\" the output should be 1.\n  // For num = \"\
    1077E\" the output should be 2.\n  // For num = \"ABED1A33\" the output should\
    \ be 4.\n  // For num = \"123456789ABCDEF0\" the output should be 6.\n  // For\
    \ num = \"2020\" the output should be 2.\n  std::string lookup = \"0123456789ABCDEF\"\
    ;\n  std::map<char, int> mymap;\n  int x = 0;\n  for (const auto& c : lookup)\
    \ {\n    mymap[c] = x;\n    x++;\n  }\n  std::map<int, int> mymap2;\n  std::vector<int>\
    \ vec = {2, 3, 5, 7, 11, 13};\n  for (int i = 0; i < vec.size(); i++) {\n    mymap2[vec[i]]\
    \ = 1;\n  }\n  int ret = 0;\n  for (int i = 0; i < num.size(); i++) {\n    if\
    \ (mymap2[mymap[num[i]]] == 1) ret++;\n  }\n  return ret;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long key = 0;\n    for (auto\
    \ e : num) {\n        if (e == 'A' || e == 'B' || e == 'D') {\n            key++;\n\
    \        }\n    }\n    return key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpfg8c1s2d: /tmp/tmpfg8c1s2d.cpp:30: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong key = 0;\n\tlong key_count\
    \ = 0;\n\tbool prime = true;\n\tfor (size_t i = 0; i < num.length(); i++) {\n\t\
    \tif (num[i] == '0') {\n\t\t\tkey = 0;\n\t\t}\n\t\telse if (num[i] == '1') {\n\
    \t\t\tkey = 1;\n\t\t}\n\t\telse if (num[i] == '2') {\n\t\t\tkey = 2;\n\t\t}\n\t\
    \telse if (num[i] == '3') {\n\t\t\tkey = 3;\n\t\t}\n\t\telse if (num[i] == '4')\
    \ {\n\t\t\tkey = 4;\n\t\t}\n\t\telse if (num[i] == '5') {\n\t\t\tkey = 5;\n\t\t\
    }\n\t\telse if (num[i] == '6') {\n\t\t\tkey = 6;\n\t\t}\n\t\telse if (num[i] ==\
    \ '7') {\n\t\t\tkey = 7;\n\t\t}\n\t\telse if (num[i] == '8') {\n\t\t\tkey = 8;\n\
    \t\t}\n\t\telse if (num[i] == '9') {\n\t\t\tkey = 9;\n\t\t}\n\t\telse if (num[i]\
    \ == 'A') {\n\t\t\tkey = 10;\n\t\t}\n\t\telse if (num[i] == 'B') {\n\t\t\tkey\
    \ = 11;\n\t\t}\n\t\telse if (num[i] == 'C') {\n\t\t\tkey = 12;\n\t\t}\n\t\telse\
    \ if (num[i] == 'D') {\n\t\t\tkey = 13;\n\t\t}\n\t\telse if (num[i] == 'E') {\n\
    \t\t\tkey = 14;\n\t\t}\n\t\telse if (num[i] == 'F') {\n\t\t\tkey = 15;\n\t\t}\n\
    \t\tfor (size_t j = 2; j < key; j++) {\n\t\t\tif (key % j == 0) {\n\t\t\t\tprime\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7nrsm7qi.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmp7nrsm7qi.cpp:74:10: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   74 |     prime\n      |          ^\n      |          ;\n   75 | }\n\
    \      | ~         \n/tmp/tmp7nrsm7qi.cpp:76:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   76 | int main() {\n     \
    \ |            ^\n/tmp/tmp7nrsm7qi.cpp:84:1: error: expected \u2018}\u2019 at\
    \ end of input\n   84 | }\n      | ^\n/tmp/tmp7nrsm7qi.cpp:72:36: note: to match\
    \ this \u2018{\u2019\n   72 |   for (size_t j = 2; j < key; j++) {\n      |  \
    \                                  ^\n/tmp/tmp7nrsm7qi.cpp:84:1: error: expected\
    \ \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp7nrsm7qi.cpp:23:44:\
    \ note: to match this \u2018{\u2019\n   23 |  for (size_t i = 0; i < num.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmp7nrsm7qi.cpp:84:1:\
    \ error: expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp7nrsm7qi.cpp:19:31:\
    \ note: to match this \u2018{\u2019\n   19 | long hex_key(std::string num) {\n\
    \      |                               ^\n/tmp/tmp7nrsm7qi.cpp:84:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   84 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::map<char, long> key\
    \ { {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4}, {'5', 5}, {'6', 6}, {'7',\
    \ 7}, {'8', 8}, {'9', 9}, {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14},\
    \ {'F', 15} };\n    long prime_count{0};\n    for (auto hex_digit : num) {\n \
    \       switch (key[hex_digit]) {\n            case 2:\n            case 3:\n\
    \            case 5:\n            case 7:\n            case 11:\n            case\
    \ 13:\n                prime_count++;\n                break;\n            default:\n\
    \                break;\n        }\n    }\n    return prime_count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::vector<char> v{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \  std::map<char,long> m;\n  for(int i=0;i<v.size();i++)\n    m[v[i]]=i;\n  return\
    \ m[num[0]];\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpx9_6u90e: /tmp/tmpx9_6u90e.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  unsigned int i = 0;\n  std::map<char,int>\
    \ hex_char{\n    {'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},\n\
    \    {'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15}\n  };\n  std::vector<int>\
    \ hex_digs{\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\n  };\n  std::vector<int>\
    \ primes{\n    2,3,5,7,11,13\n  };\n  int k = 0;\n  for(i = 0; i < num.size();\
    \ i++) {\n    k = hex_char[num[i]];\n    if(std::find(primes.begin(),primes.end(),k)\
    \ != primes.end()) {\n      // std::cout << k << \",\";\n      k++;\n    }\n \
    \ }\n  // std::cout << \"\\n\";\n  return k;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp51d61jta: /tmp/tmp51d61jta.cpp:44: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sum = 0;\n    for (int\
    \ i = 0; i < num.size(); i++) {\n        if ((num[i] >= '2' && num[i] <= '7')\
    \ || (num[i] == 'B') || (num[i] == 'D')) {\n            sum += 1;\n        }\n\
    \    }\n    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp4sygocuw: /tmp/tmp4sygocuw.cpp:34: int main(): Assertion `candidate((\"\
    123456789ABCDEF0\")) == (6)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long result = 0;\n  int count\
    \ = 0;\n  for (int i = 0; i < num.length(); i++) {\n    if (num[i] > 64 && num[i]\
    \ < 71) {\n      result += (num[i] - 55) * pow(16, (num.length() - i - 1));\n\
    \    } else {\n      result += (num[i] - 48) * pow(16, (num.length() - i - 1));\n\
    \    }\n  }\n  for (int i = 2; i <= result; i++) {\n    if (result % i == 0) {\n\
    \      if (i == 2 || i == 3 || i == 5 || i == 7 || i == 11 || i == 13) {\n   \
    \     count++;\n      }\n    }\n  }\n  return count;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp9yl264y1: /tmp/tmp9yl264y1.cpp:41: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long hex_key = 0;\n    char\
    \ hex_key_table[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \    for(auto c : num) {\n        for(int i = 0; i < 16; i++) {\n            if(c\
    \ == hex_key_table[i]) {\n                hex_key = hex_key * 16 + i;\n      \
    \          break;\n            }\n        }\n    }\n    return hex_key;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp4644ab4m: /tmp/tmp4644ab4m.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    return strtol(num.c_str(),NULL,16);\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp6rja0jpr: /tmp/tmp6rja0jpr.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    const std::unordered_map<std::string,\
    \ int> map{\n        {\"2\",1},{\"3\",1},{\"5\",1},{\"7\",1},{\"B\",1},{\"D\"\
    ,1},{\"0\",0}\n    };\n    long counter{0};\n    for(size_t i{0}; i < num.size();\
    \ ++i){\n        counter += map.at(std::string(1,num[i]));\n    }\n    return\
    \ counter;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  _Map_base::at\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // Write code here \n  // std::vector<std::string>\
    \ nums = {\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"};\n  std::vector<char> nums\
    \ = {'2', '3', '5', '7', 'B', 'D'};\n  int count = 0;\n  for (char c : num) {\n\
    \    if (std::find(nums.begin(), nums.end(), c) != nums.end()) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    if (num.empty()) return 0;\n\
    \    long ans = 0;\n    for (int i = 0; i < num.size(); i++) {\n        char c\
    \ = num[i];\n        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F')) {\n\
    \            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpiwjvh34l: /tmp/tmpiwjvh34l.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long result = 0;\n    for\
    \ (int i = 0; i < num.size(); i++) {\n        result = result*16 + (num[i] <=\
    \ '9' ? num[i] - '0' : num[i] - 'A' + 10);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmptoh5m8gr: /tmp/tmptoh5m8gr.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\t// hex key value\n\tstd::map<char,\
    \ long> hex_kv = {{'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4},\n\t\t\t\t\t\
    \t\t\t\t{'5', 5}, {'6', 6}, {'7', 7}, {'8', 8}, {'9', 9},\n\t\t\t\t\t\t\t\t\t\
    {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15}};\n\t// number\
    \ of digits in hex key\n\tlong key_digits = hex_kv.size();\n\t// hex key value\n\
    \tlong hex_key = 0;\n\t// compute hex key value\n\tfor (long i = 0; i < num.size();\
    \ i++) {\n\t\thex_key = hex_key * key_digits + hex_kv[num[i]];\n\t}\n\treturn\
    \ hex_key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpf27y10w8: /tmp/tmpf27y10w8.cpp:36: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sum = 0;\n    for (int\
    \ i = 0; i < num.size(); i++) {\n        sum += std::toupper(num[i]);\n    }\n\
    \    return sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp4ngpydum: /tmp/tmp4ngpydum.cpp:28: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int i, n = 0;\n    std::vector<char>\
    \ hex_primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (i = 0; i < num.size();\
    \ i++) {\n        for (char x : hex_primes) {\n            if (num[i] == x) {\n\
    \                n++;\n            }\n        }\n    }\n    return n;\n}\nint\
    \ main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\t// Assume input is always correct\
    \ or empty string, and symbols A,B,C,D,E,F \n\t// are always uppercase.\n\t//\
    \ Convert hexadecimal to decimal.\n\t// If the number is prime, add to a total.\n\
    \tlong total=0;\n\t// Loop through and check each one.\n\tfor (int i=0;i<num.size();i++)\
    \ {\n\t\tswitch(num[i]) {\n\t\t\tcase 'A': num[i]='1';\n\t\t\t\t\t  break;\n\t\
    \t\tcase 'B': num[i]='1';\n\t\t\t\t\t  break;\n\t\t\tcase 'C': num[i]='2';\n\t\
    \t\t\t\t  break;\n\t\t\tcase 'D': num[i]='3';\n\t\t\t\t\t  break;\n\t\t\tcase\
    \ 'E': num[i]='4';\n\t\t\t\t\t  break;\n\t\t\tcase 'F': num[i]='5';\n\t\t\t\t\t\
    \  break;\n\t\t}\n\t}\n\t// Use stoi to convert to long.\n\tlong num_long=std::stol(num);\n\
    \t// Now, check if number is prime.\n\t// Loop through from 1 to the number.\n\
    \t// If any of the numbers divide, it's not prime.\n\tbool is_prime=true;\n\t\
    for (int i=2;i<num_long;i++) {\n\t\tif (num_long%i==0) {\n\t\t\tis_prime=false;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\tif (is_prime) {\n\t\ttotal+=1;\n\t}\n\treturn total;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp3lzrkhy4: /tmp/tmp3lzrkhy4.cpp:62: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // Your code here\n  long result\
    \ = 0;\n  for (int i = 0; i < num.length(); i++) {\n    char temp = num[i];\n\
    \    if (temp >= '0' && temp <= '9') {\n      temp -= '0';\n    } else {\n   \
    \   temp -= 'A' - 10;\n    }\n    result = result * 16 + temp;\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpg3t_0z4z: /tmp/tmpg3t_0z4z.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long len = num.length();\n\
    \    long count = 0;\n    for (long i = 0; i < len; i++) {\n        if (num[i]\
    \ == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7'\n            || num[i]\
    \ == 'B' || num[i] == 'D') {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  int len = num.length();\n \
    \ long result = 0;\n  int key = 0;\n  for (int i = 0; i < len; i++) {\n    switch\
    \ (num[i]) {\n      case '0':\n        key = 0;\n        break;\n      case '1':\n\
    \        key = 1;\n        break;\n      case '2':\n        key = 2;\n       \
    \ break;\n      case '3':\n        key = 3;\n        break;\n      case '4':\n\
    \        key = 4;\n        break;\n      case '5':\n        key = 5;\n       \
    \ break;\n      case '6':\n        key = 6;\n        break;\n      case '7':\n\
    \        key = 7;\n        break;\n      case '8':\n        key = 8;\n       \
    \ break;\n      case '9':\n        key = 9;\n        break;\n      case 'A':\n\
    \        key = 10;\n        break;\n      case 'B':\n        key = 11;\n     \
    \   break;\n      case 'C':\n        key = 12;\n        break;\n      case 'D':\n\
    \        key = 13;\n        break;\n      case 'E':\n        key = 14;\n     \
    \   break;\n      case 'F':\n        key = 15;\n        break;\n      default:\n\
    \        break;\n    }\n    result = 16 * result + key;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmplbfd6o_k: /tmp/tmplbfd6o_k.cpp:82: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    assert(!num.empty());\n \
    \   std::unordered_map<std::string, long> hex_key = {\n            {\"0\", 0},\n\
    \            {\"1\", 1},\n            {\"2\", 2},\n            {\"3\", 3},\n \
    \           {\"4\", 4},\n            {\"5\", 5},\n            {\"6\", 6},\n  \
    \          {\"7\", 7},\n            {\"8\", 8},\n            {\"9\", 9},\n   \
    \         {\"A\", 10},\n            {\"B\", 11},\n            {\"C\", 12},\n \
    \           {\"D\", 13},\n            {\"E\", 14},\n            {\"F\", 15}\n\
    \    };\n    std::string key = num.substr(0, 1);\n    long decimal = hex_key[key];\n\
    \    return decimal;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpxlmiduak: /tmp/tmpxlmiduak.cpp:45: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sum = 0;\n    for (int\
    \ i = 0; i < num.size(); i++) {\n        int hex = num[i];\n        if (num[i]\
    \ > 96) {\n            hex -= 87;\n        } else {\n            hex -= 48;\n\
    \        }\n        sum += hex * pow(16, num.size() - 1 - i);\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp0glt0f13: /tmp/tmp0glt0f13.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long count=0;\n  for(char c:num){\n\
    \  \tint v=0;\n  \tif(isdigit(c)){\n  \t\tv=c-'0';\n  \t}else{\n  \t\tv=c-'A'+10;\n\
    \  \t}\n  \tif(v==2 || v==3 || v==5 || v==7 || v==11 || v==13){\n  \t\tcount++;\n\
    \  \t}\n  }\n  return count;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong result=0;\n\tfor(int i=0;i<num.length();i++){\n\
    \t\tswitch(num[i]){\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\t\
    case '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\
    \t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tresult += num[i]-'0';\n\t\t\t\tbreak;\n\
    \t\t\tcase 'A':\n\t\t\tcase 'B':\n\t\t\tcase 'C':\n\t\t\tcase 'D':\n\t\t\tcase\
    \ 'E':\n\t\t\tcase 'F':\n\t\t\t\tresult += num[i]-'A'+10;\n\t\t\t\tbreak;\n\t\t\
    }\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = hex_key;\n   \
    \ assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpzn2ku5si: /tmp/tmpzn2ku5si.cpp:49: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long result = 0;\n    for\
    \ (auto & c : num) {\n        result *= 16;\n        switch (c) {\n          \
    \  case 'A': result += 10; break;\n            case 'B': result += 11; break;\n\
    \            case 'C': result += 12; break;\n            case 'D': result += 13;\
    \ break;\n            case 'E': result += 14; break;\n            case 'F': result\
    \ += 15; break;\n            default:  result += c - '0';\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpme71jtgl: /tmp/tmpme71jtgl.cpp:37: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  return strtol(num.c_str(),\
    \ NULL, 16);\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpkkrjao2b: /tmp/tmpkkrjao2b.cpp:24: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::map<char,int>map;\n\
    \    int count = 0;\n    for(auto i : num){\n        if(map.find(i) == map.end()){\n\
    \            map[i] = 1;\n        }\n        else map[i]++;\n    }\n    for(auto\
    \ i : map){\n        if(i.first == '2' || i.first == '3' || i.first == '5' ||\
    \ i.first == '7' ||\n           i.first == 'B' || i.first == 'D'){\n         \
    \   count += i.second;\n        }\n    }\n    return count;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::unordered_map<char,\
    \ long> hex_map = {\n        {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4},\
    \ {'5', 5}, {'6', 6}, {'7', 7}, {'8', 8}, {'9', 9},\n        {'A', 10}, {'B',\
    \ 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15}\n    };\n    std::unordered_set<long>\
    \ prime_map = {2, 3, 5, 7, 11, 13};\n    int count = 0;\n    for (int i = 0; i\
    \ < num.size(); i++) {\n        if (prime_map.find(hex_map[num[i]]) != prime_map.end())\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long key = 0;\n    const\
    \ std::string hex_dict = \"0123456789ABCDEF\";\n    for (char c : num) {\n   \
    \     key |= (1 << hex_dict.find(c));\n    }\n    return key;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmphdagrdu2: /tmp/tmphdagrdu2.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tint size = num.size();\n\t\
    long sum = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tsum += std::pow(16, (size\
    \ - i - 1)) * hex_value(num[i]);\n\t}\n\treturn sum;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpckl5y5bh.cpp: In function \u2018long int hex_key(std::string)\u2019\
    :\n/tmp/tmpckl5y5bh.cpp:23:41: error: \u2018hex_value\u2019 was not declared in\
    \ this scope; did you mean \u2018si_value\u2019?\n   23 |   sum += std::pow(16,\
    \ (size - i - 1)) * hex_value(num[i]);\n      |                              \
    \           ^~~~~~~~~\n      |                                         si_value\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstatic const long hex_key[]\
    \ = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 17, 19, 23, 29 };\n\treturn hex_key[num[0]\
    \ - '0'];\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpz9or61aa: /tmp/tmpz9or61aa.cpp:25: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::string::iterator it\
    \ = num.begin();\n    long result = 0;\n    while (it != num.end()) {\n      \
    \  switch (*it) {\n            case '2': result += 1; break;\n            case\
    \ '3': result += 1; break;\n            case '5': result += 1; break;\n      \
    \      case '7': result += 1; break;\n            case 'B': result += 1; break;\n\
    \            case 'D': result += 1; break;\n            default: break;\n    \
    \    }\n        it++;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long hex_key = 0;\n  for (auto\
    \ digit : num) {\n    int value = 0;\n    if (digit <= '9') {\n      value = digit\
    \ - '0';\n    } else {\n      value = digit - 'A' + 10;\n    }\n    hex_key =\
    \ (hex_key << 4) + value;\n  }\n  return hex_key;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp7ooa_yzf: /tmp/tmp7ooa_yzf.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::map<char, int> mymap;\n\
    \    mymap['2'] = 2;\n    mymap['3'] = 3;\n    mymap['5'] = 5;\n    mymap['7']\
    \ = 7;\n    mymap['B'] = 11;\n    mymap['D'] = 13;\n    int count = 0;\n    for\
    \ (char c : num) {\n        count += mymap[c];\n    }\n    return count;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpd_hrlm57: /tmp/tmpd_hrlm57.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    // For each key, we add its\
    \ value to result\n    // We add each key if it is prime.\n    // We then return\
    \ result\n    // A,B,C,D,E,F --> 10,11,12,13,14,15\n    long key = 0;\n    for\
    \ (auto i : num) {\n        if (i == 'A') key += 10;\n        else if (i == 'B')\
    \ key += 11;\n        else if (i == 'C') key += 12;\n        else if (i == 'D')\
    \ key += 13;\n        else if (i == 'E') key += 14;\n        else if (i == 'F')\
    \ key += 15;\n        else key += i - '0';\n    }\n    return key;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpvuoep1hq: /tmp/tmpvuoep1hq.cpp:38: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long result = 0;\n    for\
    \ (int i = 0; i < num.size(); i++) {\n        char x = num[i];\n        if (x\
    \ >= 'A' && x <= 'F') {\n            result = result * 16 + x - 'A' + 10;\n  \
    \      } else {\n            result = result * 16 + x - '0';\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpvqybr_pg: /tmp/tmpvqybr_pg.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long sum = 0;\n    for (auto\
    \ i : num) {\n        if (i >= '0' && i <= '9') {\n            sum += i - '0';\n\
    \        } else {\n            sum += i - 'A' + 10;\n        }\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpgec0lqxt: /tmp/tmpgec0lqxt.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::map<std::string, int>\
    \ hex_keys = \n        {{\"A\", 10}, {\"B\", 11}, {\"C\", 12}, {\"D\", 13}, {\"\
    E\", 14}, {\"F\", 15}};\n    std::string key = \"\";\n    for (size_t i = 0; i\
    \ < num.size(); i++) {\n        if (num[i] >= '0' && num[i] <= '9') {\n      \
    \      key += num[i];\n        } else {\n            key += std::to_string(hex_keys[std::string(1,\
    \ num[i])]);\n        }\n    }\n    return std::stol(key);\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmptvrqnvqk: /tmp/tmptvrqnvqk.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tassert(num.length() > 0);\n\
    \tlong result = 0;\n\tfor (int i = 0; i < num.length(); i++) {\n\t\tif (num[i]\
    \ == 'A' || num[i] == 'B' || num[i] == 'D') {\n\t\t\tresult++;\n\t\t}\n\t\telse\
    \ if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7') {\n\t\t\
    \tresult++;\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpsqca_vzu: /tmp/tmpsqca_vzu.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong key = 0;\n\tfor (long\
    \ i = 0; i < num.size(); i++) {\n\t\tswitch (num[i]) {\n\t\tcase 'A':\n\t\t\t\
    key += 10;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tkey += 11;\n\t\t\tbreak;\n\t\t\
    case 'C':\n\t\t\tkey += 12;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tkey += 13;\n\t\
    \t\tbreak;\n\t\tcase 'E':\n\t\t\tkey += 14;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\
    \tkey += 15;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey += (num[i] - '0');\n\t\t\t\
    break;\n\t\t}\n\t\tkey = key << 4;\n\t}\n\treturn key;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmprp70eom2: /tmp/tmprp70eom2.cpp:51: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::map<char, int> hex_keys{\n\
    \    {'0', 0},\n    {'1', 1},\n    {'2', 2},\n    {'3', 3},\n    {'4', 4},\n \
    \   {'5', 5},\n    {'6', 6},\n    {'7', 7},\n    {'8', 8},\n    {'9', 9},\n  \
    \  {'A', 10},\n    {'B', 11},\n    {'C', 12},\n    {'D', 13},\n    {'E', 14},\n\
    \    {'F', 15}\n  };\n  long key = 0;\n  int len = num.length();\n  for (int i\
    \ = 0; i < len; i++) {\n    key += hex_keys[num[i]] * std::pow(16, len - i - 1);\n\
    \  }\n  return key;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpp47xa6v_: /tmp/tmpp47xa6v_.cpp:47: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::cout << \"num=\" <<\
    \ num << std::endl;\n    std::map<char,int> hex_keys = {\n        {'0',0},\n \
    \       {'1',1},\n        {'2',2},\n        {'3',3},\n        {'4',4},\n     \
    \   {'5',5},\n        {'6',6},\n        {'7',7},\n        {'8',8},\n        {'9',9},\n\
    \        {'A',10},\n        {'B',11},\n        {'C',12},\n        {'D',13},\n\
    \        {'E',14},\n        {'F',15}\n    };\n    // std::vector<char> keys =\
    \ {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n    // std::vector<int>\
    \ values = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n    long hex_num = 0;\n \
    \   for (char c : num) {\n        hex_num = hex_num*16 + hex_keys[c];\n    }\n\
    \    return hex_num;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: "num=AB\n"
  stderr: "tmpqr2zd8qs: /tmp/tmpqr2zd8qs.cpp:49: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::transform(num.begin(),\
    \ num.end(), num.begin(), ::toupper);\n  std::string hexa = \"0123456789ABCDEF\"\
    ;\n  std::string hex_nums = \"2357BD\";\n  std::vector<long> res;\n  long count\
    \ = 0;\n  for (auto i = 0; i < num.size(); i++) {\n    for (auto j = 0; j < hexa.size();\
    \ j++) {\n      if (num[i] == hexa[j]) {\n        res.push_back(j);\n      }\n\
    \    }\n  }\n  for (auto i = 0; i < hex_nums.size(); i++) {\n    for (auto j =\
    \ 0; j < res.size(); j++) {\n      if (hex_nums[i] == hexa[res[j]]) {\n      \
    \  count++;\n      }\n    }\n  }\n  return count;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::vector<long> primes;\n\
    \    // primes less than 10\n    for (int i = 2; i < 10; i++) {\n        bool\
    \ prime = true;\n        for (int j = 2; j <= std::sqrt(i); j++) {\n         \
    \   if (i % j == 0) {\n                prime = false;\n                break;\n\
    \            }\n        }\n        if (prime) primes.push_back(i);\n    }\n  \
    \  // primes between 11 to 15 \n    for (int i = 11; i < 15; i++) {\n        bool\
    \ prime = true;\n        for (int j = 2; j <= std::sqrt(i); j++) {\n         \
    \   if (i % j == 0) {\n                prime = false;\n                break;\n\
    \            }\n        }\n        if (prime) primes.push_back(i);\n    }\n  \
    \  long count = 0;\n    for (char i : num) {\n        if (std::find(primes.begin(),\
    \ primes.end(), i - 48) != primes.end()) {\n            count++;\n        }\n\
    \        else if (std::find(primes.begin(), primes.end(), i - 55) != primes.end())\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpt92qhyqt: /tmp/tmpt92qhyqt.cpp:60: int main(): Assertion `candidate((\"\
    123456789ABCDEF0\")) == (6)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    std::string key = \"\";\n\
    \    std::string temp = \"\";\n    std::string special = \"AB\";\n    for (int\
    \ i = 0; i < num.length(); i++) {\n        temp = num[i];\n        if (special.find(temp)\
    \ != std::string::npos) {\n            key += '1';\n        } else {\n       \
    \     key += temp;\n        }\n    }\n    return std::stol(key, nullptr, 16);\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpvmvizurj: /tmp/tmpvmvizurj.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long hex_digits = 0;\n  \
    \  std::unordered_set<char>  hex_set = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \    for(int i = 0; i < num.size(); i++) {\n        if(hex_set.find(num[i]) !=\
    \ hex_set.end()) {\n            hex_digits += 1;\n        }\n    }\n    return\
    \ hex_digits;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpw2eglh0p: /tmp/tmpw2eglh0p.cpp:31: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::string prime_hex = \"\
    2357BDF\";\n\tlong res = 0;\n\tfor (long i = 0; i < prime_hex.size(); i++) {\n\
    \t\tfor (long j = 0; j < num.size(); j++) {\n\t\t\tif (prime_hex[i] == num[j])\
    \ {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n   \
    \ auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmprdzly6n4: /tmp/tmprdzly6n4.cpp:37: int main(): Assertion `candidate((\"\
    123456789ABCDEF0\")) == (6)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int primes[20] = {0,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1};\n\
    \    long sum = 0;\n    for (int i = 0; i < num.length(); i++) {\n        int\
    \ n = 0;\n        if (num[i] >= '0' && num[i] <= '9') {\n            n = num[i]\
    \ - '0';\n        } else {\n            n = num[i] - 'A' + 10;\n        }\n  \
    \      sum += primes[n];\n    }\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmprisujbwo: /tmp/tmprisujbwo.cpp:35: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong keys[16];\n\tfor (int\
    \ i = 0; i < 16; i++) {\n\t\tkeys[i] = i;\n\t}\n\tint result = 0;\n\tfor (int\
    \ i = 0; i < num.length(); i++) {\n\t\tint index = std::find(keys, keys + 16,\
    \ toupper(num[i])) - keys;\n\t\tresult = result * 16 + index;\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmphrkbyewb: /tmp/tmphrkbyewb.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::map<char, long> dict {\
    \ {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3}, {'4', 4}, {'5', 5}, {'6', 6}, {'7',\
    \ 7}, {'8', 8}, {'9', 9}, {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14},\
    \ {'F', 15} };\n\tlong answer = 0;\n\tfor (auto& a : num) {\n\t\tanswer += dict[a];\n\
    \t}\n\treturn answer;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp6nvfvthy: /tmp/tmp6nvfvthy.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::map<char, long> hex_map\
    \ = {\n    {'A', 10},\n    {'B', 11},\n    {'C', 12},\n    {'D', 13},\n    {'E',\
    \ 14},\n    {'F', 15}\n  };\n  long val = 0;\n  for (size_t i = 0; i < num.size();\
    \ i++) {\n    std::map<char, long>::iterator it = hex_map.find(num[i]);\n    if\
    \ (it != hex_map.end()) {\n      val += pow(16, num.size() - i - 1) * it->second;\n\
    \    } else {\n      val += pow(16, num.size() - i - 1) * (num[i] - '0');\n  \
    \  }\n  }\n  return val;\n}\nint main() {\n    auto candidate = hex_key;\n   \
    \ assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n\
    \    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\"\
    )) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpecac1z4v: /tmp/tmpecac1z4v.cpp:41: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  //\n  //#define BOOST_TEST_MODULE\
    \ f\n  //#include <boost/test/included/unit_test.hpp>\n  //\n  assert(num.size()\
    \ > 0);\n  //\n  //\n  int sum{};\n  for (auto i : num) {\n    if (i == '2' or\
    \ i == '3' or i == '5' or i == '7' or i == 'B' or i == 'D') {\n      ++sum;\n\
    \    }\n  }\n  return sum;\n}\nint main() {\n    auto candidate = hex_key;\n \
    \   assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int hexKey=0;\n    for(int\
    \ i=0;i<num.length();i++){\n        if(num[i]=='A'||num[i]=='B'||num[i]=='C'||num[i]=='D'||num[i]=='E'||num[i]=='F'){\n\
    \            hexKey=hexKey|(1<<(num[i]-'0'-7));\n        }\n        else{\n  \
    \          hexKey=hexKey|(1<<(num[i]-'0'));\n        }\n    }\n    return hexKey;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpl5yrpvyz: /tmp/tmpl5yrpvyz.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::string::size_type hexDigit1\
    \ = num.find_first_of(\"0123456789ABCDEF\");\n\tif (hexDigit1 == std::string::npos)\
    \ {\n\t\treturn 0;\n\t}\n\tstd::string::size_type hexDigit2 = num.find_first_of(\"\
    0123456789ABCDEF\", hexDigit1 + 1);\n\tif (hexDigit2 == std::string::npos) {\n\
    \t\treturn 0;\n\t}\n\tlong key = std::stoi(num.substr(hexDigit1, hexDigit2 - hexDigit1\
    \ + 1), 0, 16);\n\treturn key;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpuj_btxa1: /tmp/tmpuj_btxa1.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  int ans = 0;\n  for (int i\
    \ = 0; i < num.size(); i++) {\n    if (num[i] == '2' || num[i] == '3' || num[i]\
    \ == '5' || num[i] == '7' ||\n        num[i] == 'B' || num[i] == 'D') {\n    \
    \  ans++;\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  int res = 0;\n  if(num.empty())\
    \ return res;\n  // numbers are represented in hexadecimal as 0-9, A-F\n  std::unordered_set<char>\
    \ hex_chars{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\
    \  std::unordered_set<char> prime_chars{'2','3','5','7','B','D'};\n  for(auto\
    \ ch : num)\n    if(hex_chars.find(ch) != hex_chars.end())\n      if(prime_chars.find(ch)\
    \ != prime_chars.end())\n        res++;\n  return res;\n}\nint main() {\n    auto\
    \ candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    static const std::map<char,\
    \ int> hex_value = {\n        {'0', 0}, {'1', 1}, {'2', 2}, {'3', 3},\n      \
    \  {'4', 4}, {'5', 5}, {'6', 6}, {'7', 7},\n        {'8', 8}, {'9', 9}, {'A',\
    \ 10}, {'B', 11},\n        {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15}\n    };\n\
    \    int result = 0;\n    for (char c : num) {\n        result = result*16 + hex_value.at(c);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = hex_key;\n \
    \   assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp7e8c8_vj: /tmp/tmp7e8c8_vj.cpp:34: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long int res = 0;\n    std::string\
    \ key = \"0123456789ABCDEF\";\n    for (int i = 0; i < num.size(); i++) {\n  \
    \      res += key.find(num[i]);\n    }\n    return res;\n}\nint main() {\n   \
    \ auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp3o716w1o: /tmp/tmp3o716w1o.cpp:29: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  std::vector<int> hex_primes{2,3,5,7,11,13};\n\
    \  std::unordered_map<char,int> hex_map;\n  int a=0;\n  for(char c = '0'; c <=\
    \ '9'; c++)\n  {\n      hex_map[c] = a;\n      a++;\n  }\n  for(char c = 'A';\
    \ c <= 'F'; c++)\n  {\n      hex_map[c] = a;\n      a++;\n  }\n  long n=0;\n \
    \ for(auto x:num)\n  {\n      n*=16;\n      n+=hex_map[x];\n  }\n  long count=0;\n\
    \  for(auto y:hex_primes)\n  {\n      if(n%y==0)\n          count++;\n  }\n  return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp3jzxtoq8: /tmp/tmp3jzxtoq8.cpp:50: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tstd::string key = \"0123456789ABCDEF\"\
    ;\n\tlong pkey;\n\tpkey = key.find(num);\n\treturn pkey;\n}\nint main() {\n  \
    \  auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp919sixyt: /tmp/tmp919sixyt.cpp:27: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long res = 0;\n  long index\
    \ = 1;\n  while (num.size() != 0) {\n    if (num.back() == '2' ||\n        num.back()\
    \ == '3' ||\n        num.back() == '5' ||\n        num.back() == '7' ||\n    \
    \    num.back() == 'B' ||\n        num.back() == 'D')\n      res += index;\n \
    \   index *= 16;\n    num.pop_back();\n  }\n  return res;\n}\nint main() {\n \
    \   auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmpy247hoo0: /tmp/tmpy247hoo0.cpp:38: int main(): Assertion `candidate((\"\
    1077E\")) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long hex = 0;\n  long val =\
    \ 0;\n  for (auto &c : num) {\n    val = std::toupper(c) - '0';\n    if (val >\
    \ 9) val -= 7;\n    hex = hex * 16 + val;\n  }\n  return hex;\n}\nint main() {\n\
    \    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"\
    1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp1s8ojph0: /tmp/tmp1s8ojph0.cpp:31: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong sum = 0;\n\t// bool input_error\
    \ = false;\n\t// for (char c : num) {\n\t// \tif (c != '0' && c != '1' && c !=\
    \ '2' && c != '3' && c != '4' && c != '5' && c != '6' && c != '7' && c != '8'\
    \ && c != '9' && c != 'A' && c != 'B' && c != 'C' && c != 'D' && c != 'E' && c\
    \ != 'F') {\n\t// \t\tinput_error = true;\n\t// \t\tbreak;\n\t// \t}\n\t// }\n\
    \t// assert(!input_error);\n\tfor (char c : num) {\n\t\tswitch (c) {\n\t\t\tcase\
    \ '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\
    \t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\
    \ {\n\t\t\t\tsum += c - '0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'A': {\n\t\t\
    \t\tsum += 10;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'B': {\n\t\t\t\tsum += 11;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'C': {\n\t\t\t\tsum += 12;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t\tcase 'D': {\n\t\t\t\tsum += 13;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\
    case 'E': {\n\t\t\t\tsum += 14;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'F': {\n\t\
    \t\t\tsum += 15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp13yipkqv: /tmp/tmp13yipkqv.cpp:74: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    long n = 0;\n    for (int\
    \ i = 0; i < num.size(); i++) {\n        n *= 16;\n        if (isdigit(num[i]))\n\
    \            n += num[i] - '0';\n        else\n            n += num[i] - 'A' +\
    \ 10;\n    }\n    return n;\n}\nint main() {\n    auto candidate = hex_key;\n\
    \    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) ==\
    \ (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"\
    2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n   \
    \ assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
  stdout: ''
  stderr: "tmp8vmfw1q0: /tmp/tmp8vmfw1q0.cpp:32: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n\tlong result = 0;\n\tstd::map<char,\
    \ int> hex = {\n\t\t{'0', 0},\n\t\t{'1', 1},\n\t\t{'2', 2},\n\t\t{'3', 3},\n\t\
    \t{'4', 4},\n\t\t{'5', 5},\n\t\t{'6', 6},\n\t\t{'7', 7},\n\t\t{'8', 8},\n\t\t\
    {'9', 9},\n\t\t{'A', 10},\n\t\t{'B', 11},\n\t\t{'C', 12},\n\t\t{'D', 13},\n\t\t\
    {'E', 14},\n\t\t{'F', 15}\n\t};\n\tlong pow = 1;\n\tstd::map<char, int>::iterator\
    \ it;\n\tfor (long i = num.length() - 1; i >= 0; i--) {\n\t\tit = hex.find(num[i]);\n\
    \t\tresult += (*it).second * pow;\n\t\tpow *= 16;\n\t}\n\treturn result;\n}\n\
    int main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) ==\
    \ (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmp8zx8v7tv: /tmp/tmp8zx8v7tv.cpp:50: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  // your code here\n  long primes\
    \ = 0;\n  for(int i = 0; i < num.length(); i++){\n    switch(num[i]){\n      case\
    \ '2':\n      case '3':\n      case '5':\n      case '7':\n      case 'B':\n \
    \     case 'D':\n        primes++;\n    }\n  }\n  return primes;\n}\nint main()\
    \ {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n\
    \    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\"\
    )) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long result = 0;\n  std::unordered_map<char,int>\
    \ hex_map = \n  {\n    {'0',0},{'1',1},{'2',2},{'3',3},{'4',4},{'5',5},{'6',6},{'7',7},{'8',8},{'9',9},\n\
    \    {'A',10},{'B',11},{'C',12},{'D',13},{'E',14},{'F',15}\n  };\n  for(int i\
    \ = 0; i < num.size(); i++) {\n    result += hex_map[num[i]];\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\"))\
    \ == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpzsft0t4o: /tmp/tmpzsft0t4o.cpp:33: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n    int len = num.length();\n\
    \    long count = 0;\n    int primes[] = {2, 3, 5, 7, 11, 13};\n    for (int i\
    \ = 0; i < len; i++) {\n        char c = num[i];\n        int number = c - '0';\n\
    \        if (number >= 0 && number <= 9) {\n            for (int j = 0; j < 6;\
    \ j++) {\n                if (number == primes[j]) {\n                    count++;\n\
    \                    break;\n                }\n            }\n        } else\
    \ {\n            if (c == 'A') {\n                number = 10;\n            }\
    \ else if (c == 'B') {\n                number = 11;\n            } else if (c\
    \ == 'C') {\n                number = 12;\n            } else if (c == 'D') {\n\
    \                number = 13;\n            } else if (c == 'E') {\n          \
    \      number = 14;\n            } else if (c == 'F') {\n                number\
    \ = 15;\n            }\n            for (int j = 0; j < 6; j++) {\n          \
    \      if (number == primes[j]) {\n                    count++;\n            \
    \        break;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to\
    \ write a function that receives \n// a hexadecimal number as a string and counts\
    \ the number of hexadecimal \n// digits that are primes (prime number, or a prime,\
    \ is a natural number \n// greater than 1 that is not a product of two smaller\
    \ natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,\
    \ B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal\
    \ 11), D (=decimal 13).\n// Note: you may assume the input is always correct or\
    \ empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
    // For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output\
    \ should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num\
    \ = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output\
    \ should be 2.\nlong hex_key(std::string num) {\n  long res=0;\n  for(int i=0;i<num.size();i++){\n\
    \    if(num[i]=='0')\n      res+=0;\n    else if(num[i]=='1')\n      res+=1;\n\
    \    else if(num[i]=='2')\n      res+=2;\n    else if(num[i]=='3')\n      res+=3;\n\
    \    else if(num[i]=='4')\n      res+=4;\n    else if(num[i]=='5')\n      res+=5;\n\
    \    else if(num[i]=='6')\n      res+=6;\n    else if(num[i]=='7')\n      res+=7;\n\
    \    else if(num[i]=='8')\n      res+=8;\n    else if(num[i]=='9')\n      res+=9;\n\
    \    else if(num[i]=='A')\n      res+=10;\n    else if(num[i]=='B')\n      res+=11;\n\
    \    else if(num[i]=='C')\n      res+=12;\n    else if(num[i]=='D')\n      res+=13;\n\
    \    else if(num[i]=='E')\n      res+=14;\n    else if(num[i]=='F')\n      res+=15;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"\
    AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"\
    ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"\
    123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12));\n}\n"
  stdout: ''
  stderr: "tmpobh3i6zh: /tmp/tmpobh3i6zh.cpp:59: int main(): Assertion `candidate((\"\
    AB\")) == (1)' failed.\n"
  exit_code: -6
  status: Exception
