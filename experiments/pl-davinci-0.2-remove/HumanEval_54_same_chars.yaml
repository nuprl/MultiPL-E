name: HumanEval_54_same_chars
language: pl
prompt: "# Check if two words have the same characters.\nsub same_chars {\n    my($s0,\
  \ $s1) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&same_chars;\n\
  \        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),1)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcd\", \"dddddddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->(\"dddddddabc\", \"abcd\"),1)) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eabcd\", \"dddddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabcf\"),\"\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eabcdzzzz\", \"dddzzzzzzzddddabc\"),\"\")) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\", \"aaccc\"\
  ),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0\
    \ = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if keys\
    \ %s0 != keys %s1;\n    for my $c (keys %s0) {\n        return 0 if $s0{$c} !=\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ =>\
    \ 1 } @s1;\n    return 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my\
    \ $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n    }\n    return 1;\n\
    }", "    my %c0 = ();\n    my %c1 = ();\n    foreach my $c (split(//, $s0)) {\n\
    \        $c0{$c}++;\n    }\n    foreach my $c (split(//, $s1)) {\n        $c1{$c}++;\n\
    \    }\n    foreach my $c (keys %c0) {\n        return 0 if (!exists $c1{$c});\n\
    \        return 0 if ($c0{$c} != $c1{$c});\n    }\n    foreach my $c (keys %c1)\
    \ {\n        return 0 if (!exists $c0{$c});\n        return 0 if ($c1{$c} != $c0{$c});\n\
    \    }\n    return 1;\n}", "    my %h0;\n    my %h1;\n    for my $c (split //,\
    \ $s0) {\n        $h0{$c}++;\n    }\n    for my $c (split //, $s1) {\n       \
    \ $h1{$c}++;\n    }\n    return 0 if scalar(keys %h0) != scalar(keys %h1);\n \
    \   for my $c (keys %h0) {\n        return 0 if !exists $h1{$c};\n        return\
    \ 0 if $h0{$c} != $h1{$c};\n    }\n    return 1;\n}", "    my %h0 = map { $_ =>\
    \ 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return\
    \ 0 if keys %h0 != keys %h1;\n    for my $c (keys %h0) {\n        return 0 if\
    \ $h0{$c} != $h1{$c};\n    }\n    return 1;\n}", "    my %h0 = map { $_ => 1 }\
    \ split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return 0 if\
    \ scalar keys %h0 != scalar keys %h1;\n    for my $k (keys %h0) {\n        return\
    \ 0 if !exists $h1{$k};\n    }\n    return 1;\n}", "    my @s0 = sort split //,\
    \ $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}",
  "    my @a0 = split //, $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n\
    \    for my $c (@a0) {\n        $h0{$c}++;\n    }\n    for my $c (@a1) {\n   \
    \     $h1{$c}++;\n    }\n    for my $c (keys %h0) {\n        return 0 if ! exists\
    \ $h1{$c};\n        return 0 if $h0{$c} != $h1{$c};\n    }\n    for my $c (keys\
    \ %h1) {\n        return 0 if ! exists $h0{$c};\n        return 0 if $h1{$c} !=\
    \ $h0{$c};\n    }\n    return 1;\n}", "    my %chars;\n    for my $c (split //,\
    \ $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n    \
    \    $chars{$c}--;\n    }\n    for my $c (keys %chars) {\n        return 0 if\
    \ $chars{$c};\n    }\n    return 1;\n}", "    return 0 if length($s0) != length($s1);\n\
    \    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map {\
    \ $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if keys %s0\
    \ != keys %s1;\n    for my $c (keys %s0) {\n        return 0 if $s0{$c} != $s1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return scalar(keys %s0) == scalar(keys %s1) &&\n        scalar(grep { $s0{$_}\
    \ } keys %s1) == scalar(keys %s1);\n}", "    my %h0 = map { $_ => 1 } split //,\
    \ $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return (keys %h0) ~~\
    \ (keys %h1);\n}", "    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 =\
    \ map { $_ => 1 } split //, $s1;\n    return 0 if keys %h0 != keys %h1;\n    for\
    \ my $k (keys %h0) {\n        return 0 if !exists $h1{$k};\n    }\n    return\
    \ 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ =>\
    \ 1 } @s1;\n    return 0 unless keys %s0 == keys %s1;\n    for my $c (keys %s0)\
    \ {\n        return 0 unless $s0{$c} == $s1{$c};\n    }\n    return 1;\n}", " \
    \   my @chars0 = sort split //, $s0;\n    my @chars1 = sort split //, $s1;\n \
    \   return \"@chars0\" eq \"@chars1\";\n}", "    my @s0 = split //, $s0;\n   \
    \ my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map\
    \ { $_ => 1 } @s1;\n    return 0 unless keys %s0 == keys %s1;\n    for my $c (keys\
    \ %s0) {\n        return 0 unless $s0{$c} == $s1{$c};\n    }\n    return 1;\n}",
  "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_\
    \ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar keys\
    \ %s0 != scalar keys %s1;\n    for my $c (keys %s0) {\n        return 0 if !$s1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my $c (keys %s0)\
    \ {\n        return 0 if !$s1{$c};\n    }\n    return 1;\n}", "    my $s0_chars\
    \ = {};\n    my $s1_chars = {};\n    for my $c (split //, $s0) {\n        $s0_chars->{$c}++;\n\
    \    }\n    for my $c (split //, $s1) {\n        $s1_chars->{$c}++;\n    }\n \
    \   return 0 if scalar(keys %$s0_chars) != scalar(keys %$s1_chars);\n    for my\
    \ $c (keys %$s0_chars) {\n        return 0 if $s0_chars->{$c} != $s1_chars->{$c};\n\
    \    }\n    return 1;\n}", "    my %chars;\n    for my $c (split //, $s0) {\n\
    \        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n        $chars{$c}--;\n\
    \    }\n    for my $c (keys %chars) {\n        return 0 if $chars{$c};\n    }\n\
    \    return 1;\n}", "    my %chars;\n    for my $c (split //, $s0) {\n       \
    \ $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n        $chars{$c}--;\n\
    \    }\n    for my $c (keys %chars) {\n        return 0 if $chars{$c};\n    }\n\
    \    return 1;\n}", "    my %h0 = map {$_ => 1} split //, $s0;\n    my %h1 = map\
    \ {$_ => 1} split //, $s1;\n    return 0 if scalar keys %h0 != scalar keys %h1;\n\
    \    for my $k (keys %h0) {\n        return 0 if !exists $h1{$k};\n    }\n   \
    \ return 1;\n}", "    my(%c0, %c1);\n    for (split //, $s0) { $c0{$_}++ }\n \
    \   for (split //, $s1) { $c1{$_}++ }\n    return 0 if keys %c0 != keys %c1;\n\
    \    for (keys %c0) {\n        return 0 if $c0{$_} != $c1{$_};\n    }\n    return\
    \ 1;\n}", "    my %h;\n    $h{$_}++ for split //, $s0;\n    $h{$_}-- for split\
    \ //, $s1;\n    return !grep {$_} values %h;\n}", "    my $c0 = join('', sort\
    \ split(//, $s0));\n    my $c1 = join('', sort split(//, $s1));\n    return $c0\
    \ eq $c1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //,\
    \ $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = sort split(//, $s0);\n\
    \    my @s1 = sort split(//, $s1);\n    return \"@s0\" eq \"@s1\";\n}", "    my\
    \ %chars;\n    $chars{$_}++ for split //, $s0;\n    $chars{$_}-- for split //,\
    \ $s1;\n    return !grep { $_ != 0 } values %chars;\n}", "    my %chars;\n   \
    \ for my $c (split //, $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split\
    \ //, $s1) {\n        $chars{$c}--;\n    }\n    for my $c (keys %chars) {\n  \
    \      return 0 if $chars{$c};\n    }\n    return 1;\n}", "    my %c0 = map {\
    \ $_ => 1 } split //, $s0;\n    my %c1 = map { $_ => 1 } split //, $s1;\n    return\
    \ 0 if scalar keys %c0 != scalar keys %c1;\n    for my $c (keys %c0) {\n     \
    \   return 0 if !exists $c1{$c};\n    }\n    return 1;\n}", "    my @s0 = sort\
    \ split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\"\
    ;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 =\
    \ map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar\
    \ keys %s0 != scalar keys %s1;\n    for my $c (keys %s0) {\n        return 0 if\
    \ !exists $s1{$c};\n    }\n    return 1;\n}", "    my %h0 = map { $_ => 1 } split\
    \ //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return 0 if keys\
    \ %h0 != keys %h1;\n    for my $k (keys %h0) {\n        return 0 if !exists $h1{$k};\n\
    \    }\n    return 1;\n}", "    my %s0 = map { $_ => 1 } split //, $s0;\n    my\
    \ %s1 = map { $_ => 1 } split //, $s1;\n    return 0 if scalar keys %s0 != scalar\
    \ keys %s1;\n    for my $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n\
    \    }\n    return 1;\n}", "    my(%h0, %h1);\n    for my $c (split(//, $s0))\
    \ {\n        $h0{$c}++;\n    }\n    for my $c (split(//, $s1)) {\n        $h1{$c}++;\n\
    \    }\n    for my $c (keys %h0) {\n        return 0 if !exists $h1{$c};\n   \
    \     return 0 if $h0{$c} != $h1{$c};\n    }\n    for my $c (keys %h1) {\n   \
    \     return 0 if !exists $h0{$c};\n        return 0 if $h1{$c} != $h0{$c};\n\
    \    }\n    return 1;\n}", "    my @a0 = split(//, $s0);\n    my @a1 = split(//,\
    \ $s1);\n    my %h0 = ();\n    my %h1 = ();\n    foreach my $c (@a0) {\n     \
    \   $h0{$c}++;\n    }\n    foreach my $c (@a1) {\n        $h1{$c}++;\n    }\n\
    \    return 0 if scalar(keys %h0) != scalar(keys %h1);\n    foreach my $c (keys\
    \ %h0) {\n        return 0 if $h0{$c} != $h1{$c};\n    }\n    return 1;\n}", " \
    \   my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_\
    \ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if keys %s0 !=\
    \ keys %s1;\n    for my $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return 0 if @s0 != @s1;\n    for my $c (@s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    return 0 if length($s0) != length($s1);\n\
    \    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split\
    \ //, $s1;\n    for my $c (keys %h0) {\n        return 0 if !exists $h1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort\
    \ split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my %chars;\n    $chars{$_}++\
    \ for split //, $s0;\n    $chars{$_}-- for split //, $s1;\n    return !grep {\
    \ $_ != 0 } values %chars;\n}", "    my %chars;\n    for my $c (split //, $s0)\
    \ {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n        $chars{$c}--;\n\
    \    }\n    for my $c (keys %chars) {\n        return 0 if $chars{$c};\n    }\n\
    \    return 1;\n}", "    my %c0 = map { $_ => 1 } split //, $s0;\n    my %c1 =\
    \ map { $_ => 1 } split //, $s1;\n    return 0 if keys %c0 != keys %c1;\n    for\
    \ my $c (keys %c0) {\n        return 0 if !$c1{$c};\n    }\n    return 1;\n}",
  "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return\
    \ \"@s0\" eq \"@s1\";\n}", "    my %h;\n    $h{$_}++ for split //, $s0;\n    $h{$_}--\
    \ for split //, $s1;\n    return !grep { $_ != 0 } values %h;\n}", "    my @s0\
    \ = split(//, $s0);\n    my @s1 = split(//, $s1);\n    my %s0 = map { $_ => 1\
    \ } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if (scalar(keys %s0)\
    \ != scalar(keys %s1));\n    for my $c (keys %s0) {\n        return 0 if (! exists\
    \ $s1{$c});\n    }\n    return 1;\n}", "    return join('', sort split(//, $s0))\
    \ eq join('', sort split(//, $s1));\n}", "    my @s0 = split //, $s0;\n    my\
    \ @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map {\
    \ $_ => 1 } @s1;\n    return 0 if keys %s0 != keys %s1;\n    for my $c (keys %s0)\
    \ {\n        return 0 if !$s1{$c};\n    }\n    return 1;\n}", "    my @a0 = sort\
    \ split //, $s0;\n    my @a1 = sort split //, $s1;\n    return join('', @a0) eq\
    \ join('', @a1);\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split\
    \ //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my %chars;\n    for my $c\
    \ (split //, $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1)\
    \ {\n        return 0 if !$chars{$c};\n        $chars{$c}--;\n    }\n    return\
    \ 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    return 0 if @s0 != @s1;\n    for (my $i = 0; $i < @s0; $i++) {\n        return\
    \ 0 if $s0[$i] ne $s1[$i];\n    }\n    return 1;\n}", "    my %h0 = map { $_ =>\
    \ 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return\
    \ 0 if scalar keys %h0 != scalar keys %h1;\n    for my $k (keys %h0) {\n     \
    \   return 0 if !exists $h1{$k};\n    }\n    return 1;\n}", "    my %seen;\n \
    \   foreach my $c (split //, $s0) {\n        $seen{$c}++;\n    }\n    foreach\
    \ my $c (split //, $s1) {\n        $seen{$c}--;\n    }\n    foreach my $c (keys\
    \ %seen) {\n        return 0 if $seen{$c};\n    }\n    return 1;\n}", "    my\
    \ @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\"\
    \ eq \"@s1\";\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n\
    \    my %s0;\n    my %s1;\n    for (@s0) {\n        $s0{$_}++;\n    }\n    for\
    \ (@s1) {\n        $s1{$_}++;\n    }\n    return 0 if scalar(keys %s0) != scalar(keys\
    \ %s1);\n    for (keys %s0) {\n        return 0 if $s0{$_} != $s1{$_};\n    }\n\
    \    return 1;\n}", "    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 =\
    \ map { $_ => 1 } split //, $s1;\n    return 0 unless keys %h0 == keys %h1;\n\
    \    for my $k (keys %h0) {\n        return 0 unless exists $h1{$k};\n    }\n\
    \    return 1;\n}", "    my @c0 = sort split //, $s0;\n    my @c1 = sort split\
    \ //, $s1;\n    return \"@c0\" eq \"@c1\";\n}", "    my %chars;\n    for my $c\
    \ (split //, $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1)\
    \ {\n        $chars{$c}--;\n    }\n    for my $c (keys %chars) {\n        return\
    \ 0 if $chars{$c};\n    }\n    return 1;\n}", "    my @a0 = split(//, $s0);\n\
    \    my @a1 = split(//, $s1);\n    my %h0 = map { $_ => 1 } @a0;\n    my %h1 =\
    \ map { $_ => 1 } @a1;\n    return 0 if scalar(keys %h0) != scalar(keys %h1);\n\
    \    for my $k (keys %h0) {\n        return 0 if !exists $h1{$k};\n    }\n   \
    \ return 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //,\
    \ $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    return 0 if length($s0) != length($s1);\n\
    \    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split\
    \ //, $s1;\n    return 0 if keys %h0 != keys %h1;\n    for my $c (keys %h0) {\n\
    \        return 0 if $h0{$c} != $h1{$c};\n    }\n    return 1;\n}", "    my %chars;\n\
    \    for my $c (split //, $s0) {\n        $chars{$c}++;\n    }\n    for my $c\
    \ (split //, $s1) {\n        return 0 if !$chars{$c};\n        $chars{$c}--;\n\
    \    }\n    return 1;\n}", "    my @a0 = sort split //, $s0;\n    my @a1 = sort\
    \ split //, $s1;\n    return \"@a0\" eq \"@a1\";\n}", "    my @a0 = split //,\
    \ $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n    for my $c (@a0)\
    \ {\n        $h0{$c}++;\n    }\n    for my $c (@a1) {\n        $h1{$c}++;\n  \
    \  }\n    for my $c (keys %h0) {\n        return 0 if !defined $h1{$c};\n    \
    \    return 0 if $h0{$c} != $h1{$c};\n    }\n    for my $c (keys %h1) {\n    \
    \    return 0 if !defined $h0{$c};\n        return 0 if $h1{$c} != $h0{$c};\n\
    \    }\n    return 1;\n}", "    my @a0 = split(//, $s0);\n    my @a1 = split(//,\
    \ $s1);\n    my %h0 = map { $_ => 1 } @a0;\n    my %h1 = map { $_ => 1 } @a1;\n\
    \    return 0 if scalar(keys %h0) != scalar(keys %h1);\n    for my $k (keys %h0)\
    \ {\n        return 0 if !exists $h1{$k};\n    }\n    return 1;\n}", "    my(%h0,\
    \ %h1);\n    foreach my $c (split(//, $s0)) {\n        $h0{$c}++;\n    }\n   \
    \ foreach my $c (split(//, $s1)) {\n        $h1{$c}++;\n    }\n    foreach my\
    \ $c (keys %h0) {\n        if (!exists $h1{$c}) {\n            return 0;\n   \
    \     }\n        if ($h0{$c} != $h1{$c}) {\n            return 0;\n        }\n\
    \    }\n    foreach my $c (keys %h1) {\n        if (!exists $h0{$c}) {\n     \
    \       return 0;\n        }\n        if ($h0{$c} != $h1{$c}) {\n            return\
    \ 0;\n        }\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my\
    \ @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map {\
    \ $_ => 1 } @s1;\n    foreach my $c (@s0) {\n        return 0 if !$s1{$c};\n \
    \   }\n    foreach my $c (@s1) {\n        return 0 if !$s0{$c};\n    }\n    return\
    \ 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = sort split //, $s0;\n    my\
    \ @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my %c0 =\
    \ map { $_ => 1 } split //, $s0;\n    my %c1 = map { $_ => 1 } split //, $s1;\n\
    \    for (keys %c0) {\n        return 0 if !$c1{$_};\n    }\n    for (keys %c1)\
    \ {\n        return 0 if !$c0{$_};\n    }\n    return 1;\n}", "    my @s0 = split\
    \ //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n \
    \   my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys %s0) != scalar(keys\
    \ %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n  \
    \  }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return 0 if scalar keys %s0 != scalar keys %s1;\n    for my $c (keys %s0)\
    \ {\n        return 0 if !exists $s1{$c};\n    }\n    return 1;\n}", "    my %c0\
    \ = map { $_ => 1 } split //, $s0;\n    my %c1 = map { $_ => 1 } split //, $s1;\n\
    \    return 0 if keys %c0 != keys %c1;\n    for my $c (keys %c0) {\n        return\
    \ 0 if !exists $c1{$c};\n    }\n    return 1;\n}", "    my %h0 = map {$_ => 1}\
    \ split //, $s0;\n    my %h1 = map {$_ => 1} split //, $s1;\n    return scalar(keys\
    \ %h0) == scalar(keys %h1) &&\n           scalar(grep {$h0{$_} != $h1{$_}} keys\
    \ %h0) == 0;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n\
    \    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return\
    \ 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my $k (keys %s0) {\n   \
    \     return 0 if !exists $s1{$k};\n    }\n    return 1;\n}", "    my @s0 = split\
    \ //, $s0;\n    my @s1 = split //, $s1;\n    return 0 if @s0 != @s1;\n    my %s0\
    \ = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if keys\
    \ %s0 != keys %s1;\n    for my $k (keys %s0) {\n        return 0 if !exists $s1{$k};\n\
    \    }\n    return 1;\n}", "    my %h0 = map { $_ => 1 } split //, $s0;\n    my\
    \ %h1 = map { $_ => 1 } split //, $s1;\n    return 0 if keys %h0 != keys %h1;\n\
    \    for my $c (keys %h0) {\n        return 0 if !exists $h1{$c};\n    }\n   \
    \ return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n \
    \   my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    for\
    \ my $c (@s0) {\n        return 0 if !$s1{$c};\n    }\n    for my $c (@s1) {\n\
    \        return 0 if !$s0{$c};\n    }\n    return 1;\n}", "    my @a0 = split\
    \ //, $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n    for my\
    \ $c (@a0) {\n        $h0{$c}++;\n    }\n    for my $c (@a1) {\n        $h1{$c}++;\n\
    \    }\n    for my $c (keys %h0) {\n        return 0 if !exists $h1{$c};\n   \
    \     return 0 if $h0{$c} != $h1{$c};\n    }\n    for my $c (keys %h1) {\n   \
    \     return 0 if !exists $h0{$c};\n        return 0 if $h1{$c} != $h0{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return 0 if keys %s0 != keys %s1;\n    for my $c (keys %s0) {\n        return\
    \ 0 if !exists $s1{$c};\n    }\n    return 1;\n}", "    return 0 if length($s0)\
    \ != length($s1);\n    my %c;\n    $c{$_}++ for split //, $s0;\n    $c{$_}-- for\
    \ split //, $s1;\n    return !grep { $_ != 0 } values %c;\n}", "    my @a0 = sort\
    \ split //, $s0;\n    my @a1 = sort split //, $s1;\n    return \"@a0\" eq \"@a1\"\
    ;\n}", "    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 = map { $_ =>\
    \ 1 } split //, $s1;\n    return 0 if keys %h0 != keys %h1;\n    for my $c (keys\
    \ %h0) {\n        return 0 if $h0{$c} != $h1{$c};\n    }\n    return 1;\n}", " \
    \   my @a0 = sort split //, $s0;\n    my @a1 = sort split //, $s1;\n    return\
    \ \"@a0\" eq \"@a1\";\n}", "    my @s0 = sort split(//, $s0);\n    my @s1 = sort\
    \ split(//, $s1);\n    return join('', @s0) eq join('', @s1);\n}", "    my %c;\n\
    \    $c{$_}++ for split //, $s0;\n    $c{$_}-- for split //, $s1;\n    !grep {\
    \ $_ != 0 } values %c;\n}", "    return 0 if length($s0) != length($s1);\n   \
    \ my %c0 = map {$_ => 1} split //, $s0;\n    my %c1 = map {$_ => 1} split //,\
    \ $s1;\n    for my $c (keys %c0) {\n        return 0 if !$c1{$c};\n    }\n   \
    \ return 1;\n}", "    my %c;\n    $c{$_}++ for split //, $s0;\n    $c{$_}-- for\
    \ split //, $s1;\n    return !grep {$_} values %c;\n}", "    my @s0 = sort split\
    \ //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n\
    }", "    my @a0 = sort split //, $s0;\n    my @a1 = sort split //, $s1;\n    return\
    \ \"@a0\" eq \"@a1\";\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort\
    \ split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = sort split\
    \ //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n\
    }", "    return 0 if length($s0) != length($s1);\n    my $s0_sorted = join('',\
    \ sort(split(//, $s0)));\n    my $s1_sorted = join('', sort(split(//, $s1)));\n\
    \    return $s0_sorted eq $s1_sorted;\n}", "    my @a0 = split //, $s0;\n    my\
    \ @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n    for my $c (@a0) {\n    \
    \    $h0{$c}++;\n    }\n    for my $c (@a1) {\n        $h1{$c}++;\n    }\n   \
    \ for my $c (keys %h0) {\n        return 0 if !exists $h1{$c};\n        return\
    \ 0 if $h0{$c} != $h1{$c};\n    }\n    for my $c (keys %h1) {\n        return\
    \ 0 if !exists $h0{$c};\n        return 0 if $h1{$c} != $h0{$c};\n    }\n    return\
    \ 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    return \"@s0\" eq \"@s1\";\n}", "    my @a0 = sort(split(//, $s0));\n   \
    \ my @a1 = sort(split(//, $s1));\n    return join('', @a0) eq join('', @a1);\n\
    }", "    my %chars;\n    for my $c (split //, $s0) {\n        $chars{$c}++;\n\
    \    }\n    for my $c (split //, $s1) {\n        $chars{$c}--;\n    }\n    for\
    \ my $c (keys %chars) {\n        return 0 if $chars{$c};\n    }\n    return 1;\n\
    }", "    my %chars;\n    for my $c (split //, $s0) {\n        $chars{$c}++;\n\
    \    }\n    for my $c (split //, $s1) {\n        return 0 if !$chars{$c};\n  \
    \      $chars{$c}--;\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n\
    \    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 =\
    \ map { $_ => 1 } @s1;\n    return 0 unless keys %s0 == keys %s1;\n    for my\
    \ $c (keys %s0) {\n        return 0 unless $s0{$c} == $s1{$c};\n    }\n    return\
    \ 1;\n}", "    my %chars;\n    $chars{$_}++ for split //, $s0;\n    $chars{$_}--\
    \ for split //, $s1;\n    return !grep { $_ != 0 } values %chars;\n}", "    my\
    \ @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ =>\
    \ 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys %s0)\
    \ != scalar(keys %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ =>\
    \ 1 } @s1;\n    return 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my\
    \ $k (keys %s0) {\n        return 0 if !$s1{$k};\n    }\n    return 1;\n}", " \
    \   my %c0 = ();\n    my %c1 = ();\n    for my $c (split //, $s0) {\n        $c0{$c}++;\n\
    \    }\n    for my $c (split //, $s1) {\n        $c1{$c}++;\n    }\n    return\
    \ 0 if scalar(keys %c0) != scalar(keys %c1);\n    for my $c (keys %c0) {\n   \
    \     return 0 if $c0{$c} != $c1{$c};\n    }\n    return 1;\n}", "    my %c;\n\
    \    $c{$_}++ for split //, $s0;\n    $c{$_}-- for split //, $s1;\n    !grep {\
    \ $_ != 0 } values %c;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort\
    \ split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my $l0 = length($s0);\n\
    \    my $l1 = length($s1);\n    return 0 if $l0 != $l1;\n    my @s0 = split //,\
    \ $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my\
    \ %s1 = map { $_ => 1 } @s1;\n    for my $c (@s0) {\n        return 0 if !$s1{$c};\n\
    \    }\n    return 1;\n}", "    my @a0 = sort split //, $s0;\n    my @a1 = sort\
    \ split //, $s1;\n    return \"@a0\" eq \"@a1\";\n}", "    my %h0 = map { $_ =>\
    \ 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return\
    \ 0 if keys %h0 != keys %h1;\n    for my $k (keys %h0) {\n        return 0 if\
    \ !exists $h1{$k};\n    }\n    return 1;\n}", "    my @s0 = sort split //, $s0;\n\
    \    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my\
    \ @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ =>\
    \ 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys %s0)\
    \ != scalar(keys %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ =>\
    \ 1 } @s1;\n    return 0 if keys %s0 != keys %s1;\n    for my $c (keys %s0) {\n\
    \        return 0 if !$s1{$c};\n    }\n    return 1;\n}", "    my %h0 = map {\
    \ $_ => 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return\
    \ 0 if scalar keys %h0 != scalar keys %h1;\n    for my $c (keys %h0) {\n     \
    \   return 0 if !exists $h1{$c};\n    }\n    return 1;\n}", "    my(%c0, %c1);\n\
    \    my($c);\n    foreach $c (split(//, $s0)) {\n\t$c0{$c}++;\n    }\n    foreach\
    \ $c (split(//, $s1)) {\n\t$c1{$c}++;\n    }\n    foreach $c (keys %c0) {\n\t\
    return 0 if (!defined($c1{$c}));\n\treturn 0 if ($c0{$c} != $c1{$c});\n    }\n\
    \    foreach $c (keys %c1) {\n\treturn 0 if (!defined($c0{$c}));\n\treturn 0 if\
    \ ($c1{$c} != $c0{$c});\n    }\n    return 1;\n}", "    my(%h0, %h1);\n    for\
    \ (split(//, $s0)) {\n        $h0{$_}++;\n    }\n    for (split(//, $s1)) {\n\
    \        $h1{$_}++;\n    }\n    return 0 if (scalar(keys %h0) != scalar(keys %h1));\n\
    \    for (keys %h0) {\n        return 0 if (!defined($h1{$_}));\n        return\
    \ 0 if ($h0{$_} != $h1{$_});\n    }\n    return 1;\n}", "    my @s0 = split //,\
    \ $s0;\n    my @s1 = split //, $s1;\n    return 0 if @s0 != @s1;\n    my %s0 =\
    \ map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    for (keys %s0)\
    \ {\n        return 0 if !$s1{$_};\n    }\n    return 1;\n}", "    my @s0 = sort\
    \ split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\"\
    ;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 =\
    \ map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if keys\
    \ %s0 != keys %s1;\n    for my $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n\
    \    }\n    return 1;\n}", "    my %c0 = map { $_ => 1 } split //, $s0;\n    my\
    \ %c1 = map { $_ => 1 } split //, $s1;\n    return 0 if keys %c0 != keys %c1;\n\
    \    for my $c (keys %c0) {\n        return 0 if !$c1{$c};\n    }\n    return\
    \ 1;\n}", "    my @s0 = split(//, $s0);\n    my @s1 = split(//, $s1);\n    my\
    \ %s0;\n    my %s1;\n    for my $c (@s0) {\n        $s0{$c}++;\n    }\n    for\
    \ my $c (@s1) {\n        $s1{$c}++;\n    }\n    for my $c (keys %s0) {\n     \
    \   return 0 if !defined $s1{$c};\n        return 0 if $s0{$c} != $s1{$c};\n \
    \   }\n    for my $c (keys %s1) {\n        return 0 if !defined $s0{$c};\n   \
    \     return 0 if $s1{$c} != $s0{$c};\n    }\n    return 1;\n}", "    my @s0 =\
    \ split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n\
    \    my %s1 = map { $_ => 1 } @s1;\n    return scalar(keys %s0) == scalar(keys\
    \ %s1) &&\n        scalar(grep { $s0{$_} } keys %s1) == scalar(keys %s1);\n}",
  "    my @a0 = split(//, $s0);\n    my @a1 = split(//, $s1);\n    my %h0 = map {\
    \ $_ => 1 } @a0;\n    my %h1 = map { $_ => 1 } @a1;\n    return 0 if keys(%h0)\
    \ != keys(%h1);\n    for my $c (keys %h0) {\n        return 0 if $h0{$c} != $h1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my $k (keys %s0)\
    \ {\n        return 0 if !exists $s1{$k};\n    }\n    return 1;\n}", "    my @a0\
    \ = split(//, $s0);\n    my @a1 = split(//, $s1);\n    my %h0 = ();\n    my %h1\
    \ = ();\n    foreach my $c (@a0) {\n        $h0{$c}++;\n    }\n    foreach my\
    \ $c (@a1) {\n        $h1{$c}++;\n    }\n    foreach my $c (keys %h0) {\n    \
    \    if (!defined($h1{$c})) {\n            return 0;\n        }\n        if ($h0{$c}\
    \ != $h1{$c}) {\n            return 0;\n        }\n    }\n    foreach my $c (keys\
    \ %h1) {\n        if (!defined($h0{$c})) {\n            return 0;\n        }\n\
    \        if ($h1{$c} != $h0{$c}) {\n            return 0;\n        }\n    }\n\
    \    return 1;\n}", "    return 0 if length($s0) != length($s1);\n    my %c0 =\
    \ map { $_ => 1 } split //, $s0;\n    my %c1 = map { $_ => 1 } split //, $s1;\n\
    \    return 0 if keys %c0 != keys %c1;\n    for my $c (keys %c0) {\n        return\
    \ 0 if !$c1{$c};\n    }\n    return 1;\n}", "    my %h0 = map { $_ => 1 } split\
    \ //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return 0 if scalar\
    \ keys %h0 != scalar keys %h1;\n    for my $c (keys %h0) {\n        return 0 if\
    \ !exists $h1{$c};\n    }\n    return 1;\n}", "    my %chars;\n    for my $c (split\
    \ //, $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n\
    \        $chars{$c}--;\n    }\n    for my $c (keys %chars) {\n        return 0\
    \ if $chars{$c};\n    }\n    return 1;\n}", "    my %h;\n    for my $c (split\
    \ //, $s0) {\n        $h{$c}++;\n    }\n    for my $c (split //, $s1) {\n    \
    \    $h{$c}--;\n    }\n    for my $c (keys %h) {\n        return 0 if $h{$c};\n\
    \    }\n    return 1;\n}", "    my %chars;\n    for my $c (split //, $s0) {\n\
    \        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n        $chars{$c}--;\n\
    \    }\n    for my $c (keys %chars) {\n        return 0 if $chars{$c};\n    }\n\
    \    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n\
    \    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return\
    \ 0 if keys %s0 != keys %s1;\n    for my $c (keys %s0) {\n        return 0 if\
    \ !$s1{$c};\n    }\n    return 1;\n}", "    my %chars;\n    for my $c (split //,\
    \ $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n    \
    \    $chars{$c}--;\n    }\n    for my $c (keys %chars) {\n        return 0 if\
    \ $chars{$c};\n    }\n    return 1;\n}", "    my @s0 = sort split //, $s0;\n \
    \   my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my\
    \ @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ =>\
    \ 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys %s0)\
    \ != scalar(keys %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my %s0 = map { $_ => 1 } split //,\
    \ $s0;\n    my %s1 = map { $_ => 1 } split //, $s1;\n    return 0 if scalar keys\
    \ %s0 != scalar keys %s1;\n    for my $k (keys %s0) {\n        return 0 if !exists\
    \ $s1{$k};\n    }\n    return 1;\n}", "    my %c0 = map { $_ => 1 } split //,\
    \ $s0;\n    my %c1 = map { $_ => 1 } split //, $s1;\n    return scalar(keys %c0)\
    \ == scalar(keys %c1) &&\n           scalar(grep { $c0{$_} } keys %c1) == scalar(keys\
    \ %c0);\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    return \"@s0\" eq \"@s1\";\n}", "    my @a0 = split //, $s0;\n    my @a1\
    \ = split //, $s1;\n    my %c0;\n    my %c1;\n    for my $c (@a0) {\n        $c0{$c}++;\n\
    \    }\n    for my $c (@a1) {\n        $c1{$c}++;\n    }\n    for my $c (keys\
    \ %c0) {\n        if (!defined $c1{$c}) {\n            return 0;\n        }\n\
    \        if ($c0{$c} != $c1{$c}) {\n            return 0;\n        }\n    }\n\
    \    for my $c (keys %c1) {\n        if (!defined $c0{$c}) {\n            return\
    \ 0;\n        }\n        if ($c1{$c} != $c0{$c}) {\n            return 0;\n  \
    \      }\n    }\n    return 1;\n}", "    my %chars;\n    $chars{$_}++ for split\
    \ //, $s0;\n    $chars{$_}-- for split //, $s1;\n    return !grep { $_ != 0 }\
    \ values %chars;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split\
    \ //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = sort split //, $s0;\n\
    \    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my\
    \ @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\"\
    \ eq \"@s1\";\n}", "    my(%h0, %h1);\n    for my $c (split //, $s0) {\n     \
    \   $h0{$c}++;\n    }\n    for my $c (split //, $s1) {\n        $h1{$c}++;\n \
    \   }\n    return 0 unless scalar(keys %h0) == scalar(keys %h1);\n    for my $c\
    \ (keys %h0) {\n        return 0 unless $h0{$c} == $h1{$c};\n    }\n    return\
    \ 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0\
    \ = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys\
    \ %s0) != scalar(keys %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my @a0 = sort split //, $s0;\n    my\
    \ @a1 = sort split //, $s1;\n    return \"@a0\" eq \"@a1\";\n}", "    my @s0 =\
    \ split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n\
    \    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys %s0) != scalar(keys\
    \ %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n  \
    \  }\n    return 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort\
    \ split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = sort split\
    \ //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n\
    }", "    my @s0 = sort(split(//, $s0));\n    my @s1 = sort(split(//, $s1));\n\
    \    return join('', @s0) eq join('', @s1);\n}", "    my %h0 = map { $_ => 1 }\
    \ split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return 0 if\
    \ keys %h0 != keys %h1;\n    for my $k (keys %h0) {\n        return 0 if !exists\
    \ $h1{$k};\n    }\n    return 1;\n}", "    my @s0 = sort split //, $s0;\n    my\
    \ @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    my @s0 =\
    \ sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq\
    \ \"@s1\";\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n  \
    \  my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return\
    \ 0 if keys %s0 != keys %s1;\n    for my $c (keys %s0) {\n        return 0 if\
    \ !exists $s1{$c};\n    }\n    return 1;\n}", "    my %h0 = map { $_ => 1 } split\
    \ //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    return scalar(keys\
    \ %h0) == scalar(keys %h1) &&\n        scalar(grep { $h0{$_} != $h1{$_} } keys\
    \ %h0) == 0;\n}", "    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 = map\
    \ { $_ => 1 } split //, $s1;\n    return 0 unless keys %h0 == keys %h1;\n    for\
    \ my $k (keys %h0) {\n        return 0 unless $h0{$k} == $h1{$k};\n    }\n   \
    \ return 1;\n}", "    my %chars;\n    for my $c (split //, $s0) {\n        $chars{$c}++;\n\
    \    }\n    for my $c (split //, $s1) {\n        $chars{$c}--;\n    }\n    for\
    \ my $c (keys %chars) {\n        return 0 if $chars{$c};\n    }\n    return 1;\n\
    }", "    my %h;\n    $h{$_}++ for split //, $s0;\n    $h{$_}-- for split //, $s1;\n\
    \    return !grep { $_ } values %h;\n}", "    my @s0 = split //, $s0;\n    my\
    \ @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map {\
    \ $_ => 1 } @s1;\n    return (scalar keys %s0 == scalar keys %s1) &&\n       \
    \    (scalar keys %s0 == scalar grep { $s0{$_} } @s1);\n}", "    return 0 if length($s0)\
    \ != length($s1);\n    my %h;\n    $h{$_}++ for split //, $s0;\n    $h{$_}-- for\
    \ split //, $s1;\n    return !grep { $_ != 0 } values %h;\n}", "    my %chars;\n\
    \    $chars{$_}++ for split //, $s0;\n    $chars{$_}-- for split //, $s1;\n  \
    \  return !grep { $_ != 0 } values %chars;\n}", "    my @s0 = split //, $s0;\n\
    \    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 =\
    \ map { $_ => 1 } @s1;\n    return 0 if @s0 != @s1;\n    for my $c (@s0) {\n \
    \       return 0 if !exists $s1{$c};\n    }\n    return 1;\n}", "    return 0\
    \ if length($s0) != length($s1);\n    my %h0 = map { $_ => 1 } split //, $s0;\n\
    \    my %h1 = map { $_ => 1 } split //, $s1;\n    return 0 if scalar(keys %h0)\
    \ != scalar(keys %h1);\n    for my $c (keys %h0) {\n        return 0 if !exists\
    \ $h1{$c};\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0;\n    my %s1;\n    for my $c (@s0) {\n        $s0{$c}++;\n\
    \    }\n    for my $c (@s1) {\n        $s1{$c}++;\n    }\n    for my $c (keys\
    \ %s0) {\n        return 0 if !exists $s1{$c};\n        return 0 if $s0{$c} !=\
    \ $s1{$c};\n    }\n    for my $c (keys %s1) {\n        return 0 if !exists $s0{$c};\n\
    \        return 0 if $s0{$c} != $s1{$c};\n    }\n    return 1;\n}", "    my @s0\
    \ = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return join('',\
    \ @s0) eq join('', @s1);\n}", "    my(%c0, %c1);\n    foreach my $c (split(//,\
    \ $s0)) {\n        $c0{$c}++;\n    }\n    foreach my $c (split(//, $s1)) {\n \
    \       $c1{$c}++;\n    }\n    return 0 if (scalar(keys %c0) != scalar(keys %c1));\n\
    \    foreach my $c (keys %c0) {\n        return 0 if (!exists $c1{$c});\n    \
    \    return 0 if ($c0{$c} != $c1{$c});\n    }\n    return 1;\n}", "    my %h0\
    \ = map { $_ => 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n\
    \    return 0 if scalar keys %h0 != scalar keys %h1;\n    for my $k (keys %h0)\
    \ {\n        return 0 if !exists $h1{$k};\n    }\n    return 1;\n}", "    my @s0\
    \ = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\"\
    \ eq \"@s1\";\n}", "    my %h;\n    $h{$_}++ for split //, $s0;\n    $h{$_}--\
    \ for split //, $s1;\n    return !grep { $_ != 0 } values %h;\n}", "    my %h0;\n\
    \    my %h1;\n    for my $c (split(//, $s0)) {\n        $h0{$c}++;\n    }\n  \
    \  for my $c (split(//, $s1)) {\n        $h1{$c}++;\n    }\n    for my $c (keys\
    \ %h0) {\n        return 0 if !defined $h1{$c};\n        return 0 if $h0{$c} !=\
    \ $h1{$c};\n    }\n    for my $c (keys %h1) {\n        return 0 if !defined $h0{$c};\n\
    \        return 0 if $h1{$c} != $h0{$c};\n    }\n    return 1;\n}", "    my @s0\
    \ = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 }\
    \ @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if (scalar keys %s0) !=\
    \ (scalar keys %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my %chars;\n    $chars{$_}++ for split(//,\
    \ $s0);\n    $chars{$_}-- for split(//, $s1);\n    return all { $_ == 0 } values\
    \ %chars;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n   \
    \ my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return\
    \ 0 unless keys %s0 == keys %s1;\n    for my $c (keys %s0) {\n        return 0\
    \ unless exists $s1{$c};\n    }\n    return 1;\n}", "    my @s0 = sort split //,\
    \ $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\" eq \"@s1\";\n}",
  "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return\
    \ \"@s0\" eq \"@s1\";\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n\
    \    return 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my $c (keys %s0)\
    \ {\n        return 0 if !exists $s1{$c};\n    }\n    return 1;\n}", "    my %c0\
    \ = count_chars($s0);\n    my %c1 = count_chars($s1);\n    return 0 if keys(%c0)\
    \ != keys(%c1);\n    for my $k (keys %c0) {\n        return 0 if $c0{$k} != $c1{$k};\n\
    \    }\n    return 1;\n}", "    my @a0 = split //, $s0;\n    my @a1 = split //,\
    \ $s1;\n    my %h0;\n    my %h1;\n    for my $c (@a0) {\n        $h0{$c}++;\n\
    \    }\n    for my $c (@a1) {\n        $h1{$c}++;\n    }\n    for my $c (keys\
    \ %h0) {\n        return 0 if !exists $h1{$c};\n        return 0 if $h0{$c} !=\
    \ $h1{$c};\n    }\n    for my $c (keys %h1) {\n        return 0 if !exists $h0{$c};\n\
    \        return 0 if $h1{$c} != $h0{$c};\n    }\n    return 1;\n}", "    my @s0\
    \ = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\"\
    \ eq \"@s1\";\n}", "    my %h0 = map { $_ => 1 } split //, $s0;\n    my %h1 =\
    \ map { $_ => 1 } split //, $s1;\n    return 0 if keys %h0 != keys %h1;\n    for\
    \ my $k (keys %h0) {\n        return 0 if !exists $h1{$k};\n    }\n    return\
    \ 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    return \"@s0\" eq \"@s1\";\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ =>\
    \ 1 } @s1;\n    return 0 if scalar(keys %s0) != scalar(keys %s1);\n    for my\
    \ $c (keys %s0) {\n        return 0 if !exists $s1{$c};\n    }\n    return 1;\n\
    }", "    return join('', sort split(//, $s0)) eq join('', sort split(//, $s1));\n\
    }", "    my %chars;\n    for my $c (split //, $s0) {\n        $chars{$c}++;\n\
    \    }\n    for my $c (split //, $s1) {\n        return 0 if !$chars{$c};\n  \
    \      $chars{$c}--;\n    }\n    return 1;\n}", "    return join('', sort(split(//,\
    \ $s0))) eq join('', sort(split(//, $s1)));\n}", "    my %c;\n    for my $c (split\
    \ //, $s0) {\n        $c{$c}++;\n    }\n    for my $c (split //, $s1) {\n    \
    \    return 0 if --$c{$c} < 0;\n    }\n    return 1;\n}", "    my @a0 = split\
    \ //, $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n    for (@a0)\
    \ {\n        $h0{$_}++;\n    }\n    for (@a1) {\n        $h1{$_}++;\n    }\n \
    \   return 0 if scalar(keys %h0) != scalar(keys %h1);\n    for (keys %h0) {\n\
    \        return 0 if $h0{$_} != $h1{$_};\n    }\n    return 1;\n}", "    my @s0\
    \ = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n    return \"@s0\"\
    \ eq \"@s1\";\n}", "    my @a0 = split //, $s0;\n    my @a1 = split //, $s1;\n\
    \    my %h0;\n    my %h1;\n    for my $c (@a0) {\n        $h0{$c}++;\n    }\n\
    \    for my $c (@a1) {\n        $h1{$c}++;\n    }\n    for my $c (keys %h0) {\n\
    \        return 0 if !defined $h1{$c};\n        return 0 if $h0{$c} != $h1{$c};\n\
    \    }\n    for my $c (keys %h1) {\n        return 0 if !defined $h0{$c};\n  \
    \      return 0 if $h1{$c} != $h0{$c};\n    }\n    return 1;\n}", "    my %h;\n\
    \    for my $c (split //, $s0) {\n        $h{$c}++;\n    }\n    for my $c (split\
    \ //, $s1) {\n        $h{$c}--;\n    }\n    for my $c (keys %h) {\n        return\
    \ 0 if $h{$c};\n    }\n    return 1;\n}", "    my %h0;\n    my %h1;\n    for my\
    \ $c (split //, $s0) {\n        $h0{$c}++;\n    }\n    for my $c (split //, $s1)\
    \ {\n        $h1{$c}++;\n    }\n    for my $c (keys %h0) {\n        return 0 if\
    \ !exists $h1{$c};\n        return 0 if $h0{$c} != $h1{$c};\n    }\n    for my\
    \ $c (keys %h1) {\n        return 0 if !exists $h0{$c};\n        return 0 if $h1{$c}\
    \ != $h0{$c};\n    }\n    return 1;\n}", "    my %chars;\n    for my $c (split\
    \ //, $s0) {\n        $chars{$c}++;\n    }\n    for my $c (split //, $s1) {\n\
    \        $chars{$c}--;\n    }\n    for my $c (keys %chars) {\n        return 0\
    \ if $chars{$c};\n    }\n    return 1;\n}", "    my @s0 = sort split //, $s0;\n\
    \    my @s1 = sort split //, $s1;\n    return join(\"\", @s0) eq join(\"\", @s1);\n\
    }", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map\
    \ { $_ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    return 0 if scalar(keys\
    \ %s0) != scalar(keys %s1);\n    for my $c (keys %s0) {\n        return 0 if !exists\
    \ $s1{$c};\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my %s1 = map { $_ =>\
    \ 1 } @s1;\n    for my $c (@s0) {\n        return 0 if !$s1{$c};\n    }\n    for\
    \ my $c (@s1) {\n        return 0 if !$s0{$c};\n    }\n    return 1;\n}", "  \
    \  my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0;\n    my %s1;\n\
    \    for my $c (@s0) {\n        $s0{$c}++;\n    }\n    for my $c (@s1) {\n   \
    \     $s1{$c}++;\n    }\n    return 0 if scalar(keys %s0) != scalar(keys %s1);\n\
    \    for my $c (keys %s0) {\n        return 0 if $s0{$c} != $s1{$c};\n    }\n\
    \    return 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split\
    \ //, $s1;\n    return \"@s0\" eq \"@s1\";\n}", "    return 0 if length($s0) !=\
    \ length($s1);\n    my %c0 = map {$_ => 1} split //, $s0;\n    my %c1 = map {$_\
    \ => 1} split //, $s1;\n    return 0 if scalar(keys %c0) != scalar(keys %c1);\n\
    \    for my $c (keys %c0) {\n        return 0 if !$c1{$c};\n    }\n    return\
    \ 1;\n}", "    my %c0 = map { $_ => 1 } split //, $s0;\n    my %c1 = map { $_\
    \ => 1 } split //, $s1;\n    return 0 if keys %c0 != keys %c1;\n    for my $c\
    \ (keys %c0) {\n        return 0 if !$c1{$c};\n    }\n    return 1;\n}", "   \
    \ my @c0 = sort split //, $s0;\n    my @c1 = sort split //, $s1;\n    return \"\
    @c0\" eq \"@c1\";\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split\
    \ //, $s1;\n    return \"@s0\" eq \"@s1\";\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
