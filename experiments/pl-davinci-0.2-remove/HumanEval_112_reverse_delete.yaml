name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    $s =~ s/[$c]//g;\n    return ($s, $s eq reverse $s);\n}", "   \
    \ my $r = '';\n    my %c = map { $_ => 1 } split //, $c;\n    for my $i (0 ..\
    \ length($s) - 1) {\n        $r .= substr($s, $i, 1) unless $c{substr($s, $i,\
    \ 1)};\n    }\n    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse\
    \ $s;\n    my %hash = map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n  \
    \  $r =~ s/[$c]//g;\n    return ($s, $s eq $r);\n}", "    my @s = split //, $s;\n\
    \    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r = grep\
    \ { !$c{$_} } @s;\n    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map {\
    \ $_ => 1 } split //, $c;\n    for my $char (split //, $s) {\n        $result\
    \ .= $char unless $c_hash{$char};\n    }\n    my $len = length $result;\n    for\
    \ my $i (0..$len/2-1) {\n        if (substr($result, $i, 1) ne substr($result,\
    \ $len-$i-1, 1)) {\n            $is_palindrome = 0;\n            last;\n     \
    \   }\n    }\n    return ($result, $is_palindrome);\n}", "    my $r = $s;\n  \
    \  $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}",
  "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse\
    \ $s;\n    my %c = map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    $r\
    \ =~ s/[$c]//g;\n    return ($s, $s eq $r);\n}", "    my $res = $s;\n    for my\
    \ $char (split //, $c) {\n        $res =~ s/$char//g;\n    }\n    return ($res,\
    \ $res eq reverse $res);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my %h = map {$_ =>\
    \ 1} split //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $i = 0;\n    while ($i < length $s) {\n        if ($c{substr\
    \ $s, $i, 1}) {\n            substr $s, $i, 1, '';\n            substr $r, $i,\
    \ 1, '';\n        } else {\n            $i++;\n        }\n    }\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s, $s eq $r);\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map {\
    \ $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    $s =~ s/[$c]//g;\n    return ($s,\
    \ $s eq reverse $s);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $result = $s;\n    for my $char (split //, $c)\
    \ {\n        $result =~ s/$char//g;\n    }\n    return ($result, $result eq reverse\
    \ $result);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my $result = $s;\n    for my $char (split //, $c) {\n\
    \        $result =~ s/$char//g;\n    }\n    return ($result, $result eq reverse\
    \ $result);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my %c = map {$_ => 1} split //, $c;\n    my $r = join\
    \ '', grep {!$c{$_}} split //, $s;\n    return ($r, $r eq reverse $r);\n}", " \
    \   my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ ($r, $p);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join\
    \ '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n\
    \    $r =~ s/[$c]//g;\n    return ($s, $s eq $r);\n}", "    my $r = $s;\n    for\
    \ my $c (split //, $c) {\n        $r =~ s/$c//g;\n    }\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n\
    \    return ($t, $t eq $r);\n}", "    my $r = reverse $s;\n    my $t = $s;\n \
    \   $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}", "    my $r = reverse $s;\n\
    \    my %c = map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n\
    \    return ($s, $s eq $r);\n}", "    my $r = join '', grep { index($c, $_) ==\
    \ -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n\
    \    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse\
    \ $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t, $t eq $r);\n}",
  "    my $res = $s;\n    $res =~ s/[$c]//g;\n    my $rev = reverse $res;\n    return\
    \ ($res, $res eq $rev);\n}", "    my $r = reverse $s;\n    my %c = map { $_ =>\
    \ 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/$c//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return\
    \ ($t, $t eq $r);\n}", "    my $r = reverse $s;\n    my %h = map { $_ => 1 } split\
    \ //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s, $s eq $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n  \
    \  return ($r, $p);\n}", "    my $s1 = $s;\n    $s1 =~ s/[$c]//g;\n    my $s2\
    \ = reverse $s1;\n    return ($s1, $s1 eq $s2);\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $r = join '',\
    \ grep { index($c, $_) == -1 } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $res = $s;\n    $res =~ s/[$c]//g;\n    return ($res, $res eq reverse\
    \ $res);\n}", "    my $res = $s;\n    $res =~ s/[$c]//g;\n    return ($res, $res\
    \ eq reverse $res);\n}", "    my $r = join '', grep { index($c, $_) == -1 } split\
    \ //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %hash = map {$_ =>\
    \ 1} split //, $c;\n    my $new_s = join '', grep {!$hash{$_}} split //, $s;\n\
    \    my $rev_s = reverse $new_s;\n    return ($new_s, $new_s eq $rev_s);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ ($r, $p);\n}", "    my $r = reverse $s;\n    my %h;\n    for my $c (split //,\
    \ $c) {\n        $h{$c} = 1;\n    }\n    for my $c (split //, $s) {\n        if\
    \ ($h{$c}) {\n            $s =~ s/$c//g;\n            $r =~ s/$c//g;\n       \
    \ }\n    }\n    return ($s, $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my $p =\
    \ $s eq $r;\n    my $d = $s;\n    $d =~ s/[$c]//g;\n    return ($d, $p);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $result = $s;\n    for my $c_char (split //, $c) {\n        $result =~ s/$c_char//g;\n\
    \    }\n    return ($result, $result eq reverse $result);\n}", "    my %c = map\
    \ { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my @s = split //, $s;\n    my @c\
    \ = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r = grep { !$c{$_}\
    \ } @s;\n    my $r = join '', @r;\n    return ($r, $r eq reverse $r);\n}", " \
    \   my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ ($r, $p);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $i = 0;\n    my $j = 0;\n    while ($i < length $s && $j < length\
    \ $r) {\n        if ($c{substr($s, $i, 1)}) {\n            $i++;\n        } elsif\
    \ ($c{substr($r, $j, 1)}) {\n            $j++;\n        } else {\n           \
    \ if (substr($s, $i, 1) ne substr($r, $j, 1)) {\n                return (substr($s,\
    \ $i), 0);\n            }\n            $i++;\n            $j++;\n        }\n \
    \   }\n    return (substr($s, $i), 1);\n}", "    my $s_copy = $s;\n    my $c_copy\
    \ = $c;\n    $s_copy =~ s/[$c_copy]//g;\n    my $s_copy_reverse = reverse $s_copy;\n\
    \    my $result = ($s_copy eq $s_copy_reverse) ? 1 : 0;\n    return ($s_copy,\
    \ $result);\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    return\
    \ ($result, $result eq reverse $result);\n}", "    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $s_copy = $s;\n    $s_copy =~ s/[$c]//g;\n \
    \   my $s_copy_reverse = reverse $s_copy;\n    return ($s_copy, $s_copy eq $s_copy_reverse);\n\
    }", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my\
    \ $s1 = join '', grep { !$c{$_} } split //, $s;\n    my $r1 = join '', grep {\
    \ !$c{$_} } split //, $r;\n    return ($s1, $s1 eq $r1);\n}", "    my %c = map\
    \ { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { not $c{$_} } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse\
    \ $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i = 0;\n    while ($i\
    \ < length $s) {\n        if ($c{substr $s, $i, 1}) {\n            substr $s,\
    \ $i, 1, '';\n            substr $r, $i, 1, '';\n        } else {\n          \
    \  $i++;\n        }\n    }\n    return ($s, $s eq $r);\n}", "    my $r = reverse\
    \ $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my @s = split //, $s;\n\
    \    my @r = split //, $r;\n    my @t;\n    for my $i (0 .. $#s) {\n        if\
    \ (!$c{$s[$i]}) {\n            push @t, $s[$i];\n        }\n        if (!$c{$r[$i]})\
    \ {\n            push @t, $r[$i];\n        }\n    }\n    my $t = join '', @t;\n\
    \    return ($t, $t eq reverse $t);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $s_copy = $s;\n    $s_copy =~\
    \ s/[$c]//g;\n    my $s_copy_reverse = reverse $s_copy;\n    return ($s_copy,\
    \ $s_copy eq $s_copy_reverse);\n}", "    my %hash = map { $_ => 1 } split //,\
    \ $c;\n    my $res = join '', grep { !$hash{$_} } split //, $s;\n    return ($res,\
    \ $res eq reverse $res);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $res = $s;\n    $res =~ s/[$c]//g;\n  \
    \  my $rev = reverse $res;\n    return ($res, $res eq $rev);\n}", "    my $res\
    \ = $s;\n    $res =~ s/[$c]//g;\n    return ($res, $res eq reverse $res);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ ($r, $p);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join\
    \ '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    my @r;\n    for my $i\
    \ (@s) {\n        push @r, $i unless grep {$i eq $_} @c;\n    }\n    my $r = join\
    \ '', @r;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my $r\
    \ = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my\
    \ $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n    my $i = 0;\n\
    \    my $j = 0;\n    while ($i < length $s && $j < length $r) {\n        if ($c{substr($s,\
    \ $i, 1)}) {\n            $i++;\n        } elsif ($c{substr($r, $j, 1)}) {\n \
    \           $j++;\n        } else {\n            if (substr($s, $i, 1) ne substr($r,\
    \ $j, 1)) {\n                return (substr($s, $i), 0);\n            }\n    \
    \        $i++;\n            $j++;\n        }\n    }\n    return (substr($s, $i),\
    \ 1);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n\
    \    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s, $s eq $r);\n}", " \
    \   my $r = reverse($s);\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return ($t,\
    \ $t eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse\
    \ $r;\n    return ($r, $p);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my\
    \ $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my $r = $s;\n    $r =~\
    \ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my\
    \ $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "  \
    \  my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = reverse $s;\n    my $r_c = reverse $c;\n    my $r_s = $s;\n    $r_s\
    \ =~ s/[$c]//g;\n    my $r_r_s = reverse $r_s;\n    return ($r_s, $r_r_s eq $r_s);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $res = $s;\n    my %c = map {$_ => 1} split //, $c;\n    $res =~ s/[$c]//g;\n\
    \    return ($res, $res eq reverse $res);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my $r = $s;\n \
    \   $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n\
    \    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $r = reverse\
    \ $s;\n    my %c = map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    $r\
    \ =~ s/[$c]//g;\n    return ($s, $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r\
    \ eq reverse $r;\n    return ($r, $p);\n}", "    my $result = $s;\n    $result\
    \ =~ s/[$c]//g;\n    return ($result, $result eq reverse $result);\n}", "    my\
    \ $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "  \
    \  my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ ($r, $p);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join\
    \ '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n}",
  "    my %c = map {$_ => 1} split //, $c;\n    my $r = join '', grep {!$c{$_}} split\
    \ //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1\
    \ } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my %c = map {$_ =>\
    \ 1} split //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my $s_copy = $s;\n    $s_copy =~ s/[$c]//g;\n    my $s_copy_reverse\
    \ = reverse $s_copy;\n    return ($s_copy, $s_copy eq $s_copy_reverse);\n}", " \
    \   my $s_copy = $s;\n    $s_copy =~ s/[$c]//g;\n    my $s_copy_reverse = reverse\
    \ $s_copy;\n    return ($s_copy, $s_copy eq $s_copy_reverse);\n}", "    my $r\
    \ = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r,\
    \ $p);\n}", "    my $r = reverse $s;\n    my %h = map { $_ => 1 } split //, $c;\n\
    \    for my $i (0 .. length($s) - 1) {\n        substr($s, $i, 1, '') if $h{substr($s,\
    \ $i, 1)};\n        substr($r, $i, 1, '') if $h{substr($r, $i, 1)};\n    }\n \
    \   return ($s, $s eq $r);\n}", "    my @s = split //, $s;\n    my @c = split\
    \ //, $c;\n    my %c = map { $_ => 1 } @c;\n    @s = grep { !$c{$_} } @s;\n  \
    \  my $s = join '', @s;\n    return ($s, $s eq reverse $s);\n}", "    my $r =\
    \ $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my %c\
    \ = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split\
    \ //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1\
    \ } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my\
    \ $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my $r = $s;\n    $r =~\
    \ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $res = '';\n   \
    \ my %c = map { $_ => 1 } split //, $c;\n    for my $ch (split //, $s) {\n   \
    \     $res .= $ch unless $c{$ch};\n    }\n    return (reverse($res) eq $res, $res);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = reverse $s;\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n  \
    \  return ($s, $p);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = reverse $s;\n    my %h = map { $_ => 1 } split //, $c;\n    $s\
    \ =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n    return ($s, $s eq $r);\n}", "    my\
    \ %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { not $c{$_} }\
    \ split //, $s;\n    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n  \
    \  $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my $t = $s;\n\
    \    $t =~ s/[$c]//g;\n    return ($t, $t eq reverse $t);\n}", "    my $res =\
    \ $s;\n    $res =~ s/[$c]//g;\n    my $rev = reverse $res;\n    return ($res,\
    \ $res eq $rev);\n}", "    my $s_copy = $s;\n    $s_copy =~ s/[$c]//g;\n    return\
    \ ($s_copy, $s_copy eq reverse $s_copy);\n}", "    my $r = reverse $s;\n    my\
    \ %c = map { $_ => 1 } split //, $c;\n    my $i = 0;\n    while ($i < length $s)\
    \ {\n        if ($c{substr $s, $i, 1}) {\n            substr $s, $i, 1, '';\n\
    \            substr $r, $i, 1, '';\n        } else {\n            $i++;\n    \
    \    }\n    }\n    return ($s, $s eq $r);\n}", "    my %chars = map { $_ => 1\
    \ } split //, $c;\n    my $s_rev = reverse $s;\n    my $s_rev_filtered = join\
    \ '', grep { !$chars{$_} } split //, $s_rev;\n    my $s_filtered = join '', grep\
    \ { !$chars{$_} } split //, $s;\n    return ($s_rev_filtered, $s_rev_filtered\
    \ eq $s_filtered);\n}", "    my $r = reverse $s;\n    $s =~ s/[$c]//g;\n    return\
    \ ($s, $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r\
    \ eq reverse $r;\n    return ($r, $p);\n}", "    my @s = split //, $s;\n    my\
    \ @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r = grep { !$c{$_}\
    \ } @s;\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return ($r,\
    \ $p);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse\
    \ $r);\n}", "    my $r = reverse $s;\n    my %c = map { $_ => 1 } split //, $c;\n\
    \    my $i = 0;\n    my $j = 0;\n    while ($i < length $s && $j < length $r)\
    \ {\n        if ($c{substr($s, $i, 1)}) {\n            $i++;\n        } elsif\
    \ ($c{substr($r, $j, 1)}) {\n            $j++;\n        } else {\n           \
    \ if (substr($s, $i, 1) ne substr($r, $j, 1)) {\n                return (substr($s,\
    \ $i), 0);\n            }\n            $i++;\n            $j++;\n        }\n \
    \   }\n    return (substr($s, $i), 1);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my %c =\
    \ map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n\
    \    return ($s, $s eq $r);\n}", "    my $r = join '', reverse split //, $s;\n\
    \    my $t = join '', reverse split //, $c;\n    return ($r, $r eq $s);\n}", " \
    \   my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}",
  "    my $s1 = $s;\n    $s1 =~ s/[$c]//g;\n    my $s2 = reverse $s1;\n    return\
    \ ($s1, $s1 eq $s2);\n}", "    my %c = map { $_ => 1 } split //, $c;\n    $s =~\
    \ s/[$c]//g;\n    return ($s, $s eq reverse $s);\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n}", "    my %c = map {$_\
    \ => 1} split //, $c;\n    my $s_ = join '', grep {!$c{$_}} split //, $s;\n  \
    \  my $r = reverse $s_;\n    return ($s_, $s_ eq $r);\n}", "    my %c = map {\
    \ $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    my $p = $r eq\
    \ reverse $r;\n    return ($r, $p);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %hash = map { $_ => 1 } split\
    \ //, $c;\n    my $result = join '', grep { !$hash{$_} } split //, $s;\n    return\
    \ ($result, $result eq reverse $result);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my %c =\
    \ map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    $r =~ s/[$c]//g;\n\
    \    return ($s, $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my $r = '';\n    my $p = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split '', $c;\n    for my $ch (split\
    \ '', $s) {\n        if (!exists $c_hash{$ch}) {\n            $r .= $ch;\n   \
    \         $p = $ch . $p;\n        }\n    }\n    $is_palindrome = 0 if $r ne $p;\n\
    \    return ($r, $is_palindrome);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return ($r, $r eq reverse $r);\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    return\
    \ ($result, $result eq reverse $result);\n}", "    my %c = map { $_ => 1 } split\
    \ //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r,\
    \ $r eq reverse $r);\n}", "    my $r = reverse $s;\n    my %h = map { $_ => 1\
    \ } split //, $c;\n    my $i = 0;\n    my $j = 0;\n    while ($i < length $s)\
    \ {\n        if (exists $h{substr $s, $i, 1}) {\n            $i++;\n         \
    \   $j++;\n        }\n        else {\n            substr $s, $i, 1, substr $r,\
    \ $j, 1;\n            $i++;\n            $j++;\n        }\n    }\n    return ($s,\
    \ $s eq $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq\
    \ reverse $r);\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r\
    \ eq reverse $r);\n}", "    my $s_copy = $s;\n    $s_copy =~ s/[$c]//g;\n    my\
    \ $s_copy_reverse = reverse $s_copy;\n    return ($s_copy, $s_copy eq $s_copy_reverse);\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return ($r, $r eq reverse $r);\n\
    }", "    my $r = reverse($s);\n    my $p = $s eq $r;\n    $s =~ s/[$c]//g;\n \
    \   return ($s, $p);\n}", "    my $t = join '', grep { index($c, $_) == -1 } split\
    \ //, $s;\n    return ($t, $t eq reverse $t);\n}", "    my %c = map { $_ => 1\
    \ } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return\
    \ ($r, $r eq reverse $r);\n}", "    my @s = split //, $s;\n    my @c = split //,\
    \ $c;\n    my %c = map { $_ => 1 } @c;\n    my @r = grep { !$c{$_} } @s;\n   \
    \ my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
