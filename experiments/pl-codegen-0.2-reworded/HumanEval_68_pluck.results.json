{
  "name": "HumanEval_68_pluck",
  "language": "pl",
  "prompt": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "results": [
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    my($min_index_value_index_value) = -1;\n    my($min_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp074nauve.pl line 48, at end of line\nsyntax error at /tmp/tmp074nauve.pl line 48, near \"$min_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp074nauve.pl line 87, at end of line\nsyntax error at /tmp/tmp074nauve.pl line 87, at EOF\nExecution of /tmp/tmp074nauve.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $index];\n            $index += 1;\n            continue;\n        }\n        if ($node % 2 == 0) {\n            $smallest_even_value = $node;\n            $smallest_index = $index;\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    my $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "ok!ok!ok!",
      "stderr": "Can't \"continue\" outside a when block at /tmp/tmpn7luraya.pl line 35.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpyh82xfof.pl line 70, at end of line\nsyntax error at /tmp/tmpyh82xfof.pl line 70, at EOF\nExecution of /tmp/tmpyh82xfof.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_index) = 0;\n    my($smallest_index_index_index_value) = 0;\n    my($smallest_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpswzfu_38.pl line 51, at end of line\nsyntax error at /tmp/tmpswzfu_38.pl line 51, near \"$smallest_index_index_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpswzfu_38.pl line 90, at end of line\nsyntax error at /tmp/tmpswzfu_38.pl line 90, at EOF\nExecution of /tmp/tmpswzfu_38.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [ $smallest_even_value, $smallest_index ];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_value, $min_index) = 0;\n    my($index, $value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            if ($min_value == 0) {\n                $min_index = $index;\n                $min_value = $node;\n            } else if ($node < $min_value) {\n                $min_index = $index;\n                $min_value = $node;\n            }\n        }\n        $index += 1;\n    }\n    return [$min_value, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpqjtk91xb.pl line 39, near \"else if\"\nsyntax error at /tmp/tmpqjtk91xb.pl line 47, near \"}\"\nExecution of /tmp/tmpqjtk91xb.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmptmfrpjo4.pl line 70, at end of line\nsyntax error at /tmp/tmptmfrpjo4.pl line 70, at EOF\nExecution of /tmp/tmptmfrpjo4.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpej3b2_nk.pl line 48, at end of line\nsyntax error at /tmp/tmpej3b2_nk.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpej3b2_nk.pl line 87, at end of line\nsyntax error at /tmp/tmpej3b2_nk.pl line 87, at EOF\nExecution of /tmp/tmpej3b2_nk.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            $result = [ $node, $min_index ];\n            $min_even_value = $node;\n            $min_even_index = $min_index;\n            $min_index = $node;\n        } else if ($even_value < $min_even_value) {\n            $result = [ $node, $min_index ];\n            $min_even_value = $node;\n            $min_even_index = $min_index;\n            $min_index = $node;\n        } else if ($even_value == $min_even_value) {\n            if ($node < $min_index) {\n                $result = [ $node, $min_index ];\n                $min_even_value = $node;\n                $min_even_index = $min_index;\n                $min_index = $node;\n            } else if ($node == $min_index) {\n                $result = [ $node, $min_index ];\n            }\n        }\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpeqtybcc5.pl line 41, near \"else if\"\nsyntax error at /tmp/tmpeqtybcc5.pl line 46, near \"} else\"\nsyntax error at /tmp/tmpeqtybcc5.pl line 52, near \"} else\"\nExecution of /tmp/tmpeqtybcc5.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_even_index) = 0;\n    my($smallest_index, $smallest_value) = 0;\n    my($index, $value) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        $value = $node;\n        $index = $arr.index($node);\n        if ($value % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $value;\n                $smallest_even_index = $index;\n            } else if ($value < $smallest_even_value) {\n                $smallest_even_value = $value;\n                $smallest_even_index = $index;\n            }\n        }\n        if ($value < $smallest_value) {\n            $smallest_value = $value;\n            $smallest_index = $index;\n        }\n    }\n    if ($smallest_even_value == 0) {\n        $result = [$smallest_even_index, $smallest_even_value];\n    } else {\n        $result = [$smallest_index, $smallest_value];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Not enough arguments for index at /tmp/tmp23f5t2yc.pl line 34, near \"$node)\"\nsyntax error at /tmp/tmp23f5t2yc.pl line 39, near \"else if\"\nsyntax error at /tmp/tmp23f5t2yc.pl line 55, near \"}\"\nExecution of /tmp/tmp23f5t2yc.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_index) = 0;\n    my($smallest_index_index_index_value) = 0;\n    my($smallest_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpswzfu_38.pl line 51, at end of line\nsyntax error at /tmp/tmpswzfu_38.pl line 51, near \"$smallest_index_index_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpswzfu_38.pl line 90, at end of line\nsyntax error at /tmp/tmpswzfu_38.pl line 90, at EOF\nExecution of /tmp/tmpswzfu_38.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        } else if ($even_value < $min_even_value) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        }\n        if ($node < $min_value) {\n            $min_value = $node;\n            $min_index = $node;\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpp6zsoqlx.pl line 38, near \"else if\"\nsyntax error at /tmp/tmpp6zsoqlx.pl line 48, near \"}\"\nExecution of /tmp/tmpp6zsoqlx.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        } else if ($min_even_value == 0) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        } else if ($even_value < $min_even_value) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        } else if ($even_value == $min_even_value) {\n            if ($node < $min_even_index) {\n                $min_even_index = $node;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_index, $min_even_index];\n    } else {\n        return [$min_even_value, $min_even_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpfk5wny0w.pl line 38, near \"else if\"\nsyntax error at /tmp/tmpfk5wny0w.pl line 41, near \"} else\"\nsyntax error at /tmp/tmpfk5wny0w.pl line 44, near \"} else\"\nExecution of /tmp/tmpfk5wny0w.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_even_value, $index) = 0;\n    my($smalest_even_value_index) = 0;\n    my($smalest_index) = 0;\n    my($smalest_index_index) = 0;\n    my($smalest_index_value) = 0;\n    my($smalest_index_value_index) = 0;\n    my($smalest_index_value_index_index) = 0;\n    my($smalest_index_value_index_value) = 0;\n    my($smalest_index_value_index_value_index) = 0;\n    my($smalest_index_value_index_value_index_index) = 0;\n    my($smalest_index_value_index_value_index_value) = 0;\n    my($smalest_index_value_index_value_index_value_index) = 0;\n    my($smalest_index_value_index_value_index_value_index_index) = 0;\n    my($smalest_index_value_index_value_index_value_index_value) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index_index) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index_value_index_index) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smalest_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "No such class use at /tmp/tmp2bu8kt_b.pl line 50, near \"my\nuse\"\nsyntax error at /tmp/tmp2bu8kt_b.pl line 50, near \"my\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp2bu8kt_b.pl line 89, at end of line\nsyntax error at /tmp/tmp2bu8kt_b.pl line 89, at EOF\nExecution of /tmp/tmp2bu8kt_b.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        my $even = $node % 2;\n        if ($even == 0) {\n            if ($min_even == 0) {\n                $min_index_value = $node;\n                $min_index_index = $node;\n            }\n            if ($node < $min_even) {\n                $min_even = $node;\n                $min_index_value = $node;\n                $min_index_index = $node;\n            }\n            if ($node < $min_value) {\n                $min_value = $node;\n                $min_index_value = $node;\n                $min_index_index = $node;\n            }\n        }\n    }\n    return [$min_index_value, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_index) = -1;\n    my($min_index_index_index_value) = -1;\n    my($min_index_index_index_index) = -1;\n    my($min_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpdb6m_xi3.pl line 52, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 52, near \"$min_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpdb6m_xi3.pl line 91, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 91, at EOF\nExecution of /tmp/tmpdb6m_xi3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value < $min_even_value) {\n            $min_even_value = $even_value;\n            $min_even_index = $node;\n        }\n        if ($node < $min_value) {\n            $min_index = $node;\n            $min_value = $node;\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $smallest_index];\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value < $smallest_even_value) {\n            $smallest_even_value = $even_value;\n            $smallest_index = $node;\n        }\n    }\n    $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_even_index) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0 && $min_even == 0) {\n            $min_even_index = $node;\n            $min_even = $node;\n        } else if ($even == 0 && $min_even != 0) {\n            $min_even = $node;\n            $min_even_index = $node;\n        } else if ($even != 0 && $min_even == 0) {\n            $min_even = $node;\n            $min_even_index = $node;\n        } else if ($even != 0 && $min_even != 0) {\n            if ($node < $min_even) {\n                $min_even = $node;\n                $min_even_index = $node;\n            } else if ($node == $min_even) {\n                if ($node < $min_index) {\n                    $min_even = $node;\n                    $min_even_index = $node;\n                } else if ($node < $min_index_index) {\n                    $min_even = $node;\n                    $min_even_index = $node;\n                }\n            }\n        }\n    }\n    if ($min_even_index == 0) {\n        return [0, 0];\n    } else {\n        return [$min_even, $min_even_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpt36sz7ms.pl line 39, near \"else if\"\nsyntax error at /tmp/tmpt36sz7ms.pl line 42, near \"} else\"\nsyntax error at /tmp/tmpt36sz7ms.pl line 45, near \"} else\"\nsyntax error at /tmp/tmpt36sz7ms.pl line 49, near \"}\"\nsyntax error at /tmp/tmpt36sz7ms.pl line 53, near \"}\"\nsyntax error at /tmp/tmpt36sz7ms.pl line 56, near \"}\"\nExecution of /tmp/tmpt36sz7ms.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index) = 0;\n    my($small\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpghiiye06.pl line 71, at end of line\nsyntax error at /tmp/tmpghiiye06.pl line 71, near \"$small\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpghiiye06.pl line 110, at end of line\nsyntax error at /tmp/tmpghiiye06.pl line 110, at EOF\nExecution of /tmp/tmpghiiye06.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            if ($min_even == 0) {\n                $min_even = $node;\n                $min_index = $node;\n            } else {\n                $min_index_value = $node;\n                $min_index_value_index = $node;\n            }\n        } else {\n            if ($min_even == 0) {\n                $min_index_value_index = $node;\n                $min_index_value_index_index = $node;\n            } else {\n                $min_index_value = $node;\n                $min_index_value_index = $node;\n            }\n        }\n    }\n    if ($min_even == 0) {\n        return [$min_index, $min_index_value];\n    } else {\n        return [$min_index_value_index, $min_index_value_index_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else if ($min_value == 0) {\n            $min_value = $node;\n            $min_index = $node;\n        } else if ($node < $min_value) {\n            $min_value = $node;\n            $min_index = $node;\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_value, $min_index];\n    } else {\n        return [$min_even_value, $min_even_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpb9loe9zy.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpb9loe9zy.pl line 39, near \"} else\"\nsyntax error at /tmp/tmpb9loe9zy.pl line 42, near \"} else\"\nsyntax error at /tmp/tmpb9loe9zy.pl line 45, near \"}\"\nExecution of /tmp/tmpb9loe9zy.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        my $value = $node;\n        if ($value % 2 == 0) {\n            if ($value < $smallest_even_value) {\n                $smallest_even_value = $value;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value) {\n        $result = [ $smallest_even_value, $smallest_index ];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        $result = [$smallest_index, $smallest_index];\n    } else {\n        $result = [$smallest_even_value, $smallest_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            if ($min_even == -1 || $min_even > $even) {\n                $min_even = $even;\n                $min_index = $node;\n            }\n        } else if ($min_even == -1) {\n            $min_even = $even;\n            $min_index = $node;\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    return [$min_even, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpnfidwosl.pl line 41, near \"else if\"\nsyntax error at /tmp/tmpnfidwosl.pl line 50, near \"}\"\nExecution of /tmp/tmpnfidwosl.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $index = $index + 1;\n            continue;\n        }\n        if ($node < $smallest_value) {\n            $smallest_value = $node;\n            $smallest_index = $index;\n        }\n        $index = $index + 1;\n    }\n    return [$smallest_value, $smallest_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($index, $value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    my($min_index_odd, $min_value_odd) = 0;\n    my($min_index_even_odd, $min_value_even_odd) = 0;\n    my($min_index_even_odd_index, $min_value_even_odd_index) = 0;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmp1p6tx5l2.pl line 74, at end of line\nsyntax error at /tmp/tmp1p6tx5l2.pl line 74, at EOF\nExecution of /tmp/tmp1p6tx5l2.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_value, $smallest_index_index) = 0;\n    my($smallest_index_value_index, $smallest_index_index_index) = 0;\n    my($smallest_index_value_index_index) = 0;\n    my($smallest_index_value_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp_0j9yrjb.pl line 46, at end of line\nsyntax error at /tmp/tmp_0j9yrjb.pl line 46, near \"$smallest_index_value_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp_0j9yrjb.pl line 85, at end of line\nsyntax error at /tmp/tmp_0j9yrjb.pl line 85, at EOF\nExecution of /tmp/tmp_0j9yrjb.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    my($min_index_value_index_index) = -1;\n    my($min_index_value_index_index_index) = -1;\n    my($min_index_value_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpkiqjnc_k.pl line 48, at end of line\nsyntax error at /tmp/tmpkiqjnc_k.pl line 48, near \"$min_index_value_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpkiqjnc_k.pl line 87, at end of line\nsyntax error at /tmp/tmpkiqjnc_k.pl line 87, at EOF\nExecution of /tmp/tmpkiqjnc_k.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value < $min_even_value) {\n            $min_even_value = $even_value;\n            $min_even_index = $node;\n        }\n        if ($even_value == $min_even_value) {\n            if ($node < $min_index) {\n                $min_index = $node;\n            }\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            } else if ($node == $smallest_even_value) {\n                if ($node < $smallest_index) {\n                    $smallest_index = $node;\n                }\n            }\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return;\n    }\n    $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpfzu37329.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpfzu37329.pl line 38, near \"else if\"\nsyntax error at /tmp/tmpfzu37329.pl line 43, near \"}\"\nsyntax error at /tmp/tmpfzu37329.pl line 50, near \"}\"\nExecution of /tmp/tmpfzu37329.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_even_index, $min_index_index) = 0;\n    my($index) = 0;\n    my($even_value) = 0;\n    my($even_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            $even_value = $node;\n            $even_index = $index;\n        }\n        $index += 1;\n        if ($node < $min_even) {\n            $min_even = $node;\n            $min_even_index = $index;\n        }\n        if ($node < $min_even_index) {\n            $min_even_index = $index;\n        }\n    }\n    if ($min_even_index == 0) {\n        return [$min_even, $min_even_index];\n    }\n    return [$min_even, $min_even_index, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$smalest_value, $index];\n            continue;\n        }\n        if ($node % 2 == 0) {\n            $smalest_value = $node;\n            $index = $node;\n        }\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        $result = [$smallest_index, $smallest_even_value];\n    } else {\n        $result = [$smallest_even_value, $smallest_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    my($min_index_value_index_value) = -1;\n    my($min_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp074nauve.pl line 48, at end of line\nsyntax error at /tmp/tmp074nauve.pl line 48, near \"$min_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp074nauve.pl line 87, at end of line\nsyntax error at /tmp/tmp074nauve.pl line 87, at EOF\nExecution of /tmp/tmp074nauve.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_even_value, $index) = 0;\n    my($smallest_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $index = 0;\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value < $smalest_even_value) {\n            $smalest_even_value = $even_value;\n            $index = $node;\n        }\n        if ($node < $smallest_index) {\n            $smallest_index = $node;\n        }\n    }\n    return [ $smalest_even_value, $index ];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($plucked_node) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpo698mxdc.pl line 70, at end of line\nsyntax error at /tmp/tmpo698mxdc.pl line 70, at EOF\nExecution of /tmp/tmpo698mxdc.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    my($min_index_odd, $min_value_odd) = 0;\n    my($min_index_even_odd, $min_value_even_odd) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            } else if ($min_even_value > $node) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else if ($min_even_value == 0) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        } else if ($min_even_value > $node) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        }\n        my $odd_value = $node % 2;\n        if ($odd_value == 0) {\n            if ($min_index_even_odd == 0) {\n                $min_index_even_odd = $node;\n                $min_value_even_odd = $node;\n            } else if ($min_index_even_odd > $node) {\n                $min_index_even_odd = $node;\n                $min_value_even_odd = $node;\n            }\n        } else if ($min_index_even_odd == 0) {\n            $min_index_even_odd = $node;\n            $min_value_even_odd = $node;\n        } else if ($min_index_even_odd > $node) {\n            $min_index_even_odd = $node;\n            $min_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpix82msx5.pl line 42, near \"else if\"\nsyntax error at /tmp/tmpix82msx5.pl line 46, near \"} else\"\nsyntax error at /tmp/tmpix82msx5.pl line 49, near \"} else\"\nsyntax error at /tmp/tmpix82msx5.pl line 52, near \"}\"\nsyntax error at /tmp/tmpix82msx5.pl line 58, near \"else if\"\nsyntax error at /tmp/tmpix82msx5.pl line 62, near \"}\"\nsyntax error at /tmp/tmpix82msx5.pl line 65, near \"}\"\n\"use\" not allowed in expression at /tmp/tmpix82msx5.pl line 68, at end of line\nsyntax error at /tmp/tmpix82msx5.pl line 68, near \"$min_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpix82msx5.pl line 107, at end of line\n/tmp/tmpix82msx5.pl has too many errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_value_index) = 0;\n    my($min_index_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Bareword found where operator expected at /tmp/tmpcea8addx.pl line 50, near \"$\nuse Test::Deep\"\n\t(Missing operator before Test::Deep?)\nsyntax error at /tmp/tmpcea8addx.pl line 50, near \"$\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpcea8addx.pl line 89, at end of line\nsyntax error at /tmp/tmpcea8addx.pl line 89, at EOF\nExecution of /tmp/tmpcea8addx.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_for_even_value) = 0;\n    my($smallest_index_for_odd_value) = 0;\n    my($smallest_index_for_zero) = 0;\n    my($smallest_index_for_nonzero) = 0;\n    my($smallest_index_for_odd_value_for_zero) = 0;\n    my($smallest_index_for_odd_value_for_nonzero) = 0;\n    my($smallest_index_for_nonzero_for_zero) = 0;\n    my($smallest_index_for_nonzero_for_odd_value) = 0;\n    my($smallest_index_for_zero_for_odd_value) = 0;\n    my($smallest_index_for_nonzero_for_odd_value) = 0;\n    my($smallest_index_for_odd_value_for_nonzero) = 0;\n    my($smallest_index_for_odd_value_for_zero) = 0;\n    my($smallest_index_for_zero_for_odd_value) = 0;\n    my($smallest_index_for_nonzero_for_odd_value) = 0;\n    my($smallest_index_for_odd_value_for_nonzero) = 0;\n    my($smallest_index_for_odd_value_for_zero) = 0;\n    my($smallest_index_for_zero_for_odd_value) = 0;\n    my($smallest_index_for_nonzero_for_odd_value) = 0;\n    my($smallest_index_for_odd_value_for_nonzero) = 0;\n    my($smallest_index_for_odd_value_for_zero) = 0;\n    my($smallest_index_for_zero_for_odd_value) = 0;\n    my($smallest_index_for_nonzero_for_odd_value) = 0;\n    my($smallest_index_for_odd_value_for_nonzero)\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpv9n5auqi.pl line 52, at end of line\nsyntax error at /tmp/tmpv9n5auqi.pl line 52, near \")\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpv9n5auqi.pl line 91, at end of line\nsyntax error at /tmp/tmpv9n5auqi.pl line 91, at EOF\nExecution of /tmp/tmpv9n5auqi.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_index) = 0;\n    my($min_even_value_index) = 0;\n    my($min_index_index) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_value_index) = 0;\n    my($min_index_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpbyve6ln8.pl line 48, at end of line\nsyntax error at /tmp/tmpbyve6ln8.pl line 48, near \"$min_index_index_value_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpbyve6ln8.pl line 87, at end of line\nsyntax error at /tmp/tmpbyve6ln8.pl line 87, at EOF\nExecution of /tmp/tmpbyve6ln8.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_index) = 0;\n    my($min_even_value_index) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_value_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_value_index = $node;\n            }\n        }\n        if ($min_index == 0) {\n            $min_index = $node;\n            $min_index_index = $node;\n        } else if ($node < $min_index) {\n            $min_index = $node;\n            $min_index_index = $node;\n        }\n    }\n    return [$min_even_value, $min_even_value_index, $min_index, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpyte8xh2d.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpyte8xh2d.pl line 44, near \"else if\"\nsyntax error at /tmp/tmpyte8xh2d.pl line 48, near \"}\"\nExecution of /tmp/tmpyte8xh2d.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpej3b2_nk.pl line 48, at end of line\nsyntax error at /tmp/tmpej3b2_nk.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpej3b2_nk.pl line 87, at end of line\nsyntax error at /tmp/tmpej3b2_nk.pl line 87, at EOF\nExecution of /tmp/tmpej3b2_nk.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == -1 || $node < $min_even) {\n                $min_even = $node;\n                $min_index = $node;\n            }\n        } else {\n            if ($min_value == -1 || $node < $min_value) {\n                $min_value = $node;\n                $min_index_value = $node;\n                $min_index_index = $node;\n            }\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    if ($min_index_value == -1) {\n        return [$min_value, $min_index];\n    }\n    if ($min_index_index == -1) {\n        return [$min_value, $min_index_value];\n    }\n    return [$min_value, $min_index, $min_index_value, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == -1 || $min_even > $node) {\n                $min_even = $node;\n            }\n        }\n        if ($min_index == -1 || $min_index > $node) {\n            $min_index = $node;\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    if ($min_index == -1) {\n        return [ $min_even, $min_index ];\n    }\n    if ($min_even == $min_index) {\n        return [ $min_even, $min_index ];\n    }\n    if ($min_even > $min_index) {\n        return [ $min_index, $min_index ];\n    }\n    return [ $min_even, $min_index ];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmphc26fglu.pl line 69, at end of line\nsyntax error at /tmp/tmphc26fglu.pl line 69, at EOF\nExecution of /tmp/tmphc26fglu.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_even_value_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_even_value_index = $node;\n            }\n        }\n        if ($node < $smallest_index) {\n            $smallest_index = $node;\n            $smallest_index_index = $node;\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return [$smallest_index, $smallest_index_index];\n    } else {\n        return [$smallest_even_value, $smallest_even_value_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp_34xbpen.pl line 36, near \"else if\"\nsyntax error at /tmp/tmp_34xbpen.pl line 51, near \"}\"\nExecution of /tmp/tmp_34xbpen.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_even_value, $index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            $index = $node;\n            $smalest_even_value = $node;\n            $smallest_index = $node;\n            $smallest_value = $node;\n        } else if ($smalest_even_value == 0) {\n            $index = $node;\n            $smalest_even_value = $node;\n            $smallest_index = $node;\n            $smallest_value = $node;\n        } else if ($smalest_even_value < $node) {\n            $index = $node;\n            $smalest_even_value = $node;\n            $smallest_index = $node;\n            $smallest_value = $node;\n        }\n    }\n    return [$smalest_even_value, $smallest_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpr58sx002.pl line 41, near \"else if\"\nsyntax error at /tmp/tmpr58sx002.pl line 46, near \"} else\"\nsyntax error at /tmp/tmpr58sx002.pl line 52, near \"}\"\nExecution of /tmp/tmpr58sx002.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index) = 0;\n    my($min\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpc20pd_kr.pl line 75, at end of line\nsyntax error at /tmp/tmpc20pd_kr.pl line 75, near \"$min\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpc20pd_kr.pl line 114, at end of line\nsyntax error at /tmp/tmpc20pd_kr.pl line 114, at EOF\nExecution of /tmp/tmpc20pd_kr.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_even_index, $min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == 0 || $node < $min_even) {\n                $min_even = $node;\n                $min_even_index = $node;\n            }\n        }\n        if ($node < $min_index) {\n            $min_index = $node;\n            $min_index_index = $node;\n        }\n    }\n    if ($min_even_index) {\n        return [$min_even_index, $min_index_index];\n    } else {\n        return [];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            } else {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            }\n        } else if ($min_even_value == 0) {\n            $min_even_index = $node;\n            $min_even_value = $node;\n        } else if ($min_even_value < $node) {\n            $min_even_index = $node;\n            $min_even_value = $node;\n        }\n        if ($min_index == 0) {\n            $min_index = $node;\n            $min_value = $node;\n        } else if ($min_value < $node) {\n            $min_index = $node;\n            $min_value = $node;\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_index, $min_even_value];\n    }\n    if ($min_index == 0) {\n        return [$min_index, $min_value];\n    }\n    return [$min_index, $min_value];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp32icenr6.pl line 44, near \"else if\"\nsyntax error at /tmp/tmp32icenr6.pl line 47, near \"} else\"\nsyntax error at /tmp/tmp32icenr6.pl line 54, near \"else if\"\nsyntax error at /tmp/tmp32icenr6.pl line 57, near \"}\"\nExecution of /tmp/tmp32icenr6.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($index, $value) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $index;\n                $min_even_value = $value;\n            }\n            else {\n                if ($value < $min_even_value) {\n                    $min_even_index = $index;\n                    $min_even_value = $value;\n                }\n            }\n        }\n        else {\n            if ($min_value == 0) {\n                $min_index = $index;\n                $min_value = $value;\n            }\n            else {\n                if ($value < $min_value) {\n                    $min_index = $index;\n                    $min_value = $value;\n                }\n            }\n        }\n        $index += 1;\n        $value += $node;\n    }\n    if ($min_even_value == 0) {\n        $result = [$min_even_value, $min_even_index];\n    }\n    else {\n        $result = [$min_value, $min_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [ $smallest_even_value, $smallest_index ];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $index) = 0;\n    my($result) = [];\n    my($i) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $smalest_value = $node;\n            $index = $i;\n        }\n        $i += 1;\n    }\n    if ($smalest_value == 0) {\n        $result = [$smalest_value, $index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_index = $node;\n            }\n            else if ($node == $min_even_value) {\n                $min_index = min($min_index, $node);\n            }\n        }\n    }\n    if ($min_even_value) {\n        $result = [$min_even_value, $min_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmps9vtvkfo.pl line 36, near \"else if\"\nsyntax error at /tmp/tmps9vtvkfo.pl line 45, near \"}\"\nExecution of /tmp/tmps9vtvkfo.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    my($min_index_value_index_index) = -1;\n    my($min_index_value_index_index_index) = -1;\n    my($min_index_value_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_value_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpkiqjnc_k.pl line 48, at end of line\nsyntax error at /tmp/tmpkiqjnc_k.pl line 48, near \"$min_index_value_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpkiqjnc_k.pl line 87, at end of line\nsyntax error at /tmp/tmpkiqjnc_k.pl line 87, at EOF\nExecution of /tmp/tmpkiqjnc_k.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [ $node, $index ];\n            $index += 1;\n            continue;\n        }\n        if ($node % 2 == 0) {\n            if ($node < $smallest_value) {\n                $smallest_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_value == 0) {\n        $result = [];\n    } else {\n        $result = [ $smallest_value, $smallest_index ];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            $min_even = $node;\n            $min_index = $node;\n            $min_value = $node;\n        } else if ($even < $min_even) {\n            $min_even = $even;\n            $min_index = $node;\n            $min_value = $node;\n        } else if ($even == $min_even) {\n            if ($node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            } else if ($node == $min_value) {\n                $min_index_value = $node;\n            }\n        }\n    }\n    if ($min_even == 0) {\n        return [$min_value, $min_index];\n    } else if ($min_even == $min_index_value) {\n        return [$min_value, $min_index];\n    } else {\n        return [$min_index, $min_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp9xdh7cjn.pl line 41, near \"else if\"\nsyntax error at /tmp/tmp9xdh7cjn.pl line 45, near \"} else\"\nsyntax error at /tmp/tmp9xdh7cjn.pl line 49, near \"} else\"\nExecution of /tmp/tmp9xdh7cjn.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$smalest_value, $index];\n            continue;\n        }\n        if ($node % 2 == 0) {\n            $smalest_value = $node;\n            $index = $node;\n        }\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_value_index) = 0;\n    my($smallest_index_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp8e0dztff.pl line 47, at end of line\nsyntax error at /tmp/tmp8e0dztff.pl line 47, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp8e0dztff.pl line 86, at end of line\nsyntax error at /tmp/tmp8e0dztff.pl line 86, at EOF\nExecution of /tmp/tmp8e0dztff.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            $result = [$node, $min_index];\n            $min_even_value = $node;\n            $min_even_index = $min_index;\n        } else if ($even_value < $min_even_value) {\n            $min_even_value = $even_value;\n            $min_even_index = $min_index;\n        }\n        $min_index += 1;\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpdgtgimxp.pl line 40, near \"else if\"\nsyntax error at /tmp/tmpdgtgimxp.pl line 47, near \"}\"\nExecution of /tmp/tmpdgtgimxp.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_of_smallest_even_value) = 0;\n    my($smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value) = 0;\n    my($smallest_value_of_smallest_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value_of_smallest_value) = 0;\n    my\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "No such class use at /tmp/tmpycz2ry7y.pl line 44, near \"my\nuse\"\nsyntax error at /tmp/tmpycz2ry7y.pl line 44, near \"my\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpycz2ry7y.pl line 83, at end of line\nsyntax error at /tmp/tmpycz2ry7y.pl line 83, at EOF\nExecution of /tmp/tmpycz2ry7y.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value < $min_even_value) {\n            $min_even_value = $even_value;\n            $min_even_index = $node;\n        }\n        if ($node < $min_value) {\n            $min_index = $node;\n            $min_value = $node;\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index++;\n    }\n    return [$smallest_even_value, $smallest_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $index];\n            $index += 1;\n        } else if ($node % 2 == 0) {\n            $smallest_even_value = $node;\n            $smallest_index = $index;\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    } else {\n        $result = [$smallest_even_value, $smallest_index];\n        return $result;\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp26zji0fw.pl line 35, near \"else if\"\nsyntax error at /tmp/tmp26zji0fw.pl line 47, near \"}\"\nExecution of /tmp/tmp26zji0fw.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            } else {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else if ($min_even_value == 0) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        } else if ($min_even_value > $node) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_value > 0) {\n        return [$min_even_value, $min_index];\n    }\n    return [$min_value, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpbmfdola_.pl line 44, near \"else if\"\nsyntax error at /tmp/tmpbmfdola_.pl line 47, near \"} else\"\nsyntax error at /tmp/tmpbmfdola_.pl line 51, near \"}\"\nExecution of /tmp/tmpbmfdola_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_even_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == 0) {\n                $min_even = $node;\n                $min_even_index = $node;\n            } else if ($node < $min_even) {\n                $min_even = $node;\n                $min_even_index = $node;\n            }\n        }\n    }\n    if ($min_even == 0) {\n        return [$min_even_index, $min_even_index];\n    } else {\n        return [$min_even, $min_even_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpjslvd97z.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpjslvd97z.pl line 46, near \"}\"\nExecution of /tmp/tmpjslvd97z.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        my $value = $node;\n        if ($value % 2 == 0) {\n            if ($value < $smallest_even_value) {\n                $smallest_even_value = $value;\n                $smallest_index = $index;\n            }\n        }\n        $index++;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($index, $value) = 0;\n    my($smallest_index, $smallest_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return [0, $smallest_index];\n    } else {\n        return [$smallest_even_value, $smallest_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpy92l2ady.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpy92l2ady.pl line 48, near \"}\"\nExecution of /tmp/tmpy92l2ady.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_for_even_value) = 0;\n    my($smallest_index_for_odd_value) = 0;\n    my($smallest_index_for_zero) = 0;\n    my($smallest_index_for_non_zero) = 0;\n    my($smallest_index_for_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_non_zero) = 0\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpgk2ij7w_.pl line 49, at end of line\nsyntax error at /tmp/tmpgk2ij7w_.pl line 49, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpgk2ij7w_.pl line 88, at end of line\nsyntax error at /tmp/tmpgk2ij7w_.pl line 88, at EOF\nExecution of /tmp/tmpgk2ij7w_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_value, $min_index) = 0;\n    my($min_value_index) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $value = $node;\n        my $index = $arr.index($node);\n        if ($value % 2 == 0) {\n            if ($min_value == 0) {\n                $min_value = $value;\n                $min_value_index = $index;\n            } else if ($value < $min_value) {\n                $min_value = $value;\n                $min_value_index = $index;\n            }\n        }\n        if ($index < $min_index_index || $min_index_index == 0) {\n            $min_index_index = $index;\n        }\n    }\n    if ($min_value_index == 0) {\n        return [0, 0];\n    }\n    return [$min_value, $min_value_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Not enough arguments for index at /tmp/tmpa18a7lfx.pl line 36, near \"$node)\"\nsyntax error at /tmp/tmpa18a7lfx.pl line 41, near \"else if\"\nsyntax error at /tmp/tmpa18a7lfx.pl line 54, near \"}\"\nExecution of /tmp/tmpa18a7lfx.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_value_index) = 0;\n    my($smallest_index_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp8e0dztff.pl line 47, at end of line\nsyntax error at /tmp/tmp8e0dztff.pl line 47, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp8e0dztff.pl line 86, at end of line\nsyntax error at /tmp/tmp8e0dztff.pl line 86, at EOF\nExecution of /tmp/tmp8e0dztff.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_index) = -1;\n    my($min_index_index_index_value) = -1;\n    my($min_index_index_index_index) = -1;\n    my($min_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpdb6m_xi3.pl line 52, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 52, near \"$min_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpdb6m_xi3.pl line 91, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 91, at EOF\nExecution of /tmp/tmpdb6m_xi3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($i) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $i;\n            }\n        }\n        $i++;\n    }\n    if ($smallest_even_value) {\n        $result = [ $smallest_even_value, $smallest_index ];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_index) = -1;\n    my($min_index_index_index_value) = -1;\n    my($min_index_index_index_index) = -1;\n    my($min_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpdb6m_xi3.pl line 52, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 52, near \"$min_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpdb6m_xi3.pl line 91, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 91, at EOF\nExecution of /tmp/tmpdb6m_xi3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_value, $smallest_index_index) = 0;\n    my($smallest_index_value_index, $smallest_index_index_index) = 0;\n    my($smallest_index_value_index_index) = 0;\n    my($smallest_index_value_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp_0j9yrjb.pl line 46, at end of line\nsyntax error at /tmp/tmp_0j9yrjb.pl line 46, near \"$smallest_index_value_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp_0j9yrjb.pl line 85, at end of line\nsyntax error at /tmp/tmp_0j9yrjb.pl line 85, at EOF\nExecution of /tmp/tmp_0j9yrjb.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else if ($min_value == 0) {\n            $min_value = $node;\n            $min_index = $node;\n        } else if ($node < $min_value) {\n            $min_value = $node;\n            $min_index = $node;\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpd7yxc381.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpd7yxc381.pl line 39, near \"} else\"\nsyntax error at /tmp/tmpd7yxc381.pl line 42, near \"} else\"\nsyntax error at /tmp/tmpd7yxc381.pl line 45, near \"}\"\nExecution of /tmp/tmpd7yxc381.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $smalest_index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmp3mxjaq1w.pl line 72, at end of line\nsyntax error at /tmp/tmp3mxjaq1w.pl line 72, at EOF\nExecution of /tmp/tmp3mxjaq1w.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_even_index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($index) = 0;\n    my($i) = 0;\n    my($j) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $i];\n            return $result;\n        }\n        if ($node % 2 == 0) {\n            $smallest_even_value = $node;\n            $smallest_even_index = $i;\n        }\n        $i += 1;\n    }\n    if ($smallest_even_value == 0) {\n        $result = [$smallest_even_value, $smallest_even_index];\n        return $result;\n    }\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $i];\n            return $result;\n        }\n        if ($node < $smallest_even_value) {\n            $smallest_value = $node;\n            $smallest_index = $i;\n        }\n        $i += 1;\n    }\n    $result = [$smallest_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_index) = 0;\n    my($smallest_index_index_index_value) = 0;\n    my($smallest_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpswzfu_38.pl line 51, at end of line\nsyntax error at /tmp/tmpswzfu_38.pl line 51, near \"$smallest_index_index_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpswzfu_38.pl line 90, at end of line\nsyntax error at /tmp/tmpswzfu_38.pl line 90, at EOF\nExecution of /tmp/tmpswzfu_38.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_node) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index_node = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index_node = $node;\n            } else if ($node == $smallest_even_value) {\n                if ($smallest_index_node < $node) {\n                    $smallest_index_node = $node;\n                }\n            }\n        }\n    }\n    return [$smallest_even_value, $smallest_index_node];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp00c67zj7.pl line 35, near \"else if\"\nsyntax error at /tmp/tmp00c67zj7.pl line 38, near \"else if\"\nsyntax error at /tmp/tmp00c67zj7.pl line 43, near \"}\"\nExecution of /tmp/tmp00c67zj7.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_index) = -1;\n    my($min_index_index_index_value) = -1;\n    my($min_index_index_index_index) = -1;\n    my($min_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpdb6m_xi3.pl line 52, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 52, near \"$min_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpdb6m_xi3.pl line 91, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 91, at EOF\nExecution of /tmp/tmpdb6m_xi3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    return [$smallest_even_value, $smallest_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmped_6m27m.pl line 35, near \"else if\"\nsyntax error at /tmp/tmped_6m27m.pl line 43, near \"}\"\nExecution of /tmp/tmped_6m27m.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($plucked_node) = [];\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            }\n            else if ($node == $smallest_even_value) {\n                $smallest_index = min($smallest_index, $node);\n            }\n        }\n    }\n    if ($smallest_even_value) {\n        $plucked_node = [$smallest_even_value, $smallest_index];\n    }\n    return $plucked_node;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpxzs1dnoy.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpxzs1dnoy.pl line 45, near \"}\"\nExecution of /tmp/tmpxzs1dnoy.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpdjg6n03s.pl line 70, at end of line\nsyntax error at /tmp/tmpdjg6n03s.pl line 70, at EOF\nExecution of /tmp/tmpdjg6n03s.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_index) = 0;\n    my($min_even_value_index) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_value_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_value_index = $node;\n            }\n        }\n        if ($min_index == 0) {\n            $min_index = $node;\n            $min_index_index = $node;\n        } else if ($node < $min_index) {\n            $min_index = $node;\n            $min_index_index = $node;\n        }\n    }\n    return [$min_even_value_index, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp85zjt4m3.pl line 36, near \"else if\"\nsyntax error at /tmp/tmp85zjt4m3.pl line 44, near \"else if\"\nsyntax error at /tmp/tmp85zjt4m3.pl line 48, near \"}\"\nExecution of /tmp/tmp85zjt4m3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $node;\n            }\n            else {\n                $min_even_index = $min_index;\n            }\n            $min_even_value = $node;\n        }\n        else {\n            if ($min_value == 0) {\n                $min_index = $node;\n            }\n            else {\n                $min_index = $min_index;\n            }\n            $min_value = $node;\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n            else if ($node == $min_even_value) {\n                $min_even_index = $node;\n            }\n        }\n        else {\n            if ($node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            }\n            else if ($node == $min_value) {\n                $min_index = $node;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_index, $min_index];\n    }\n    else {\n        return [$min_even_value, $min_even_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp2fhxf1x_.pl line 36, near \"else if\"\nsyntax error at /tmp/tmp2fhxf1x_.pl line 40, near \"else\"\nsyntax error at /tmp/tmp2fhxf1x_.pl line 45, near \"else\"\nExecution of /tmp/tmp2fhxf1x_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == -1 || $min_even > $node) {\n                $min_even = $node;\n            }\n        }\n        if ($min_index == -1 || $min_index > $node) {\n            $min_index = $node;\n        }\n        if ($min_value == -1 || $min_value > $node) {\n            $min_value = $node;\n        }\n        if ($min_index_value == -1 || $min_index_value > $node) {\n            $min_index_value = $node;\n        }\n        if ($min_index_value_index == -1 || $min_index_value_index > $node) {\n            $min_index_value_index = $node;\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    return [$min_even, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0 || $node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else {\n            if ($min_value == 0 || $node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            }\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_value_index) = 0;\n    my($smallest_index_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp8e0dztff.pl line 47, at end of line\nsyntax error at /tmp/tmp8e0dztff.pl line 47, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp8e0dztff.pl line 86, at end of line\nsyntax error at /tmp/tmp8e0dztff.pl line 86, at EOF\nExecution of /tmp/tmp8e0dztff.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    foreach my $node (@$arr) {\n        my $even = $node % 2;\n        if ($even == 0) {\n            if ($min_even == -1) {\n                $min_even = $node;\n                $min_index = $node;\n            } else if ($min_even == $node) {\n                $min_index = $node;\n            } else if ($min_even > $node) {\n                $min_even = $node;\n                $min_index = $node;\n            } else if ($min_even == $node && $min_index > $node) {\n                $min_index = $node;\n            }\n        }\n        if ($min_even == -1) {\n            $min_even = $node;\n            $min_index = $node;\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    return [$min_even, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp2v_95jho.pl line 38, near \"else if\"\nsyntax error at /tmp/tmp2v_95jho.pl line 40, near \"else if\"\nsyntax error at /tmp/tmp2v_95jho.pl line 43, near \"} else\"\nsyntax error at /tmp/tmp2v_95jho.pl line 46, near \"}\"\nsyntax error at /tmp/tmp2v_95jho.pl line 50, near \"}\"\nExecution of /tmp/tmp2v_95jho.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    my($index) = 0;\n    my($index_index) = 0;\n    my($index_index_index) = 0;\n    my($index_index_index_index) = 0;\n    my($index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpacduj5u5.pl line 49, at end of line\nsyntax error at /tmp/tmpacduj5u5.pl line 49, near \"$index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpacduj5u5.pl line 88, at end of line\nsyntax error at /tmp/tmpacduj5u5.pl line 88, at EOF\nExecution of /tmp/tmpacduj5u5.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($index) = 0;\n    my($result) = [];\n    my($result_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result_index = $index;\n            $result = [ $node, $index ];\n            $index += 1;\n        } else {\n            if ($node % 2 == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n            $index += 1;\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    } else {\n        return [ $smallest_even_value, $smallest_index ];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "ok!ok!ok!",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_even_value_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_even_value_index = $node;\n            }\n        }\n        if ($node < $smallest_index) {\n            $smallest_index = $node;\n            $smallest_index_index = $node;\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return [$smallest_index, $smallest_index_index];\n    } else {\n        return [$smallest_even_value, $smallest_even_value_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp_34xbpen.pl line 36, near \"else if\"\nsyntax error at /tmp/tmp_34xbpen.pl line 51, near \"}\"\nExecution of /tmp/tmp_34xbpen.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_even_value_index = $node;\n            }\n            else if ($node == $smallest_even_value) {\n                $smallest_even_value_index = $node;\n            }\n        }\n        if ($node < $smallest_index) {\n            $smallest_index = $node;\n            $smallest_index_index = $node;\n        }\n        else if ($node == $smallest_index) {\n            $smallest_index_index = $node;\n        }\n    }\n    if ($smallest_even_value_index) {\n        return [$smallest_even_value_index, $smallest_index_index];\n    }\n    else if ($smallest_index_index) {\n        return [$smallest_index_index, $smallest_index_index];\n    }\n    else {\n        return [];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpolo2s28d.pl line 37, near \"else if\"\nsyntax error at /tmp/tmpolo2s28d.pl line 45, near \"else if\"\nsyntax error at /tmp/tmpolo2s28d.pl line 48, near \"}\"\nExecution of /tmp/tmpolo2s28d.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    my($min_index_odd, $min_value_odd) = 0;\n    my($min_index_even_odd, $min_value_even_odd) = 0;\n    my($min_index_even_odd_even, $min_value_even_odd_even) = 0;\n    my($min_index_even_odd_odd, $min_value_even_odd_odd) = 0;\n    my($min_index_even_odd_even_odd, $min_value_even_odd_even_odd) = 0;\n    my($min_index_even_odd_odd_even, $min_value_even_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_even, $min_value_even_odd_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_odd_even, $min_value_even_odd_odd_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_odd_odd_even, $min_value_even_odd_odd_odd_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_odd_odd_odd_even, $min_value_even_odd_odd_odd_odd_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_odd_odd_odd_odd_even, $min_value_even_odd_odd_odd_odd_odd_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_odd_odd_odd_odd_odd_even, $min_value_even_odd_odd_odd_odd_odd_odd_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_odd\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpj5f7vqnf.pl line 44, at end of line\nsyntax error at /tmp/tmpj5f7vqnf.pl line 44, near \"$min_index_even_odd_odd_odd_odd\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpj5f7vqnf.pl line 83, at end of line\nsyntax error at /tmp/tmpj5f7vqnf.pl line 83, at EOF\nExecution of /tmp/tmpj5f7vqnf.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value) = -1;\n    my($min_even_index) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    my($min_index_value_index_value) = -1;\n    my($min_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) =\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpk0gef29g.pl line 48, at end of line\nsyntax error at /tmp/tmpk0gef29g.pl line 48, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpk0gef29g.pl line 87, at end of line\nsyntax error at /tmp/tmpk0gef29g.pl line 87, at EOF\nExecution of /tmp/tmpk0gef29g.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_value_index) = 0;\n    my($smallest_index_value_index_index) = 0;\n    my($smallest_index_value_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpyy_4oz20.pl line 48, at end of line\nsyntax error at /tmp/tmpyy_4oz20.pl line 48, near \"$smallest_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpyy_4oz20.pl line 87, at end of line\nsyntax error at /tmp/tmpyy_4oz20.pl line 87, at EOF\nExecution of /tmp/tmpyy_4oz20.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == 0) {\n                $min_even = $node;\n                $min_index = $node;\n            } else if ($min_even > $node) {\n                $min_even = $node;\n                $min_index = $node;\n            } else if ($min_even == $node) {\n                if ($min_index == 0) {\n                    $min_index_value = $node;\n                    $min_index_index = $node;\n                } else if ($min_index > $node) {\n                    $min_index_value = $node;\n                    $min_index_index = $node;\n                } else if ($min_index == $node) {\n                    if ($min_index_index == 0) {\n                        $min_index_value = $node;\n                        $min_index_index = $node;\n                    } else if ($min_index_index > $node) {\n                        $min_index_value = $node;\n                        $min_index_index = $node;\n                    } else if ($min_index_index == $node) {\n                        die \"Duplicate even values\";\n                    }\n                }\n            }\n        }\n    }\n    if ($min_even == 0) {\n        return [];\n    } else {\n        return [ $min_even, $min_index ];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpc0ps9w3l.pl line 38, near \"else if\"\nsyntax error at /tmp/tmpc0ps9w3l.pl line 41, near \"else if\"\nsyntax error at /tmp/tmpc0ps9w3l.pl line 45, near \"} else\"\nsyntax error at /tmp/tmpc0ps9w3l.pl line 48, near \"} else\"\nsyntax error at /tmp/tmpc0ps9w3l.pl line 52, near \"}\"\nsyntax error at /tmp/tmpc0ps9w3l.pl line 55, near \"}\"\nExecution of /tmp/tmpc0ps9w3l.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($result) = [];\n    my($index, $value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $index = $value;\n            $value = 0;\n        } else {\n            $value += $node;\n        }\n        if ($value % 2 == 0) {\n            if ($value < $min_even_value) {\n                $min_even_value = $value;\n                $min_even_index = $index;\n            }\n        } else {\n            if ($value < $min_value) {\n                $min_value = $value;\n                $min_index = $index;\n            }\n        }\n    }\n    if ($min_even_value) {\n        $result = [$min_even_value, $min_even_index];\n    } else if ($min_value) {\n        $result = [$min_value, $min_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpwownlla3.pl line 53, near \"else if\"\nsyntax error at /tmp/tmpwownlla3.pl line 57, near \"}\"\nExecution of /tmp/tmpwownlla3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_of_smallest_even_value) = 0;\n    my($smallest_value_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_value) = 0;\n    my($smallest_value_of_smallest_value) = 0;\n    my($index_of_smallest_value) = 0;\n    my($index_of_smallest_even_value) = 0;\n    my($index_of_smallest_value_of_smallest_even_value) = 0;\n    my($index_of_smallest_even_value_of_smallest_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value_of_smallest_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_value_of_smallest_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_value) = 0;\n    my($index_of_smallest_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp9i20v5ff.pl line 44, at end of line\nsyntax error at /tmp/tmp9i20v5ff.pl line 44, near \"$index_of_smallest_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_value_of_smallest_value_of_smallest_even_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp9i20v5ff.pl line 83, at end of line\nsyntax error at /tmp/tmp9i20v5ff.pl line 83, at EOF\nExecution of /tmp/tmp9i20v5ff.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even_value, $min_index_even_index) = 0;\n    my($min_index_value, $min_index_value_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            } else {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            }\n        } else {\n            if ($min_index_even_value == 0) {\n                $min_index_even_index = $node;\n                $min_index_even_value = $node;\n            } else {\n                $min_index_even_index = $node;\n                $min_index_even_value = $node;\n            }\n        }\n        if ($min_index == 0) {\n            $min_index = $node;\n            $min_value = $node;\n        } else {\n            if ($min_index_value == 0) {\n                $min_index_value_index = $node;\n                $min_index_value = $node;\n            } else {\n                $min_index_value_index = $node;\n                $min_index_value = $node;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_index, $min_even_value];\n    } else {\n        return [$min_index_even_index, $min_index_even_value];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            if ($min_even == -1) {\n                $min_even = $node;\n                $min_index = $node;\n            } else if ($node < $min_even) {\n                $min_even = $node;\n                $min_index = $node;\n            }\n        } else if ($min_even == -1) {\n            $min_even = $node;\n            $min_index = $node;\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    return [$min_even, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmphwa6csis.pl line 41, near \"else if\"\nsyntax error at /tmp/tmphwa6csis.pl line 45, near \"} else\"\nsyntax error at /tmp/tmphwa6csis.pl line 49, near \"}\"\nExecution of /tmp/tmphwa6csis.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_even_value, $index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        if ($node % 2 == 0) {\n            $smalest_even_value = $node;\n            $index = $node;\n        } else {\n            if ($smalest_even_value == 0) {\n                $smalest_even_value = $node;\n                $index = $node;\n            } else {\n                if ($node < $smalest_even_value) {\n                    $smalest_even_value = $node;\n                    $index = $node;\n                }\n                if ($node < $smallest_value) {\n                    $smallest_value = $node;\n                    $smallest_index = $node;\n                }\n            }\n        }\n    }\n    if ($smalest_even_value == 0) {\n        return [$smallest_value, $smallest_index];\n    } else {\n        return [$smalest_even_value, $index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_even_index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_value_index) = 0;\n    my($smallest_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index) = 0;\n    my($smallest_index_value_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($smallest_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "No such class use at /tmp/tmpfjw4v7tv.pl line 48, near \"my\nuse\"\nsyntax error at /tmp/tmpfjw4v7tv.pl line 48, near \"my\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpfjw4v7tv.pl line 87, at end of line\nsyntax error at /tmp/tmpfjw4v7tv.pl line 87, at EOF\nExecution of /tmp/tmpfjw4v7tv.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($smallest_value_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_index) = 0;\n    my($smallest_index_index_index_value) = 0;\n    my($smallest_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpptkc5vul.pl line 52, at end of line\nsyntax error at /tmp/tmpptkc5vul.pl line 52, near \"$smallest_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpptkc5vul.pl line 91, at end of line\nsyntax error at /tmp/tmpptkc5vul.pl line 91, at EOF\nExecution of /tmp/tmpptkc5vul.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value) = 0;\n    my($min_even_index) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp05j6fjdj.pl line 49, at end of line\nsyntax error at /tmp/tmp05j6fjdj.pl line 49, near \"$min_index_value_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp05j6fjdj.pl line 88, at end of line\nsyntax error at /tmp/tmp05j6fjdj.pl line 88, at EOF\nExecution of /tmp/tmp05j6fjdj.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value) = 0;\n    my($min_even_index) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp05j6fjdj.pl line 49, at end of line\nsyntax error at /tmp/tmp05j6fjdj.pl line 49, near \"$min_index_value_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp05j6fjdj.pl line 88, at end of line\nsyntax error at /tmp/tmp05j6fjdj.pl line 88, at EOF\nExecution of /tmp/tmp05j6fjdj.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_even_value, $index) = 0;\n    my($smallest_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index) = 0;\n    my($smallest_index_index_value) = 0;\n    my($smallest_index_index_index) = 0;\n    my($smallest_index_index_index_value) = 0;\n    my($smallest_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_index_index_index_index_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmptc05ytd5.pl line 51, at end of line\nsyntax error at /tmp/tmptc05ytd5.pl line 51, near \"$smallest_index_index_index_index_index_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmptc05ytd5.pl line 90, at end of line\nsyntax error at /tmp/tmptc05ytd5.pl line 90, at EOF\nExecution of /tmp/tmptc05ytd5.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpyh82xfof.pl line 70, at end of line\nsyntax error at /tmp/tmpyh82xfof.pl line 70, at EOF\nExecution of /tmp/tmpyh82xfof.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($smallest_index_value, $smallest_index_index) = 0;\n    my($index) = 0;\n    my($index_value) = 0;\n    my($index_index) = 0;\n    foreach my $node (@$arr) {\n        $index = $node - 1;\n        $index_value = $node;\n        $index_index = $index;\n        if ($index_value % 2 == 0) {\n            if ($smallest_value == 0) {\n                $smallest_value = $index_value;\n                $smallest_index = $index_index;\n            } else if ($index_value < $smallest_value) {\n                $smallest_value = $index_value;\n                $smallest_index = $index_index;\n            }\n        }\n    }\n    if ($smallest_value == 0) {\n        return [$smallest_value, $smallest_index];\n    } else {\n        return [$smallest_value, $smallest_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpsekz89qy.pl line 41, near \"else if\"\nsyntax error at /tmp/tmpsekz89qy.pl line 52, near \"}\"\nExecution of /tmp/tmpsekz89qy.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_index) = -1;\n    my($min_index_index_index_value) = -1;\n    my($min_index_index_index_index) = -1;\n    my($min_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpdb6m_xi3.pl line 52, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 52, near \"$min_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpdb6m_xi3.pl line 91, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 91, at EOF\nExecution of /tmp/tmpdb6m_xi3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_for_even_value) = 0;\n    my($smallest_index_for_odd_value) = 0;\n    my($smallest_index_for_zero) = 0;\n    my($smallest_index_for_non_zero) = 0;\n    my($smallest_index_for_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_non_zero) = 0\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpgk2ij7w_.pl line 49, at end of line\nsyntax error at /tmp/tmpgk2ij7w_.pl line 49, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpgk2ij7w_.pl line 88, at end of line\nsyntax error at /tmp/tmpgk2ij7w_.pl line 88, at EOF\nExecution of /tmp/tmpgk2ij7w_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else if ($min_value == 0) {\n            $min_value = $node;\n            $min_index = $node;\n        } else if ($node < $min_value) {\n            $min_value = $node;\n            $min_index = $node;\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpd7yxc381.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpd7yxc381.pl line 39, near \"} else\"\nsyntax error at /tmp/tmpd7yxc381.pl line 42, near \"} else\"\nsyntax error at /tmp/tmpd7yxc381.pl line 45, near \"}\"\nExecution of /tmp/tmpd7yxc381.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [ $node, $index ];\n            $index += 1;\n        } else {\n            if ($node < $smallest_value) {\n                $smallest_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_value == 0) {\n        return $result;\n    } else {\n        return [ $smallest_value, $smallest_index ];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($plucked_node) = [];\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $plucked_node = [$smallest_even_value, $smallest_index];\n            $smallest_even_value = $node;\n            $smallest_index = $node;\n        } else if ($node % 2 == 0) {\n            $smallest_even_value = $node;\n            $smallest_index = $node;\n        }\n    }\n    return $plucked_node;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpxbcoxlqj.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpxbcoxlqj.pl line 42, near \"}\"\nExecution of /tmp/tmpxbcoxlqj.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($min_even == -1 || $even < $min_even) {\n            $min_even = $even;\n            $min_index = $node;\n        }\n        if ($min_even == $even && $min_index == $node) {\n            continue;\n        }\n        if ($min_value == -1 || $node < $min_value) {\n            $min_value = $node;\n            $min_index_value = $node;\n            $min_index_index = $node;\n        }\n        if ($min_value == $node && $min_index_value == $node) {\n            continue;\n        }\n        if ($min_index_index == $node) {\n            continue;\n        }\n        $min_index_index = $node;\n    }\n    if ($min_index_index == -1) {\n        return [];\n    }\n    return [$min_value, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Can't \"continue\" outside a when block at /tmp/tmpzo4r87n_.pl line 43.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_index_even, $min_index_index) = 0;\n    my($min_index_even_index, $min_index_index_index) = 0;\n    my($min_index_even_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == 0 || $node < $min_even) {\n                $min_even = $node;\n                $min_index = $node;\n            }\n            if ($min_even == $node) {\n                $min_index_even = $node;\n                $min_index_index = $node;\n            }\n        }\n        if ($node % 2 == 1) {\n            if ($min_even == 0 || $node < $min_even) {\n                $min_even = $node;\n                $min_index_even = $node;\n                $min_index_even_index = $node;\n            }\n            if ($min_even == $node) {\n                $min_index_even_index = $node;\n                $min_index_even_index_index = $node;\n            }\n        }\n    }\n    if ($min_even == 0) {\n        return [0, 0];\n    }\n    if ($min_even == $min_index) {\n        return [$min_index, $min_index_index];\n    }\n    if ($min_even == $min_index_even) {\n        return [$min_index_even, $min_index_even_index];\n    }\n    if ($min_even == $min_index_even_index) {\n        return [$min_index_even_index, $min_index_even_index_index];\n    }\n    return [$min_index, $min_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            $min_even = $node;\n            $min_index = $node;\n            $min_value = $node;\n        } else if ($min_even == 0) {\n            $min_index_value = $node;\n            $min_index = $node;\n        } else if ($min_even == $even) {\n            $min_index_value = $node;\n            $min_index = $node;\n        } else if ($min_even < $even) {\n            $min_index_value = $node;\n            $min_index = $node;\n        }\n    }\n    if ($min_even == 0) {\n        return [$min_value, $min_index];\n    } else {\n        return [$min_index_value, $min_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp1widpue_.pl line 41, near \"else if\"\nsyntax error at /tmp/tmp1widpue_.pl line 44, near \"} else\"\nsyntax error at /tmp/tmp1widpue_.pl line 47, near \"} else\"\nsyntax error at /tmp/tmp1widpue_.pl line 50, near \"}\"\nExecution of /tmp/tmp1widpue_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else {\n            if ($min_value == 0) {\n                $min_value = $node;\n                $min_index = $node;\n            } else if ($node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_index, $min_even_index];\n    } else if ($min_value == 0) {\n        return [$min_index, $min_index];\n    } else {\n        return [$min_even_index, $min_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpxu9mw5v0.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpxu9mw5v0.pl line 39, near \"} else\"\nsyntax error at /tmp/tmpxu9mw5v0.pl line 43, near \"} else\"\nsyntax error at /tmp/tmpxu9mw5v0.pl line 46, near \"}\"\nExecution of /tmp/tmpxu9mw5v0.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_value_index_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_index_index) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_index_index) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_index_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_index_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_index) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp3ajco785.pl line 53, at end of line\nsyntax error at /tmp/tmp3ajco785.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp3ajco785.pl line 92, at end of line\nsyntax error at /tmp/tmp3ajco785.pl line 92, at EOF\nExecution of /tmp/tmp3ajco785.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even_value, $min_index_even_value) = 0;\n    my($min_index_even_value_index, $min_index_even_value_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n            $min_index_even_value = $node;\n            $min_index_even_value_index = $node;\n        } else if ($even_value < $min_even_value) {\n            $min_even_value = $node;\n            $min_even_index = $node;\n            $min_index_even_value = $node;\n            $min_index_even_value_index = $node;\n        } else if ($even_value == $min_even_value) {\n            if ($node < $min_index_even_value) {\n                $min_index_even_value = $node;\n                $min_index_even_value_index = $node;\n            } else if ($node == $min_index_even_value) {\n                if ($node < $min_index_even_value_index) {\n                    $min_index_even_value_index = $node;\n                }\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [0, 0];\n    }\n    return [$min_even_value, $min_index_even_value];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpuxawhmy4.pl line 42, near \"else if\"\nsyntax error at /tmp/tmpuxawhmy4.pl line 47, near \"} else\"\nsyntax error at /tmp/tmpuxawhmy4.pl line 51, near \"} else\"\nExecution of /tmp/tmpuxawhmy4.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_value_index) = -1;\n    my($min_index_value_index_value) = -1;\n    my($min_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp074nauve.pl line 48, at end of line\nsyntax error at /tmp/tmp074nauve.pl line 48, near \"$min_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp074nauve.pl line 87, at end of line\nsyntax error at /tmp/tmp074nauve.pl line 87, at EOF\nExecution of /tmp/tmp074nauve.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_even_index) = 0;\n    my($smallest_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_even_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_even_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_index = $node;\n            }\n        } else {\n            if ($smallest_index == 0) {\n                $smallest_index = $node;\n            } else if ($node < $smallest_index) {\n                $smallest_index = $node;\n            }\n        }\n    }\n    return [$smallest_even_value, $smallest_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp8bfnyn_h.pl line 35, near \"else if\"\nsyntax error at /tmp/tmp8bfnyn_h.pl line 38, near \"else if\"\nsyntax error at /tmp/tmp8bfnyn_h.pl line 41, near \"} else\"\nExecution of /tmp/tmp8bfnyn_h.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_index) = -1;\n    my($min_even_value_index) = -1;\n    my($min_index_index) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_value_index) = -1;\n    my($min_index_index_value_index_value) = -1;\n    my($min_index_index_value_index_value_index) = -1;\n    my($min_index_index_value_index_value_index_value) = -1;\n    my($min_index_index_value_index_value_index_value_index) = -1;\n    my($min_index_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = -1;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = -1;\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpoaiat75o.pl line 86, at end of line\nsyntax error at /tmp/tmpoaiat75o.pl line 86, at EOF\nExecution of /tmp/tmpoaiat75o.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0 || $node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else {\n            if ($min_value == 0 || $node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            }\n        }\n    }\n    return [$min_even_value, $min_even_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_in_array) = 0;\n    my($smallest_index_in_array_index) = 0;\n    my($smallest_index_in_array_value) = 0;\n    my($smallest_index_in_array_index_value) = 0;\n    my($smallest_index_in_array_index_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_value_value_value_value_value_value_value_value) = 0;\n    my($smallest_index_in_array_index_value_value_value_value_value_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpsqvgqxcv.pl line 46, at end of line\nsyntax error at /tmp/tmpsqvgqxcv.pl line 46, near \"$smallest_index_in_array_index_value_value_value_value_value_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpsqvgqxcv.pl line 85, at end of line\nsyntax error at /tmp/tmpsqvgqxcv.pl line 85, at EOF\nExecution of /tmp/tmpsqvgqxcv.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_index_even, $min_index_index) = 0;\n    my($min_index_even_index, $min_index_index_index) = 0;\n    my($min_index_even_index_index) = 0;\n    my($min_index_even_index_index_index) = 0;\n    my($min_index_even_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_even_index_index_index_index_index_index_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp14ta6aaz.pl line 46, at end of line\nsyntax error at /tmp/tmp14ta6aaz.pl line 46, near \"$min_index_even_index_index_index_index_index_index_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp14ta6aaz.pl line 85, at end of line\nsyntax error at /tmp/tmp14ta6aaz.pl line 85, at EOF\nExecution of /tmp/tmp14ta6aaz.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_value, $smallest_index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmphc26fglu.pl line 69, at end of line\nsyntax error at /tmp/tmphc26fglu.pl line 69, at EOF\nExecution of /tmp/tmphc26fglu.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    my($min_index_odd, $min_value_odd) = 0;\n    my($min_index_even_odd, $min_value_even_odd) = 0;\n    my($min_index_even_odd_even, $min_value_even_odd_even) = 0;\n    my($min_index_even_odd_odd, $min_value_even_odd_odd) = 0;\n    my($min_index_even_odd_even_odd, $min_value_even_odd_even_odd) = 0;\n    my($min_index_even_odd_odd_even, $min_value_even_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd, $min_value_even_odd_odd_odd) = 0;\n    my($min_index_even_odd_odd_even_odd, $min_value_even_odd_odd_even_odd) = 0;\n    my($min_index_even_odd_odd_odd_even_odd, $min_value_even_odd_odd_odd_even_odd) = 0;\n    my($min_index_even_odd_odd_odd_even_odd_even, $min_value_even_odd_odd_odd_even_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_even_odd_odd, $min_value_even_odd_odd_odd_even_odd_odd) = 0;\n    my($min_index_even_odd_odd_odd_even_odd_odd_even, $min_value_even_odd_odd_odd_even_odd_odd_even) = 0;\n    my($min_index_even_odd_odd_odd_even_odd_odd_odd, $min_value_even_odd_odd_odd_even_odd_odd_odd) = 0;\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpth4p68ge.pl line 84, at end of line\nsyntax error at /tmp/tmpth4p68ge.pl line 84, at EOF\nExecution of /tmp/tmpth4p68ge.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $min_even) {\n                $min_even = $node;\n                $min_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($min_even == 0) {\n        $result = [$min_index, $min_even];\n    } else {\n        $result = [$min_index, $min_even, $min_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even = $node % 2;\n        if ($even == 0) {\n            $min_even = $node;\n            $min_index = $node;\n            $min_value = $node;\n            $min_index_value = $node;\n            $min_index_value_index = $node;\n        } else if ($even < $min_even) {\n            $min_even = $node;\n            $min_index = $node;\n            $min_value = $node;\n            $min_index_value = $node;\n            $min_index_value_index = $node;\n        } else if ($even == $min_even) {\n            if ($node < $min_index_value) {\n                $min_index_value = $node;\n                $min_index_value_index = $node;\n            }\n            if ($node < $min_index) {\n                $min_index = $node;\n                $min_index_value = $node;\n                $min_index_value_index = $node;\n            }\n        }\n    }\n    if ($min_index_value_index == 0) {\n        return [$min_value, $min_index];\n    } else {\n        return [$min_index_value, $min_index_value_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp8tu3j50i.pl line 44, near \"else if\"\nsyntax error at /tmp/tmp8tu3j50i.pl line 50, near \"} else\"\nsyntax error at /tmp/tmp8tu3j50i.pl line 60, near \"}\"\nExecution of /tmp/tmp8tu3j50i.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($index, $value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    my($min_index_odd, $min_value_odd) = 0;\n    my($min_index_even_index, $min_value_even_index) = 0;\n    my($min_index_odd_index, $min_value_odd_index) = 0;\n    foreach my $node (@$arr) {\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $index;\n                $min_even_value = $value;\n            }\n            else {\n                if ($value < $min_even_value) {\n                    $min_even_index = $index;\n                    $min_even_value = $value;\n                }\n            }\n        }\n        else {\n            if ($min_value == 0) {\n                $min_index = $index;\n                $min_value = $value;\n            }\n            else {\n                if ($value < $min_value) {\n                    $min_index = $index;\n                    $min_value = $value;\n                }\n            }\n        }\n        $index += 1;\n        $value += $node;\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_value, $min_even_index];\n    }\n    else {\n        if ($min_value == 0) {\n            return [$min_value, $min_index];\n        }\n        else {\n            if ($min_even_value < $min_value) {\n                return [$min_even_value, $min_even_index];\n            }\n            else {\n                if ($min_even_value == $min_value) {\n                    if ($min_even_index < $min_index) {\n                        return [$min\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpcyua2r53.pl line 79, at end of line\nsyntax error at /tmp/tmpcyua2r53.pl line 79, near \"$min\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpcyua2r53.pl line 118, at end of line\nsyntax error at /tmp/tmpcyua2r53.pl line 118, at EOF\nExecution of /tmp/tmpcyua2r53.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n            else if ($node == $min_even_value) {\n                $min_even_index = $node;\n            }\n        }\n        else {\n            if ($node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            }\n            else if ($node == $min_value) {\n                $min_index = $node;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_index, $min_value];\n    }\n    else {\n        return [$min_even_index, $min_even_value];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp2w19kiud.pl line 36, near \"else if\"\nsyntax error at /tmp/tmp2w19kiud.pl line 40, near \"else\"\nsyntax error at /tmp/tmp2w19kiud.pl line 45, near \"else\"\nExecution of /tmp/tmp2w19kiud.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == 0 || $min_even > $node) {\n                $min_even = $node;\n                $min_index = $node;\n            }\n        } else {\n            if ($min_value == 0 || $min_value > $node) {\n                $min_value = $node;\n                $min_index_value = $node;\n                $min_index_index = $node;\n            }\n        }\n    }\n    if ($min_even == 0) {\n        return [$min_value, $min_index_index];\n    } else {\n        return [$min_even, $min_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_even_index) = 0;\n    my($min_index_index) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_value_index) = 0;\n    my($min_index_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpi5ycmkfa.pl line 48, at end of line\nsyntax error at /tmp/tmpi5ycmkfa.pl line 48, near \"$min_index_index_value_index_value_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpi5ycmkfa.pl line 87, at end of line\nsyntax error at /tmp/tmpi5ycmkfa.pl line 87, at EOF\nExecution of /tmp/tmpi5ycmkfa.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            } else if ($node == $smallest_even_value) {\n                if ($node < $smallest_index) {\n                    $smallest_index = $node;\n                }\n            }\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [ $smallest_even_value, $smallest_index ];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp1ukmu0jh.pl line 35, near \"else if\"\nsyntax error at /tmp/tmp1ukmu0jh.pl line 38, near \"else if\"\nsyntax error at /tmp/tmp1ukmu0jh.pl line 43, near \"}\"\nsyntax error at /tmp/tmp1ukmu0jh.pl line 50, near \"}\"\nExecution of /tmp/tmp1ukmu0jh.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    my($min_index_even, $min_value_even) = 0;\n    my($min_index_odd, $min_value_odd) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            continue;\n        }\n        my $even_value = $node % 2;\n        if ($even_value == 0) {\n            if ($min_even_value == 0) {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            } else {\n                $min_even_index = $min_even_index;\n                $min_even_value = $min_even_value;\n            }\n        } else if ($even_value == 1) {\n            if ($min_even_value == 0) {\n                $min_even_index = $node;\n                $min_even_value = $node;\n            } else {\n                $min_even_index = $min_even_index;\n                $min_even_value = $min_even_value;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_value == 1) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_value == 2) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_value == 3) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_value == 4) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_value == 5) {\n        return [$min_even_value, $min_even_index];\n    }\n    if ($min_even_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpc6_1ew5o.pl line 45, near \"else if\"\nsyntax error at /tmp/tmpc6_1ew5o.pl line 49, near \"} else\"\nsyntax error at /tmp/tmpc6_1ew5o.pl line 53, near \"}\"\n\"use\" not allowed in expression at /tmp/tmpc6_1ew5o.pl line 74, at end of line\nMissing right curly or square bracket at /tmp/tmpc6_1ew5o.pl line 113, at end of line\nExecution of /tmp/tmpc6_1ew5o.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n        }\n        $index++;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    } else {\n        $result = [ $smallest_even_value, $smallest_index ];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpway071nr.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpway071nr.pl line 48, near \"}\"\nExecution of /tmp/tmpway071nr.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_even_index) = 0;\n    my($smallest_index, $smallest_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            $smallest_even_value = $node;\n            $smallest_even_index = $node;\n        } else {\n            $smallest_index = $node;\n            $smallest_value = $node;\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return [$smallest_index, $smallest_value];\n    } else {\n        return [$smallest_even_index, $smallest_even_value];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        my $value = $node;\n        if ($value % 2 == 0) {\n            if ($value < $smallest_even_value) {\n                $smallest_even_value = $value;\n                $smallest_index = $index;\n            }\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value) {\n        $result = [$smallest_even_value, $smallest_index];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_value, $smallest_index_index) = 0;\n    my($smallest_index_value_index, $smallest_index_index_index) = 0;\n    my($smallest_index_value_index_index) = 0;\n    my($smallest_index_value_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($smallest_index_value_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp_0j9yrjb.pl line 46, at end of line\nsyntax error at /tmp/tmp_0j9yrjb.pl line 46, near \"$smallest_index_value_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp_0j9yrjb.pl line 85, at end of line\nsyntax error at /tmp/tmp_0j9yrjb.pl line 85, at EOF\nExecution of /tmp/tmp_0j9yrjb.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_for_even_value) = 0;\n    my($smallest_index_for_odd_value) = 0;\n    my($smallest_index_for_zero) = 0;\n    my($smallest_index_for_non_zero) = 0;\n    my($smallest_index_for_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_even) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_odd) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_zero) = 0;\n    my($smallest_index_for_non_zero_non_zero_non_zero_non_zero_non_zero) = 0\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpgk2ij7w_.pl line 49, at end of line\nsyntax error at /tmp/tmpgk2ij7w_.pl line 49, near \"use Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpgk2ij7w_.pl line 88, at end of line\nsyntax error at /tmp/tmpgk2ij7w_.pl line 88, at EOF\nExecution of /tmp/tmpgk2ij7w_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    my($min_index_value) = -1;\n    my($min_index_index) = -1;\n    my($min_index_index_value) = -1;\n    my($min_index_index_index) = -1;\n    my($min_index_index_index_value) = -1;\n    my($min_index_index_index_index) = -1;\n    my($min_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = -1;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = -1;\n    my($min_index_index_index_index_index_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpdb6m_xi3.pl line 52, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 52, near \"$min_index_index_index_index_index_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpdb6m_xi3.pl line 91, at end of line\nsyntax error at /tmp/tmpdb6m_xi3.pl line 91, at EOF\nExecution of /tmp/tmpdb6m_xi3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_even_index) = 0;\n    my($smallest_index, $smallest_value) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_even_index = $node;\n            }\n            if ($node < $smallest_value) {\n                $smallest_value = $node;\n                $smallest_index = $node;\n            }\n        }\n    }\n    if ($smallest_even_value == 0) {\n        $result = [ $smallest_index, $smallest_value ];\n    } else {\n        $result = [ $smallest_even_index, $smallest_even_value ];\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_index) = 0;\n    my($min_even_value_index) = 0;\n    my($min_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_value_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_value_index = $node;\n            }\n        }\n        if ($min_index == 0) {\n            $min_index = $node;\n            $min_index_index = $node;\n        } else if ($node < $min_index) {\n            $min_index = $node;\n            $min_index_index = $node;\n        }\n    }\n    if ($min_even_value_index == 0) {\n        return [$min_even_value, $min_index_index];\n    } else {\n        return [$min_even_value, $min_even_value_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpiqqgl9h1.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpiqqgl9h1.pl line 44, near \"else if\"\nsyntax error at /tmp/tmpiqqgl9h1.pl line 48, near \"}\"\nExecution of /tmp/tmpiqqgl9h1.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even_value, $min_even_index) = 0;\n    my($min_index, $min_value) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even_value == 0) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            } else if ($node < $min_even_value) {\n                $min_even_value = $node;\n                $min_even_index = $node;\n            }\n        } else {\n            if ($min_value == 0) {\n                $min_value = $node;\n                $min_index = $node;\n            } else if ($node < $min_value) {\n                $min_value = $node;\n                $min_index = $node;\n            }\n        }\n    }\n    if ($min_even_value == 0) {\n        return [$min_even_index, $min_even_index];\n    } else if ($min_value == 0) {\n        return [$min_index, $min_index];\n    } else {\n        return [$min_even_index, $min_index];\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpxu9mw5v0.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpxu9mw5v0.pl line 39, near \"} else\"\nsyntax error at /tmp/tmpxu9mw5v0.pl line 43, near \"} else\"\nsyntax error at /tmp/tmpxu9mw5v0.pl line 46, near \"}\"\nExecution of /tmp/tmpxu9mw5v0.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_even_value_index) = 0;\n    my($smallest_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_even_value_index = $node;\n            }\n            else if ($node == $smallest_even_value) {\n                $smallest_even_value_index = $node;\n            }\n        }\n        if ($node < $smallest_index) {\n            $smallest_index = $node;\n            $smallest_index_index = $node;\n        }\n        else if ($node == $smallest_index) {\n            $smallest_index_index = $node;\n        }\n    }\n    return [$smallest_even_value_index, $smallest_index_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmp35wzzr2_.pl line 37, near \"else if\"\nsyntax error at /tmp/tmp35wzzr2_.pl line 45, near \"else if\"\nsyntax error at /tmp/tmp35wzzr2_.pl line 48, near \"}\"\nExecution of /tmp/tmp35wzzr2_.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($index) = 0;\n    my($result) = [];\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $index;\n            }\n            $index += 1;\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    }\n    $result = [$smallest_even_value, $smallest_index];\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_index_value) = 0;\n    my($min_index_index_index_index) = 0;\n    my($min_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index) = 0;\n    my($min_index_index_index_index_index_index_index_index_index_index_index_value) = 0;\n    my($min_index\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpop9sg36a.pl line 53, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 53, near \"$min_index\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpop9sg36a.pl line 92, at end of line\nsyntax error at /tmp/tmpop9sg36a.pl line 92, at EOF\nExecution of /tmp/tmpop9sg36a.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even, $min_index) = 0;\n    my($min_even_index) = 0;\n    my($min_index_index) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index_value) = 0;\n    my($min_index_index_value_index) = 0;\n    my($min_index_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index_value_index_value\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmpi5ycmkfa.pl line 48, at end of line\nsyntax error at /tmp/tmpi5ycmkfa.pl line 48, near \"$min_index_index_value_index_value_index_value_index_value\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmpi5ycmkfa.pl line 87, at end of line\nsyntax error at /tmp/tmpi5ycmkfa.pl line 87, at EOF\nExecution of /tmp/tmpi5ycmkfa.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_even_value, $index) = 0;\n    my($smallest_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($node < $smalest_even_value) {\n                $smalest_even_value = $node;\n                $index = $smallest_index;\n            }\n            if ($node < $smalest_even_value) {\n                $smalest_even_value = $node;\n                $index = $smallest_index;\n            }\n        }\n        $smallest_index += 1;\n    }\n    return [ $smalest_even_value, $index ];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value) = 0;\n    my($smallest_index) = 0;\n    my($plucked_node) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpo698mxdc.pl line 70, at end of line\nsyntax error at /tmp/tmpo698mxdc.pl line 70, at EOF\nExecution of /tmp/tmpo698mxdc.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "Missing right curly or square bracket at /tmp/tmpe17gskey.pl line 69, at end of line\nsyntax error at /tmp/tmpe17gskey.pl line 69, at EOF\nExecution of /tmp/tmpe17gskey.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($result) = [];\n    my($index) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $index];\n            $index += 1;\n        } else if ($node % 2 == 0) {\n            $smallest_even_value = $node;\n            $smallest_index = $index;\n        }\n        $index += 1;\n    }\n    if ($smallest_even_value == 0) {\n        return $result;\n    } else {\n        my $result = [$smallest_even_value, $smallest_index];\n        return $result;\n    }\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpshze1j8m.pl line 35, near \"else if\"\nsyntax error at /tmp/tmpshze1j8m.pl line 47, near \"}\"\nExecution of /tmp/tmpshze1j8m.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = -1;\n    my($min_index) = -1;\n    my($min_value) = -1;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($min_even == -1 || $node < $min_even) {\n                $min_even = $node;\n                $min_index = $node;\n            }\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n    }\n    return [$min_even, $min_index];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smalest_value, $index) = 0;\n    my($result) = [];\n    my($i) = 0;\n    foreach my $node (@$arr) {\n        if ($node == 0) {\n            $result = [$node, $i];\n            $smalest_value = $node;\n            $index = $i;\n            continue;\n        }\n        if ($node % 2 == 0) {\n            $smalest_value = $node;\n            $index = $i;\n        }\n        $i++;\n    }\n    return $result;\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_index) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_index_index) = 0;\n    my($min_index_index_value_index) = 0;\n    my($min_index_index_value_index_index) = 0;\n    my($min_index_index_value_index_value) = 0;\n    my($min_index_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index_index_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index_index_index_index_index) = 0;\n    my($min_index_index_value_index_value_index_value_index_value_index_index_index_index_index_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp7a7fndgu.pl line 50, at end of line\nsyntax error at /tmp/tmp7a7fndgu.pl line 50, near \"$min_index_index_value_index_value_index_value_index_value_index_index_index_index_index_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp7a7fndgu.pl line 89, at end of line\nsyntax error at /tmp/tmp7a7fndgu.pl line 89, at EOF\nExecution of /tmp/tmp7a7fndgu.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min_even) = 0;\n    my($min_index) = 0;\n    my($min_value) = 0;\n    my($min_index_value) = 0;\n    my($min_index_value_index) = 0;\n    my($min_index_value_index_value) = 0;\n    my($min_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index) = 0;\n    my($min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmphbprhni3.pl line 48, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 48, near \"$min_index_value_index_value_index_value_index_value_index_value_index_value_index_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmphbprhni3.pl line 87, at end of line\nsyntax error at /tmp/tmphbprhni3.pl line 87, at EOF\nExecution of /tmp/tmphbprhni3.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_of_smallest_even_value) = 0;\n    my($smallest_index_of_smallest_even_value_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array) = 0;\n    my($smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\"use\" not allowed in expression at /tmp/tmp7twwguet.pl line 41, at end of line\nsyntax error at /tmp/tmp7twwguet.pl line 41, near \"$smallest_index_of_smallest_even_value_in_array_in_array_in_array_in_array_in_array_in_array_\nuse Test::Deep\"\nMissing right curly or square bracket at /tmp/tmp7twwguet.pl line 80, at end of line\nsyntax error at /tmp/tmp7twwguet.pl line 80, at EOF\nExecution of /tmp/tmp7twwguet.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    },
    {
      "program": "# \"Given an array representing a branch of a tree that has non-negative integer nodes\n# your task is to pluck one of the nodes and return it.\n# The plucked node should be the node with the smallest even value.\n# If multiple nodes with the same smallest even value are found return the node that has smallest index.\n# The plucked node should be returned in an array, [ smalest_value, its index ],\n# If there are no even values or the given array is empty, return [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($smallest_even_value, $smallest_index) = 0;\n    my($smallest_index_value) = 0;\n    my($smallest_index_index) = 0;\n    foreach my $node (@$arr) {\n        if ($node % 2 == 0) {\n            if ($smallest_even_value == 0) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            } else if ($node < $smallest_even_value) {\n                $smallest_even_value = $node;\n                $smallest_index = $node;\n            }\n        }\n    }\n    if ($smallest_even_value == 0) {\n        return [];\n    } else {\n        $smallest_index_value = $smallest_even_value;\n        $smallest_index_index = $smallest_index;\n    }\n    foreach my $node (@$arr) {\n        if ($node == $smallest_index_value) {\n            $smallest_index_value = $node;\n            $smallest_index_index = $node;\n        }\n    }\n    return [ $smallest_index_value, $smallest_index_index ];\n}\n\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "syntax error at /tmp/tmpuym7ssvf.pl line 36, near \"else if\"\nsyntax error at /tmp/tmpuym7ssvf.pl line 55, near \"}\"\nExecution of /tmp/tmpuym7ssvf.pl aborted due to compilation errors.\n",
      "exit_code": 255,
      "status": "Exception"
    }
  ]
}