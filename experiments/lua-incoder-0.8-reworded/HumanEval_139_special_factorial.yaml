name: HumanEval_139_special_factorial
language: lua
prompt: "-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n!\
  \ * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial(4)\n\
  -- 288\n-- The function will receive an integer as input and should return the special\n\
  -- factorial of this integer.\nlocal function special_factorial(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = special_factorial\n\
  \    lu.assertEquals(candidate(4), 288)\n    lu.assertEquals(candidate(5), 34560)\n\
  \    lu.assertEquals(candidate(7), 125411328000)\n    lu.assertEquals(candidate(1),\
  \ 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n < 2 then\n    return 1\n  end\n  local result = 1\n  for i =\
    \ 1, n do\n    result = result * (i-1)\n  end\n  return result\nend", "  if n\
    \ == 0 then\n    return 1\n  elseif n < 0 then\n    error(\"Brazilian factorial\
    \ only accept non-negative integers\")\n  elseif n == 1 then\n    return n\n \
    \ else\n    return n * special_factorial(n-1)\n  end\nend", "  assert(n > 1)\n\
    \  local fact = 1\n  for i = 1, n do\n    fact = fact * i\n  end\n  return fact\n\
    end", "   if n == 0 then\n      return 1\n   else\n      return n * special_factorial(n\
    \ - 1)\n   end\nend", "    local n2 = math.floor(n)\n    local f = 1\n    for\
    \ i=1, n2 do\n        f = f * (n-i) * (i+1)\n    end\n    return f\nend", "  if\
    \ n <= 0 then\n    return 1\n  else\n    local fact = 1\n    for i = 1, n do\n\
    \      fact = fact * i\n    end\n    return fact\n  end\nend", "  -- Base Cases\n\
    \  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return n\n  else\n\
    \    -- Recursive Cases\n    return n * special_factorial(n - 1)\n  end\nend",
  "  if n < 2 then\n    return 1\n  end\n  local factorial = 1\n  for i = 2, n do\n\
    \    factorial = factorial * i\n  end\n  return factorial\nend", '  assert(n >
    0, "n must be positive")', "  if n < 2 then\n    return 1\n  elseif n == 1 then\n\
    \    return 1\n  elseif n == 2 then\n    return 2\n  elseif n == 3 then\n    return\
    \ 6\n  else\n    -- We take the fibonacci number of the given number\n    local\
    \ fib = fibonacci(n)\n    local factorial = 1\n    local i = 1\n    while i <\
    \ n do\n      factorial *= fib\n      i = 1\n      fib = fibonacci(n - i)\n  \
    \  end\n    return factorial\n  end\nend", "  if n < 2 then return 1 end\n  local\
    \ result = 1\n  while n > 1 do\n    if n % 2 == 0 then\n      result = result\
    \ * n\n    end\n    n = n / 2\n  end\n  return result\nend", "   if n == 0 then\n\
    \      return 1\n   elseif n == 1 then\n      return n\n   else\n      return\
    \ n * special_factorial(n - 1)\n   end\nend", "  if n == 1 then\n    return 1\n\
    \  else\n    return n * special_factorial(n - 1)\n  end\nend", "    local factorial\
    \ = 1\n    for i = 1, n do\n        factorial = factorial * i\n    end\n    return\
    \ factorial\nend", "  -- Special case of 0\n  if n == 0 then return 1 end\n  --\
    \ Special case for 1\n  if n == 1 then return n end\n  -- Recursive case\n  local\
    \ num = n * special_factorial(n-1)\n  return num\nend", "  local factorial = assert(math.huge,\
    \ \"HUGE is not a number\")\n  for i = 1, n do\n    factorial = factorial * i\n\
    \  end\n  return factorial\nend", "   assert(n > 0)\n   if n < 2 then return 1\n\
    \   else if n <= 20 then return math.factorial(n)\n   else return special_factorial(n\
    \ - 1) * math.factorial(n - 2)\n   end\nend", "  if n == 0 then return 1\n  elseif\
    \ n == 1 then return n\n  elseif n < 0 then error(\"negative factorial\") end\n\
    \  local factorial = 1\n  local factorial_2 = 1\n  for i=1,n do\n    factorial\
    \ = factorial * i\n    factorial_2 = factorial_2 * i\n  end\n  return factorial\
    \ * factorial_2\nend", "    local factorial = math.factorial\n    local power\
    \ = math.power\n    if n == 0 then return 1 end\n    return factorial(n - 1) *\
    \ power(n, n - 1) * power(n - 1, n - 2)\nend", "  if n < 1 then\n    return 1\n\
    \  elseif n < 2 then\n    return 1\n  else\n    return n * special_factorial(n\
    \ - 1)\n  end\nend", "  if n < 1 then return 1 end\n  return n * special_factorial(n\
    \ - 1)\nend", "   assert(n > 0, \"Negative factorial not allowed.\")\n   local\
    \ result = 1\n   for i=1,n do\n      result = result * i\n   end\n   return result\n\
    end", "  if n==0 then return 1 end\n  local fact = 1\n  local i = 1\n  while i<=n\
    \ do\n    fact = fact * i\n    i = i + 1\n  end\n  return fact\nend", "  -- BASE\
    \ CASE\n  if n == 0 then\n    return 1\n  end", "  assert(n > 0, 'n must be positive')\n\
    \  -- TODO: replace with pcall(require,'luarocks.loader') and call factorial()\
    \ from C?\n  return assert(require'luarocks.loader')['factorial'](n)\nend", "\t\
    local fact = 1\n\tlocal k = n\n\twhile k > 0 do\n\t\tfact = fact * (k - 1)\n\t\
    \tk = k - 1\n\tend\n\treturn fact\nend", "    local fact = 1\n    for i=1,n do\
    \ fact = fact*i end\n    return fact\nend", "\tlocal fact = 1\n\tlocal i = 1\n\
    \twhile i <= n do\n\t\tfact = fact * i\n\t\ti = i + 1\n\tend\n\treturn fact\n\
    end", "  if n ~= 0 then\n    local fact = 1\n    for i = 1, n do\n      fact =\
    \ fact * (i + 1)\n    end\n    return fact\n  else\n    error('Brazilian factorial\
    \ not defined for 0!')\n  end\nend", "    assert(n > 0)\n    local factorial =\
    \ 1\n    for i = 2, n do\n        factorial = factorial * i\n    end\n    return\
    \ factorial\nend", "  if n < 0 then\n    error('factorial_error: input must be\
    \ an integer >= 0')\n  end\n  if n==0 then\n    return 1\n  end\n  return n *\
    \ special_factorial(n-1)\nend", "\t-- The factorial of a number is the product\
    \ of its digits, starting from one:\n\t-- > factorial(12)\n\t-- 720\n\t-- As factorials\
    \ are multiplicative, this means that the product of digits in a\n\t-- number\
    \ will also result in a number. For example, 12! = 720 = 24 * 12 * 12\n\t-- =\
    \ 720 * 12 = 720**2.\n\t-- Hence, factorials should never be called on a number\
    \ less than 1.", "  assert(n > 0, \"You must insert a positive integer\")\n  if\
    \ n==1 then\n    return 1\n  else\n    return n * special_factorial(n-1)\n  end\n\
    end", "    local result = 1\n    for i=1, n do\n        result = result * (n-i)\n\
    \    end\n    return result\nend", "   assert(n > 0, 'Input must be positive')\n\
    \   local factorial = 1\n   for i = 2, n do\n      factorial = factorial * i\n\
    \   end\n   return factorial\nend", "  if n == 0 then\n    return 1\n  elseif\
    \ n == 1 then\n    return n\n  else\n    return n * special_factorial(n - 1)\n\
    \  end\nend", "  assert(n >= 0, 'Negative factorial encountered.')\n  if n ==\
    \ 0 then return 1 end\n  if n == 1 then return 1 end\n  return n * special_factorial(n\
    \ - 1)\nend", "  if n == 0 then return 1\n  elseif n == 1 then return n\n  else\
    \ return n * special_factorial(n-1)\n  end\nend", "   if n < 1 then return 0 end\n\
    \   if n == 1 then return 1 end\n   return n * special_factorial(n-1)\nend", "\t\
    if n <= 1 then\n\t\treturn 1\n\telse\n\t\treturn n * special_factorial(n - 1)\n\
    \tend\nend", "   assert(type(n) == \"number\")\n   assert(n >= 0)\n   \n   if\
    \ n < 1 then\n      return 1\n   end", "  if n <= 1 then\n    return 1\n  else\n\
    \    local result = 1\n    for i = 1, n do\n      result = result * i\n    end\n\
    \    return result\n  end\nend", "  assert(n > 1)\n  local nfact = 1\n  for i\
    \ = 2, n do\n    nfact = nfact * i\n  end\n  return nfact\nend", "    if n < 2\
    \ then\n        return 1\n    end", "   if n <= 0 then return 0 end\n   local\
    \ factorial = 1\n   for i=1,n do\n      factorial = factorial * (i-1)\n   end\n\
    \   return factorial\nend", "  local product = 1\n  local i = 1\n  while i <=\
    \ n do\n    product = product * i\n    i = i + 1\n  end\n  return product\nend",
  "\t-- If n is 0 then return 1.\n\tif n == 0 then\n\t\treturn 1\n\tend", "  local\
    \ result = 1\n  for i=1, n do\n    result = result * (n - i) * (i + 1)\n  end\n\
    \  return result\nend", "  if n <= 1 then\n    return 1\n  else\n    return n*special_factorial(n-1)\n\
    \  end\nend", "\tif n == 0 then return 1 end\n\tlocal factorial = special_factorial(n\
    \ - 1)\n\treturn n * factorial\nend", "  if n < 1 then return 0 end\n  local factorial\
    \ = 1\n  for i = 1, n do\n    factorial = factorial * (i - 1)\n  end\n  return\
    \ factorial\nend", "  if n < 0 then\n    error(\"special_factorial: invalid input\"\
    )\n  end\n  if n==0 then\n    return 1\n  else\n    return n * special_factorial(n\
    \ - 1)\n  end\nend", "\tif n == 0 then return 1 end\n\tlocal factorial = 1\n\t\
    for i = 1, n do factorial = factorial * (i - 1) end\n\treturn factorial\nend",
  "  if n <= 0 then\n    return 0\n  end\n  local factorial = 1\n  for i = 2, n do\n\
    \    factorial = factorial * i\n  end\n  return factorial\nend", "  -- Special\
    \ case when n is 0\n  if n == 0 then\n    return 1\n  end", "  if n < 1 then return\
    \ 0 end\n  local factorial = 1\n  for i = n, 1, -1 do\n    factorial = factorial\
    \ * i\n  end\n  return factorial\nend", "    assert(n > 1, 'Input must be greater\
    \ than 1')\n    local fact = 1\n    for i = 2, n do\n        fact = fact * i\n\
    \    end\n    return fact\nend", "   assert(n > 0, \"Factorial of a non-positive\
    \ integer is undefined\")\n   if n < 0 then return 0 end\n   local result = 1\n\
    \   if n == 1 then return result end\n   for i = 2, n do\n      result = result\
    \ * i\n   end\n   return result\nend", "  assert(n > 0, 'Brazilian factorial only\
    \ defined for positive integers')\n  if n == 0 then\n    return 1\n  end\n  if\
    \ n == 3 then\n    return 6\n  end\n  return n * special_factorial(n-1)\nend",
  "    if n == 0 then\n        return 1\n    else\n        return n * special_factorial(n\
    \ - 1)\n    end\nend", "  if n < 1 then\n    return 1\n  else\n    local result\
    \ = 1\n    local factorial_n = math.factorial(n)\n    for i = 1, n do\n      result\
    \ = result * i\n      result = result * factorial_n\n    end\n    return result\n\
    \  end\nend", "    local result = 1\n    local factorial = 1\n    for i = 1, n\
    \ do\n        factorial = factorial * i\n        result = result + factorial\n\
    \    end\n    return result\nend", "  if n < 2 then\n    return 1\n  else\n  \
    \  local mult = 1\n    for i=3,n,1 do\n      mult = mult*i\n    end\n    return\
    \ mult\n  end\nend", "  if n == 0 or n == 1 then\n    return 1\n  elseif n < 0\
    \ then\n    return nil\n  else\n    return n * special_factorial(n - 1)\n  end\n\
    end", "  if n < 0 then\n    return nil\n  elseif n == 0 then\n    return 1\n \
    \ elseif n < 10 then\n    return n\n  elseif n < 100 then\n    return n * special_factorial(n\
    \ - 10)\n  elseif n < 100 then\n    return n * special_factorial(n - 100)\n  else\n\
    \    return n * special_factorial(n - 1000)\n  end\nend", "   assert(n > 0, \"\
    factorial function receives positive integer only\")\n   if n == 1 then\n    \
    \  return 1\n   else\n      return factorial(n) * special_factorial(n - 1)\n \
    \  end\nend", "\tassert(n >= 0, \"special_factorial requires a non-negative integer\"\
    )\n\tassert(n > 0, \"special_factorial requires a positive integer\")", "  if\
    \ n < 2 then\n    return 1\n  else\n    return n * special_factorial(n - 1)\n\
    \  end\nend", "  assert(n ~= nil, \"Factorial not defined for 0!\")\n  assert(n\
    \ >= 0, \"Factorial not defined for negative numbers!\")\n  if n == 0 then\n \
    \   return 1\n  end\n  local fac = 1\n  for _ = 1, n do\n    fac *= _\n  end\n\
    \  return fac\nend", "    local fact = 1\n    for i=1,n do\n        fact = fact\
    \ * (i-1)\n    end\n    return fact\nend", "  if n < 0 then\n    error('negative\
    \ factorials are not valid')\n  end", "  assert(type(n) == \"number\")\n  assert(n\
    \ > 0)\n  if n == 0 then\n    return 1\n  else\n    return math.factorial(n)\n\
    \  end\nend", "   assert(n > 0, \"factorial of negative number\")\n   local factorial_table\
    \ = {}\n   factorial_table[1] = 1\n   for i = 2, n do\n      factorial_table[i]\
    \ = factorial_table[i - 1] * i\n   end\n   return factorial_table[n]\nend", " \
    \ if n < 1 then return 1 end\n  return n * special_factorial(n - 1)\nend", " \
    \ if n==0 then\n    return 1\n  else\n    return n * special_factorial(n-1)\n\
    \  end\nend", "  if n <= 1 then return 1 end\n  local factorial = 1\n  -- Only\
    \ a small subset of powers of n can be factorials.\n  -- See http://en.wikipedia.org/wiki/Factorial#Table_of_common_factors\n\
    \  -- For now we just use the table of common factors.\n  assert(special_factors[n\
    \ / 2], 'Table of common factors is missing')\n  local i = special_factors[n /\
    \ 2]\n  while i do\n    factorial = factorial * i\n    i = special_factors[n -\
    \ i]\n  end\n  return factorial\nend", "    if n == 0 then\n        return 1\n\
    \    end", "  local factorial = 1\n  for i = 2, n do\n    factorial = factorial\
    \ * i\n  end\n  return factorial\nend", "\tassert(n >= 0, 'n should be a non-negative\
    \ number')\n\tif n < 1 then\n\t\treturn 1\n\telseif n <= 2 then\n\t\treturn n\n\
    \telse\n\t\treturn special_factorial(n - 1) * n\n\tend\nend", "  if n <= 0 then\
    \ return 1 end\n  local product = 1\n  local i = 1\n  repeat\n    product = product\
    \ * i\n    i = i + 1\n  until n > i\n  return product\nend", "\t-- Check that\
    \ n is a positive integer\n\tif n <= 0 then\n\t\terror(\"Invalid input: n should\
    \ be a positive integer\", 2)\n\tend\n\t-- Base Case\n\tif n == 1 then\n\t\treturn\
    \ 1\n\tend\n\t-- Recursive Case\n\treturn n * special_factorial(n - 1)\nend",
  "  if n == 0 then\n    return 1\n  else\n    return factorial(n) * special_factorial(n\
    \ - 1)\n  end\nend", "    assert(n >= 0)\n    local factorial = 1\n    for _ =\
    \ 1, n do\n        factorial *= _\n    end\n    return factorial\nend", "    local\
    \ fact = 1\n    for i = 1, n do\n        fact = fact * (i + 1)\n    end\n    return\
    \ fact\nend", "  if n <= 1 then return 1 end\n  return n * special_factorial(n\
    \ - 1)\nend", "    local factorial = 1\n    local n = n", "   local factorial\
    \ = 1\n   for i = n, 1, -1 do\n      factorial = factorial * i\n   end\n   return\
    \ factorial\nend", "  local fact = 1\n  for i=n,1,-1 do\n    fact = fact * i\n\
    \  end\n  return fact\nend", "  if n == 1 then\n    return 1\n  else\n    return\
    \ n * special_factorial(n - 1)\n  end\nend", "  if n <= 1 then\n    return 1\n\
    \  else\n    return n * special_factorial(n - 1)\n  end\nend", "  if n == 0 then\n\
    \    return 1\n  else\n    return n * special_factorial(n - 1)\n  end\nend", "\t\
    local factorial = 1\n\tfor i = 1, n do\n\t\tfactorial = factorial * i\n\tend\n\
    \treturn factorial\nend", "  assert(n > 0, 'The factorial of the special number\
    \ must be positive.')\n  local fact = 1\n  local k = 1\n  while k + 1 < n do\n\
    \    fact = fact * (k + 1)\n    k = k + 2\n  end\n  return fact\nend", "  local\
    \ factorial = 1\n  for i = 1, n do\n    factorial = factorial * i\n  end\n  return\
    \ factorial\nend", "  assert(n >= 0, \"Negative factorials are not allowed\")\n\
    \  if n == 0 then\n    return 1\n  else\n    local factorial = 1\n    for i =\
    \ 2, n do\n      factorial = factorial * i\n    end\n    return factorial\n  end\n\
    end", "  if n < 2 then\n    return 1\n  elseif n < 5 then\n    return n * special_factorial(n\
    \ - 1)\n  else\n    return special_factorial(n - 1) * math.factorial(n - 2)\n\
    \  end\nend", "    local factorial = math.factorial(n)\n    if n == 0 or n ==\
    \ 1 then\n        return factorial\n    else\n        return factorial * special_factorial(n-1)\n\
    \    end\nend", "    if n < 1 then\n        error()\n    end\n    local result\
    \ = 1\n    for i = 1, n do\n        result = result * i\n    end\n    return result\n\
    end", "  assert(n > 0)\n  local result = 1\n  -- Calculate factorials\n  while\
    \ n > 1 do\n    local tmp_result = n * result\n    result = tmp_result\n    n\
    \ = n - 1\n  end\n  return result\nend", "   if n < 0 then\n      return nil,\
    \ \"The special factorial can not be calculated for negative numbers\"\n   else\n\
    \      return special_factorial(n - 1) * math.factorial(n)\n   end\nend", "  \
    \  if n == 0 then\n        return 1\n    end", "  if n <= 0 then error(\"factorial\
    \ is undefined for n < 0\") end\n  local res = 1\n  for i = 1, n do\n    res =\
    \ res * i\n  end\n  return res\nend", "  if n == 0 or n == 1 then\n    return\
    \ 1\n  else\n    return n * special_factorial(n - 1)\n  end\nend", "   if n ==\
    \ 0 then\n      return 1\n   elseif n == 1 then\n      return n\n   elseif n ==\
    \ 2 then\n      return n * n\n   else\n      return n * special_factorial(n -\
    \ 1)\n   end\nend", "  assert(n > 0, \"Factorial of a negative number not defined.\"\
    )\n  return n * factorial(n-1)\nend", "   if n == 0 then\n      return 1\n   else\n\
    \      return n * special_factorial(n-1)\n   end\nend", "    if n == 0 then\n\
    \        return 1\n    end\n    \n    return n * special_factorial(n - 1)\nend",
  "    if n==0 then\n        return 1\n    elseif n==1 then\n        return 1\n  \
    \  else\n        return n*special_factorial(n-1)\n    end\nend", "  if n <= 1\
    \ then\n    return 1\n  end\n  local i = 1\n  local factorial = 1\n  while i <=\
    \ n do\n    factorial = factorial * (n - i)\n    i = i + 1\n  end\n  return factorial\n\
    end", "  if n < 2 then\n    return 1\n  else\n    return (math.math.factorial(n))\n\
    \  end\nend", "\tif n ~= 0 then\n\t\tif n < 0 then\n\t\t\treturn 1\n\t\telse\n\
    \t\t\tlocal factorial = 1\n\t\t\t-- This loop will continue until n >= 0, at which\
    \ point the\n\t\t\t-- factorial will be equal to the value of n!\n\t\t\tfor i\
    \ = 1, n do\n\t\t\t\tfactorial = factorial * (i - 1)\n\t\t\tend\n\t\t\treturn\
    \ factorial\n\t\tend\n\telse\n\t\terror('Brazilian factorial undefined for n <=\
    \ 0')\n\tend\nend", "\tif n == 0 then return 1 end\n\tif n == 2 then return 2\
    \ end\n\treturn n * special_factorial(n - 1)\nend", "   assert(n > 0, \"Brazilian\
    \ factorial is only defined for positive integers\")\n   return assert(math.factorial(math.abs(n)),\
    \ \"Brazilian factorial is not defined for negative or 0 integers\")\nend", " \
    \ if n < 2 then\n    return 1\n  else\n    local factorial_table = {\n      [1]\
    \ = 1,\n      [2] = 1,\n      [3] = 2,\n      [4] = 6,\n      [5] = 24,\n    \
    \  [6] = 120,\n      [7] = 720,\n      [8] = 5040,\n      [9] = 40320,\n     \
    \ [10] = 362880,\n      [11] = 3628800,\n      [12] = 39916800,\n      [13] =\
    \ 479001600,\n      [14] = 6227020800,\n      [15] = 87178291200,\n      [16]\
    \ = 1307674368000\n    }\n    local factorial = 1\n    for i = 2, n do\n     \
    \ factorial = factorial_table[i] * factorial\n    end\n    return factorial\n\
    \  end\nend", "  local i\n  local factorial = 1\n  for i = 1, n do\n    factorial\
    \ = factorial * i\n  end\n  return factorial\nend", "    local factorial = 1\n\
    \    for i = 1, n do\n        factorial = factorial * i\n    end\n    return factorial\n\
    end", "  if n < 0 then\n    error(\"argument must be positive\", n)\n  end\n \
    \ local factorial = 1\n  for i=1,n do\n    factorial = factorial * i\n  end\n\
    \  return factorial\nend", "  -- Special factorial is defined as n! (n factorial)\n\
    \  -- Where n is a positive integer\n  -- We do some checks to ensure that n is\
    \ an integer\n  -- TODO: Checks n is not zero\n  -- TODO: Checks n is not negative\n\
    \  -- TODO: Checks n is a positive integer\n  if n == 0 then\n    return 1\n \
    \ else\n    -- TODO: Implement the factorial method using the recursive approach\n\
    \    -- Hint: Look at the formula above!\n  end\nend", "  local factorial = 1\n\
    \  for i = 2, n do\n    factorial = factorial * (i - 1)\n  end\n  return factorial\n\
    end", "  -- This table is aproximated using the formula (n+1)! = n.(n+1)!(n.(n+1)!)\n\
    \  -- However, since factorials grow very slowly for large numbers, the\n  --\
    \ intermediate values computed up to 10 (the default value) won't be used.\n \
    \ local factorials = math.max(10, math.floor((math.pow(n + 1, 1) - 1) / 2))\n\
    \  for i = 1, factorials do\n    factorials = factorials * (i + 2)\n  end\n  return\
    \ factorials\nend", "\tlocal fact = 1\n\tfor i = 1, n do\n\t\tfact = fact * i\n\
    \tend\n\treturn fact\nend", "  assert(n > 0, 'Input must be positive')\n  if n\
    \ == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n  elseif n == 2\
    \ then\n    return 2\n  else\n    return n * special_factorial(n - 1)\n  end\n\
    end", "  local factorial = 1\n  for i = n, 0, -1 do\n    factorial = factorial\
    \ * i\n  end\n  return factorial\nend", "    local factorial = 1\n    for i =\
    \ 1, n do\n        factorial = factorial * (i + 1)\n    end\n    return factorial\n\
    end", "    local n2 = math.floor(n/2)\n    local factorial = 1\n    for i = 1,\
    \ n2 do\n        factorial = factorial * i\n    end\n    return factorial\nend",
  "  assert(n > 0, \"special_factorial function cannot work with negative values\"\
    )\n  local fact = 1\n  for i = 1, n do\n    fact = fact * i\n  end\n  return fact\n\
    end", "  if n < 1 then return 0 end\n  local fact = 1\n  for i= 1, n do\n    fact\
    \ = fact * i\n  end\n  return fact\nend", "    if n == 0 then\n        return\
    \ 1\n    elseif n == 1 then\n        return n\n    end\n    local factorial =\
    \ 1\n    for i = 2, n do\n        factorial = factorial * (i - 1)\n    end\n \
    \   return factorial\nend", "  if n == 1 then\n    return 1\n  end", "  if n <\
    \ 0 then\n    return error(\"Negative argument\", tostring(n))\n  end\n  local\
    \ factorial = 1\n  for i = 1, n do\n    factorial = factorial * i\n  end\n  return\
    \ factorial\nend", "    local fact = 1\n    for i = 1, n do\n        fact = fact\
    \ * (i + 1)\n    end\n    return fact\nend", "  assert(n >= 0)\n  local fact =\
    \ 1\n  for i=2,n do\n    fact = fact * i\n  end\n  return fact\nend", "  -- Initialize\
    \ a variable\n  local factorial = 1\n  -- Check for 0\n  if n == 0 then\n    return\
    \ factorial\n  end\n  -- Calculate n!\n  for i = 1, n do\n    factorial = factorial\
    \ * i\n  end\n  -- Return factorial\n  return factorial\nend", "  local factorial\
    \ = 1\n  for i = 1, n do\n    factorial = factorial * i\n  end\n  return factorial\n\
    end", "  local fact = 1\n  for i=1,n do\n    fact = fact * (i-1)\n  end\n  return\
    \ fact\nend", "    assert(n >= 0 and n <= 100, \"Only accept positive integers\"\
    )\n    if n == 0 then\n        return 1\n    end\n    return n * special_factorial(n\
    \ - 1)\nend", "  assert(n > 0)\n  local factorial = 1\n  local factorial_of_n\
    \ = 1\n  for i = 1, n do\n    factorial = factorial * i\n    factorial_of_n =\
    \ factorial_of_n * i\n  end\n  return factorial * factorial_of_n\nend", "    local\
    \ factorial = 1\n    for i = 1, n do\n        factorial *= i\n    end\n    return\
    \ factorial\nend", "  if n < 0 then return 1 end\n  if n == 0 then return 1 end\n\
    \  if n <= 1 then return n end\n  return n * special_factorial(n - 1)\nend", " \
    \ if n < 2 then\n    return 1\n  else\n    local factorial = 1\n    for i = 2,\
    \ n do\n      factorial = factorial * i\n    end\n    return factorial\n  end\n\
    end", "  if n == 1 then\n    return 1\n  elseif n == 0 then\n    return 0\n  elseif\
    \ n == -1 then\n    return 0\n  elseif n < 0 then\n    return 0\n  end", "\t--\
    \ Special case\n\tif n == 0 then\n\t\treturn 1\n\tend\n\t-- Compute the factorial\
    \ of the given number\n\tlocal f = math.factorial(n)\n\t-- Compute the factorial\
    \ of the given number raised to the power of the given number\n\tlocal fac = f\n\
    \tfor i = n, 1, -1 do\n\t\tfac = fac * i\n\tend\n\treturn fac\nend", "  if n <\
    \ 2 then return 1 end\n  local factorial_ = 1\n  for i = 1, n do\n    factorial_\
    \ = factorial_ * (i - 1) * (n - i)\n  end\n  return factorial_\nend", "  if n==0\
    \ then\n    return 1\n  else\n    return n*special_factorial(n-1)\n  end\nend",
  "    if n == 0 then\n        return 1\n    elseif n < 0 then\n        return error(\"\
    The argument must be positive\")\n    elseif n <= 1 then\n        return n\n \
    \   elseif n == 2 then\n        return special_factorial(n - 1) * n\n    else\n\
    \        return special_factorial(n - 1) * n + special_factorial(n - 2)\n    end\n\
    end", "    local factorial = 1\n    for i=1, n do\n        factorial = factorial\
    \ * i\n    end\n    return factorial\nend", "    local factorial = 1\n    for\
    \ i = 1, n do\n        factorial = factorial * i\n    end\n    return factorial\n\
    end", "  if n < 2 then\n    return 1\n  elseif n == 2 then\n    return 4\n  else\n\
    \    return n * special_factorial(n - 1)\n  end\nend", "  if n < 2 then\n    return\
    \ 1\n  else\n    local fact = 1\n    for i = 1, n do\n      fact = fact * (i +\
    \ 1)\n    end\n    return fact\n  end\nend", "    if n < 0 then\n        return\
    \ nil\n    end", "    if n <= 1 then return 1 else n*special_factorial(n-1) end\n\
    end", "  assert(n > 0)\n  local fact = 1\n  for i = 1, n do\n    fact = fact *\
    \ (i-1) * (n-i)\n  end\n  return fact\nend", "  if n <= 1 then return 1 end\n\
    \  return n * special_factorial(n - 1)\nend", "  -- Initialize factorial to 1\n\
    \  local factorial = 1\n  -- Initialize a counter variable to be 1\n  local counter\
    \ = 1\n  -- Loop while counter is less than or equal to n\n  while counter <=\
    \ n do\n    -- Increment factorial\n    factorial = factorial * counter\n    --\
    \ Decrement counter\n    counter = counter + 1\n  end\n  return factorial\nend",
  "    local fact = 1\n    \n    for i=1,n do fact = fact*i end", "  if n < 0 then\n\
    \    error(\"The integer must be positive!\")\n  elseif n < 1 then\n    return\
    \ 1\n  else\n    return n * special_factorial(n - 1)\n  end\nend", "   if n ==\
    \ 0 or n == 1 then\n      return 1\n   end\n   return n * special_factorial(n-1)\n\
    end", "  assert(n >= 0)\n  if n == 1 then return 1 end\n  local fact = 1\n  local\
    \ i\n  for i=1, n do\n    fact = fact * (n-i+1)\n  end\n  return fact\nend", " \
    \  -- Special case zero\n   if n == 0 then\n      return 1\n   end", "  if n <\
    \ 0 then\n    print(\"ERROR: function special_factorial(n) receives an invalid\
    \ argument.\")\n  elseif n == 0 then\n    return 1\n  elseif n == 1 then\n   \
    \ return 1\n  elseif n == 2 then\n    return 2\n  elseif n % 2 == 0 then\n   \
    \ return special_factorial(n - 1) * n\n  else\n    return special_factorial(n\
    \ / 2) * n * n\n  end\nend", "  if n < 1 then\n    return 1\n  elseif n < 3 then\n\
    \    return n\n  else\n    return special_factorial(n-1) * special_factorial(n-2)\n\
    \  end\nend", "   if n < 0 then\n      return nil, \"n must be > 0\"\n   end\n\
    \   if n == 0 then\n      return 1\n   else\n      return math.factorial(n)\n\
    \   end\nend", "  if n < 0 then\n    error(\"factorial(): n must be >= 0\")\n\
    \  end", "  if n < 0 then\n    error(\"the argument must be positive\")\n  end",
  "    if n == 0 then\n        return 1\n    elseif n == 1 then\n        return n\n\
    \    else\n        return special_factorial(n - 1) * n\n    end\nend", "  if n\
    \ < 2 then\n    return 1\n  elseif n < 4 then\n    return special_factorial(n-1)\
    \ * n\n  else\n    return special_factorial(n-1) * special_factorial(n-2) * math.pow(n,\
    \ 3)\n  end\nend", "  if n == 0 then\n    return 1\n  end\n  local result\n  if\
    \ n == 1 then\n    result = 1\n  else\n    result = n * special_factorial(n-1)\n\
    \  end\n  return result\nend", "    local fact = 1\n    repeat\n        fact =\
    \ fact * n\n        n = n - 1\n    until n == 0\n    return fact\nend", "  assert(n\
    \ >= 0, 'Negative factorial is not defined')\n  local factorial = 1\n  for i =\
    \ 1, n do\n    factorial = factorial * i\n  end\n  return factorial\nend", " \
    \ if n <= 1 then\n    return 1\n  else\n    local factorial = 1\n    for i = 1,\
    \ n do\n      factorial = factorial * i\n    end\n    return factorial\n  end\n\
    end", "  local fact = 1\n  for i = 1, n do\n    fact = fact * (n - i)\n  end\n\
    \  return fact\nend", "  local factorial = 1\n  for i = n, 1, -1 do\n    factorial\
    \ = factorial * i\n  end\n  return factorial\nend", "  assert(n > 0, \"Cannot\
    \ compute factorial of negative numbers\")\n  local fact = 1\n  for i = 1, n do\n\
    \    fact = fact * (i+1)\n  end\n  return fact\nend", "  -- If the argument is\
    \ negative, we must treat it as a non-negative negative integer\n  -- since factorials\
    \ are defined for positive integers.\n  -- Note: Lua numbers are actually integers\
    \ but the function returns a float\n  if n <= 0 then\n    return special_factorial(math.abs(n))\n\
    \  end", "  assert(n > 0)\n  local result = 1\n  local i = 1\n  while i <= n do\n\
    \    result = result * (n - i)\n    i = i + 1\n  end\n  return result\nend", " \
    \ -- We calculate the factorial recursively\n  -- To save memory, we compute in\
    \ reverse\n  local factorial_result = 1\n  for i = n, 1, -1 do\n    factorial_result\
    \ = factorial_result * (i - 1) * i\n  end\n  return factorial_result\nend", " \
    \   local fact = 1\n    for i = 1, n do\n        fact = fact * (i-1)\n    end\n\
    \    return fact\nend", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n\
    \    return 1\n  else\n    return n * special_factorial(n - 1)\n  end\nend", " \
    \   local factorial = 1\n    local n = 1", "    local fact = 1\n    for i = 2,\
    \ n do\n        fact = fact * i\n    end\n    return fact\nend", "\tlocal factorial\
    \ = 1\n\tfor i = n, 1, -1 do\n\t\tfactorial = factorial * i\n\tend\n\treturn factorial\n\
    end", "  if n < 2 then return 1 end\n  return n * special_factorial(n-1)\nend",
  "  assert(n >= 0, 'Input negative or equal to zero')\n  local factorial = 1\n  while\
    \ n > 1 do\n    factorial = factorial * n\n    n = n - 1\n  end\n  return factorial\n\
    end", "  if n < 1 then\n    return 1\n  end", "    if n < 1 then\n        error('The\
    \ number should be greater than 0.')\n    end\n    local factorial = 1\n    local\
    \ i\n    for i = 2, n do\n        factorial = factorial * (i - 1)\n    end\n \
    \   return factorial\nend", "\t-- Return 0 factorial since 0! is 1.\n\tif n ==\
    \ 0 then\n\t\treturn 0\n\tend", "  if n < 2 then\n    return 1\n  else\n    return\
    \ n * special_factorial(n - 1)\n  end\nend", "    local fact = 1\n    for _ =\
    \ 1, n do\n        fact = fact * factorial(_)\n    end\n    return fact\nend",
  "\t-- If the input is a number smaller than the factorial of the\n\t-- factorial\
    \ of the factorial...\n\tif n < 1 then\n\t\treturn 1\n\tend", "   if n == 1 then\n\
    \      return 1\n   else\n      return n * special_factorial(n-1)\n   end\nend",
  "  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n  else\n  \
    \  return n * special_factorial(n - 1)\n  end\nend", "  if n < 1 then return 1\
    \ end\n  local factorial = factorial(1)\n  for i = 1, n do\n    factorial = factorial\
    \ * i\n  end\n  return factorial\nend", "   assert(n > 1, 'Error: factorial of\
    \ a negative integer is undefined.')\n   local f = 1\n   for i = 1, n do\n   \
    \   f = f * i\n   end\n   return f\nend", "    if n <= 0 then\n        return\
    \ 0\n    end\n    local fact = 1\n    local i = 1\n    while i <= n do\n     \
    \   fact = fact * i\n        i = i + 1\n    end\n    return fact\nend", "  if\
    \ n < 2 then return 1 end\n  local factorial = 1\n  for i = n, 1, -1 do\n    factorial\
    \ = factorial * i\n  end\n  return factorial\nend", "  if n == 0 then\n    return\
    \ 1\n  elseif n < 0 then\n    return special_factorial(-n)\n  else\n    return\
    \ factorial(math._factorial(n))\n  end\nend", "    if n == 0 then\n        return\
    \ 1\n    elseif n < 0 then\n        print(\"Error: Special factorial of a negative\
    \ integer cannot be computed.\")\n        return nil\n    end\n    if n == 1 then\n\
    \        return 1\n    else\n        return n * special_factorial(n - 1)\n   \
    \ end\nend", "  if n == 0 then return 1 end\n  local n1 = n - 1\n  local n2 =\
    \ n1 - 1\n  local n3 = n2 - 1\n  local n4 = n3 - 1\n  local n5 = n4 - 1\n  local\
    \ n6 = n5 - 1\n  local n7 = n6 - 1\n  local n8 = n7 - 1\n  local n9 = n8 - 1\n\
    \  local n10 = n9 - 1\n  local n11 = n10 - 1\n  local n12 = n11 - 1\n  local n13\
    \ = n12 - 1\n  local n14 = n13 - 1\n  local n15 = n14 - 1\n  local n16 = n15 -\
    \ 1\n  local n17 = n16 - 1\n  local n18 = n17 - 1\n  local n19 = n18 - 1\n  local\
    \ n20 = n19 - 1\n  local n21 = n20 - 1\n  local n22 = n21 - 1\n  local n23 = n22\
    \ - 1\n  local n24 = n23 - 1\n  local n25 = n24 - 1\n  local n26 = n25 - 1\n \
    \ local n27 = n26 - 1\n  local n28 = n27 - 1\n  local n29 = n28 - 1\n  local n30\
    \ = n29 - 1\n  local n31 = n30 - 1\n  local n32 = n31 - 1\n  local n33 = n32 -\
    \ 1\n  local n34 = n33 - 1\n  local n35 = n34 - 1\n  local n36 = n35 - 1\n  local\
    \ n37 = n36 - 1\n  local n38 = n37 - 1\n  local n39 = n38 - 1\n  local n40 = n39\
    \ - 1\n  local n41 = n40 - 1\n  local n42 = n41 - 1\n  local n43 = n42 - 1\n \
    \ local n44 = n43 - 1\n  local n45 = n44 - 1\n  local n46 = n45 - 1\n  local n47\
    \ = n46 - 1\n  local n48 = n47 - 1\n  local n49 = n48 - 1\n  local n50 = n49 -\
    \ 1\n  local n51 = n50 - 1\n  local n52 = n51 - 1\n  local n53 = n52 - 1\n  local\
    \ n54 = n53 - 1\n  local n55 = n54 - 1\n  local n56 = n55 - 1\n  local n57 = n56\
    \ - 1\n  local n58 = n57 - 1\n  local n59 = n58 - 1\n  local n60 = n59 - 1\n \
    \ local n61 = n60 - ", "  assert(n > 0, 'Expected an integer greater than 0.')\n\
    \  local factorial = 1\n  for _ = 1, n do\n    factorial = factorial * _\n  end\n\
    \  return factorial\nend", "  assert(n >= 0, 'Negative factorial cannot be calculated.')\n\
    \  assert(n > 0, 'Negative factorial cannot be calculated.')\n  local fact = 1\n\
    \  for i = 1, n do\n    fact = fact * (i - 1)\n  end\n  return fact\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
