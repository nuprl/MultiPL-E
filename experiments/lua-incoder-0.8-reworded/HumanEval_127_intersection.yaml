name: HumanEval_127_intersection
language: lua
prompt: "-- You are given two intervals,\n-- where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed\
  \ which means that the interval (start, end)\n-- includes both start and end.\n\
  -- For each given interval, it is assumed that its start is less or equal its end.\n\
  -- Your task is to determine whether the length of intersection of these two \n\
  -- intervals is a prime number.\n-- Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n--\
  \ If the length of the intersection is a prime number, return \"YES\",\n-- otherwise,\
  \ return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output]\
  \ samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1,\
  \ 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal\
  \ function intersection(interval1, interval2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n\
  \    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1,\
  \ 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n\
  \    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11,\
  \ 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n \
  \   lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2,\
  \ -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tassert(type(interval1) == \"table\", \"interval1 should be a table\"\
    )\n\tassert(type(interval2) == \"table\", \"interval2 should be a table\")\n\t\
    \n\tlocal interval1Length = interval1.end - interval1.start + 1 -- length of the\
    \ interval 1\n\tlocal interval2Length = interval2.end - interval2.start + 1 --\
    \ length of the interval 2\n\t\n\t-- if the length of interval2 is bigger than\
    \ interval1\n\tif interval2Length > interval1Length then\n\t\t-- return the length\
    \ of interval1 as it's intersection\n\t\treturn interval1Length\n\tend", "   \
    \ local i1 = interval1[1]\n    local i2 = interval2[1]\n    local e1 = interval1[2]\n\
    \    local e2 = interval2[2]\n    if i2 <= i1 then\n        return 'NO'\n    end\n\
    \    if e1 <= i2 then\n        return 'NO'\n    end\n    if e1 < e2 then\n   \
    \     return 'YES'\n    end\n    return 'YES'\nend", "    if interval1[1] < interval2[1]\
    \ then return 'NO' end\n    if interval2[1] < interval1[1] then return 'NO' end\n\
    \    local start1, end1 = interval1[1], interval1[2]\n    local start2, end2 =\
    \ interval2[1], interval2[2]\n    if start1 < end2 and start2 < end1 then return\
    \ 'NO' end\n    if start1 > end2 then start2, end2 = end2, start2\n    local middle1,\
    \ middle2 = start2 + 1, end2 - 1\n    while middle1 <= middle2 do\n        if\
    \ start1 <= middle1 and middle1 <= end1 then\n            if start2 <= middle2\
    \ and middle2 <= end2 then\n                return middle1\n            else\n\
    \                middle1 = middle1 + 1\n            end\n        else\n      \
    \      if start2 <= middle1 and middle1 <= end2 then\n                middle1\
    \ = middle1 + 1\n            else\n                middle2 = middle2 - 1\n   \
    \         end\n        end\n    end\n    return 'YES'\nend\n</cell>\n<text>\n\
    Let's test our function by running the following samples:", "  local start = interval1[1]\n\
    \  local end = interval2[2]", "    local result = 'NO'\n    if interval1[1] <\
    \ interval2[1] then\n        result = 'NO'\n    elseif interval1[1] == interval2[1]\
    \ then\n        if interval1[2] < interval2[2] then\n            result = 'NO'\n\
    \        elseif interval1[2] == interval2[2] then\n            if interval1[3]\
    \ <= interval2[3] then\n                result = 'YES'\n            else\n   \
    \             result = 'NO'\n            end\n        end\n    end\n    return\
    \ result\nend\n</cell>\n<text>\nProblem 3", "    local len1 = math.abs(interval1[1]\
    \ - interval1[0])\n    local len2 = math.abs(interval2[1] - interval2[0])\n  \
    \  local lenIntersection = len1 - len2\n    local isPrime = false\n    if lenIntersection\
    \ == 0 then\n        return \"NO\"\n    end\n    if lenIntersection == 1 then\n\
    \        if interval1[1] < interval2[1] then\n            return \"NO\"\n    \
    \    else\n            return \"YES\"\n        end\n    end\n    for i = 2, lenIntersection\
    \ do\n        if interval1[1] % i == 0 then\n            if interval2[1] % i ==\
    \ 0 then\n                isPrime = true\n                break\n            end\n\
    \        end\n    end\n    if isPrime then\n        return \"YES\"\n    end\n\
    \    return \"NO\"\nend", "  if interval1 then\n    if interval2[1] then\n   \
    \   if interval2[2] then\n        return interval1[1] >= interval2[1] and interval1[2]\
    \ <= interval2[2]\n      else\n        return interval1[1] >= interval2[1]\n \
    \     end\n    else\n      return interval1[1] <= interval2[2]\n    end\n  else\n\
    \    return interval2[1]\n  end\nend", "\tif interval1[1] < interval2[2] and interval1[2]\
    \ < interval2[1]\n\tand interval1[2] < interval2[2] and interval1[2] < interval2[1]\n\
    \tand interval1[1] < interval2[1] and interval1[1] < interval2[2]\n\tand interval1[1]\
    \ < interval2[2] and interval1[1] < interval2[1]\n\tthen\n\t\treturn 'NO'\n\t\
    else\n\t\treturn 'YES'\n\tend\nend", "\tlocal length = math.max(interval1[1],\
    \ interval2[1]) - math.min(interval1[1], interval2[1])\n\tif interval1[1] == interval2[1]\
    \ then\n\t\tif interval1[2] == interval2[2] then\n\t\t\treturn length == 2\n\t\
    \telse\n\t\t\treturn length == 3\n\t\tend\n\telse\n\t\treturn length == 2\n\t\
    end\nend", "\tlocal len1 = interval1[1]:sub(1, interval1[1]:len() - 1)\n\tlocal\
    \ len2 = interval2[1]:sub(1, interval2[1]:len() - 1)\n\tif len1 > len2 then\n\t\
    \treturn \"NO\"\n\tend\n\tfor i = 1, len1 + 1 do\n\t\tif interval1[1]:sub(i) ==\
    \ interval2[1]:sub(i) then\n\t\t\treturn \"NO\"\n\t\tend\n\tend\n\tif len1 < len2\
    \ then\n\t\treturn \"NO\"\n\tend\n\treturn \"YES\"\nend", "\t-- start from small\
    \ to large\n\tlocal start = tonumber(interval1[1])\n\tlocal end = tonumber(interval1[2])\n\
    \tlocal start1 = tonumber(interval2[1])\n\tlocal end1 = tonumber(interval2[2])",
  "  -- [array] returns array\n  -- [string] returns string\n  -- [number] returns\
    \ number\n  -- [table] returns table\n  -- [boolean] returns boolean\n  -- [array]\
    \ return array\n  -- [string] return string\n  -- [number] return number\n  --\
    \ [table] return table\n  -- [boolean] return boolean\n  -- [boolean] return boolean\n\
    \  -- [array] return array\n  -- [string] return string\n  -- [number] return\
    \ number", "\tif interval1[1] > interval2[1] then \n\t\treturn \"NO\"\n\tend\n\
    \tif interval1[1] < interval2[1] then\n\t\tinterval1, interval2 = interval2, interval1\n\
    \tend\n\t\n\tlocal l1, l2 = interval1[1], interval2[1]\n\t\n\tif l1 == l2 then\n\
    \t\treturn \"YES\"\n\tend\n\t\n\tlocal i, j = 0, 0\n\t\n\twhile i < l1 and j <\
    \ l2 do\n\t\tif i < l1 and j < l2 then\n\t\t\tlocal t1, t2 = interval1[i], interval2[j]\n\
    \t\t\tif t1 <= t2 then\n\t\t\t\ti = i + 1\n\t\t\telse\n\t\t\t\tj = j + 1\n\t\t\
    \tend\n\t\telse\n\t\t\tif i < l1 then\n\t\t\t\ti = i + 1\n\t\t\telse\n\t\t\t\t\
    j = j + 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\tif i == l1 and j == l2 then \n\t\t\
    return \"NO\"\n\tend\n\t\n\tif i < l1 then\n\t\treturn \"YES\"\n\tend\n\t\n\t\
    if j < l2 then\n\t\treturn \"YES\"\n\tend\n\t\n\treturn \"YES\"\nend", "    local\
    \ start = min(interval1[1], interval2[1]) \n    local end = max(interval1[2],\
    \ interval2[2])\n    \n    local intersect = false\n    if start <= end then\n\
    \        intersect = true\n        for i = start, end do\n            if start\
    \ <= i && i <= end then\n                intersect = true\n            end\n \
    \       end\n    end\n    \n    if intersect then \n        local len = 0\n  \
    \      for i = start, end do \n            if start <= i then\n              \
    \  len = len + 1\n            end\n        end\n        \n        if len == 2\
    \ or len == 3 or len == 5 then\n            return 'YES'\n        else\n     \
    \       return 'NO'\n        end\n    else\n        return 'NO'\n    end\nend\n\
    </cell>\n<code language=julia-1.4>\n# Run this cell to test your solution\nsamples\
    \ = [(-10, 10), (3, 8), (2, 3), (4, 13), (6, 7), (9, 11), (7, 7), (3, 5), (3,\
    \ 6), (6, 9), (3, 5), (3, 9)]\nprintln(\"Results:\")\nfor test in samples \n \
    \   answer = intersection(test[1], test[2])\n    println(\"Answer:\", answer)\n\
    \    println(\"Test case: \", test)\nend\n</cell>\n<text>\n2.2 Solution using\
    \ set function", "  if interval1[1] < interval2[1] then\n    return interval1[1]\
    \ <= interval2[1] and \"YES\" or \"NO\"\n  else\n    return interval2[1] <= interval1[1]\
    \ and \"YES\" or \"NO\"\n  end\nend", "\tlocal start = math.min(interval1.start,\
    \ interval2.start)\n\tlocal end = math.max(interval1.end, interval2.end)\n\treturn\
    \ math.abs(end - start) == 2\nend", "  local length = interval1[1]:intersect(interval2[1])\n\
    \  if length == 0 then\n    return \"NO\"\n  else\n    if interval1[1] < interval2[1]\
    \ and interval1[1] ~= interval2[1] then\n      length = length + 1\n    end\n\
    \    if interval1[2] <= interval2[2] then\n      length = length + 1\n    end\n\
    \    local start = interval1[1]:intersect(interval2[1])\n    if start ~= length\
    \ then\n      return \"NO\"\n    end\n    local end = interval1[2]:intersect(interval2[2])\n\
    \    if end ~= length then\n      return \"NO\"\n    end\n    return \"YES\"\n\
    \  end\nend", "  if interval1[1] < interval2[0] then\n    return nil\n  elseif\
    \ interval1[1] == interval2[0] then\n    return interval1[1]\n  elseif interval1[1]\
    \ > interval2[1] then\n    return nil\n  end", "\tif interval1[1] < interval2[1]\
    \ then\n\t\tlocal temp = interval1[1]\n\t\tinterval1[1] = interval2[1]\n\t\tinterval2[1]\
    \ = temp\n\tend\n\tif interval1[2] > interval2[2] then\n\t\tlocal temp = interval1[2]\n\
    \t\tinterval1[2] = interval2[2]\n\t\tinterval2[2] = temp\n\tend\n\tlocal count\
    \ = 0\n\tfor i = interval1[1], interval2[2], 1 do count = count + 1 end\n\treturn\
    \ count\nend", "   if interval1[1] == interval2[1] then\n      return interval1[2]\
    \ >= interval2[2] and interval1[2] <= interval2[1]\n   else\n      return interval1[1]\
    \ < interval2[1] or interval1[1] > interval2[2]\n   end\nend", "  if interval1[1]\
    \ < interval2[1] or interval1[2] > interval2[2] then\n    return 'NO'\n  else\n\
    \    local i1start = interval1[1]\n    local i1end = interval1[2]\n    local i1length\
    \ = i1end - i1start + 1\n    local i2start = interval2[1]\n    local i2end = interval2[2]\n\
    \    local i2length = i2end - i2start + 1\n    local i1count = 0\n    local i2count\
    \ = 0\n    local isPrime = 1\n    for i = i1start + 1, i1end - 1 do\n      for\
    \ j = i2start + 1, i2end - 1 do\n        if i == j then\n          i1count = i1count\
    \ + 1\n        elseif j < i then\n          i2count = i2count + 1\n        else\n\
    \          local m = (j - i + 1) / 2\n          if m == 1 then -- j and i are\
    \ equal\n            if isPrime == 1 then\n              isPrime = isPrime + 1\n\
    \            else\n              isPrime = isPrime - 1\n            end\n    \
    \      end\n        end\n      end\n      if isPrime == 0 then return 'NO' end\n\
    \      isPrime = 1\n    end\n    if i1count == i2count then\n      return 'YES'\n\
    \    else\n      return 'NO'\n    end\n  end\nend", "   local interval1 = interval1[1]\n\
    \   local interval2 = interval2[1]\n   local interval1Start = interval1[1]\n \
    \  local interval1End = interval1[2]\n   local interval2Start = interval2[1]\n\
    \   local interval2End = interval2[2]\n   if interval1Start <= interval2End then\n\
    \      local interval1End = interval1End\n      local interval2Start = interval2Start\n\
    \      local interval2End = interval2End\n   end\n   local interval1Length = interval1End\
    \ - interval1Start + 1\n   local interval2Length = interval2End - interval2Start\
    \ + 1\n   if interval1Length == interval2Length then\n      for i, v in ipairs(interval1Start:interval1End)\
    \ do\n         for j, w in ipairs(interval2Start:interval2End) do\n          \
    \  if v == w then\n               interval1Length += 1\n            end\n    \
    \     end\n      end\n      if interval1Length % 2 = 0 then\n         if interval1Length\
    \ > 1 then\n            return \"YES\"\n         else\n            return \"NO\"\
    \n         end\n      else\n         return \"NO\"\n      end\n   else\n     \
    \ return \"NO\"\n   end\nend", "  return interval1[1] > interval2[1] and interval1[1]\
    \ < interval2[2] or interval1[2] > interval2[1] and interval1[2] < interval2[2]\
    \ or interval1[1] == interval2[1] and interval1[2] == interval2[2] or interval1[2]\
    \ > interval2[1] and interval1[2] < interval2[1] and interval1[1] == interval2[1]\
    \ and interval1[2] < interval2[2]\nend", "  if interval1.start >= interval2.end\
    \ and interval1.end <= interval2.start then\n    return 'NO'\n  elseif interval1.start\
    \ < interval2.start then\n    return intersection(interval2, interval1)\n  elseif\
    \ interval1.end > interval2.end then\n    return intersection(interval1, interval2)\n\
    \  else\n    local commonInterval = interval1:findCommon(interval2)\n    return\
    \ 'YES' -- if commonInterval.count ~= 1 then\n  end \nend", "    if interval1\
    \ ~= interval2 then\n        if interval1[1] < interval2[1] then\n           \
    \ if interval1[2] < interval2[2] then\n                return \"YES\"\n      \
    \      end\n            return nil\n        end\n        return \"NO\"\n    end",
  "  -- Your code here\n  local start1 = interval1[1]\n  local end1 = interval1[2]\n\
    \  local start2 = interval2[1]\n  local end2 = interval2[2]\n  if start1 > end2\
    \ or start2 > end1 then\n    return nil\n  end\n  if start1 == end1 or start2\
    \ == end2 then\n    return nil\n  end", "  if interval1[1] < interval1[2] then\n\
    \    return interval1[2]\n  end\n  if interval2[1] < interval2[2] then\n    return\
    \ interval2[2]\n  end\n  local intersection = interval1[1]\n  local interval1End\
    \ = interval1[2]\n  local interval2Start = interval2[1]\n  local interval2End\
    \ = interval2[2]\n  while not (interval1End < interval2Start or interval2End <\
    \ interval1Start) do\n    local newIntersection = intersection + 1\n    if newIntersection\
    \ > interval2End then\n      interval2End = newIntersection\n    elseif newIntersection\
    \ < interval2Start then\n      interval2Start = newIntersection\n    end\n  end\n\
    \  if interval1End >= interval2Start and interval2End >= interval1Start then\n\
    \    return interval2End - interval1End\n  end\n  return 0\nend", "  assert(interval1\
    \ ~= nil and interval2 ~= nil, \"Intervals are nil\")\n  if interval1 == interval2\
    \ then\n    return \"NO\"\n  end", "\tlocal count1 = #interval1\n\tlocal count2\
    \ = #interval2\n\tif (count1 < 2 or not count2) and (count2 < 2 or not count1)\
    \ then\n\t\treturn 'NO'\n\tend\n\t\n\tlocal total = 0\n\tlocal i = 0\n\twhile\
    \ i < count1 and i < count2 do\n\t\ttotal = total + interval1[i] * interval2[i]\n\
    \t\ti = i + 1\n\tend\n\t\n\t-- check if it is prime\n\tif (count1 == 1 or count2\
    \ == 1) then\n\t\treturn 'NO'\n\telseif (total % 2 == 1) then\n\t\treturn 'YES'\n\
    \telse\n\t\treturn 'NO'\n\tend\nend", "\tif interval2[1] < interval1[1] or interval2[2]\
    \ < interval1[2] then\n\t\treturn 'NO'\n\tend\n\tif interval1[1] == interval2[1]\
    \ and interval1[2] == interval2[2] then\n\t\tif interval1[1] > interval2[1] and\
    \ interval1[1] > interval2[2] then\n\t\t\treturn 'YES'\n\t\telse\n\t\t\treturn\
    \ 'NO'\n\t\tend\n\tend\n\tif interval2[1] > interval1[1] and interval2[2] > interval1[2]\
    \ then\n\t\treturn 'NO'\n\tend\n\tif interval1[1] > interval2[1] and interval1[2]\
    \ > interval2[2] then\n\t\treturn 'NO'\n\tend\n\tif interval1[1] < interval2[1]\
    \ and interval1[2] < interval2[2] then\n\t\treturn 'NO'\n\tend\n\tif interval1[1]\
    \ < interval2[1] and interval1[2] > interval2[2] then\n\t\treturn 'NO'\n\tend\n\
    \tif interval1[1] == interval2[1] and interval1[2] < interval2[2] then\n\t\treturn\
    \ 'NO'\n\tend\n\tif interval1[1] > interval2[1] and interval1[2] < interval2[2]\
    \ then\n\t\treturn 'NO'\n\tend\n\tif interval1[1] > interval2[1] and interval1[2]\
    \ > interval2[2] then\n\t\treturn 'NO'\n\tend\n\tif interval1[1] == interval2[1]\
    \ and interval1[2] > interval2[2] then\n\t\treturn 'YES'\n\tend\n\treturn 'YES'\n\
    end", "    local intersect = {}\n    if interval1[1] < interval2[0] then\n   \
    \     intersect[1] = interval1[1]\n        intersect[2] = interval2[1]\n    else\n\
    \        intersect[1] = interval2[1]\n        intersect[2] = interval1[1]\n  \
    \  end\n    if intersect[2] < intersect[1] then -- if the second interval is completely\
    \ in first interval\n        intersect[1] = intersect[2]\n        intersect[2]\
    \ = interval1[1]\n    end\n    local length = math.abs(intersect[2] - intersect[1])\
    \ -- find the length of the intersection between the given two intervals\n   \
    \ for i = 2, #intersect do\n        if intersect[i] > intersect[i-1] then\n  \
    \          length = length + math.abs(intersect[i] - intersect[i-1])\n       \
    \ end\n    end\n    if isPrime(length) then\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend", "\t-- Your code here\n\tif interval1.start\
    \ <= interval1.end then\n\t\tif interval2.start <= interval2.end then\n\t\t\t\
    if interval1.start <= interval2.start then\n\t\t\t\treturn interval1.end - interval2.start\n\
    \t\t\telse\n\t\t\t\treturn interval2.end - interval1.start\n\t\t\tend\n\t\telse\n\
    \t\t\treturn interval2.start - interval1.start\n\t\tend\n\telse\n\t\treturn interval2.end\
    \ - interval1.end\n\tend\nend", "    local start1, end1 = interval1[1], interval1[2]\n\
    \    local start2, end2 = interval2[1], interval2[2]\n    local length_intersection\
    \ = math.abs(start1 - start2) + math.abs(end1 - end2)\n    if length_intersection\
    \ == 0 then\n        return \"NO\"\n    end\n    if start1 <= start2 and end2\
    \ <= end1 then\n        return \"NO\"\n    end\n    if start2 <= start1 and end1\
    \ <= end2 then\n        return \"NO\"\n    end\n    if start1 <= start2 and start2\
    \ <= end1 then\n        return \"NO\"\n    end\n    if end1 <= end2 and end2 <=\
    \ end1 then\n        return \"NO\"\n    end\n    if start1 <= start2 and end1\
    \ > end2 then\n        return \"NO\"\n    end\n    if start2 <= start1 and end1\
    \ > end2 then\n        return \"NO\"\n    end\n    if start1 > start2 and end1\
    \ <= end2 then\n        return \"NO\"\n    end\n    if end1 > end2 and end2 <=\
    \ end1 then\n        return \"NO\"\n    end\n    if start1 > start2 and end1 >\
    \ end2 then\n        return \"YES\"\n    end\n    return \"YES\"\nend", "\tlocal\
    \ start = math.max(interval1[1], interval2[1])\n\tlocal end = math.min(interval1[2],\
    \ interval2[2])\n\tif start >= end then\n\t\treturn \"NO\"\n\tend\n\tlocal length\
    \ = end - start + 1\n\tif length == 1 then\n\t\treturn \"YES\"\n\tend\n\tfor i=2,\
    \ math.floor(math.sqrt(length)) + 1 do\n\t\tif length % i == 0 then\n\t\t\treturn\
    \ \"NO\"\n\t\tend\n\tend\n\treturn \"YES\"\nend", "  -- Your code here\n  local\
    \ interval1start = interval1.start\n  local interval1end = interval1.end\n  local\
    \ interval2start = interval2.start\n  local interval2end = interval2.end\n  local\
    \ start1 = interval1start or interval1\n  local end1 = interval1end or interval1\n\
    \  local start2 = interval2start or interval2\n  local end2 = interval2end or\
    \ interval2\n  local start1start = start1 == start2 or\n    start1 and start2\
    \ and\n    start1 < start2 or\n    start1 == start2 and\n    start2 and\n    start1\
    \ < start2\n  local end1start = end1 == end2 or\n    end1 and end2 and\n    end1\
    \ < end2 or\n    end1 == end2 and\n    end2 and\n    end1 < end2\n  local start1end\
    \ = start1 == end1 or\n    start1 and start2 and\n    start1 < end2 or\n    start1\
    \ == end2 and\n    start2 and\n    start1 < end2\n  local end1end = end1 == start1\
    \ or\n    end1 and end2 and\n    end1 < start2 or\n    end1 == start2 and\n  \
    \  end2 and\n    end1 < start2\n  return not (start1end or end1end or start1start\
    \ or end1start) and\n    not (start1end and end1end and start1start and end1start)\
    \ and\n    not (start1end and end1end and start1start and end1start) and (\n \
    \     start1start == end1start or start1start == end1end or start1end == end1start)\n\
    end", "  if interval1 ~= interval2 and interval1 ~= interval2 then\n    local\
    \ interval1, interval2 = interval1, interval2\n    local start = interval1[1]\n\
    \    local end = interval1[2]\n    local result\n    for i = start, end do\n \
    \     if i ~= end then\n        local temp = i\n        i = end\n        end =\
    \ temp\n      end\n    end\n    local length = end\n    if start < end then\n\
    \      result = \"NO\"\n    else\n      local div = math.huge\n      local check\
    \ = end - 1\n      while check ~= 0 do\n        if length < check and check(div)\
    \ ~= 0 then\n          length = check\n        else\n          local temp = check\n\
    \          check = check(div)\n          div = div / 2\n          temp = temp\
    \ * 2\n          if div >= 1 then\n            div = div - 1\n          end\n\
    \          length = temp\n        end\n      end\n      result = \"YES\"\n   \
    \ end\n    return interval {\"YES\", length}\n  end\nend", "\treturn (interval1[1]\
    \ >= interval2[1] and interval1[1] <= interval2[2] and\n\t\tinterval1[2] >= interval2[1]\
    \ and interval1[2] <= interval2[2])\nend", "  -- Write your code here\n  if interval1[1]\
    \ > interval2[1] then\n    interval1, interval2 = interval2, interval1\n  end",
  "\tif interval1 ~= interval2 then\n\t\tlocal intervals = { interval1, interval2\
    \ }\n\t\tlocal n = #intervals\n\t\tlocal i = 0\n\t\twhile i < n do\n\t\t\tlocal\
    \ interval1 = intervals[i]\n\t\t\tlocal interval2 = intervals[i + 1]\n\t\t\tif\
    \ interval2.start < interval1.end then\n\t\t\t\t-- The intervals (interval1, interval2)\n\
    \t\t\t\t-- do not intersect each other.\n\t\t\t\treturn 'NO'\n\t\t\tend\n\t\t\t\
    -- Find the index of the second interval.\n\t\t\tlocal j = i + 1\n\t\t\twhile\
    \ j < n do\n\t\t\t\tlocal interval = intervals[j]\n\t\t\t\tif interval.start >\
    \ interval2.end then\n\t\t\t\t\t-- The intervals (interval1, interval2)\n\t\t\t\
    \t\t-- do not intersect each other.\n\t\t\t\t\treturn 'NO'\n\t\t\t\tend\n\t\t\t\
    \tif interval.start == interval1.end then\n\t\t\t\t\t-- The intervals (interval1,\
    \ interval2)\n\t\t\t\t\t-- are equal. This is the only case.\n\t\t\t\t\t-- The\
    \ length of intervals is 1.\n\t\t\t\t\t-- We return YES.\n\t\t\t\t\treturn 'YES'\n\
    \t\t\t\tend\n\t\t\t\t-- The intervals (interval1, interval2)\n\t\t\t\t-- do not\
    \ intersect each other.\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\ti = i + 1\n\t\tend\n\
    \tend\n\treturn 'NO'\nend", "    local start = interval1[1]\n    local end = interval1[2]\n\
    \    local start_2 = interval2[1]\n    local end_2 = interval2[2]", "\t-- TODO:\
    \ Write your code here\n\tassert(interval1 ~= nil, \"interval 1 must not be nil\"\
    )\n\tassert(interval2 ~= nil, \"interval 2 must not be nil\")\n\tassert(interval1.start\
    \ <= interval1.end, \"start is less or equal to end\")\n\tassert(interval2.start\
    \ <= interval2.end, \"start is less or equal to end\")\n\t\n\tif interval1.start\
    \ > interval2.start then\n\t\treturn \"NO\"\n\telseif interval1.start <= interval2.start\
    \ then\n\t\tif interval1.end >= interval2.end then\n\t\t\treturn \"YES\"\n\t\t\
    else\n\t\t\treturn \"NO\"\n\t\tend\n\telse\n\t\tif interval1.end >= interval2.end\
    \ then\n\t\t\treturn \"NO\"\n\t\telse\n\t\t\treturn \"YES\"\n\t\tend\n\tend\n\
    end", "\tlocal l1 = interval1[1]\n\tlocal r1 = interval1[2]\n\tlocal l2 = interval2[1]\n\
    \tlocal r2 = interval2[2]", "\t-- initialize interval1\n\tlocal interval1Start\
    \ = interval1.start\n\tlocal interval1End = interval1.end", "  local intersectionLength\
    \ = math.abs(interval1[1]-interval2[1]) * math.abs(interval1[2]-interval2[2])\n\
    \  return math.gcd(intersectionLength, 2) == 1 and \"YES\" or \"NO\"\nend\n</cell>\n\
    <cell>", "  local start, end = interval1[1], interval1[2]\n  local i1, i2 = interval2[1],\
    \ interval2[2]\n  if start < end and i1 < i2 and start <= i2 then\n    return\
    \ start <= i2 and i1 < i2 or start < i2 and start <= i2 and i1 > i2\n  elseif\
    \ start > end or i1 > i2 then\n    return false\n  else\n    return true\n  end\n\
    end", "\tlocal start1 = interval1[1]\n\tlocal end1 = interval1[2]\n\tlocal start2\
    \ = interval2[1]\n\tlocal end2 = interval2[2]\n\t\n\t-- check if both intervals\
    \ are overlapped\n\tif start1 <= end2 then\n\t\treturn start1 <= end1 and start2\
    \ <= end2\n\telse\n\t\treturn start1 <= end1 and start2 >= end2\n\tend\nend",
  "    local s1 = interval1[1]\n    local e1 = interval1[2]\n    local s2 = interval2[1]\n\
    \    local e2 = interval2[2]\n    if s2 <= e1 then return \"NO\" end\n    if e2\
    \ < s1 then return \"NO\" end\n    if e1 < s2 then return \"NO\" end", "\tlocal\
    \ function is_prime(n)\n\t\tif n == 0 then\n\t\t\treturn true\n\t\telse\n\t\t\t\
    local m = math.sqrt(n)\n\t\t\tfor i = 1, m do\n\t\t\t\tif n % i == 0 then\n\t\t\
    \t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\tend\n\
    \tlocal i1start, i1end = interval1[1], interval1[2]\n\tlocal i2start, i2end =\
    \ interval2[1], interval2[2]\n\tlocal i1len = i1end - i1start\n\tlocal i2len =\
    \ i2end - i2start\n\tif i1end <= i2start then\n\t\treturn 'NO'\n\tend\n\tif i1end\
    \ - i2start > 1 then\n\t\tlocal interval1m = (i1start + i1end) / 2\n\t\tlocal\
    \ interval2m = (i2start + i2end) / 2\n\t\tlocal intersection_len = i2end - interval1m\n\
    \t\treturn is_prime(intersection_len)\n\telseif i1end - i2start == 1 then\n\t\t\
    local interval1m = (i1start + i1end) / 2\n\t\tlocal interval2m = i2start\n\t\t\
    local intersection_len = i2end - interval1m\n\t\treturn is_prime(intersection_len)\n\
    \tend\n\t\n\t-- find the intersection\n\tlocal i1m = (i1start + i1end) / 2\n\t\
    local i2m = (i2start + i2end) / 2\n\tlocal intersection_lenm = i2end - i1m\n\t\
    \n\t-- check if both intersection lengths are prime numbers\n\tlocal res\n\tif\
    \ not is_prime(intersection_lenm) then\n\t\tres  = 'NO'\n\telseif not is_prime(intersection_len)\
    \ then\n\t\tres  = 'NO'\n\telse\n\t\t-- check whether both intervals have the\
    \ same length\n\t\tif intersection_lenm == intersection_len then\n\t\t\tres  =\
    \ 'YES'\n\t\telse\n\t\t\t-- check whether one interval is longer than the other\n\
    \t\t\tif i1end - i2start > 1 then\n\t\t\t\tlocal interval1m = (i1start + i1end)\
    \ / 2\n\t\t\t\tlocal interval2m = (i2start + i2end) / 2\n\t\t\t\tlocal intersection_len\
    \ = i2end - interval1m\n\t\t\t\t-- check whether one interval is longer than the\
    \ other\n\t\t\t\tif intersection_lenm == intersection_len then\n\t\t\t\t\tres\
    \  = 'YES'\n\t\t\t\telse\n\t\t\t\t\tres  = 'NO'\n\t\t\t\tend\n\t\t\telse\n\t\t\
    \t\tres  = 'NO'\n\t\t\tend\n\t\tend\n\tend\n\treturn res\nend", "\tif interval1[1]\
    \ < interval1[2] then\n\t\tinterval1 = {interval1[2], interval1[1]}\n\telse\n\t\
    \tinterval1 = {interval1[1], interval1[2]}\n\tend\n\tif interval2[1] < interval2[2]\
    \ then\n\t\tinterval2 = {interval2[2], interval2[1]}\n\telse\n\t\tinterval2 =\
    \ {interval2[1], interval2[2]}\n\tend\n\tif interval1[2] < interval2[2] then\n\
    \t\tlocal temp = interval2[2]\n\t\tinterval2[2] = interval2[1]\n\t\tinterval2[1]\
    \ = temp\n\tend\n\tlocal length = interval2[1] - interval1[1]\n\treturn ((length\
    \ == 1) or ((length == 2) and  ((interval1[1] <= interval2[2]) and (interval1[2]\
    \ <= interval2[1]))) or ((length == 3) and (((interval1[1] >= interval2[2]) and\
    \ (interval1[2] >= interval2[1])) or ((interval1[1] >= interval2[2]) and (interval1[2]\
    \ <= interval2[1])) or ((interval1[1] <= interval2[2]) and (interval1[2] >= interval2[1]))))\
    \ )\nend", "\tlocal intersect = 0\n\tlocal intersectLength = 0\n\tfor i = 1, #interval1\
    \ do\n\t\tif interval1[i] < interval2[i] then\n\t\t\tintersect = intersect + 1\n\
    \t\telseif interval1[i] > interval2[i] then\n\t\t\tintersect = intersect - 1\n\
    \t\telseif interval1[i] == interval2[i] then\n\t\t\tintersectLength = intersectLength\
    \ + 1\n\t\tend\n\tend", "\tlocal num1, num2 = interval1[1], interval2[1]\n\tif\
    \ num1 ~= num2 then\n\t\tif num1 < num2 then\n\t\t\tinterval1[2], interval2[2]\
    \ = interval2[2], interval1[2]\n\t\telse\n\t\t\tinterval1[1], interval2[1] = interval2[1],\
    \ interval1[1]\n\t\tend\n\tend\n\tlocal length = interval1[2]\n\tlocal start1\
    \ = interval1[1]\n\tlocal end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\
    \tlocal end2 = interval2[2]\n\tlocal ans = \"\"\n\tif start1 < end2 and end1 >\
    \ start2 then\n\t\tif length == start1 then\n\t\t\tif end2 < end1 then\n\t\t\t\
    \tans = \"YES\"\n\t\t\telse\n\t\t\t\tans = \"NO\"\n\t\t\tend\n\t\telse\n\t\t\t\
    ans = \"NO\"\n\t\tend\n\telse\n\t\tif end2 < end1 then\n\t\t\tans = \"NO\"\n\t\
    \telse\n\t\t\tif length == start2 then\n\t\t\t\tans = \"YES\"\n\t\t\telse\n\t\t\
    \t\tans = \"NO\"\n\t\t\tend\n\t\tend\n\tend\n\treturn ans\nend", "   -- Write\
    \ your code here\n    local interval1Length = math.abs(interval1[1] - interval1[0])\
    \ -- lengths of both intervals\n    local interval2Length = math.abs(interval2[1]\
    \ - interval2[0])\n    if interval1Length == 0 or interval2Length == 0 then\n\
    \        return 'NO'\n    end\n    local interLength = 0\n    for i = interval1[1]\
    \ + 1, interval1[1] + interval1Length do\n        for j = interval2[1] + 1, interval2[1]\
    \ + interval2Length do\n            interLength = interLength + 1\n          \
    \  if i == j then\n            end\n        end\n    end\n    if interLength ==\
    \ 1 then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend",
  "    if interval1.start > interval2.start then return \"NO\" end\n    if interval1.end\
    \ < interval2.start then return \"NO\" end\n    if interval1.end > interval2.end\
    \ then return \"NO\" end", "\tlocal intersect = interval1[1] > interval2[1] and\
    \ interval1[1] < interval2[2] or\n\tinterval1[2] > interval2[1] and interval1[2]\
    \ < interval2[2] or\n\tinterval1[1] < interval2[1] and interval1[2] < interval2[2]\
    \ or\n\tinterval1[1] > interval2[1] and interval1[1] < interval2[2] or\n\tinterval1[2]\
    \ > interval2[1] and interval1[2] < interval2[2]", "  if interval1[1] < interval2[1]\
    \ then\n    return false\n  elseif interval1[1] > interval2[1] then\n    return\
    \ true\n  end", "    local start1 = interval1[1]\n    local end1 = interval1[2]\n\
    \    local start2 = interval2[1]\n    local end2 = interval2[2]", "\tlocal start,\
    \ end = interval1[1], interval1[2]\n\tlocal start2, end2 = interval2[1], interval2[2]\n\
    \tif start < end2 then\n\t\tif start <= end2 then -- if the given intervals overlap\n\
    \t\t\tlocal length_intersect = math.abs(end - start2)\n\t\t\tif length_intersect\
    \ == 1 then return \"NO\" end\n\t\t\tif length_intersect > 1 and math.gcd(length_intersect,\
    \ 2) == 1 then -- check whether the given interval has common divisor\n\t\t\t\t\
    local length = end - start\n\t\t\t\tif length == 0 then return \"NO\" end\n\t\t\
    \t\treturn \"YES\"\n\t\t\telse\n\t\t\t\treturn \"NO\"\n\t\t\tend\n\t\telse --\
    \ if the given intervals doesn't overlap\n\t\t\tlocal length = end - start\n\t\
    \t\tif length == 0 then return \"NO\" end\n\t\t\treturn \"YES\"\n\t\tend\n\telse\n\
    \t\tif start > end2 then -- if the given intervals overlap\n\t\t\tlocal length\
    \ = end - start2\n\t\t\tif length == 0 then return \"NO\" end\n\t\t\treturn \"\
    YES\"\n\t\telse -- if the given intervals doesn't overlap\n\t\t\tlocal length\
    \ = start2 - start\n\t\t\tif length == 0 then return \"NO\" end\n\t\t\treturn\
    \ \"YES\"\n\t\tend\n\tend\nend", "  if interval1 ~= nil and interval2 ~= nil then\n\
    \tlocal l1 = interval1[1]:tointeger() - interval1[1]:tointeger() + 1\n\tlocal\
    \ l2 = interval2[1]:tointeger() - interval2[1]:tointeger() + 1\n\tif l1 == l2\
    \ then\n\t  local s1 = interval1[1]:tointeger()\n\t  local e1 = interval1[2]:tointeger()\n\
    \t  local s2 = interval2[1]:tointeger()\n\t  local e2 = interval2[2]:tointeger()\n\
    \t  local s = s1 < s2 and s2 or s1\n\t  local e = e1 < e2 and e2 or e1\n\t  if\
    \ e <= s then\n\t    return \"YES\"\n\t  else\n\t    return \"NO\"\n\t  end\n\t\
    else\n\t  return \"NO\"\n\tend\n  else\n    return \"NO\"\n  end\nend", "  assert(interval1\
    \ ~= nil, 'interval1 ~= nil')\n  assert(interval2 ~= nil, 'interval2 ~= nil')\n\
    \  local interval1_start, interval1_end = interval1[1], interval1[2]\n  local\
    \ interval2_start, interval2_end = interval2[1], interval2[2]\n  \n  -- If the\
    \ two intervals are equal, return 'YES'\n  if interval1_start == interval2_start\
    \ or interval1_end == interval2_end then\n    return 'YES'\n  end\n  \n  -- If\
    \ the first interval is smaller, return the result\n  if interval1_start < interval2_start\
    \ then\n    return intersection({interval1_start, interval1_end}, {interval2_start,\
    \ interval2_end})\n  end\n  \n  -- If the first interval is bigger, return the\
    \ result\n  if interval1_end < interval2_end then\n    return intersection({interval1_start,\
    \ interval1_end}, {interval2_start, interval2_end})\n  end\n  \n  -- If the two\
    \ intervals have no intersection, return 'NO'\n  if interval1_start < interval2_end\
    \ or interval1_end > interval2_start then\n    return 'NO'\n  end\n  \n  -- For\
    \ each of the two intervals,\n  -- if the end is less, then the result should\
    \ be 'YES'\n  if interval1_end < interval2_start then\n    return 'YES'\n  end\n\
    \  \n  -- For each of the two intervals,\n  -- if the end is greater, then the\
    \ result should be 'NO'\n  if interval1_start < interval2_end then\n    return\
    \ 'NO'\n  end\n  \n  -- If there are any intersections and their length has already\
    \ been determined, return 'NO'\n  if interval1_start <= interval1_end and interval2_start\
    \ <= interval2_end then\n    return 'NO'\n  end\n  \n  -- If there is no intersection,\
    \ return the result\n  return 'YES'\nend", "  if interval1[1] <= interval2[1]\
    \ and interval2[1] <= interval1[2] then\n    if interval1[1] <= interval2[2] and\
    \ interval2[2] <= interval1[2] then\n      return true\n    else\n      if interval1[1]\
    \ < interval2[1] or interval2[1] < interval1[1] then\n        return true\n  \
    \    else\n        return false\n      end\n    end\n  end\n  return false\nend",
  "   if interval1.start < interval2.start then\n      return interval1.start, interval2.start\n\
    \   elseif interval1.end > interval2.end then\n      return interval1.end, interval2.end\n\
    \   end\n   \n   local intersect = interval1.end\n   for i=interval2.start + 1,\
    \ interval1.end do\n      intersect = intersect + interval1.start\n   end\n  \
    \ \n   return intersect, intersect - interval1.start\nend", "  -- Sort the intervals.\n\
    \  local intervals1 = {}\n  for i=1, #interval1 do\n    table.insert(intervals1,\
    \ {interval1[i], interval1[i+1]})\n  end\n  table.sort(intervals1)\n  local intervals2\
    \ = {}\n  for i=1, #interval2 do\n    table.insert(intervals2, {interval2[i],\
    \ interval2[i+1]})\n  end\n  table.sort(intervals2)", "  return interval1 and\
    \ interval2 and #interval1 ~= #interval2 and math.max(interval1[1], interval2[1])\
    \ <= math.min(interval1[2], interval2[2])\nend", "    if interval1[1] <= interval2[1]\
    \ then\n        local start1 = interval1[1]\n        local end1 = interval1[2]\n\
    \        local start2 = interval2[1]\n        local end2 = interval2[2]\n    \
    \    if start1 < start2 then\n            return false\n        end\n        if\
    \ end2 < end1 then\n            return false\n        end\n        return true\n\
    \    end\n    if interval1[2] <= interval2[2] then\n        local start1 = interval1[1]\n\
    \        local end1 = interval1[2]\n        local start2 = interval2[1]\n    \
    \    local end2 = interval2[2]\n        if start2 < start1 then\n            return\
    \ false\n        end\n        if end1 < end2 then\n            return false\n\
    \        end\n        return true\n    end\n    return false\nend", "\tif interval1[1]\
    \ ~= interval2[1] or interval1[2] ~= interval2[2] then\n\t\treturn \"NO\"\n\t\
    end", "\tlocal start = interval1[1]\n\tlocal end = interval1[2]\n\tlocal start2\
    \ = interval2[1]\n\tlocal end2 = interval2[2]\n\tif start > end or start2 > end2\
    \ then return 'NO' else return 'YES' end\n\tlocal intersection_length = 0\n\t\
    local intersect_start = start\n\tlocal intersect_end = end\n\tlocal intersect_start2\
    \ = start2\n\tlocal intersect_end2 = end2\n\twhile intersect_start <= intersect_end\
    \ and intersect_start2 <= intersect_end2 do\n\t\tlocal length = math.abs(intersect_end\
    \ - intersect_start)\n\t\tintersection_length = intersection_length + length\n\
    \t\tlocal intersect_end = intersect_end + length\n\t\tlocal intersect_end2 = intersect_end2\
    \ + length\n\tend\n\tif intersection_length % 2 = 0 then\n\t\treturn 'NO'\n\t\
    else\n\t\treturn 'YES'\n\tend\nend", "\tlocal result\n\tlocal start1 = interval1[1]\n\
    \tlocal end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\
    \tif start1 > end1 then\n\t\tresult = start1\n\t\tstart1 = end1\n\t\tend1 = result\n\
    \tend\n\tif start2 > end2 then\n\t\tresult = start2\n\t\tstart2 = end2\n\t\tend2\
    \ = result\n\tend\n\tif start1 <= start2 then\n\t\tif end1 <= end2 then\n\t\t\t\
    local length1 = end1 - start1 + 1\n\t\t\tlocal length2 = end2 - start2 + 1\n\t\
    \t\tif length1 < length2 then\n\t\t\t\tresult = start1\n\t\t\tend\n\t\telse\n\t\
    \t\tresult = start2\n\t\tend\n\tend\n\tif start2 <= start1 then\n\t\tif end2 <=\
    \ end1 then\n\t\t\tresult = start2\n\t\tend\n\tend\n\tif result ~= nil then\n\t\
    \t-- Prime\n\t\tif result ~= start1 then\n\t\t\tif result ~= end1 then\n\t\t\t\
    \treturn \"NO\"\n\t\t\telse\n\t\t\t\treturn \"YES\"\n\t\t\tend\n\t\telse\n\t\t\
    \treturn \"YES\"\n\t\tend\n\tend\nend", "\tlocal count = 0\n\tfor i = 1, #interval2\
    \ do\n\t\tif interval1[1] < interval2[i] then\n\t\t\tcount = count + 1\n\t\tend\n\
    \tend\n\treturn (math.min(interval1[1], interval2[i]) == math.max(interval1[2],\
    \ interval2[i]))\nend", "  if interval1.start <= interval2.end and interval2.start\
    \ <= interval1.end then\n    if interval1.end == interval2.start then\n      print('YES')\n\
    \      return 'YES'\n    else\n      local length = math.abs(interval1.start -\
    \ interval2.end)\n      local count = 0\n      for a = interval1.start .. interval1.end\
    \ do\n        for b = interval2.start .. interval2.end do\n          if math.abs(a\
    \ - b) == length then\n            count = count + 1\n          end\n        end\n\
    \      end\n      if count == (length / 2) then\n        print('YES')\n      \
    \  return 'YES'\n      else\n        print('NO')\n        return 'NO'\n      end\n\
    \    end\n  elseif interval1.start >= interval2.start then\n    if interval1.start\
    \ < interval2.end then\n      print('YES')\n      return 'YES'\n    else\n   \
    \   local length = math.abs(interval1.end - interval2.start)\n      local count\
    \ = 0\n      for a = interval1.start .. interval1.end do\n        for b = interval2.start\
    \ .. interval2.end do\n          if math.abs(a - b) == length then\n         \
    \   count = count + 1\n          end\n        end\n      end\n      if count ==\
    \ (length / 2) then\n        print('YES')\n        return 'YES'\n      else\n\
    \        print('NO')\n        return 'NO'\n      end\n    end\n  elseif interval1.end\
    \ >= interval2.end then\n    if interval1.end < interval2.start then\n      print('YES')\n\
    \      return 'YES'\n    else\n      local length = math.abs(interval1.start -\
    \ interval2.end)\n      local count = 0\n      for a = interval1.start .. interval1.end\
    \ do\n        for b = interval2.start .. interval2.end do\n          if math.abs(a\
    \ - b) == length then\n            count = count + 1\n          end\n        end\n\
    \      end\n      if count == (length / 2) then\n        print('YES')\n      \
    \  return 'YES'\n      else\n        print('NO')\n        return 'NO'\n      end\n\
    \    end\n  elseif interval1.start <= interval2.start then\n    if interval1.end\
    \ <= interval2.end then\n      print('YES')\n      return 'YES'\n    else\n  \
    \    print('NO')\n      return 'NO'\n    end\n  else\n    print('NO')\n    return\
    \ 'NO'\n  end\nend", "  if interval1[1] < interval2[1] and interval1[1] < interval2[2]\
    \ then\n    return interval1\n  elseif interval2[1] < interval1[1] and interval2[1]\
    \ < interval1[2] then\n    return interval2\n  elseif interval1[1] == interval2[1]\
    \ and interval1[2] == interval2[2] then\n    return interval1\n  end\nend", "\t\
    -- start by checking if they intersect\n\tif interval1[1] <= interval2[2] and\
    \ interval2[1] <= interval1[2] then\n\t\t-- they intersect so we need to check\
    \ if they intersect\n\t\tif interval1[1] > interval2[2] then\n\t\t\t-- smaller\
    \ end is greater start\n\t\t\tif interval1[2] > interval2[1] then\n\t\t\t\t--\
    \ larger end is smaller start\n\t\t\t\treturn false\n\t\t\telse\n\t\t\t\t-- both\
    \ start is greater so check for larger end\n\t\t\t\tif interval1[2] < interval2[1]\
    \ then\n\t\t\t\t\t-- smaller end is larger end\n\t\t\t\t\treturn false\n\t\t\t\
    \telse\n\t\t\t\t\t-- both end is greater so check smaller end\n\t\t\t\t\tif interval1[1]\
    \ < interval2[2] then\n\t\t\t\t\t\t-- smaller end is smaller end\n\t\t\t\t\t\t\
    return false\n\t\t\t\t\telse\n\t\t\t\t\t\t-- both start and end are equal so check\
    \ if they are prime\n\t\t\t\t\t\tif prime_check(interval1[1] and interval1[2])\
    \ ~= nil then\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn\
    \ false\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\
    \t-- smaller start is greater end\n\t\t\tif interval1[1] > interval2[2] then\n\
    \t\t\t\t-- larger start is smaller end\n\t\t\t\treturn false\n\t\t\telse\n\t\t\
    \t\t-- both end is greater so check smaller end\n\t\t\t\tif interval1[2] < interval2[1]\
    \ then\n\t\t\t\t\t-- smaller start is smaller start\n\t\t\t\t\treturn false\n\t\
    \t\t\telse\n\t\t\t\t\t-- both start and end are equal so check if they are prime\n\
    \t\t\t\t\tif prime_check(interval1[1] and interval1[2]) ~= nil then\n\t\t\t\t\t\
    \treturn true\n\t\t\t\t\telse\n\t\t\t\t\t\treturn false\n\t\t\t\t\tend\n\t\t\t\
    \tend\n\t\t\tend\n\t\tend\n\telse\n\t\treturn false\n\tend\nend", "\tif interval1\
    \ ~= interval2 then\n\t\tif interval1[1] ~= interval2[2] then\n\t\t\tif interval1[1]\
    \ < interval2[2] then\n\t\t\t\tif interval1[1] < interval2[1] then\n\t\t\t\t\t\
    return 'YES'\n\t\t\t\telse\n\t\t\t\t\treturn 'NO'\n\t\t\t\tend\n\t\t\telse\n\t\
    \t\t\tif interval1[1] > interval2[1] then\n\t\t\t\t\treturn 'YES'\n\t\t\t\telse\n\
    \t\t\t\t\treturn 'NO'\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tif interval1[2]\
    \ > interval2[2] then\n\t\t\t\treturn 'NO'\n\t\t\telse\n\t\t\t\treturn 'YES'\n\
    \t\t\tend\n\t\tend\n\telse\n\t\treturn 'NO'\n\tend\nend", "  local interval1start,\
    \ interval1end = interval1[1], interval1[2]\n  local interval2start, interval2end\
    \ = interval2[1], interval2[2]\n  local intersection1start, intersection1end =\
    \ interval1start, interval1end\n  local intersection2start, intersection2end =\
    \ interval2start, interval2end\n  if interval1start > interval2start or interval1end\
    \ < interval2end then\n    return \"NO\"\n  elseif interval1start <= interval2start\
    \ and interval1end >= interval2start then\n    interval1start, intersection1start,\
    \ intersection1end = interval2start, interval2end, interval1end\n  elseif interval1start\
    \ <= interval2end and interval1end >= interval2end then\n    interval1start, intersection1start,\
    \ intersection1end = interval2start, interval2end, interval1start\n  else\n  \
    \  return \"NO\"\n  end\n  if intersection1start > intersection2start or intersection1end\
    \ < intersection2end then\n    return \"NO\"\n  elseif intersection1start <= intersection2start\
    \ and intersection1end >= intersection2start then\n    intersection1start, intersection1end,\
    \ intersection2start, intersection2end = intersection2start, intersection2end,\
    \ intersection1end, intersection1start\n  elseif intersection1start <= intersection2end\
    \ and intersection1end >= intersection2end then\n    intersection1start, intersection1end,\
    \ intersection2start, intersection2end = intersection2start, intersection2end,\
    \ intersection1start, intersection1end\n  end\n  local total1start, total1end,\
    \ total2start, total2end = interval1start, interval1end, interval2start, interval2end\n\
    \  for i = 1, (total1end - total1start + 1) do\n    if total2end - total2start\
    \ + 1 >= i and total2start <= total2end and total2end >= total1start and total2end\
    \ <= total1end then\n      local j = i\n      local k = total1end - j + 1\n  \
    \    while k >= 1 do\n        local a = math.mod(total1start, j) + math.mod(total1end,\
    \ j) - math.mod(intersection1start, j) - math.mod(intersection1end, j)\n     \
    \   local b = math.mod(total2start, k) + math.mod(total2end, k) - math.mod(intersection2start,\
    \ k) - math.mod(intersection2end, k)\n        local c = math.abs(math.mod(a, j))\n\
    \        local d = math.abs(math.mod(b, k))\n        if c > d then\n         \
    \ total1start, total1end, total2start, total2end = total1start, total1end, total2start,\
    \ total2end\n        else\n          total1start, total1end, total2start, total2end\
    \ = total2start, ", "\tlocal n1, n2 = interval1[1], interval1[2]\n\tlocal m1,\
    \ m2 = interval2[1], interval2[2]\n\t\n\tif m1 <= n2 then\n\t\tif m2 > n1 then\n\
    \t\t\tlocal isPrime = true\n\t\t\tfor i = m2, n1, -1 do\n\t\t\t\tlocal t = n /\
    \ i\n\t\t\t\tif t <= 1 and t ~= i-1 then\n\t\t\t\t\tisPrime = false\n\t\t\t\t\t\
    break\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn isPrime and \"YES\" or \"NO\"\n\t\t\
    end\n\tend\n\tif m2 <= n1 then\n\t\tif m1 > n2 then\n\t\t\tlocal isPrime = true\n\
    \t\t\tfor i = m1, n2, -1 do\n\t\t\t\tlocal t = n / i\n\t\t\t\tif t <= 1 and t\
    \ ~= i-1 then\n\t\t\t\t\tisPrime = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\
    end\n\t\t\treturn isPrime and \"YES\" or \"NO\"\n\t\tend\n\tend\n\treturn \"NO\"\
    \nend", "\tlocal l1, r1 = interval1[1], interval1[2]\n\tlocal l2, r2 = interval2[1],\
    \ interval2[2]", "\treturn (interval1[1] < interval2[1] and interval1[1] < interval2[2])\
    \ or (interval2[1] < interval1[1] and interval2[1] < interval1[2])\nend", "\t\
    -- Your code here\n\tif interval1[1] > interval2[1] then\n\t\treturn 'NO'\n\t\
    elseif interval1[1] < interval2[1] then\n\t\treturn 'YES'\n\telse\n\t\treturn\
    \ 'NO'\n\tend\nend", "  local interval1Start = interval1[1]\n  local interval1End\
    \ = interval1[2]\n  local interval2Start = interval2[1]\n  local interval2End\
    \ = interval2[2]", "  local function is_overlap(interval1, interval2)\n    return\
    \ interval1[1] >= interval2[1] and interval1[1] <= interval2[2]\n  end\n  local\
    \ function is_overlap1(interval1, interval2)\n    return interval1[1] >= interval2[1]\
    \ and interval1[2] <= interval2[1]\n  end\n  local function is_overlap2(interval1,\
    \ interval2)\n    return interval1[1] >= interval2[2] and interval1[2] <= interval2[2]\n\
    \  end\n  if is_overlap1(interval1, interval2) or is_overlap2(interval1, interval2)\
    \ then\n    return 'NO'\n  end\n  if is_overlap(interval1, interval2) then \n\
    \    return 'NO'\n  end\n  local intersected_interval = interval1[1] .. ':' ..\
    \ interval1[2] .. interval2[1] .. ':' .. interval2[2]\n  if interval1[1] == interval2[1]\
    \ and interval1[2] == interval2[2] then\n    return 'YES'\n  end\n  local length\
    \ = 2\n  while length <= interval2[2] do\n    intersected_interval = intersected_interval\
    \ .. ':' .. length\n    length = length + 1\n  end\n  intersected_interval = intersected_interval\
    \ .. ':' .. interval2[2]\n  local prime = false\n  for i = 2, #primes do\n   \
    \ local p1 = primes[i]\n    if intersected_interval == p1 then\n      prime =\
    \ true\n      break\n    end\n  end\n  if prime then\n    return 'YES'\n  end\n\
    \  return 'NO'\nend", "  if interval1[1] < interval2[1] and interval1[2] < interval2[2]\
    \ then\n    return (\"NO\")\n  else\n    return (\"YES\")\n  end\nend", "\tlocal\
    \ i1, i2 = interval1[1], interval2[1]\n\tif i1 <= i2 then\n\t\tif i2 <= i1 then\n\
    \t\t\tif i1 == i2 then\n\t\t\t\treturn \"YES\"\n\t\t\telse\n\t\t\t\treturn \"\
    NO\"\n\t\t\tend\n\t\telse\n\t\t\tif i1 > i2 then\n\t\t\t\treturn \"NO\"\n\t\t\t\
    else\n\t\t\t\treturn \"YES\"\n\t\t\tend\n\t\tend\n\telse\n\t\tif i1 <= i2 then\n\
    \t\t\tif i2 > i1 then\n\t\t\t\treturn \"YES\"\n\t\t\telse\n\t\t\t\treturn \"NO\"\
    \n\t\t\tend\n\t\telse\n\t\t\treturn \"NO\"\n\t\tend\n\tend\nend", "  local intersect_len\
    \ = (interval2[1] - interval1[1]) * (interval2[2] - interval1[2])\n  return interval1[1]\
    \ <= interval2[1] and interval1[2] <= interval2[2] and intersect_len % 2 == 0\n\
    end", "    local l1 = interval1[1]\n    local r1 = interval1[2]\n    local l2\
    \ = interval2[1]\n    local r2 = interval2[2]", "\tlocal s1, s2 = interval1[1],\
    \ interval2[1]\n\tlocal e1, e2 = interval1[2], interval2[2]\n\tlocal s3 = e1 <\
    \ e2 and s1 + 1 or s2\n\tlocal e3 = e1 < e2 and e1 + 1 or e2\n\t\n\tif s3 > e3\
    \ then\n\t\treturn \"NO\"\n\telseif s3 < e3 then\n\t\tlocal s1 = interval1[1]\n\
    \t\tlocal e1 = interval1[2]\n\t\tlocal s2 = interval2[1]\n\t\tlocal e2 = interval2[2]\n\
    \t\tlocal len1 = e1 - s1 + 1\n\t\tlocal len2 = e2 - s2 + 1\n\t\tlocal ans = len1\
    \ - len2\n\t\tlocal flag = false -- check whether the length is prime\n\t\t\n\t\
    \tfor i = 2, ans do\n\t\t\tif (len1 % i) == 0 then\n\t\t\t\tflag = true\n\t\t\t\
    \tbreak\n\t\t\tend\n\t\tend\n\t\t\n\t\tif not flag then\n\t\t\treturn \"YES\"\n\
    \t\telse\n\t\t\treturn \"NO\"\n\t\tend\n\telse\n\t\treturn \"NO\"\n\tend\nend",
  "\tlocal start = interval1[1]\n\tlocal end = interval1[2]\n\tlocal start2 = interval2[1]\n\
    \tlocal end2 = interval2[2]", "\tif interval1[1] <= interval2[1] then\n\t\tif\
    \ interval1[1] <= interval2[2] and interval2[2] <= interval1[2] then\n\t\t\tif\
    \ interval2[1] <= interval1[2] and interval1[2] <= interval2[2] then\n\t\t\t\t\
    return interval1[2] and interval2[2]\n\t\t\telse\n\t\t\t\treturn interval1[2]\n\
    \t\t\tend\n\t\telse\n\t\t\treturn interval1[2]\n\t\tend\n\telse\n\t\treturn interval2[2]\n\
    \tend\nend", "  if interval1[1] > interval2[1] and interval1[1] < interval2[2]\
    \ then\n    return interval1[1]\n  elseif interval1[2] > interval2[1] and interval1[2]\
    \ < interval2[2] then\n    return interval1[2]\n  else\n    return false\n  end\n\
    end", "\treturn \n\t\t((interval1[1] < interval2[1]) and (interval1[2] == interval2[2])\
    \ or (interval1[1] == interval2[1] and interval1[2] < interval2[2])) and \n\t\t\
    ((interval1[1] >= interval2[1]) and (interval1[2] < interval2[2]) or (interval1[1]\
    \ < interval2[1] and interval1[2] == interval2[2]))\nend", "  return not interval2[1]\
    \ < interval1[1] \n  and interval1[1] < interval2[2] and interval2[2] < interval1[2]\
    \ \n  and math.fmod(math.fsum(interval1[1], interval2[2], interval1[2], interval2[1]),2)\
    \ == 0 \nend", "\tlocal count = 0\n\tfor i = interval1.start, interval2.start\
    \ do\n\t\tif i >= interval1.end or i < interval2.end then\n\t\t\tcount = count\
    \ + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend", "    local len1 = interval1[1]\n\
    \    local len2 = interval2[1]\n    if len1 < len2 then\n        local tmp = interval2[1]\n\
    \        interval2[1] = interval1[1]\n        interval1[1] = tmp\n    end\n  \
    \  local intersect = 0\n    for i=interval1[1],len1 do\n        if interval2[1]\
    \ < i then\n            break\n        end\n        intersect = i\n    end\n \
    \   if intersect > len1 or intersect > len2 then\n        local tmp = intersect\n\
    \        intersect = len1\n        len1 = tmp\n    end\n    if intersect < 1 then\n\
    \        -- The intervals do not intersect\n        return 'NO'\n    end\n   \
    \ -- The intervals intersect\n    local prime = 1\n    for i=2,intersect do\n\
    \        if prime==0 and i==intersect then\n            return true -- The interval\
    \ is prime\n        elseif prime and i%2==0 then\n            prime = prime-1\n\
    \        end\n    end\n    return false -- The interval is not prime\nend", "\t\
    local start = interval1[1]\n\tlocal end = interval2[1]\n\tlocal result = 1\n\t\
    \n\twhile start <= end do\n\t\tlocal mid = start + (end - start) / 2\n\t\tif mid\
    \ > end then\n\t\t\tstart = end\n\t\telseif mid < end then\n\t\t\tend = mid\n\t\
    \telse\n\t\t\tresult = result + 1\n\t\tend\n\tend\n\t\n\tif result == 2 then --\
    \ if start and end are equal\n\t\tif start < end then\n\t\t\treturn 'YES'\n\t\t\
    else\n\t\t\treturn 'NO'\n\t\tend\n\telseif result == 1 then -- if start and end\
    \ are different\n\t\treturn 'NO'\n\tend\nend\n</cell>\n<cell>", "\tlocal start1\
    \ = interval1[1]\n\tlocal end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\
    \tlocal end2 = interval2[2]\n\tif start1 > end2 or start2 > end1 then\n\t\treturn\
    \ 'NO'\n\tend\n\tlocal intersect = start1 ~= end2 and start2 ~= end1\n\treturn\
    \ intersect and \"YES\" or \"NO\"\nend", "  local result\n  local length = math.max(interval1[1],\
    \ interval2[1]) - math.min(interval1[1], interval2[1])\n  if length <= 0 then\n\
    \    result = 'NO'\n  elseif length % 2 == 1 then\n    -- Even length\n    if\
    \ interval1[1] > interval2[1] or interval2[1] > interval1[1] then\n      result\
    \ = 'NO'\n    else\n      local count = 0\n      for index = interval1[1] + 1,interval2[1]\
    \ + 1 do\n        if interval1[1] <= index and interval2[1] <= index then\n  \
    \        count = count + 1\n        end\n      end\n      if count % 2 == 1 then\n\
    \        result = 'YES'\n      else\n        result = 'NO'\n      end\n    end\n\
    \  else\n    -- Odd length\n    local count = 0\n    for index = interval1[1]\
    \ + 1,interval2[1] + 1 do\n      if interval1[1] <= index and interval2[1] <=\
    \ index then\n        count = count + 1\n      end\n    end\n    if count < 3\
    \ then\n      result = 'NO'\n    elseif count % 2 == 0 then\n      result = 'YES'\n\
    \    else\n      result = 'NO'\n    end\n  end\n  return result\nend", "  -- The\
    \ length of the intersection must be less than or equal to the length of the union.\n\
    \  local length1 = #interval1\n  local length2 = #interval2\n  if length1 <= length2\
    \ then\n    -- The union is the longest interval with length greater than or equal\
    \ the length of the intersection.\n    local union = interval1\n    union[#union\
    \ + 1] = interval2[#interval2]\n    local intersection = interval1\n    intersection[#intersection\
    \ + 1] = interval2[#interval2]\n    local intersectLen = #intersection\n    local\
    \ unionLen = #union\n    for i = 2, intersectLen do\n      local tmp = union[i\
    \ - 1]\n      union[i] = union[i - 1] + union[i + 1]\n      union[unionLen + 1]\
    \ = tmp\n    end\n    for i = 1, intersectLen do\n      if union[unionLen - i]\
    \ < union[unionLen - i - 1] then\n        intersection[unionLen - i] = intersection[unionLen\
    \ - i] + intersection[unionLen - i - 1]\n      end\n    end\n    if #intersection\
    \ > 1 then\n      if prime_number(intersection[1]) and prime_number(intersection[#intersection])\
    \ then\n        return 'YES'\n      else\n        return 'NO'\n      end\n   \
    \ end\n  else\n    -- The union is the longest interval with length greater than\
    \ or equal the length of the intersection.\n    local union = interval2\n    union[#union\
    \ + 1] = interval1[#interval1]\n    local intersection = interval2\n    intersection[#intersection\
    \ + 1] = interval1[#interval1]\n    local intersectLen = #intersection\n    local\
    \ unionLen = #union\n    for i = 2, intersectLen do\n      local tmp = union[i\
    \ - 1]\n      union[i] = union[i - 1] + union[i + 1]\n      union[unionLen + 1]\
    \ = tmp\n    end\n    for i = 1, intersectLen do\n      if union[unionLen - i]\
    \ < union[unionLen - i - 1] then\n        intersection[unionLen - i] = intersection[unionLen\
    \ - i] + intersection[unionLen - i - 1]\n      end\n    end\n    if #intersection\
    \ > 1 then\n      if prime_number(intersection[1]) and prime_number(intersection[#intersection])\
    \ then\n        return 'YES'\n      else\n        return 'NO'\n      end\n   \
    \ end\n  end\nend", "    if interval1[1] > interval2[1] then\n        interval1,\
    \ interval2 = interval2, interval1\n    end", "  local isIntersect = interval1[1]\
    \ < interval2[1] and interval2[1] < interval1[2]\n  if isIntersect then -- check\
    \ whether the two intervals intersect\n    if interval1[2] >= interval2[1] then\
    \ -- check if the first interval ends before the second interval starts\n    \
    \  return 'NO'\n    end\n    if interval1[1] <= interval2[2] then -- check if\
    \ the first interval starts after the first interval ends\n      return 'NO'\n\
    \    end\n    return interval2[2] <= interval1[1] then -- check if the length\
    \ of the intersection exceeds the length of the first interval\n  else -- check\
    \ the two intervals don't intersect\n    return 'NO'\n  end\nend", "\tif interval1[1]\
    \ < interval2[0] then\n\t\tinterval2[1] = interval1[1]\n\telseif interval1[1]\
    \ > interval2[1] then\n\t\tinterval2[0] = interval1[0]\n\tend", "\tlocal i1 =\
    \ interval1[1]\n\tlocal i2 = interval2[1]\n\tlocal i3 = interval1[1]\n\tlocal\
    \ i4 = interval2[1]", "\tlocal length1, length2 = #interval1, #interval2\n\tlocal\
    \ totalLength = 0\n\tlocal isPrime = 0\n\tfor i=1, length1 do\n\t\tfor j=1, length2\
    \ do\n\t\t\tlocal inter = interval1[i] <= interval2[j] and interval1[i] or interval2[j]\n\
    \t\t\tif inter >= interval1[i] and inter <= interval2[j] then\n\t\t\t\ttotalLength\
    \ = totalLength + 2\n\t\t\t\tif math.floor((inter - interval1[i]) / interval2[j])\
    \ == math.floor((inter - interval2[j]) / interval1[i]) then\n\t\t\t\t\tisPrime\
    \ = isPrime + 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tif isPrime == length1\
    \ then\n\t\treturn 'YES'\n\telse\n\t\treturn 'NO'\n\tend\nend", "    local interval1_start,\
    \ interval1_end = interval1[1], interval1[2]\n    local interval2_start, interval2_end\
    \ = interval2[1], interval2[2]\n    local interval1_end2 = interval1_end - interval1_end\n\
    \    local interval2_end2 = interval2_end - interval2_end", "\tlocal l1 = interval1[1]\n\
    \tlocal l2 = interval2[1]\n\tlocal u1 = interval1[2]\n\tlocal u2 = interval2[2]\n\
    \tif l1 == u1 then return \"NO\" end\n\tif l2 == u2 then return \"NO\" end\n\t\
    if l1 <= u1 and l2 <= u2 then\n\t\tlocal m = l2 + 1\n\t\twhile m < u2 do\n\t\t\
    \tif m * m == u1 then\n\t\t\t\tbreak\n\t\t\telse\n\t\t\t\tm = m + 1\n\t\t\tend\n\
    \t\tend\n\t\tif m == u2 then\n\t\t\treturn 'YES'\n\t\telse\n\t\t\treturn 'NO'\n\
    \t\tend\n\telse\n\t\treturn 'NO'\n\tend\nend", "\tlocal a1, b1 = interval1[1],\
    \ interval1[2]\n\tlocal a2, b2 = interval2[1], interval2[2]\n\tif a1 <= b2 and\
    \ b1 <= a2 then return 'YES' end\n\treturn 'NO'\nend", "\tlocal start = interval1[1]\n\
    \tlocal end = interval1[2]\n\tlocal inter = interval2[1]\n\tlocal length1 = interval1[1]\
    \ - interval1[1]\n\tlocal length2 = interval2[1] - interval2[1]\n\tlocal result",
  "\treturn (interval1.start <= interval2.start and interval2.start <= interval1.end)\
    \ or \\\n\t\t(interval1.start <= interval2.end and interval2.end <= interval1.end)\n\
    end", "\t-- Write your code here.\n\t\n\treturn \"NO\"\nend", "\tif interval1.start\
    \ < interval2.start then\n\t\treturn 'NO'\n\tend", "\tlocal intersect = {}\n\t\
    local intersect_len = math.max( interval1[1], interval2[1] )\n\tif intersect_len\
    \ > interval1[1] or intersect_len > interval2[1] then return 'NO' end\n\tfor i\
    \ = interval1[1]+1, interval2[1]-1 do\n\t\tif i%intersect_len == 0 then\n\t\t\t\
    table.insert(intersect, i)\n\t\tend\n\tend\n\tif #intersect == 1 then\n\t\treturn\
    \ 'YES'\n\telse\n\t\treturn 'NO'\n\tend\nend", "    if interval1 == interval2\
    \ then\n        return \"NO\"\n    end", "\tlocal length1 = math.abs(interval1[1]\
    \ - interval1[0] + 1)\n\tlocal length2 = math.abs(interval2[1] - interval2[0]\
    \ + 1)", "    local length = math.abs(interval1[1]-interval1[0]) * math.abs(interval2[1]-interval2[0])\n\
    \    local interval1_start = interval1[1]\n    local interval1_end = interval1[1]\n\
    \    local interval2_start = interval2[1]\n    local interval2_end = interval2[1]",
  "\tlocal intervals1 = {interval1[1], interval1[2], interval2[1], interval2[2]}\n\
    \tlocal intervals2 = {interval2[1], interval2[2], interval1[1], interval1[2]}\n\
    \tlocal count1, count2 = #intervals1, #intervals2\n\tlocal total = 0\n\tlocal\
    \ result = \"NO\"\n\tfor i = 1, count1 do\n\t\ttotal = total + intervals1[i]\n\
    \tend\n\tfor i = 1, count2 do\n\t\ttotal = total + intervals2[i]\n\tend\n\tif\
    \ total % 2 == 1 then\n\t\tresult = \"YES\"\n\tend\n\treturn result\nend", " \
    \   if interval1[1] < interval2[1] then\n        local tmp = interval2\n     \
    \   interval2 = interval1\n        interval1 = tmp\n    end\n    local start =\
    \ min(interval1[1], interval2[1])\n    local end = max(interval1[1], interval2[1])\n\
    \    if start > end then\n        return \"NO\"\n    end\n    for i = start +\
    \ 1, end do\n        if i == start or i == end then\n            return i\n  \
    \      end\n    end\nend", "\tlocal l1 = interval1[1]\n\tlocal l2 = interval2[1]\n\
    \tlocal r1 = interval1[2]\n\tlocal r2 = interval2[2]", "\t-- Your code here\n\t\
    if interval1[1] < interval2[1] and interval1[1] < interval2[2] then \n\t\treturn\
    \ \"NO\"\n\telseif interval1[1] > interval2[1] and interval1[1] > interval2[2]\
    \ then\n\t\treturn \"NO\"\n\telseif interval1[1] < interval2[1] and interval1[1]\
    \ > interval2[2] then \n\t\treturn \"NO\"\n\telseif interval1[1] > interval2[1]\
    \ and interval1[1] < interval2[2] then \n\t\treturn \"NO\"\n\tend\n\treturn \"\
    YES\"\nend", "  local start1 = interval1[1]\n  local end1 = interval1[2]\n  local\
    \ start2 = interval2[1]\n  local end2 = interval2[2]\n  local endIntersection\
    \ = math.min(end1, end2)\n  local startIntersection = math.max(start1, start2)",
  "    if interval1[1] < interval1[2] then\n        interval1 = {interval1[1], interval1[2]}\n\
    \    elseif interval2[1] < interval2[2] then\n        interval2 = {interval2[1],\
    \ interval2[2]}\n    end\n    \n    local interval3 = {interval1[1], interval2[1]}\n\
    \    if interval3[1] < interval3[2] then\n        interval3 = {interval3[1], interval3[2]}\n\
    \    end\n    \n    local interval4 = {interval1[2], interval2[2]}\n    if interval4[1]\
    \ < interval4[2] then\n        interval4 = {interval4[1], interval4[2]}\n    end\n\
    \    \n    if interval3[1] > interval4[1] then\n        -- interval3[2] <= interval4[2]\
    \ \n        -- interval3[1] < interval4[1]\n        if interval3[1] > interval4[2]\
    \ then\n            -- interval3[2] > interval4[2]\n            -- interval3[1]\
    \ > interval4[1]\n            if interval3[2] > interval4[1] then\n          \
    \      -- interval3[2] > interval4[1]\n                -- interval3[1] > interval4[2]\n\
    \                if interval3[2] > interval4[2] then\n                    -- interval3[2]\
    \ > interval4[2]\n                    -- interval3[1] > interval4[1]\n       \
    \             if interval3[1] < interval4[1] then\n                        --\
    \ interval3[1] < interval4[1]\n                        -- interval3[2] < interval4[2]\n\
    \                        if interval3[2] > interval4[1] then\n               \
    \             -- interval3[2] > interval4[1]\n                            -- interval3[1]\
    \ < interval4[2]\n                            if interval3[1] > interval4[2] then\n\
    \                                -- interval3[1] > interval4[2]\n            \
    \                    -- interval3[2] > interval4[1]\n                        \
    \        return true\n                            end\n                      \
    \  end\n                    end\n                end\n            end\n      \
    \  end\n    else\n        -- interval3[2] <= interval4[2] \n        -- interval3[1]\
    \ > interval4[1]\n        if interval3[1] < interval4[2] then\n            --\
    \ interval3[2] < interval4[2]\n            -- interval3[1] > interval4[2]\n  \
    \          if interval3[2] < interval4[1] then\n                -- interval3[2]\
    \ < interval4[1]\n                -- interval3[1] < interval4[2]\n           \
    \     if interval3[1] < interval4[1] then\n                    -- interval3[1]\
    \ < interval4[1]\n                    -- interval3[2] < interval4[2]\n       \
    \             if interval3[2] < interval4[2] then\n                        --\
    \ interval3[2] < interval4[2]\n                        -- interval3[1] < interval4[1]\n\
    \                        if interval3[1] > interval4[1] then\n               \
    \             -- ", "   local i1Start, i1End = interval1[1], interval1[2]\n  \
    \ local i2Start, i2End = interval2[1], interval2[2]\n   if i1Start <= i1End and\
    \ i2Start <= i2End then\n      return (i1Start < i2End) and \"YES\" or \"NO\"\n\
    \   else\n      return \"NO\"\n   end\nend", "\tlocal len1 = interval1[1] - interval1[1]\
    \ + 1\n\tlocal len2 = interval2[1] - interval2[1] + 1\n\t\n\t-- If len1 is odd\
    \ and len2 is even, then return \"NO\".\n\tif len1 % 2 == 0 and len2 % 2 == 0\
    \ then\n\t\treturn \"NO\"\n\tend", "  local left_start = interval1[1]\n  local\
    \ left_end = interval1[2]\n  local right_start = interval2[1]\n  local right_end\
    \ = interval2[2]\n  if left_start > right_end then\n    return nil\n  end\n  if\
    \ left_end < right_start then\n    return nil\n  end\n  if left_start >= left_end\
    \ and right_start >= right_end then\n    return 'NO'\n  end\n  -- We only need\
    \ to check one side of the interval\n  local interval1_interval = interval1[1]\
    \ - interval1[2]\n  local interval2_interval = interval2[1] - interval2[2]\n \
    \ if interval1_interval > interval2_interval then\n    return nil\n  end\n  if\
    \ interval1_interval < interval2_interval then\n    return 'YES'\n  end\n  if\
    \ left_start <= right_start then\n    return 'YES'\n  end\n  return 'NO'\nend",
  "    local i1 = interval1[1]\n    local i2 = interval2[1]\n    local i3 = interval1[1]\n\
    \    local i4 = interval2[1]", "  -- Your code here\n  assert(type(interval1)\
    \ == \"table\")\n  assert(type(interval2) == \"table\")\n  assert(interval1 ~=\
    \ nil)\n  assert(interval2 ~= nil)\n  local result\n  if interval1[1] < interval2[1]\
    \ then \n    result, interval1, interval2 = interval2, interval1, interval2\n\
    \  end\n  if interval1[1] > interval2[1] or interval1[2] > interval2[2] then return\
    \ 'NO' end\n  local interval = { interval1[1], interval2[2] }\n  if #interval\
    \ == 2 then \n    local result1 = interval1[1] > interval2[1]\n    local result2\
    \ = interval1[2] < interval2[2]\n    if result1 and not result2 then return 'YES'\
    \ end \n    if not result1 and not result2 then return 'NO' end \n  end \n  if\
    \ #interval == 1 then return 'NO' end \n  if #interval == 2 then\n    if interval[1]\
    \ > interval[2] then\n      interval[1] = interval2[1]\n      interval[2] = interval1[2]\n\
    \    end\n    local result = interval[1] > interval[2]\n    if result then\n \
    \     if #interval > 1 then\n        local result3 = interval[1] < interval[2]\n\
    \        if result3 then\n          return 'YES'\n        else\n          return\
    \ 'NO'\n        end\n      end\n    else\n      return 'NO'\n    end\n  end\n\
    end", "    local start = math.max(interval1[1], interval2[1])\n    local end =\
    \ math.min(interval1[2], interval2[2])\n    if start > end then\n        return\
    \ \"NO\"\n    end\n    if start < end then\n        return is_prime(end - start\
    \ + 1)\n    else\n        return \"NO\"\n    end\nend", "    local interval1_start\
    \ = interval1[1]\n    local interval1_end = interval1[2]\n    local interval2_start\
    \ = interval2[1]\n    local interval2_end = interval2[2]\n    local prime_interval_start\
    \ = prime_number(interval1_start)\n    local prime_interval_end = prime_number(interval1_end)\n\
    \    local prime_interval_start_next = prime_number(interval2_start)\n    local\
    \ prime_interval_end_next = prime_number(interval2_end)\n    -- check if interval\
    \ overlap\n    if prime_interval_start_next > prime_interval_start and\n     \
    \  prime_interval_end_next > prime_interval_end then\n        if prime_interval_start_next\
    \ == prime_interval_start then\n            return prime_interval_end_next ==\
    \ prime_interval_end\n        elseif prime_interval_start_next == prime_interval_end\
    \ then\n            return prime_interval_end_next == prime_interval_start\n \
    \       else\n            return prime_interval_end_next <= prime_interval_start\
    \ and prime_interval_end_next >= prime_interval_end\n        end\n    elseif prime_interval_start_next\
    \ > prime_interval_start and\n          prime_interval_end_next <= prime_interval_end\
    \ then\n        return prime_interval_start_next <= prime_interval_start and prime_interval_start_next\
    \ >= prime_interval_end\n    elseif prime_interval_start_next <= prime_interval_start\
    \ and\n          prime_interval_end_next > prime_interval_end then\n        return\
    \ prime_interval_start_next <= prime_interval_start and prime_interval_end_next\
    \ <= prime_interval_end\n    elseif prime_interval_start_next >= prime_interval_start\
    \ and\n          prime_interval_end_next <= prime_interval_end then\n        return\
    \ prime_interval_start_next >= prime_interval_start and prime_interval_start_next\
    \ <= prime_interval_end\n    else\n        return \"NO\"\n    end\nend\n</cell>\n\
    <cell>", "\tlocal start = interval1[1]\n\tlocal end = interval1[2]\n\tlocal start2\
    \ = interval2[1]\n\tlocal end2 = interval2[2]\n\tif start > end or start2 > end2\
    \ then\n\t\treturn nil\n\tend\n\tlocal start2 = start2 - (start2 % end)\n\tlocal\
    \ end2 = end2 - (end2 % end)\n\tlocal start = start - (start % end)\n\tlocal end\
    \ = end - (end % end)\n\tlocal start2 = start2 - (start2 % end)\n\tlocal end2\
    \ = end2 - (end2 % end)\n\tlocal len = start2 <= end2 and end2 >= start2 and end2\
    \ <= len + 1 and end2 >= start + 1 and start2 <= len - 1 and end2 >= 0 - 1 and\
    \ start2 <= len + 1 and end2 >= 0 - 1 and start2 <= len - 1 and end2 >= 0\n\t\
    if len == 0 then\n\t\treturn nil\n\tend\n\tif len == 1 then\n\t\treturn true\n\
    \tend\n\tif len == 2 then\n\t\treturn start == end or start2 == end2\n\tend\n\t\
    return nil\nend", "   -- Base case: if the two intervals don't intersect, return\
    \ 'NO'.\n   -- If interval1.start is less than interval1.end, return 'NO'.\n \
    \  -- If interval2.start is less than interval2.end, return 'NO'.\n   if interval1.start\
    \ <= interval1.end and interval2.start <= interval2.end then\n      return \"\
    NO\"\n   end", "\tlocal start = math.max(interval1[1], interval2[1])\n\tlocal\
    \ end = math.min(interval1[2], interval2[2])\n\t\n\tif start == end then return\
    \ \"NO\" end\n\t\n\tif start > end then start = start .. \"9\"\n\t\n\tlocal intersection\
    \ = (end - start)\n\t\n\treturn \"YES\" if isPrime(intersection) then return \"\
    YES\" else return \"NO\" end\nend", "\tlocal function inside(l, r)\n\t\treturn\
    \ l <= r and l <= r or l >= r and l >= r\n\tend\n\tlocal l1 = interval1[1]\n\t\
    local l2 = interval1[2]\n\tlocal r1 = interval2[1]\n\tlocal r2 = interval2[2]\n\
    \tif not inside(l1, r1) or not inside(l2, r2) or not inside(r1, r2) or not inside(r2,\
    \ r1) then\n\t\treturn 'NO'\n\tend\n\tlocal count = 0\n\tlocal count1 = 1\n\t\
    local count2 = 1\n\twhile count1 <= r1 and count2 <= r2 do\n\t\tif not inside(l1,\
    \ count1) or not inside(l2, count2) then\n\t\t\tcount = count + 1\n\t\telseif\
    \ inside(l1, count1) and not inside(l2, count2) then\n\t\t\tcount = count + 1\n\
    \t\telseif inside(l1, count1) and inside(l2, count2) then\n\t\t\tcount = count\
    \ + 1\n\t\telseif inside(l1, count1) and not inside(l2, count2) then\n\t\t\tcount\
    \ = count + 1\n\t\telseif not inside(l1, count1) and inside(l2, count2) then\n\
    \t\t\tcount = count + 1\n\t\tend\n\t\tcount1 = count1 + 1\n\t\tcount2 = count2\
    \ + 1\n\tend\n\tif count == r1 * r2 then\n\t\treturn 'YES'\n\telse\n\t\treturn\
    \ 'NO'\n\tend\nend", "    if interval1[1] <= interval2[1] and interval2[1] <=\
    \ interval1[2] then\n        return interval2[1] - interval1[1] -- The length\
    \ of the intersection is equal to the difference of their ends.\n    end\nend",
  "\tlocal interval1_end = interval1[1]\n\tlocal interval2_start = interval2[1]\n\t\
    local intersection_start = interval1_end and interval2_start or interval1[1]\n\
    \tlocal intersection_end = interval1_end and interval2_start or interval2[1]\n\
    \tlocal length_intersection = interval1_end and interval2_start and interval1_end\
    \ - interval2_start or 0\n\tlocal is_prime = false\n\tif length_intersection ==\
    \ 2 then\n\t\tif length_intersection % 2 == 1 then\n\t\t\tis_prime = true\n\t\t\
    end\n\telseif length_intersection == 1 then\n\t\tif length_intersection % 2 ==\
    \ 1 then\n\t\t\tis_prime = false\n\t\tend\n\tend\n\t\n\tif is_prime then\n\t\t\
    return 'YES'\n\telse\n\t\treturn 'NO'\n\tend\nend", "\tlocal a = {}\n\tlocal b\
    \ = {}\n\tfor _, item in ipairs(interval1) do\n\t\ta[item] = true\n\tend\n\tfor\
    \ _, item in ipairs(interval2) do\n\t\tb[item] = true\n\tend\n\tif #a == #b then\n\
    \t\tlocal temp = {}\n\t\tfor _, item in ipairs(a) do\n\t\t\tif not b[item] then\n\
    \t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\treturn true\n\telse\n\t\treturn\
    \ false\n\tend\nend", "\tlocal left_lower = math.min(interval1[1], interval2[1])\n\
    \tlocal left_upper = math.max(interval1[1], interval2[1])\n\tlocal right_lower\
    \ = math.min(interval1[2], interval2[2])\n\tlocal right_upper = math.max(interval1[2],\
    \ interval2[2])", "   if interval1 ~= interval2 then\n      return false\n   end",
  "\tlocal function findPrimeFactors(n, isPrime)\n\t\tlocal factors = {}\n\t\tfor\
    \ i = 2, n do\n\t\t\tif (n % i == 0) and (not isPrime) then\n\t\t\t\tisPrime =\
    \ true\n\t\t\t\tfactors[#factors+1] = i\n\t\t\t\tfor k = i+1, n do\n\t\t\t\t\t\
    if (n % (k - 1) == 0) then\n\t\t\t\t\t\tisPrime = false\n\t\t\t\t\t\tbreak\n\t\
    \t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn (not isPrime) and factors\
    \ or nil\n\tend\n\tlocal primeFactors = findPrimeFactors(interval1.end, false)\
    \ or findPrimeFactors(interval2.end, true)\n\t\n\tlocal primeFactorLength = primeFactors\
    \ and #primeFactors or 0\n\treturn primeFactorLength == 1 and 'YES' or 'NO'\n\
    end", "\tlocal length_intersection = interval1[1]:sub(interval1[2])\n\tlocal length_other\
    \ = interval2[1]:sub(interval2[2])\n\tif length_intersection ~= length_other then\n\
    \t\treturn false\n\telse\n\t\tlocal prime_intersection = math.ceil(math.sqrt((length_intersection\
    \ + 1)) / 2)\n\t\tfor x = 2, prime_intersection do\n\t\t\tif length_intersection\
    \ % x == 0 then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\treturn true\n\t\
    end\nend", "    -- +++your code here+++\n    -- no need to worry about interval2\
    \ being negative because intersection is exclusive\n    local start1 = interval1[1]\n\
    \    local end1 = interval1[2]\n    local start2 = interval2[1]\n    local end2\
    \ = interval2[2]\n    \n    -- check for intersection first\n    if start1 <=\
    \ end2 and start2 <= end1 then\n        if start1 <= start2 then\n           \
    \ -- no intersection\n            return \"NO\"\n        else\n            --\
    \ intersection exists\n            local prime_length = math.min(end1 - start1\
    \ + 1, end2 - start2 + 1)\n            local is_prime = (prime_length == 2) and\
    \ (prime_length ~= math.gcd(prime_length, 2))\n            if is_prime then\n\
    \                return \"YES\"\n            else\n                return \"NO\"\
    \n            end\n        end\n    else\n        -- no intersection\n       \
    \ return \"NO\"\n    end\nend", "    local start, end = interval1[1], interval1[2]\n\
    \    local start2, end2 = interval2[1], interval2[2]\n    if start < end and start2\
    \ < end2 then\n        return prime_number(start <= end2 and\n            end2\
    \ <= start and start2 < end and end2 <= end2)\n    end\n    return 'NO'\nend",
  "   local interval1_start, interval1_end = interval1[1], interval1[2]\n   local\
    \ interval2_start, interval2_end = interval2[1], interval2[2]\n   local interval1_len\
    \ = interval1_end - interval1_start\n   local interval2_len = interval2_end -\
    \ interval2_start\n   if interval1_len == 0 or interval2_len == 0 then return\
    \ \"NO\" end\n   if interval1_start <= interval2_end and interval1_end >= interval2_start\
    \ then \n      return \"NO\"\n   else\n      return (interval1_len * interval2_len)\
    \ >= interval1_len * interval2_len\n   end\nend", "  local start1 = interval1[1]\n\
    \  local end1 = interval1[2]\n  local start2 = interval2[1]\n  local end2 = interval2[2]\n\
    \  if start1 > end2 then\n    return false\n  end\n  if start2 > end1 then\n \
    \   return false\n  end\n  if start1 == start2 and end1 == end2 then\n    return\
    \ 'NO'\n  end\n  if start1 == start2 then\n    return interval1[1] < interval2[2]\n\
    \  end\n  if end1 == end2 then\n    return interval1[2] < interval2[1]\n  end\n\
    \  if start1 < start2 then\n    if end1 < end2 then\n      return 'YES'\n    else\n\
    \      return interval2[2] < interval1[1]\n    end\n  else\n    if end1 < end2\
    \ then\n      return 'YES'\n    else\n      return interval2[1] < interval1[2]\n\
    \    end\n  end\nend", "  assert(interval1 ~= interval2) -- Two intervals can't\
    \ intersect\n  local start = max(interval1.start, interval2.start)\n  local end\
    \ = min(interval1.end, interval2.end)\n  -- If start and end are the same it means\
    \ one interval contains the other\n  if start == end then\n    return interval1.length\n\
    \  -- If no intersection\n  elseif start > end then\n    return 'NO'\n  -- If\
    \ intersect\n  elseif start <= 1 then\n    return 'NO'\n  -- If start > 1 and\
    \ end <= 1 then they are intersecting\n  elseif end <= 1 then\n    return 'YES'\n\
    \  end", "    local start = interval1[1]\n    local end = interval2[2]\n    local\
    \ length = end - start\n    if length == 1 then\n        if start < end then\n\
    \            return \"YES\"\n        else\n            return \"NO\"\n       \
    \ end\n    end\n    local isPrime = true\n    for i = 2, length + 1 do\n     \
    \   if start % i == 0 then\n            isPrime = false\n            break\n \
    \       end\n    end\n    if isPrime then\n        return \"YES\"\n    end\n \
    \   return \"NO\"\nend", "\tlocal start = math.min(interval1[1], interval2[1])\
    \ or 1\n\tlocal end = math.max(interval1[1], interval2[1]) or end\n\tlocal result\n\
    \tif start <= end then\n\t\tlocal firstInterval = interval1[1] - interval1[1]\
    \ + end\n\t\tlocal secondInterval = interval2[1] - interval2[1] + end\n\t\tlocal\
    \ intersect = firstInterval & secondInterval\n\t\tif intersect == 0 then\n\t\t\
    \tif firstInterval > secondInterval then\n\t\t\t\tresult = firstInterval\n\t\t\
    \telse\n\t\t\t\tresult = secondInterval\n\t\t\tend\n\t\telse\n\t\t\tif intersect\
    \ == firstInterval then\n\t\t\t\tresult = \"YES\"\n\t\t\telse\n\t\t\t\tresult\
    \ = \"NO\"\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend", "  assert(interval1\
    \ and interval2)\n  local interval1_start, interval1_end = interval1[1], interval1[2]\n\
    \  local interval2_start, interval2_end = interval2[1], interval2[2]\n  local\
    \ interval1_start_l, interval1_end_l = interval1_start, interval1_end\n  local\
    \ interval2_start_l, interval2_end_l = interval2_start, interval2_end\n  if interval1_start\
    \ > interval1_end or interval2_start > interval2_end then\n    return 'NO'\n \
    \ end\n  if interval1_end <= interval2_end then\n    if interval1_start <= interval2_end\
    \ then\n      interval1_start_l, interval1_end_l = interval1_end, interval2_end\n\
    \    else\n      interval1_start_l, interval1_end_l = interval2_end, interval1_end\n\
    \    end\n  else\n    if interval2_start <= interval1_end then\n      interval2_start_l,\
    \ interval2_end_l = interval2_end, interval1_end\n    else\n      interval2_start_l,\
    \ interval2_end_l = interval1_end, interval2_end\n    end\n  end\n  if interval1_start_l\
    \ > interval2_start_l or interval1_end_l > interval2_end_l then\n    return 'NO'\n\
    \  end\n  if interval1_end_l <= interval2_end_l then\n    if interval1_start_l\
    \ <= interval2_end_l then\n      interval1_start_l, interval1_end_l = interval1_end_l,\
    \ interval2_end_l\n    else\n      interval1_start_l, interval1_end_l = interval2_end_l,\
    \ interval1_end_l\n    end\n  end\n  if interval1_start_l <= interval2_start_l\
    \ and interval1_end_l >= interval2_end_l then\n    return 'NO'\n  end\n  if interval1_start_l\
    \ <= interval2_end_l and interval1_end_l >= interval2_start_l then\n    return\
    \ 'NO'\n  end\n  if interval1_start_l <= interval1_end_l and interval2_start_l\
    \ <= interval2_end_l then\n    return 'YES'\n  end\n  return 'NO'\nend", "\t--\
    \ Write your code here\n\tif interval1[1] < interval2[1] then\n\t\treturn \"NO\"\
    \n\telseif interval1[1] > interval2[1] then\n\t\treturn \"NO\"\n\telse\n\t\tif\
    \ interval1[2] < interval2[2] then\n\t\t\treturn \"NO\"\n\t\telseif interval1[2]\
    \ > interval2[2] then\n\t\t\treturn \"NO\"\n\t\telse\n\t\t\tif interval1[2] >\
    \ interval2[1] and interval1[2] > interval2[2] then\n\t\t\t\tif math.abs(interval1[1]-interval2[1])\
    \ <= math.abs(interval1[2]-interval2[2]) then\n\t\t\t\t\treturn \"NO\"\n\t\t\t\
    \telse\n\t\t\t\t\treturn \"YES\"\n\t\t\t\tend\n\t\t\telseif interval1[2] > interval2[1]\
    \ and interval1[2] < interval2[2] then\n\t\t\t\tif math.abs(interval1[1]-interval2[2])\
    \ <= math.abs(interval1[2]-interval2[2]) then\n\t\t\t\t\treturn \"NO\"\n\t\t\t\
    \telse\n\t\t\t\t\treturn \"YES\"\n\t\t\t\tend\n\t\t\telseif interval1[1] < interval2[1]\
    \ and interval1[2] > interval2[2] then\n\t\t\t\tif math.abs(interval1[1]-interval2[1])\
    \ <= math.abs(interval1[2]-interval2[2]) then\n\t\t\t\t\treturn \"NO\"\n\t\t\t\
    \telse\n\t\t\t\t\treturn \"YES\"\n\t\t\t\tend\n\t\t\telseif interval1[1] < interval2[1]\
    \ and interval1[2] < interval2[2] then\n\t\t\t\tif math.abs(interval1[1]-interval2[2])\
    \ <= math.abs(interval1[2]-interval2[2]) then\n\t\t\t\t\treturn \"NO\"\n\t\t\t\
    \telse\n\t\t\t\t\treturn \"YES\"\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif math.abs(interval1[1]-interval2[1])\
    \ <= math.abs(interval1[2]-interval2[2]) then\n\t\t\t\t\treturn \"NO\"\n\t\t\t\
    \telse\n\t\t\t\t\treturn \"YES\"\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend",
  "  -- Write your code here\n  -- return the result\nend", "   local start1, end1\
    \ = interval1[1], interval1[2]\n   local start2, end2 = interval2[1], interval2[2]",
  "   if interval1[1] <= interval2[1] and interval2[1] <= interval1[2] then\n    \
    \  if interval1[1] == interval2[1] then\n         if interval1[2] < interval2[2]\
    \ then\n            return false\n         end\n         return true\n      end\n\
    \      if interval1[2] == interval2[2] then\n         return true\n      end\n\
    \   end\nend\n</cell>\n<cell>\n%preview samples/intersection.lua\n</cell>\n<text>\n\
    Problem 7\nYou are given an array of positive integers nums. You are also given\
    \ an integer k.\nThe task is to find the k smallest and k largest numbers in nums.\n\
    You can assume that nums is already sorted.\nThe expected time complexity is O(logk).\n\
    The runtime is dominated by sorting and finding k largest elements.", "\tif interval1.start\
    \ < interval1.end and interval2.start < interval2.end then\n\t\tlocal start =\
    \ math.min(interval1.start, interval2.start)\n\t\tlocal end = math.max(interval1.end,\
    \ interval2.end)\n\t\tif start < end then\n\t\t\tlocal len = end - start\n\t\t\
    \tfor i=start, end do\n\t\t\t\tif isPrime(i) then\n\t\t\t\t\treturn 'YES'\n\t\t\
    \t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn 'NO'\nend", "  if interval1[1] <=\
    \ interval2[2] and interval1[2] <= interval2[1] then\n    return \"YES\"\n  elseif\
    \ interval1[1] <= interval2[1] and interval1[2] >= interval2[2] then\n    return\
    \ \"YES\"\n  elseif interval1[1] >= interval2[1] and interval1[2] <= interval2[2]\
    \ then\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  return\
    \ math.floor(\n  math.min( \n  math.max(interval1[1], interval2[1]), \n  math.max(interval1[2],\
    \ interval2[2])) - \n  math.max(interval1[1], interval2[1]) + \n  math.max(interval1[2],\
    \ interval2[2])) < 2\nend", "    local end1, start1 = interval1[1], interval1[2]\n\
    \    local end2, start2 = interval2[1], interval2[2]\n    \n    if end1 <= start2\
    \ or end2 <= start1 then\n        return \"NO\"\n    end\n    \n    local intersectionLength\
    \ = (end1 - start1) and (end2 - start2)\n    \n    if intersectionLength == 0\
    \ then\n        return \"NO\"\n    end\n    \n    -- check the length of the intersection\n\
    \    if isPrime(intersectionLength) == true then\n        return \"YES\"\n   \
    \ end\n    \n    return false\nend\n</code>\n<|/ a tags=lua |>\n<| a tags=lua\
    \ |>\n<code>", "  if interval1 ~= interval2 then\n    return false\n  end", " \
    \ local count = 0\n  for i = 1, #interval1 do\n    count = count + interval1[i]\
    \ <= interval2[i] and count or 0\n  end\n  \n  return #interval1 == 1 and count\
    \ and count > 0 and count % 2 == 0 and \"YES\" or \"NO\"\nend", "\tlocal start\
    \ = interval1.start <= interval2.start and\n\t\t\t\t\t\tinterval1.start < interval2.end\
    \ and\n\t\t\t\t\t\tinterval1.end > interval2.start\n\tlocal end = interval1.start\
    \ <= interval2.start and\n\t\t\t\t\t\tinterval1.start < interval2.end and\n\t\t\
    \t\t\t\tinterval1.end > interval2.end", "\tassert(interval1[1] < interval1[2],\
    \ 'Interval 2 should be smaller then interval 1')\n\tassert(interval1[2] < interval1[3],\
    \ 'Interval 2 should be smaller then interval 3')\n\tassert(interval2[1] < interval2[2],\
    \ 'Interval 1 should be smaller then interval 2')\n\tassert(interval2[2] < interval2[3],\
    \ 'Interval 1 should be smaller then interval 3')", "  return ((interval1[1] >=\
    \ interval2[1]) and (interval1[1] <= interval2[2])) or\n    ((interval1[2] >=\
    \ interval2[1]) and (interval1[2] <= interval2[2])) or\n    ((interval1[1] >=\
    \ interval2[1]) and (interval1[2] <= interval2[2])) or\n    ((interval1[1] <=\
    \ interval2[1]) and (interval1[1] >= interval2[2]))\nend\n</cell>\n<cell>", "\t\
    local result = \"NO\"\n\tif interval1[1] > interval2[1] or interval1[2] < interval2[2]\
    \ then\n\t\treturn result\n\telse\n\t\tlocal intersection = interval1[1] .. \"\
    ,\" .. interval1[2] .. \",\" .. interval2[1] .. \",\" .. interval2[2]\n\t\tif\
    \ #intersection == 2 then\n\t\t\tif interval1[1] > interval2[2] or interval2[1]\
    \ > interval1[2] then\n\t\t\t\treturn \"NO\"\n\t\t\telse\n\t\t\t\tif interval1[2]\
    \ == interval2[2] then\n\t\t\t\t\tresult = \"YES\"\n\t\t\t\telse\n\t\t\t\t\tresult\
    \ = \"NO\"\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tresult = \"NO\"\n\t\tend\n\
    \tend\n\treturn result\nend", "\tlocal start = interval1[1]\n\tlocal end = interval1[2]\n\
    \tlocal start = interval2[1]\n\tlocal end = interval2[2]\n\tlocal newInterval\
    \ = nil", "  -- [The length of the intersection of two intervals]\n  local length_intersection\
    \ = interval1[1] < interval2[1] and interval1[2] > interval2[2] and interval1[2]\
    \ > interval1[1] and interval1[1] < interval2[2] and interval1[1] < interval1[2]\n\
    \  if length_intersection then\n    return true\n  end\n  return false\nend",
  "    local start = min(interval1[1], interval2[1])\n    local end = max(interval1[2],\
    \ interval2[2])\n    if start > end then\n        return \"NO\"\n    elseif start\
    \ <= end then\n        local result = 0\n        for i = start, end + 1 do\n \
    \           if i % 2 == 0 then\n                result = result + 1\n        \
    \    end\n        end\n        if result == 2 then\n            return \"YES\"\
    \n        else\n            return \"NO\"\n        end\n    else\n        return\
    \ \"NO\"\n    end\nend", "  local start = interval1[1]\n  local end   = interval1[2]\n\
    \  local start = interval2[1]\n  local end   = interval2[2]\n  -- If one interval\
    \ is empty, return \"NO\".\n  if start <= end and start > 0 then\n    local length\
    \ = math.abs(end - start)\n    if length == 2 then\n      if start < end then\n\
    \        if start <= 3 then\n          return 'YES'\n        end\n        if end\
    \ >= 6 then\n          return 'YES'\n        end\n      else\n        if start\
    \ <= 3 then\n          return 'NO'\n        end\n        if end >= 6 then\n  \
    \        return 'NO'\n        end\n      end\n    end\n  end\nend", "    local\
    \ i1start = interval1[1]\n    local i1end = interval1[2]\n    local i2start =\
    \ interval2[1]\n    local i2end = interval2[2]", "  if interval1[1] < interval2[1]\
    \ then\n    return interval1[1] <= interval2[1] and\n    interval2[1] <= interval1[1]\
    \ and \n    interval1[2] < interval2[2] then\n    return interval1[2] <= interval2[2]\
    \ and\n    interval2[2] <= interval1[2]\n  end\n  return false\nend", "  local\
    \ start = interval1[1]\n  local end = interval1[2]\n  local start2 = interval2[1]\n\
    \  local end2 = interval2[2]", "  local start1, end1 = interval1[1], interval1[2]\n\
    \  local start2, end2 = interval2[1], interval2[2]", "\tlocal intersectStart =\
    \ 0\n\tlocal intersectEnd = 0\n\tlocal intersectLen = 0\n\tlocal start1 = interval1[1]\n\
    \tlocal end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\
    \tlocal tempEnd = 0\n\tlocal tempStart = 0\n\tlocal num = 0\n\tlocal isPrime =\
    \ true\n\tfor i = start1, end1 do\n\t\tfor j = start2, end2 do\n\t\t\tif i >=\
    \ j then\n\t\t\t\tintersectStart = j\n\t\t\t\tintersectEnd = i\n\t\t\t\tintersectLen\
    \ = j - i + 1\n\t\t\t\tif intersectLen == 2 then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\
    \t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tbreak\n\tend\n\tif intersectLen == 2 then\n\
    \t\treturn \"NO\"\n\tend\n\tfor i = 1, intersectLen, 1 do\n\t\tif end1 >= tempStart\
    \ and end2 >= tempStart then\n\t\t\tnum = num + math.abs(end1 - tempEnd) * (end2\
    \ - tempEnd)\n\t\tend\n\t\tif end1 < tempStart then\n\t\t\tnum = num + math.abs(end1\
    \ - tempStart) * (end2 - tempStart)\n\t\tend\n\t\tif end2 < tempStart then\n\t\
    \t\tnum = num + math.abs(end2 - tempStart) * (end1 - tempStart)\n\t\tend\n\t\t\
    if end1 <= tempStart then\n\t\t\tnum = num + math.abs(end1 - tempStart) * (end2\
    \ - tempStart)\n\t\tend\n\t\tif end2 <= tempStart then\n\t\t\tnum = num + math.abs(end2\
    \ - tempStart) * (end1 - tempStart)\n\t\tend\n\t\ttempStart = end1\n\t\ttempEnd\
    \ = end2\n\tend\n\tif math.floor(num) == num then\n\t\tisPrime = false\n\tend\n\
    \tif isPrime then\n\t\treturn \"YES\"\n\tend\n\treturn \"NO\"\nend", "  local\
    \ start = interval1[1]\n  local end = interval1[2]\n  if interval2[1] < start\
    \ or interval2[2] > end then return 'NO' end", "\t-- write your code in Lua 5.1\n\
    \t-- Your code here\nend", "    local interval1_start = interval1[1]\n    local\
    \ interval1_end = interval1[2]\n    local interval2_start = interval2[1]\n   \
    \ local interval2_end = interval2[2]\n    if interval1_start <= interval1_end\
    \ and interval2_start <= interval2_end then\n        return interval2_end - interval2_start\
    \ + 1\n    else\n        return interval1_end - interval1_start + 1 -- return\
    \ false when interval1 is not closed or interval2 is not closed\n    end\nend",
  "\tlocal length = math.abs(interval1[1] - interval1[1] + interval2[1] - interval2[1])\n\
    \treturn (math.ceil(length / 2) == math.ceil(length / 2)) and 'YES' or 'NO'\n\
    end", "\tlocal len1 = interval1[1] - interval1[1] + 1\n\tlocal len2 = interval2[1]\
    \ - interval2[1] + 1\n\tif len1 <= len2 then\n\t\treturn false\n\telseif len1\
    \ > len2 then\n\t\tlen1, len2 = len2, len1\n\tend\n\tlocal flag = false\n\tfor\
    \ i = 2, len2 do\n\t\tif interval1[1] <= interval2[1] and interval2[1] >= interval1[1]\
    \ then\n\t\t\tif interval1[1] == interval2[1] then\n\t\t\t\tflag = true\n\t\t\t\
    end\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn flag\nend", "\t-- write your\
    \ code here\n\tlocal i = 0\n\tlocal j = 0\n\tlocal i1 = interval1[1]\n\tlocal\
    \ j1 = interval1[2]\n\tlocal i2 = interval2[1]\n\tlocal j2 = interval2[2]\n\t\
    if i1 < i2 then\n\t\ti = i1\n\t\tj = i2\n\telse\n\t\ti = i2\n\t\tj = i1\n\tend\n\
    \tif i == j then\n\t\tprint(i, j)\n\t\tprint('No intersection')\n\t\treturn 'NO'\n\
    \tend\n\tif i >= j then\n\t\ti = i + 1\n\tend\n\tif j >= i then\n\t\tj = j + 1\n\
    \tend\n\tif j - i == 1 then\n\t\tprint(i, j)\n\t\tprint('YES intersection')\n\t\
    \treturn 'YES'\n\tend\n\treturn 'NO'\nend", "  if interval1[1] < interval2[1]\
    \ then\n    if interval1[1] < interval2[0] then\n      return false\n    end\n\
    \    return true\n  elseif interval1[1] > interval2[1] then\n    if interval1[1]\
    \ > interval2[0] then\n      return false\n    end\n    return true\n  end", " \
    \ local interval1_start = interval1[1]\n  local interval1_end = interval1[2]\n\
    \  local interval2_start = interval2[1]\n  local interval2_end = interval2[2]\n\
    \  local interval1_length = interval1_end - interval1_start + 1\n  local interval2_length\
    \ = interval2_end - interval2_start + 1\n  if interval1_start <= interval2_start\
    \ and interval1_end >= interval2_end or interval1_start >= interval2_start and\
    \ interval1_end <= interval2_end then\n    return interval1_length > 0 and interval2_length\
    \ > 0 and interval1_length <= interval2_length and interval1_length > 0 and interval2_length\
    \ <= interval1_length\n  else\n    return false\n  end\nend", "    local intervals\
    \ = {}\n    local length1 = 0\n    local length2 = 0\n    for i = 1, #interval1\
    \ do\n        local start = interval1[i]\n        local end = interval2[i]\n \
    \       if start > end then\n            intervals[#intervals+1] = {start, end}\n\
    \        else\n            intervals[#intervals+1] = {start, end }\n         \
    \   intervals[#intervals+1] = {start, end}\n            length1 = length1 + 1\n\
    \        end\n    end\n    for i = 1, #interval2 do\n        local start = interval2[i]\n\
    \        local end = interval1[i]\n        if start > end then\n            intervals[#intervals+1]\
    \ = {start, end}\n        else\n            intervals[#intervals+1] = {start,\
    \ end}\n            intervals[#intervals+1] = {start, end}\n            length2\
    \ = length2 + 1\n        end\n    end\n    if length1 == 0 and length2 == 0 then\n\
    \        return 'NO'\n    end\n    local isPrime = nil\n    for i = 1, #intervals\
    \ do\n        if length2 > length1 then\n            local start = intervals[i][1]\n\
    \            local end = intervals[i][2]\n            local value = length1 *\
    \ length2\n            if start > end then\n                value = length1\n\
    \            else\n                value = length2\n            end\n        \
    \    if value % 2 == 0 then\n                isPrime = false\n               \
    \ break\n            end\n            if value < 11 then\n                isPrime\
    \ = false\n                break\n            end\n            if value < 21 then\n\
    \                isPrime = true\n                break\n            end\n    \
    \    end\n        if length1 > length2 then\n            local start = intervals[i][1]\n\
    \            local end = intervals[i][2]\n            local value = length1 *\
    \ length2\n            if start > end then\n                value = length2\n\
    \            else\n                value = length1\n            end\n        \
    \    if value % 2 == 0 then\n                isPrime = false\n               \
    \ break\n            end\n            if value < 11 then\n                isPrime\
    \ = false\n                break\n            end\n            if value < 21 then\n\
    \                isPrime = true\n                break\n            end\n    \
    \    end\n        if length1 < length2 then\n            local start = intervals[i][1]\n\
    \            local end = intervals[i][2]\n            local value = length1 *\
    \ length2\n            if start > end then\n                value = length1\n\
    \            else\n                value = length2\n            end\n        \
    \    if value % 2 == 0 then\n                isPrime = false\n               \
    \ break\n            end\n            if value < 11 then\n                isPrime\
    \ = false\n                break\n            end\n            if value < 21 then\n\
    \                isPrime = true\n                break\n            end\n    \
    \    end\n    end\n    if isPrime == nil then\n", "    local left1 = interval1[1]\n\
    \    local right1 = interval1[2]\n    local left2 = interval2[1]\n    local right2\
    \ = interval2[2]\n    if left1 == right1 or left2 == right2 then\n        return\
    \ 'NO'\n    end\n    if left1 < left2 then\n        local temp = left1\n     \
    \   left1 = left2\n        left2 = temp\n    end\n    if right1 > right2 then\n\
    \        local temp = right1\n        right1 = right2\n        right2 = temp\n\
    \    end\n    if right1 <= right2 then\n        if right1 == left2 then\n    \
    \        return 'YES'\n        else\n            return 'NO'\n        end\n  \
    \  else\n        local temp = right1\n        right1 = right2\n        right2\
    \ = temp\n    end\n    local len1 = right1 - left1\n    local len2 = right2 -\
    \ left2\n    local len3 = len1 + len2 - 2\n    local a = (len1 ^ len2)\n    local\
    \ b = (len1 - len2)\n    local c = (len1 ^ len2)\n    local d = (len1 + len2)\n\
    \    if c == 1 then\n        return b == 1 and b == a and 'YES' or 'NO'\n    end\n\
    \    if b == 1 then\n        return a == 1 and a == b and 'YES' or 'NO'\n    end\n\
    \    if b == c then\n        if len1 == 1 then\n            return 'YES'\n   \
    \     else\n            return 'NO'\n        end\n    end\n    if b > c then\n\
    \        if len1 == 1 then\n            return 'NO'\n        else\n          \
    \  return 'YES'\n        end\n    end\n    if a == 1 then\n        return 'YES'\n\
    \    end\n    if a == b then\n        return 'YES'\n    end\n    return 'NO'\n\
    end", "  if interval1[1] == interval2[1] and interval1[2] == interval2[2] then\n\
    \    return \"YES\"\n  elseif interval1[1] < interval2[1] then\n    if interval1[2]\
    \ < interval2[2] then\n      return \"YES\"\n    end\n  else\n    if interval1[2]\
    \ > interval2[2] then\n      return \"YES\"\n    end\n  end", "  -- The only time\
    \ intervals that don't intersect are when the intersection\n  -- interval has\
    \ zero length.\n  if interval1.start > interval2.start then return \"NO\" end\n\
    \  if interval1.end < interval2.end then return \"NO\" end\n  local intersectionInterval\
    \ = {\n    start = min(interval1.start, interval2.start),\n    end = max(interval1.end,\
    \ interval2.end),\n  }\n  -- If the intersection is empty, it's prime.\n  if not\
    \ intersects(intersectionInterval) then return \"YES\" end\n  -- If the intersection\
    \ interval length equals the length of the interval,\n  -- then it is prime.\n\
    \  if intersectionInterval.length == interval1.length then return \"YES\" end\n\
    \  -- If the length of the intersection is prime, return \"YES\".\n  if isPrime(intersectionInterval.length)\
    \ then return \"YES\" end\nend", "    local intersection = nil\n    local end1\
    \ = interval1[1]\n    local end2 = interval2[1]\n    local start1 = interval1[2]\n\
    \    local start2 = interval2[2]\n    if end1 <= end2 then\n        if start1\
    \ <= start2 then\n            if end1 > start1 and end2 >= start2 then\n     \
    \           local start = math.max(start1, start2)\n                local end\
    \ = math.min(end1, end2)\n                intersection = (start - end) * (end\
    \ - start) -- This is an efficient way to compute intersection\n            end\n\
    \        end\n    end\n    return intersection\nend\n</cell>\n<cell>", "  local\
    \ start1 = interval1[1]\n  local end1 = interval1[2]\n  local start2 = interval2[1]\n\
    \  local end2 = interval2[2]", "  assert(type(interval1) == \"number\" and type(interval2)\
    \ == \"number\")\n  assert(interval1 > 0 and interval1 < interval2)\n  assert(interval2\
    \ > 0 and interval2 < interval1)\n  local length1 = interval2[1]\n  local length2\
    \ = interval1[1]\n  local start = math.max(interval1[1], interval2[1])\n  local\
    \ end = math.min(interval1[2], interval2[2])\n  local result = true\n  for i =\
    \ start + 1, end do\n    local n1 = interval1[i] or 0\n    local n2 = interval2[i]\
    \ or 0\n    if n1 <= n2 then\n      local n3 = n1 - n2\n      local is_prime =\
    \ n3 <= 1\n      if is_prime then\n        local prime_check\n        if n3 ==\
    \ 0 then\n          prime_check = false\n        else\n          prime_check =\
    \ not math.gcd(n3, 1)\n        end\n        local prime_check2 = n3 <= 1\n   \
    \     if prime_check2 then\n          prime_check = false\n        end\n     \
    \   if prime_check then\n          result = true\n        else\n          result\
    \ = false\n        end\n      else\n        local prime_check2 = n3 <= 1\n   \
    \     if prime_check2 then\n          result = false\n        end\n      end\n\
    \    end\n  end\n  return result\nend", "\t-- Initialize a temporary table to\
    \ store intervals\n\tlocal intervals = {}\n\tfor _, interval in pairs(interval1)\
    \ do\n\t\ttable.insert(intervals, interval)\n\tend\n\tfor _, interval in pairs(interval2)\
    \ do\n\t\ttable.insert(intervals, interval)\n\tend\n\t-- For each interval, iterate\
    \ through the table and check if \n\t-- the start and end points fall in the interval\n\
    \tfor _, interval in pairs(intervals) do\n\t\tif interval[1] <= interval[2] then\n\
    \t\t\tfor _, interval2 in pairs(intervals) do\n\t\t\t\tif interval[1] <= interval2[2]\
    \ and interval[2] <= interval2[1] then\n\t\t\t\t\t-- If both the start and end\
    \ points of these intervals fall in the same interval, return\n\t\t\t\t\tif interval[1]\
    \ == interval2[1] then\n\t\t\t\t\t\treturn 'YES'\n\t\t\t\t\tend\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn 'NO'\nend", "\tlocal s1, e1 = interval1[1],\
    \ interval1[2]\n\tlocal s2, e2 = interval2[1], interval2[2]\n\tif s1 < s2 then\n\
    \t\tif e1 < e2 then\n\t\t\treturn s2..'..'+e1\n\t\telse\n\t\t\treturn s2..'..'..'..'..'..'..'..'..'..'..'..'..'..'+e1\n\
    \t\tend\n\telse\n\t\tif e1 > e2 then\n\t\t\treturn s1..'..'..'..'..'..'..'..'..'..'..'..'..'..'..'..'+e2\n\
    \t\telse\n\t\t\treturn s1..'..'..'..'..'..'..'..'..'..'..'..'..'..'..'+e2\n\t\t\
    end\n\tend\nend", "\tif interval1[1] <= interval2[2] and interval1[2] >= interval2[1]\
    \ then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "\tlocal start\
    \ = min(interval1[1], interval2[1])\n\tlocal end = max(interval1[2], interval2[2])\n\
    \tif start < end then\n\t\treturn find_length(start, end)\n\telse\n\t\treturn\
    \ nil\n\tend\nend", "    local interval1Min, interval1Max = interval1[1], interval1[2]\n\
    \    local interval2Min, interval2Max = interval2[1], interval2[2]\n    \n   \
    \ if interval1Max <= interval2Min or interval1Min >= interval2Max then\n     \
    \   return 'NO'\n    end\n    \n    local rangeStart = max(interval1Min, interval2Min)\n\
    \    local rangeEnd = min(interval1Max, interval2Max)\n    \n    local num = 0\n\
    \    \n    for i = rangeStart, rangeEnd, 1 do\n        num = num + math.floor((i\
    \ - rangeStart) * (i - rangeStart) / 2)\n    end\n    \n    if num == rangeEnd\
    \ then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend", "\t\
    local result = 'NO'\n\tlocal intersection_len = math.min(interval1[1], interval2[1])\
    \ - math.max(interval1[1], interval2[1])\n\tif interval1[1] < interval2[1] and\
    \ interval1[2] < interval2[2] then\n\t\tresult = 'YES'\n\tend\n\treturn result,\
    \ intersection_len\nend", "\tlocal interval1_start = interval1[1]\n\tlocal interval1_end\
    \ = interval1[2]\n\tlocal interval2_start = interval2[1]\n\tlocal interval2_end\
    \ = interval2[2]", "\tif interval1[1] < interval2[0] then\n\t\treturn false\n\t\
    elseif interval2[1] < interval1[0] then\n\t\treturn true\n\telse\n\t\treturn not\
    \ (interval2[1] < interval1[1] and interval1[1] < interval2[1] and interval2[1]\
    \ < interval1[1])\n\tend\nend", "\tif interval1[1] <= interval2[1] and interval1[2]\
    \ <= interval2[2] then\n\t\tlocal length = math.abs(interval1[1] - interval1[2])\n\
    \t\tlocal prime = true\n\t\t-- iterate to find the first prime\n\t\tfor i, prime\
    \ do\n\t\t\tif length == 1 then break end\n\t\t\tif math.mod(length, prime) ~=\
    \ 0 then\n\t\t\t\tlength = math.div(length, prime)\n\t\t\t\tprime = false\n\t\t\
    \tend\n\t\tend\n\t\treturn prime and \"YES\" or \"NO\"\n\telse\n\t\treturn \"\
    NO\"\n\tend\nend", "\tlocal interval1Start=interval1[1]\n\tlocal interval1End=interval1[2]\n\
    \tlocal interval2Start=interval2[1]\n\tlocal interval2End=interval2[2]\n\tlocal\
    \ intersectCount=0\n\tfor i=interval1Start,interval1End,1 do\n\t\tfor j=interval2Start,interval2End,1\
    \ do\n\t\t\tif i==j then\n\t\t\t\tintersectCount=intersectCount+1\n\t\t\tend\n\
    \t\tend\n\tend\n\tif intersectCount%2==1 then\n\t\treturn \"NO\"\n\telse\n\t\t\
    if intersectCount==2 then\n\t\t\treturn \"YES\"\n\t\telse\n\t\t\treturn \"NO\"\
    \n\t\tend\n\tend\nend", "\tif interval1.start <= interval2.end and interval2.start\
    \ <= interval1.end then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend",
  "\tlocal l1 = interval1[1]\n\tlocal u1 = interval1[2]\n\tlocal l2 = interval2[1]\n\
    \tlocal u2 = interval2[2]", "\tlocal intersect, length, end1, end2, start1, start2\n\
    \tintersect = (start1 ~= end2) and (start2 ~= end1)\n\tend1 = interval1.end\n\t\
    end2 = interval2.end\n\tstart1 = interval1.start\n\tstart2 = interval2.start\n\
    \tif intersect then\n\t\tlength = end1 - start1 + end2 - start2\n\telse\n\t\t\
    end1 = end1 + 1\n\t\tend2 = end2 + 1\n\t\tstart1 = start1 + 1\n\t\tstart2 = start2\
    \ + 1\n\t\tlength = end1 - start1 + end2 - start2\n\tend\n\tif is_prime(length)\
    \ then\n\t\treturn \"YES\"\n\telse\n\t\treturn \"NO\"\n\tend\nend", "    local\
    \ i = 0\n    local j = 1\n    local intersection = 0\n    while i <= interval1.start\
    \ and j <= interval2.end do\n        if interval1.start < interval2.end and interval1.start\
    \ <= j then\n            intersection = interval1.end - interval1.start + 1 +\
    \ intersection\n            i = interval1.end + 1\n        else\n            intersection\
    \ = interval2.start - interval1.end + 1 + intersection\n            j = interval2.end\n\
    \        end\n    end", "  if interval1 ~= interval2 then\n    return false\n\
    \  end\n  local length = interval1[1] - interval1[1] + 1\n  if interval1[1] <=\
    \ interval2[1] and interval1[1] <= interval2[1] + length then\n    return true\n\
    \  elseif interval1[1] <= interval2[1] and interval1[1] < interval2[1] + length\
    \ then\n    interval2[1] = interval2[1] + length\n  else\n    interval1[1] = interval1[1]\
    \ + length\n    interval2[1] = interval2[1] + length\n  end\n  if interval1[2]\
    \ > interval2[2] and interval1[2] < interval2[2] + length then\n    return true\n\
    \  end\n  if interval1[2] > interval2[2] and interval1[2] < interval2[2] + length\
    \ then\n    return true\n  end\n  return false\nend", "\tlocal start_inter = interval1[1]:min(interval2[1])\n\
    \tlocal end_inter = interval1[2]:max(interval2[2])\n\tif start_inter >= end_inter\
    \ then\n\t\treturn 'NO'\n\telseif start_inter <= end_inter then\n\t\treturn 'YES'\n\
    \telse\n\t\treturn 'YES'\n\tend\nend", "\tlocal start1 = interval1[1]\n\tlocal\
    \ end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\
    \tif start1 <= end1 and start2 <= end2 then\n\t\treturn start1 <= start2 and end1\
    \ >= end2\n\telse\n\t\treturn false\n\tend\nend", "  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  -- TODO:\
    \ Write your code here\n  assert(start1 <= end1)\n  assert(start2 <= end2)\n \
    \ local intersect = end1 < end2 and end1 < start2 or end2 < start1\n  return intersect\
    \ and \"YES\" or \"NO\"\nend", "\tlocal result = 'NO'\n\tlocal interval1_start,\
    \ interval1_end = interval1[1], interval1[2]\n\tlocal interval2_start, interval2_end\
    \ = interval2[1], interval2[2]"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
