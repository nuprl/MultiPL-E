name: HumanEval_90_next_smallest
language: lua
prompt: "-- You are given a table of integers.\n-- Write a function next_smallest()\
  \ that returns the 2nd smallest element of the table.\n-- Return None if there is\
  \ no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5,\
  \ 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1,\
  \ 1})\n-- None\nlocal function next_smallest(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5,\
  \ 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Base case\n  if lst[1] == nil then\n    return nil\n  end", " \
    \  local smallest = lst[1]\n   for i = 2, #lst do\n      if lst[i] < smallest\
    \ then\n         smallest = lst[i]\n      end\n   end\n   return smallest\nend",
  "  local smallest, i, j = lst[1], 1, 1\n  while i <= #lst do\n    if lst[i] < smallest\
    \ then\n      smallest, i = lst[i], j + 1\n    end\n    i = i + 1\n  end\n  if\
    \ smallest == nil then\n    return nil\n  end\n  return smallest\nend", '  local
    i, min = 1, lst[1]', "  local smallest = nil\n  local i, count\n  for i, count\
    \ in pairs(lst) do\n    if count < 2 and smallest ~= nil then\n      count = smallest\n\
    \    elseif count > 2 then\n      count = count + 1\n      smallest = count\n\
    \    end\n  end\n  return smallest ~= nil and smallest\nend", "  local smallest,\
    \ second = lst[1], lst[2]\n  for i=3, #lst do\n    local a = lst[i]\n    if a\
    \ < smallest then\n      smallest, second = a, smallest\n    end\n    if smallest\
    \ > second then\n      break\n    end\n  end\n  return second\nend", "  if next(lst)\
    \ == nil then\n    return nil\n  end\n  local smallest = lst[1]\n  for i = 2,\
    \ #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n    end\n \
    \ end\n  return smallest\nend", "  if #lst == 0 then\n    return nil\n  end\n\
    \  local minimum, smallest = unpack(lst)\n  for i = 2, #lst do\n    local candidate,\
    \ small = unpack(lst)\n    if candidate < smallest then\n      minimum, smallest\
    \ = candidate, small\n    end\n  end\n  return smallest\nend", "    local smallest\
    \ = nil\n    for _, x in pairs(lst) do\n        if smallest == nil or x < smallest\
    \ then\n            smallest = x\n        end\n    end\n    return smallest\n\
    end", "  if lst:size() == 0 then\n    return nil\n  end\n  local smallest = lst[1]\n\
    \  local second_smallest = lst[2]\n  for i = 2, lst:size() do\n    if lst[i] <\
    \ smallest then\n      second_smallest = lst[i]\n    elseif lst[i] == smallest\
    \ then\n      second_smallest = second_smallest or lst[i]\n    end\n  end\n  return\
    \ second_smallest\nend\n</cell>\n<text>\nWrite a program to find all elements\
    \ of a list except the duplicates.\nReturn them in a new list.\nA list is duplicate\
    \ if two or more of the elements are repeated.\nThe function next_smallest() returns\
    \ the 2nd smallest element of the list.\nReturn None if the list is empty.\nThe\
    \ function next_unique() returns the 2nd smallest element of the list.\nReturn\
    \ None if there are less than 2 unique elements.", "    local smallest = nil\n\
    \    local smallest_idx = nil", "    local smallest = nil\n    for _, value in\
    \ ipairs(lst) do\n        if smallest == nil or value < smallest then\n      \
    \      smallest = value\n        end\n    end\n    return smallest\nend", "  if\
    \ #lst == 0 then\n    return nil\n  end", "  local smallest = lst[1]\n  for _,\
    \ x in ipairs(lst) do\n    if x < smallest then\n      smallest = x\n    end\n\
    \  end\n  return smallest\nend", "  -- Initialize our list to an empty table\n\
    \  local tbl = {}", "  if next(lst) == nil then\n    return nil\n  end\n  local\
    \ pivot = lst[1]\n  lst[1] = nil\n  local i = 2\n  while i <= #lst do\n    if\
    \ lst[i] < pivot then\n      lst[#lst+1], lst[i] = lst[i], lst[#lst+1]\n    else\n\
    \      break -- Exit the while loop\n    end\n    i = i + 1\n  end\n  return pivot\n\
    end", "  for i, v in pairs(lst) do\n    if v < lst[#lst] then\n      return v\n\
    \    end\n  end\n  return nil\nend", "  local min_val = nil\n  for _,v in ipairs(lst)\
    \ do\n    if min_val == nil or v < min_val then\n      min_val = v\n    end\n\
    \  end\n  return min_val\nend", "  if #lst == 0 then return nil end\n  local min_val\
    \ = lst[1]\n  for i = 2, #lst do\n    if lst[i] < min_val then\n      min_val\
    \ = lst[i]\n    end\n  end\n  return min_val\nend", "  -- Base case: empty list.\n\
    \  if type(lst) == 'table' and next(lst) ~= nil then\n    return nil\n  end\n\
    \  -- Find the smallest element of the list using binary search.\n  local function\
    \ binary_search(lst)\n    -- Assume that the smallest element is the 2nd smallest\
    \ element.\n    local _, min = 2, lst[1]\n    -- Iterate through the list until\
    \ we find an element that is larger than the minimum.\n    for i = 2, #lst do\n\
    \      if lst[i] < min then\n        min, idx = min, i\n      end\n    end\n \
    \   -- Return the element that has the minimum value.\n    return lst[idx]\n \
    \ end\n  -- If there are multiple elements that are minimums, search them in order.\n\
    \  local _, min = 2, lst[1]\n  for i = 2, #lst do\n    if lst[i] < min then\n\
    \      min = lst[i]\n    end\n  end\n  -- Return the minimum element in the list\
    \ if the list contains more than one minimum element.\n  return min and binary_search(lst)\n\
    end", '  local smallest, secondSmallest', "  local min_index = nil\n  local min_value\
    \ = nil\n  local current_index = 1\n  local current_value = nil", "  if type(lst)\
    \ == 'table' then\n    local lst = lst\n    for i = 2, #lst do\n      if lst[i\
    \ - 2] < lst[i] then\n        return lst[i - 2]\n      end\n    end\n  end\nend",
  "  local smallests = { }\n  local i = 1\n  while i <= #lst do\n    local value =\
    \ lst[i]\n    if not smallests[value] then\n      smallests[value] = i\n    end\n\
    \    i = i + 1\n  end\n  if #smallests > 1 then\n    return smallests[1]\n  end\n\
    end", "  local smallest = lst[1]\n  local next_value = lst[2]\n  for i = 2, #lst\
    \ do\n    local this_value = lst[i]\n    if this_value < next_value then\n   \
    \   smallest = this_value\n      next_value = this_value\n    end\n  end\n  return\
    \ next_value\nend", "  local min = lst.header[1]\n  local min_value = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] < min then\n      min = lst[i]\n      min_value\
    \ = lst[i-1]\n    end\n  end\n  return min_value\nend", "   local smallest = next(lst)\n\
    \   if smallest == nil then\n      return nil\n   end\n   for i=1,#lst do\n  \
    \    if lst[i] < smallest then\n         smallest = lst[i]\n      end\n   end\n\
    \   return smallest\nend", "  -- base case\n  if lst[1] == nil then\n    return\
    \ nil\n  end\n  -- recursive case\n  if lst[1] == lst[2] then\n    return lst[2]\n\
    \  else\n    -- lst[1] < lst[2] -> lst[2] is the smallest element\n    return\
    \ next_smallest(lst[2])\n  end\nend", "  -- Write your code in Python 3.8 (if\
    \ possible)\n  -- or Python 2.7 if you have not written yet the rest of the program\n\
    \  return lst[2]\nend", "  if lst[1] == nil then\n    return nil\n  else\n   \
    \ return lst[1]\n  end\nend\n</cell>\n<text>\nA few more things to notice before\
    \ we move on.", "\tlocal min\n\tfor _, x in ipairs(lst) do\n\t\tif min == nil\
    \ then\n\t\t\tmin = x\n\t\telseif x < min then\n\t\t\tmin = x\n\t\tend\n\tend\n\
    \treturn min\nend", "  if #lst < 2 then\n    return nil\n  end\n  local min =\
    \ lst[1]\n  local index = 1\n  while index <= #lst do\n    local elem = lst[index]\n\
    \    if elem < min then\n      index = index + 1\n      min = elem\n    else\n\
    \      index = index + 1\n    end\n  end\n  if index == #lst then\n    return\
    \ nil\n  else\n    return min\n  end\nend", "  for i = 1, #lst do\n    if lst[i]\
    \ < lst[i - 1] then return lst[i] end\n  end\n  return nil\nend", "  local largest,\
    \ smallest = lst[1], lst[2]\n  for _, v in pairs(lst) do\n    if smallest < v\
    \ then\n      largest, smallest = v, v\n    end\n  end\n  if smallest == largest\
    \ then\n    return nil\n  end\n  return largest\nend", "  local _, v = lst[1],\
    \ lst[2]\n  for i = 2, #lst do\n    local _, y = lst[i], lst[i + 1]\n    if v\
    \ < y then return v\n    v, y = y, v\n  end\n  return nil\nend", "  if #lst==0\
    \ then return nil end\n  if lst[1] < lst[2] then\n    return lst[2]\n  else\n\
    \    return lst[1]\n  end\nend", "  local smallest, smallest_so_far, count = lst[1],\
    \ 1, 0\n  for _,v in ipairs(lst) do\n    if v ~= smallest and v <= smallest then\n\
    \      count = count + 1\n    end\n    smallest_so_far = smallest or smallest_so_far\n\
    \    smallest = v\n  end\n  if count == 0 then\n    return smallest_so_far\n \
    \ end\n  local count2 = count + 1\n  if smallest == nil then\n    return next_smallest({smallest_so_far})\n\
    \  else\n    local lst2 = {smallest_so_far, smallest}\n    while count2 < #lst\
    \ and lst[count2] == lst2[count2] do\n      count2 = count2 + 1\n    end\n   \
    \ lst2[count2] = nil\n    return next_smallest(lst2)\n  end\nend", "    if not\
    \ lst then\n        return nil\n    end", '   local smallest = nil', '  if lst
    == nil then return end', "  return lst[#lst] or nil\nend", "   for i = 2, #lst\
    \ do\n      if lst[i-1] < lst[i] then return lst[i-1] end\n   end\n   return nil\n\
    end", "  local smallest = nil\n  for i = 2, #lst do\n    if lst[i] < smallest\
    \ or smallest == nil then\n      smallest = lst[i]\n    end\n  end\n  return smallest\n\
    end", "  local smallest = nil\n  local index = 1\n  while true do\n    local elem\
    \ = lst[index]\n    if smallest == nil or elem < smallest then\n      smallest\
    \ = elem\n      index = index + 1\n    else\n      index = index + 1\n    end\n\
    \    if index >= #lst then break end\n  end\n  return smallest\nend", "   if #lst\
    \ == 0 then\n      return nil\n   end\n   local key = lst[1]\n   local value =\
    \ nil\n   for _, elem in ipairs(lst) do\n      local new_elem = elem < key and\
    \ elem or key\n      if value == nil then\n         value = new_elem\n      else\n\
    \         if value < new_elem then\n            value = new_elem\n         end\n\
    \      end\n   end\n   return value\nend", "  if next(lst) == nil then\n    return\
    \ nil\n  end\n  return next(lst)\nend", "  if lst[1] < lst[2] then\n    return\
    \ lst[2]\n  else\n    return nil\n  end\nend", '  if lst == nil then return nil
    end', "  for i = #lst, 2, -1 do\n    if lst[i] == nil then\n      return nil\n\
    \    end\n    return lst[i]\n  end\nend", "  -- Base Case\n  if lst[1] == nil\
    \ then\n    return nil\n  end", "  local smallest, i, n = table.min(lst), 0, #lst\n\
    \  for i = 1, n do if lst[i] < smallest then smallest = lst[i] end end\n  if smallest\
    \ == nil then return nil end\n  local index = i\n  for i = i + 1, n do if lst[i]\
    \ < smallest then index = i break endend\n  return lst[index + 1]\nend", "  for\
    \ i = 2, #lst do\n    if lst[i] < lst[i - 1] then return lst[i] end\n  end\n \
    \ return nil\nend", "   for _, item in ipairs(lst) do\n      if item < lst[#lst]\
    \ then\n         return item\n      end\n   end\nend\n</cell>\n<text>\nP2.3",
  "  local smallest, value = lst[1], lst[2]\n  for _, value in pairs(lst) do\n   \
    \ if value < smallest then smallest, value = value, smallest end\n  end\n  return\
    \ smallest or value\nend", "  for i, v in ipairs(lst) do\n    if i <= #lst then\n\
    \      local smallest = lst[i - 1]\n      if smallest < v then\n        return\
    \ smallest\n      end\n    end\n  end\n  return nil\nend", "  if #lst == 0 then\n\
    \    local ret\n    return ret\n  else\n    local smallest = math.min(lst)\n \
    \   local elem = lst[smallest]\n    lst[smallest] = nil\n    return elem\n  end\n\
    end", "  if #lst == 0 then return end\n  local smallest = lst[1]\n  local new_lst\
    \ = lst[2:]\n  for i=2, #lst do\n    if lst[i] < smallest then break end\n   \
    \ smallest = lst[i]\n    new_lst = new_lst:insert(smallest)\n  end\n  return new_lst\n\
    end", "  if #lst == 0 then\n    \n    return nil\n  end\n  local smallest = lst[1]\n\
    \  for i = 2, #lst do\n    smallest = lst[i] if lst[i] < smallest end\n  end\n\
    \  return smallest\nend", '    local smallest = nil', "\tlocal smallest = nil\n\
    \tfor i, v in pairs(lst) do\n\t\tif smallest and v < smallest then\n\t\t\treturn\
    \ nil\n\t\tend\n\t\tsmallest = v\n\tend\n\treturn smallest\nend", "  if not lst\
    \ then return end -- empty table\n  local largest = lst[1]\n  for i, x in ipairs(lst)\
    \ do\n    if x < largest then\n      largest = x\n    end\n  end\n  if largest\
    \ == lst[1] then return largest\n  elseif largest[1] then return largest[1]\n\
    \  else return nil end\nend", "    if not lst then\n        return nil\n    end\n\
    \    local result = lst[1]\n    for i = 2, #lst do\n        if lst[i] < result\
    \ then\n            result = lst[i]\n        end\n    end\n    return result\n\
    end", "  return lst[next(lst)]\nend", "  -- The smallest value is the 2nd smallest\
    \ element in the array.\n  local smallest = lst[1]\n  for _, elt in pairs(lst)\
    \ do\n    if elt > smallest then return nil end\n  end\n  return smallest\nend",
  "  if lst[1] == nil then\n    return nil\n  end\n  local i, min = 1, lst[1]\n  for\
    \ i, v in ipairs(lst) do\n    if v < min then\n      min = v\n    end\n  end\n\
    \  lst[1] = min\n  return min\nend", "    local smallest = nil\n    local min_value\
    \ = nil", "   if not lst then return nil end\n   local i = #lst + 1\n   for k,\
    \ v in pairs(lst) do\n      if i < v then\n         i = v\n         k = k\n  \
    \    end\n   end\n   return k\nend", "  if #lst == 0 then\n    return nil\n  end\n\
    \  local i = math.random(#lst)\n  if i == 1 then\n    return lst[1]\n  end\n \
    \ if lst[i] < lst[i - 1] and lst[i] < lst[i + 1] then\n    return lst[i]\n  elseif\
    \ lst[i] > lst[i - 1] and lst[i] > lst[i + 1] then\n    return lst[i]\n  else\n\
    \    return lst[i]\n  end\nend", "  if #lst == 0 then return nil end\n  if lst[1]\
    \ == lst[2] then return lst[1] end\n  if lst[2] == lst[3] then return lst[2] end\n\
    \  return lst[3]\nend", "  local min = {x = nil, y = nil}\n  local current = nil",
  "    local _, result = next_smallest_aux(lst, nil)\n    return result\nend", " \
    \   local head\n    local min = nil\n    local min_val = nil\n    local rest =\
    \ lst\n    for i=1, #lst do\n        head = rest[1]\n        rest = rest[2]\n\
    \        if head < min then\n            min = head\n            min_val = head\n\
    \        elseif head == min then\n            min = head + 1\n            min_val\
    \ = head\n        end\n    end\n    if rest and rest[1] then\n        rest = rest[2]\n\
    \    end\n    if rest then\n        return rest\n    else\n        return min_val\n\
    \    end\nend", "  local n = 1\n  local next_elem = lst[1]\n  for i = 2, #lst\
    \ do\n    if lst[i] < next_elem then\n      n = i - 1\n      next_elem = lst[i]\n\
    \    end\n  end\n  if n ~= nil then\n    return next_elem\n  end\n  return nil\n\
    end", "    if lst == nil then\n        return nil\n    end", "  local smallest\
    \ = nil\n  for i, v in ipairs(lst) do\n    if smallest == nil then\n      smallest\
    \ = v\n    else\n      if v < smallest then\n        smallest = v\n      end\n\
    \    end\n  end\n  return smallest\nend", "  if next(lst) == nil then return nil\
    \ end\n  local i, j = 1, #lst\n  while j < i do\n    if lst[i] < lst[j] then\n\
    \      i, j = j, i\n    else\n      return lst[i]\n    end\n  end\nend", "  if\
    \ lst[1] == nil then\n    return nil\n  end\n  if lst[2] ~= nil then\n    return\
    \ lst[2]\n  end\n  local value = lst[1][1]\n  lst[1] = nil\n  lst[2] = value\n\
    \  return value\nend", "   local next_value = nil\n   local smallest_index = -1",
  "    if next(lst) == nil then return end\n    return lst[1]\nend", "  if next(lst)\
    \ == nil then\n    return nil\n  end\n  local key = next(lst)\n  while key ~=\
    \ nil do\n    if key < lst[1] then\n      return key\n    end\n    key = next(lst)\n\
    \  end\n  return nil\nend", "   if #lst == 0 then\n      return nil\n   end\n\
    \   local i, v = 2, lst[1]\n   for i = 2, #lst do\n      local d = lst[i]\n  \
    \    if d < v then\n         v = d\n         i = i - 1\n      end\n   end\n  \
    \ if i == #lst then\n      return nil\n   else\n      return lst[i]\n   end\n\
    end", "  if #lst == 0 then\n    return nil\n  end\n  local smallest = lst[1]\n\
    \  local second_smallest = lst[2]\n  local len = #lst\n  for i = 2, len do\n \
    \   if lst[i] < smallest then\n      second_smallest = lst[i]\n      smallest\
    \ = lst[i]\n    end\n  end\n  return smallest\nend", "   if lst == nil then return\
    \ nil end\n   local i = 2\n   while i < #lst do\n      if lst[i] < lst[1] then\
    \ return lst[i] end\n      i = i + 1\n   end\n   return nil\nend", "  return lst[#lst]\
    \ or next_smallest({lst[#lst]:next(), lst[#lst]:next()})\nend", "  local function\
    \ compare(a, b)\n    if a < b then return -1 else if a > b then return 1 else\
    \ 0 end\n  end\n  return first(sub(1, lst, compare))\nend", "  local largest,\
    \ smallest = lst[1], lst[1]\n  for i = 2, #lst do\n    if largest < lst[i] then\n\
    \      largest = lst[i]\n    end\n    if smallest > lst[i] then\n      smallest\
    \ = lst[i]\n    end\n  end\n  return smallest or nil\nend", "    if next(lst)\
    \ == nil then return end\n    local smallest = lst[1]\n    local position = next(lst)\n\
    \    while position and position[1] < smallest do\n        smallest = position[1]\n\
    \        position = next(position)\n    end\n    return smallest\nend", "  if\
    \ len(lst) == 0 then\n    return nil\n  end\n  local min_value = lst[1]\n  for\
    \ i = 2, #lst do\n    if lst[i] < min_value then\n      min_value = lst[i]\n \
    \   end\n  end\n  return min_value\nend", "  if lst == nil then\n    return nil\n\
    \  end\n  if #lst < 2 then\n    return nil\n  end\n  return lst[1]\nend", "  if\
    \ lst == nil then\n    return nil\n  else\n    local min = lst[1]\n    for _,\
    \ v in pairs(lst) do\n      if min > v then\n        min = v\n      end\n    end\n\
    \    return min\n  end\nend", "    local smallest = {}\n    for _, value in ipairs(lst)\
    \ do\n        table.insert(smallest, value)\n    end\n    table.sort(smallest)\n\
    \    if #smallest == 1 then\n        return smallest[1]\n    else\n        return\
    \ nil\n    end\nend", "   local min_el = lst[1]\n   local min = nil\n   for i\
    \ = 2, #lst do\n      if lst[i] < min_el then\n         min_el = lst[i]\n    \
    \     min = i\n      end\n   end\n   return min\nend", "  if next(lst) == nil\
    \ then\n    return nil\n  end", "  local smallest = lst[1]\n  local i = 1\n  while\
    \ i < #lst and smallest[1] < lst[i] do\n    smallest = lst[i]\n    i = i + 1\n\
    \  end\n  return smallest\nend", "  local key = {}\n  local mins = {}", "  if\
    \ #lst == 0 then return end\n  if lst[1] == lst[2] then return lst[2]\n  else\n\
    \    local first = lst[1]\n    for i = 1, #lst do\n      if lst[i] < first then\n\
    \        first = lst[i]\n      end\n    end\n    return first\n  end\nend", " \
    \ if type(lst) ~= 'table' then\n    return nil\n  elseif #lst == 0 then\n    return\
    \ nil\n  end\n  local smallest = lst[1]\n  local pos = 1\n  for i = 2, #lst do\n\
    \    local cur = lst[i]\n    if smallest < cur then\n      smallest = cur\n  \
    \    pos = i\n    end\n  end\n  return smallest\nend", "  local smallest, second_smallest,\
    \ index = 0, 0, 1\n  for _, elem in ipairs(lst) do\n    if elem < smallest then\n\
    \      second_smallest = smallest\n      smallest = elem\n    elseif elem < second_smallest\
    \ then\n      second_smallest = elem\n    end\n    if smallest ~= elem then break\
    \ end\n    index = index + 1\n  end\n  return second_smallest if not index then\
    \ return nil end\nend", "  return next(lst, nil, lst) end\nend", "  local smallest_idx\
    \ = #lst\n  for i = 1, #lst - 1 do\n    if lst[smallest_idx] > lst[i] then\n \
    \     smallest_idx = i\n    end\n  end\n  if smallest_idx == 1 then\n    return\
    \ nil\n  end\n  return lst[smallest_idx + 1]\nend", "  if lst[1] == nil then return\
    \ end\n  local val = lst[1]\n  lst[1] = nil\n  return val\nend", "    if next(lst)\
    \ == nil then\n        return\n    end", "  for i = #lst,1,-1 do\n    if lst[i]\
    \ < lst[i-1] then return lst[i-1]\n  end\n  return nil\nend", "  local smallest,\
    \ second = lst[1], lst[2]\n  local pos = 1\n  local is_sorted = true\n  local\
    \ function check()\n    if is_sorted\n      and pos < #lst\n      and lst[pos]\
    \ == smallest then\n      pos = pos + 1\n      return true\n    end\n    -- Otherwise,\
    \ if we have seen every element of the list so far, no elements satisfies the\
    \ requirement\n    -- so we can't find an element\n    return false\n  end\n \
    \ while check()\n    -- The list is sorted, but we haven't found the smallest\
    \ element yet\n    -- So we move on to the second\n    smallest, second = second,\
    \ lst[pos]\n    pos = pos + 1\n  end\n  -- No elements satisfy the requirement\n\
    \  return nil\nend", "  if #lst == 0 then return nil end\n  local elem = lst[1]\n\
    \  for i = 2, #lst do\n    if elem < lst[i] then\n      elem = lst[i]\n    end\n\
    \  end\n  return elem\nend\n</cell>\n<cell>", "  if #lst < 2 then return nil end\n\
    \  local smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest then\n\
    \      smallest = lst[i]\n    end\n  end\n  return smallest\nend", "  local function\
    \ is_smallest(key)\n    return key < lst[key] end\n  local i = 1\n  while i <=\
    \ #lst do\n    if i ~= #lst then\n      local key, value = lst[i - 1], lst[i]\n\
    \      if is_smallest(key) then return value end\n    end\n    i = i + 1\n  end\n\
    end", "  if #lst == 0 then\n    return nil\n  end\n  return lst[#lst]\nend", " \
    \ if lst == nil then\n    return nil\n  end\n  -- If the table is empty or only\
    \ has one element, then return it\n  if #lst == 1 then\n    return lst[1]\n  end",
  "  if lst == nil then return nil end\n  local smallest = lst[1]\n  for i = 2, #lst\
    \ do\n    if lst[i] < smallest then return smallest end\n    smallest = lst[i]\n\
    \  end\n  return nil\nend", "  if next(lst) == nil then\n    return nil\n  elseif\
    \ lst[1] < lst[2] then\n    return lst[1]\n  else\n    return lst[2]\n  end\n\
    end", "    if next(lst) == nil then return nil end\n    return next(lst)\nend",
  "  if next(lst) == nil then\n    return nil\n  else\n    return next(lst)\n  end\n\
    end", "    local value = lst[1]\n    for i = 2, #lst do\n        if value < lst[i]\
    \ then return lst[i] end\n    end\n    return nil\nend", "  if not lst then\n\
    \    return\n  elseif #lst > 1 then\n    if lst[#lst] <= lst[1] then\n      return\
    \ lst[#lst]\n    end\n  end\n  return\nend", "  -- Sort the list\n  lst:sort(function(a,\
    \ b)\n    local v1 = b - 1\n    local v2 = a\n    local d = v2 - v1\n    if d\
    \ ~= 0 then\n      return d\n    end\n  end)\n  -- Get the 1st element in the\
    \ list\n  local elem = lst[1]\n  if elem == nil then\n    return nil\n  end\n\
    \  -- Get the 2nd smallest element in the list\n  return elem\nend", "  if #lst\
    \ <= 1 then\n    return nil\n  end\n  local smallest = lst[1]\n  for i=2,#lst\
    \ do\n    if lst[i] < smallest then\n      smallest = lst[i]\n    end\n  end\n\
    \  return smallest\nend", "  if #lst == 0 then return nil end\n  local minimum,\
    \ minimum2 = lst[1], lst[1]\n  for i = 2, #lst do\n    if lst[i] < minimum and\
    \ minimum2 ~= nil then return minimum2 end\n    minimum2 = minimum\n    minimum\
    \ = lst[i]\n  end\n  return minimum\nend", "\t-- Handle the empty case\n\tif #lst\
    \ == 0 then\n\t\treturn nil\n\tend", "  local smallest, index = {}, {}\n  for\
    \ i, v in ipairs(lst) do\n    if v < smallest then\n      smallest = v\n     \
    \ index[i] = i\n    end\n  end\n  if #index == 0 then return nil end\n  return\
    \ smallest\nend", "    if next(lst) == nil then\n        return nil\n    end\n\
    \    local smallest = next(lst)\n    for i=next(lst) do\n        if i ~= smallest\
    \ then\n            return i\n        end\n    end\n    return nil\nend", "  --\
    \ Check for an empty list\n  if not lst[1] then return nil end", "  if lst[1]\
    \ == nil then return nil end\n  local elem = lst[1]\n  lst[1] = lst[2]\n  lst[2]\
    \ = elem\n  return elem\nend", "    local smallest, second_smallest = lst[1],\
    \ lst[2]\n    for i = 2, #lst do\n        if smallest > lst[i] then\n        \
    \    smallest, second_smallest = second_smallest, lst[i]\n        end\n    end\n\
    \    return second_smallest\nend", "  local smallest, i, smallest_index, count\n\
    \  for i = 1, #lst do\n    count = #lst\n    if count <= 1 then\n      smallest_index\
    \ = i - 1\n      break\n    end\n    if lst[i] < smallest then\n      smallest\
    \ = lst[i]\n      smallest_index = i\n    end\n  end\n  return smallest_index\n\
    end", "  if #lst==0 then\n    return nil\n  else\n    local smallest=lst[1]\n\
    \    for i=2,#lst do\n      if lst[i]<smallest then\n        smallest=lst[i]\n\
    \      end\n    end\n    return smallest\n  end\nend", "  local small, large =\
    \ lst[1], lst[1]\n  for i = 2, #lst do\n    small, large = small, lst[i] if small\
    \ == lst then lst[i] else (small, large)\n  end\n  return large\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=lua |>\nYou can do it in O(n) without looping through\
    \ all the elements as suggested by user1899362.\n<code>", "  -- Base Case\n  if\
    \ lst[1] == nil then\n    return nil\n  end", "  local smallest, n = lst[1][1],\
    \ 1\n  for i = 2, #lst do\n    if n <= smallest\n    then\n      smallest, n =\
    \ lst[i][1], n + 1\n    end\n  end\n  return smallest\nend", "  local i = 1\n\
    \  while i < #lst and lst[i] <= lst[i - 1] do\n    i = i + 1\n  end\n  if i ==\
    \ #lst then\n    return nil\n  end\n  return lst[i + 1]\nend", "  if not lst or\
    \ #lst == 0 then\n    return nil\n  end\n  local value = lst[1]\n  local is_min\n\
    \  for i = 2, #lst do\n    if lst[i] < value then\n      value = lst[i]\n    \
    \  is_min = true\n    end\n  end\n  return is_min and value or nil\nend", "  --\
    \ Write your code here\n  -- Solution provided by Akhilesh Divekar\n  if lst[1]\
    \ then\n    return lst[1]\n  end\n  -- If we have only one element, then return\
    \ the next smallest\n  return lst[2] or next_smallest(lst[3])\nend", "  local\
    \ smallest = lst[1]\n  for i = 2, #lst do\n    if lst[i] < smallest then return\
    \ lst[i] end\n    smallest = smallest\n  end\n  return nil\nend", "  if #lst ==\
    \ 0 then\n    return nil\n  end", "  local _, index = unpack(lst)\n  local i =\
    \ index - 1\n  while i >= 0 and lst[i] == nil do\n    i = i - 1\n  end\n  return\
    \ lst[i + 1] or lst[index]\nend", "  if #lst == 0 then\n    return nil\n  end",
  "  if #lst == 0 then\n    return nil\n  end\n  local min\n  min = lst[1]\n  for\
    \ i = 2, #lst do\n    if lst[i] < min then\n      min = lst[i]\n    end\n  end\n\
    \  return min\nend", "  if lst:len() > 0 then\n    local smallest1, smallest2\
    \ = lst:min()\n    if smallest2 < smallest1 then\n      return smallest2\n   \
    \ end\n  end\n  return nil\nend", "    local smallest\n    for _,v in ipairs(lst)\
    \ do\n        if smallest ~= nil then\n            if v < smallest then\n    \
    \            smallest = nil\n            end\n        else\n            smallest\
    \ = v\n        end\n    end\n    return smallest\nend\n</code>\n<|/ a tags=lua-table,lua\
    \ dscore=3 |>\n<| a dscore=2 |>\nAn old question, but I wanted to add my two cents.\n\
    As a data structure, you are not dealing with a list. Lua tables are implemented\
    \ with a hash table, but that is a detail you really shouldn't care about. Instead,\
    \ you should only care about what operations are supported on the table itself\
    \ and not on its values. A table is just a collection of values, with the ability\
    \ to perform certain operations (see the table's documentation for the full list).\n\
    As you probably know, each time you access a table value or index, the value will\
    \ need to be retrieved from the table's hash table and converted into a suitable\
    \ data type (typically a number). So, by definition, you are not guaranteed to\
    \ get the smallest value out of any table, but you cannot even tell the order\
    \ of the keys (the hash table is what keeps the values ordered).\nThe solution\
    \ is to simply perform a binary search on the table to get the smallest value.\n\
    <code>", "  for i, v in pairs(lst) do\n    if v <= lst[i + 1] then\n      return\
    \ v\n    end\n  end\n  return nil\nend", "   -- write your code here\nend", " \
    \ if next(lst) == nil then return nil end\n  local i, value = next(lst)\n  local\
    \ j = i\n  for k, v in pairs(lst) do\n    if k < value then\n      i = j\n   \
    \   value = k\n    end\n    j = j - 1\n  end\n  return value\nend\n</cell>\n<text>\n\
    4.8 Consider the following algorithm:", "   if #lst == 0 then return nil end\n\
    \   local smallest, i = lst[1], 1\n   for i = 2, #lst do\n      if lst[i] < smallest\
    \ then\n         smallest, i = lst[i], i\n      end\n   end\n   return smallest\n\
    end", "  if lst == nil then return nil end\n  local i, min\n  for i, min in ipairs(lst)\
    \ do\n    if min < #lst then\n      return lst[min+1]\n    end\n  end\n  return\
    \ nil\nend", "  if lst == nil then return end\n  if next(lst) == nil then return\
    \ end\n  return next(lst)\nend", "  return lst[2] or lst[1]\nend", "  -- Return\
    \ the 2nd smallest\n  return lst[table.sort(lst)[2]]\nend", "  local smallest,\
    \ count = lst[1], 1\n  local _, cursor = lst[1]\n  while cursor ~= nil and count\
    \ < #lst do\n    smallest, count = lst[cursor], count+1\n    cursor, cursor =\
    \ lst[cursor], nil\n  end\n  return smallest and smallest\nend", "    local smallest_key\
    \ = nil\n    local smallest_value = nil\n    for _, value in pairs(lst) do\n \
    \       if value <= smallest_value then\n            smallest_value = value\n\
    \            smallest_key = first\n        elseif value == smallest_value then\n\
    \            smallest_key = smallest_key or first\n        end\n        first\
    \ = first + 1\n    end\n    return smallest_key\nend", "  local head = {}\n  for\
    \ i, value in ipairs(lst) do\n    if head == nil or value < head[1] then head\
    \ = {i, value} end\n  end\n  return head[1]\nend", "  local smallest = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] < smallest then return lst[i] end\n  end\n\
    end", "    local min_val = next(lst)\n    local second_val = next(lst)\n    while\
    \ min_val < second_val do\n        second_val = next(lst)\n    end\n    return\
    \ second_val\nend", "   local smallest = nil\n   local smallest_idx = nil\n  \
    \ for _, item in ipairs(lst) do\n      if not smallest or item < smallest then\n\
    \         smallest = item\n         smallest_idx = nil\n      else\n         smallest_idx\
    \ = #lst + 1\n      end\n   end\n   return smallest and lst[smallest_idx] or nil\n\
    end", "  if #lst == 0 then\n    return nil\n  end\n  local value = lst[1]\n  for\
    \ i = 2, #lst do\n    if value < lst[i] then\n      value = lst[i]\n    end\n\
    \  end\n  return value\nend", "  if len(lst) == 0 then\n    return nil\n  end\n\
    \  local n = lst[1]\n  local new_lst = lst:copy()\n  new_lst[1] = n + 1\n  return\
    \ next_smallest(new_lst)\nend", "  for i = 2, #lst do\n    if lst[i] < lst[i -\
    \ 1] then\n      return lst[i]\n    end\n  end\n  return nil\nend", "  if lst\
    \ then\n    local key, value = unpack(lst)\n    if value < key then\n      return\
    \ value\n    end\n  end\n  return nil\nend", "  -- Base case\n  if #lst == 0 then\n\
    \    return nil\n  end\n  \n  -- Find the smallest element in the tail of the\
    \ list\n  local smallest = lst[1]\n  for i = 2, #lst do\n    smallest = lst[i]\
    \ < smallest and lst[i] or smallest\n  end\n  return smallest\nend", "  local\
    \ min_elem = nil\n  local min_ele_index = nil\n  for index, elem in pairs(lst)\
    \ do\n    if elem ~= nil then\n      if min_elem == nil then\n        min_elem\
    \ = elem\n        min_ele_index = index\n      else\n        if elem < min_elem\
    \ then\n          min_elem = elem\n          min_ele_index = index\n        end\n\
    \      end\n    end\n  end\n  if min_ele_index ~= nil then\n    return lst[min_ele_index]\n\
    \  end\n  return nil\nend", "  local lst = lst or {}\n  local smallest = math.min(lst)\n\
    \  while smallest ~= nil do\n    lst[#lst + 1] = smallest\n    smallest = math.min(lst)\n\
    \  end\n  local result = lst[#lst]\n  if result ~= nil then\n    return result\n\
    \  end\n  return nil\nend", "  local key = lst[1]\n  for i = 2, #lst do\n    if\
    \ lst[i] < key then\n      return lst[i]\n    end\n  end\n  return nil\nend",
  "  return next(lst, lst[1]) if lst and lst[1] < lst[2] and lst[2] < lst[3] and lst[3]\
    \ < lst[4] end\nend", "  if #lst == 0 then\n    return nil\n  end\n  local current\
    \ = lst[1]\n  for i = 2, #lst do\n    if current > lst[i] then\n      return current\n\
    \    end\n    current = lst[i]\n  end\nend", "  for _, elem in ipairs(lst) do\n\
    \    if elem < lst[2] then return elem\n  end\n  return nil\nend", "  local function\
    \ less(x, y)\n    return x < y\n  end", "    for k, v in pairs(lst) do\n     \
    \   if v < lst[v + 1] then\n            return v\n        end\n    end\nend",
  "  local n = #lst\n  if n == 0 then\n    return nil\n  end", "  return next(lst,\
    \ #lst) or nil\nend", "    local smallest = nil\n    local smallest_val = nil\n\
    \    for i, x in ipairs(lst) do\n        if smallest_val == nil or x < smallest_val\
    \ then\n            smallest_val = x\n            smallest    = i\n        end\n\
    \    end\n    return smallest == nil and nil or lst[smallest]\nend", "    local\
    \ idx = 1\n    local key = lst[idx]\n    while idx <= #lst and key <= lst[idx\
    \ - 1] do\n        idx = idx + 1\n        key = lst[idx]\n    end\n    return\
    \ key\nend", "  if next(lst) == nil then return nil end\n  return lst[1]\nend",
  "  if #lst == 0 then\n    return None\n  end", "  for k, v in pairs(lst) do\n  \
    \  if k < 2 then\n      return v\n    end\n  end\n  return nil\nend", "  if next(lst)\
    \ == nil then return nil end\n  if lst.val <= lst.next then return lst.val end\n\
    \  return next_smallest(lst.next)\nend", "  if type(lst) ~= 'table' then\n   \
    \ return nil\n  end", "    if next(lst) == nil then return nil end\n    local\
    \ curr, minimum = lst[1], lst[1]\n    for i = 2, #lst do\n        local val =\
    \ lst[i]\n        if minimum > val then\n            curr, minimum = minimum,\
    \ val\n        else\n            minimum, curr = val, minimum\n        end\n \
    \   end\n    return curr\nend", "  if type(lst) == \"table\" and #lst > 0 then\n\
    \    if lst[#lst] < lst[1] and #lst > 1 then\n      -- Return the 2nd smallest\
    \ element\n      return lst[#lst]\n    else\n      -- Return the 2nd smallest\
    \ element in the list\n      return lst[1]\n    end\n  else\n    -- Return None\
    \ if there is no such element\n    return nil\n  end\nend", '  local value = nil',
  "  if #lst <= 1 then return end\n  local smallest = lst[1]\n  for i=2, #lst do\n\
    \    if lst[i] < smallest then return i end\n    smallest = smallest\n  end\n\
    \  return nil\nend\n</cell>\n<text>\nThe next_largest() function will be similar\
    \ to the previous one.", "    for _,i in pairs(lst) do\n        if i > lst[#lst]\
    \ then\n            return i\n        end\n    end\nend", "  if #lst <= 1 then\
    \ return nil end\n  if #lst == 2 then\n    local a, b\n    if lst[1] < lst[2]\
    \ then\n      a = lst[1]\n      b = lst[2]\n    else\n      a = lst[2]\n     \
    \ b = lst[1]\n    end\n    return a, b -- return a tuple\n  end\n  local n = #lst\n\
    \  local m = math.min(n-1, n+2)\n  if m < 2 then return nil end\n  local x = lst[math.min(m-1,n)]\n\
    \  lst[m:n] = lst[#lst]\n  lst[#lst] = x\n  return x\nend", "    local min_val\
    \ = nil\n    for index, value in ipairs(lst) do\n        if min_val == nil or\
    \ value < min_val then\n            min_val = value\n        end\n    end\n  \
    \  return min_val\nend", "  local function helper(list)\n    local smallest =\
    \ list[1]\n    local result = nil\n    for i = 2, #list do\n      if list[i] <\
    \ smallest then\n        smallest = list[i]\n        result = list[1]\n      else\n\
    \        result = smallest\n      end\n    end\n    return result\n  end\n  if\
    \ #lst > 1 then\n    return helper(lst, lst[1])\n  else\n    return nil\n  end\n\
    end", "  if lst[1] < lst[2] then\n    local smallest = lst[1]\n    lst[1] = lst[2]\n\
    \    lst[2] = smallest\n  end\n  return lst[2]\nend", "\t-- check for empty list\n\
    \tif not lst then return end -- this fixes case where empty list is provided as\
    \ input for next_smallest function\n\t-- check for null list\n\tif lst == nil\
    \ then return end -- this fixes case where empty list is provided as input for\
    \ next_smallest function", "  if lst == nil then\n    return nil\n  end\n  local\
    \ key = lst[1]\n  lst = lst[2:end]\n  return key\nend", "  -- For each element\
    \ in the list, get the index of that element\n  -- >>> lst = [1]\n  -- >>> next_smallest(lst)\n\
    \  -- 0\n  -- >>> lst = [1]\n  -- >>> next_smallest(lst)\n  -- 1\n  local indexes\
    \ = {}\n  for i=0,#lst do\n    indexes[i] = i\n  end\n  -- Keep sorting the list\
    \ until we find the second smallest element\n  -- or we run out of elements\n\
    \  local second_smallest = indexes[1]\n  for i=2,#indexes do\n    if indexes[i]\
    \ < second_smallest then\n      second_smallest = indexes[i]\n    end\n  end\n\
    \  return second_smallest end\nend", "  -- Start with the smallest element\n \
    \ local smallest = lst[1]", "  local smallest, index, i = 1+lst[1], 1, 1\n  for\
    \ i, v in pairs(lst) do\n    if v < smallest then\n      smallest, index, i =\
    \ v, i, i+1\n    end\n  end\n  if i == lst[1] then\n    return nil\n  end\n  return\
    \ smallest\nend", "  local size = #lst\n  if size == 0 then return nil end\n \
    \ local i = 1\n  local min = lst[1]\n  while i <= size do\n    local el = lst[i]\n\
    \    if el < min then\n      min = el\n    end\n    i = i + 1\n  end\n  return\
    \ min\nend", "  return tbl.getn(lst) == 0 and not lst or tbl.getn(lst) == 1 and\
    \ lst[1] or nil\nend", "    if not lst then return nil end\n    local smallest,\
    \ secondlargest = lst[1], lst[1]\n    for _, v in pairs(lst) do\n        if v\
    \ < smallest then secondlargest = v end\n        if v > smallest then smallest\
    \ = v end\n    end\n    return secondlargest\nend", "  local smallest = nil\n\
    \  local smallest_idx = 1\n  for i = 1, #lst do\n    if smallest == nil or lst[i]\
    \ < smallest then\n      smallest = lst[i]\n      smallest_idx = i\n    end\n\
    \  end\n  return smallest_idx and smallest\nend", "  local smallest = nil\n  for\
    \ _, value in ipairs(lst) do\n    if smallest ~= nil and value < smallest then\n\
    \      return smallest\n    end\n    smallest = value\n  end\n  return smallest\n\
    end", "    local smallest = nil\n    for value in lst do\n        if smallest\
    \ ~= nil then\n            if value < smallest then\n                smallest\
    \ = value\n            end\n        else\n            smallest = value\n     \
    \   end\n    end\n    return smallest\nend", "  if next(lst) == nil then return\
    \ nil end\n  local min, max = lst[1], lst[2]\n  while lst[2] ~= min do\n    max\
    \ = lst[2]\n    lst = lst[3]\n  end\n  return max\nend\n</cell>\n<code language=julia-1.0>\n\
    # Now try it out!", "  if #lst <= 1 then\n    return nil\n  end\n  local min,\
    \ max = lst[1], lst[1]\n  for i = 2, #lst do\n    if lst[i] < min then\n     \
    \ min = lst[i]\n    elseif lst[i] > max then\n      max = lst[i]\n    end\n  end\n\
    \  return max\nend", "  if next(lst) == nil then\n    return nil\n  end\n  local\
    \ cur = next(lst)\n  local last = lst\n  while last ~= nil and last[1] < cur[1]\
    \ do\n    last = last[2]\n  end\n  if last ~= nil then\n    return last[1]\n \
    \ end\n  return cur[1]\nend\n</cell>\n<text>\nNext Steps\nIn the next notebook\
    \ we will use these functions to calculate the total and average of a list of\
    \ numbers.", "  if #lst == 0 then return nil end\n  local v = lst[1]\n  for i\
    \ = 2, #lst do\n    if lst[i] < v then\n      v = lst[i]\n    end\n  end\n  return\
    \ v\nend", "  if #lst <= 1 then return nil end\n  local min2, min1, min0, x =\
    \ lst[1], lst[1], lst[1], 0\n  for i = 2, #lst do\n    if x < i then\n      min0,\
    \ min1 = min1, i\n      x = i\n    else\n      min2, min0 = min0, min1\n     \
    \ x = i - 1\n    end\n  end\n  lst[2] = min2\n  return min0\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
