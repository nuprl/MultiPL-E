name: HumanEval_13_greatest_common_divisor
language: lua
prompt: "-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor(3,\
  \ 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a,\
  \ b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = greatest_common_divisor\n\
  \    lu.assertEquals(candidate(3, 7), 1)\n    lu.assertEquals(candidate(10, 15),\
  \ 5)\n    lu.assertEquals(candidate(49, 14), 7)\n    lu.assertEquals(candidate(144,\
  \ 60), 12)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   if a == 0 then\n      return b\n   end\n   if a == b then\n    \
    \  return a\n   end", "  if b == 0 then\n    return a\n  elseif b > a then\n \
    \   a, b = b, a\n  end\n  repeat\n    a, b = a % b, a\n  until (b == 0)\n  return\
    \ a\nend", "    while a > b do\n        a = a % b\n    end\n    return a\nend",
  "\tif a == 0 then return 0 end\n\tif b == 0 then return 0 end\n\t\n\twhile b > 0\
    \ do\n\t\tlocal c = a % b\n\t\tif c == 0 then\n\t\t\ta = b\n\t\telse\n\t\t\ta\
    \ = c\n\t\t\tb = a\n\t\tend\n\tend\n\treturn a\nend", "  if b == 1 then\n    return\
    \ a\n  elseif b == 0 then\n    return 0\n  elseif b < a then\n    local s, e =\
    \ b - a, b - a\n    -- Make sure we do not have a negative divisor \n    if s\
    \ <= 0 and e <= 0 then\n      -- This fixes a bug with negative divisors\n   \
    \   -- >>> greatest_common_divisor(-8, -2)\n      -- -8\n      return e\n    end\n\
    \    return greatest_common_divisor(s, b) -- a / b\n  else\n    local s, e = b\
    \ - a, b - a\n    -- Make sure we do not have a negative divisor \n    if s <=\
    \ 0 and e <= 0 then\n      -- This fixes a bug with negative divisors\n      --\
    \ >>> greatest_common_divisor(8, -2)\n      -- 2\n      return s\n    end\n  \
    \  return greatest_common_divisor(a, s) -- b / a\n  end\nend", "    -- TODO: Optimize\
    \ this by using a power of two and shifting instead of division\n    -- >>> greatest_common_divisor(25,\
    \ 15)\n    -- 5\n    -- >>> greatest_common_divisor(101, 255)\n    -- 255\n  \
    \  if b == 0 then return 0\n    else if a > b then return greatest_common_divisor(b,\
    \ a % b)\n    else return greatest_common_divisor(a, a % b)\n    end\nend", "\t\
    -- Find the GCD of a and b, leaving remainder a & b\n\t-- a & b > 0 => GCD is\
    \ (a/b)\n\t-- a & b < 0 => GCD is (b/a)\n\t-- a & b == 0 => GCD is 1", "  if b\
    \ == 0 then\n    return a\n  elseif b > a then\n    return greatest_common_divisor(b,\
    \ a%b)\n  else\n    return a%b\n  end\nend", "\tassert(type(a) == \"number\" and\
    \ type(b) == \"number\")\n\tif a == 0 then return 0 end\n\tif b == 0 then return\
    \ b end\n\tif a > b then a, b = b, a end\n\tlocal remainder = 1\n\tlocal a_pow\
    \ = math.pow(a, b)\n\twhile a_pow < a do remainder = a_remainder + 1 end\n\treturn\
    \ a * remainder\nend", "  if a == 0 then return b end\n  if b == 0 then return\
    \ a end\n  if b == a then return b end\n  if b < a then\n    a,b = b,a\n  end\n\
    \  local div = a % b\n  if div == 0 then\n    return b\n  else\n    return greatest_common_divisor(b,div)\n\
    \  end\nend", "   if b <= 0 then\n      return a\n   end\n   local result = a\n\
    \   for i = 2, b do\n      local t = result\n      result = result % i\n     \
    \ if not result then\n         return t\n      end\n   end\n   return result\n\
    end", "  if b == 1 then return a\n  else if a == 0 then return 0 end\n  elseif\
    \ a > b then return a end\n  else return b end\nend", "  local common\n  if b\
    \ == 0 then return a\n  common, a = a % b, a\n  while b > 0 do\n    common, a\
    \ = b, b % a\n  end\n  return common\nend", "   if a == b then return a\n   elseif\
    \ a == 0 then return b\n   else return greatest_common_divisor(b, a % b)\n   end\n\
    end", "    local c = 0\n    local d, e = a, b\n    repeat until d ~= 0 do\n  \
    \      local t = e % d\n        if t > c then c, d = t, d end\n        e = d\n\
    \    end\n    return c\nend", "    local max_div = math.gcd(a, b)\n    return\
    \ max_div ~= 0 and max_div or b\nend", "    assert(a >= 0 and b > 0)\n    if a\
    \ == 0 then\n        return b\n    elseif b == 0 then\n        return a\n    end\n\
    \    local gcd = a\n    while b ~= 0 do\n        gcd = b\n        b = a % b\n\
    \        a = gcd\n    end\n    return gcd\nend", "    if b == 0 then\n       \
    \ return a\n    end\n    return greatest_common_divisor(b, a/b)\nend", "  if b\
    \ == 1 then return a\n  if a == 0 then return b\n  if b == 0 then return a\n \
    \ return greatest_common_divisor(b, a % b)\nend", "    assert(type(a) == 'number')\n\
    \    assert(type(b) == 'number')", "    assert(type(a) ~= 'table' and type(b)\
    \ ~= 'table')\n    if b == 1 then return a\n    if a == 1 then return b\n    if\
    \ a == 0 then return 0\n    local c = a\n    while c ~= 0 do\n        c = c /\
    \ b\n        if c == 1 then return c\n    end\n    return c\nend", "  -- https://stackoverflow.com/questions/477486/fastest-way-to-find-greatest-common-divisor-in-python\n\
    \  if a == 0 then return b end\n  if b == 0 then return a end\n  if a > b then\
    \ return a else return b end\n  local m = a\n  while b > 0 do\n    -- Repeat \"\
    b\" times the operation \"m // b\".\n    m = m % b\n    b = b - 1\n  end\n  return\
    \ m\nend", "  if a == 1 then\n    return b\n  elseif b == 1 then\n    return a\n\
    \  elseif a == 0 then\n    return 1\n  elseif b == 0 then\n    return 0\n  end\n\
    \  local div\n  if a % 2 == 0 then\n    div = greatest_common_divisor(b, a / 2)\n\
    \  else\n    div = greatest_common_divisor(a, (b - a) / 2)\n  end\n  return div\
    \ * div\nend", "  local n = a\n  local m = b\n  while m ~= 0 do\n    local q =\
    \ m / n\n    m = n % m\n    n = q\n  end\n  return n\nend", "\tif b == 1 then\
    \ return a end\n\tif a == 1 then return b end\n\tif a > b then a, b = b, a end\n\
    \tlocal r = math.gcd(a, b)\n\treturn r / b\nend", "  if b == 1 then return a end\n\
    \  if a == 1 then return b end\n  if a % 2 == 0 then return greatest_common_divisor(a\
    \ / 2, b) end\n  if b % 2 == 0 then return greatest_common_divisor(a, b / 2) end\n\
    \  return b\nend", "  if b == 1 then return a\n  else return greatest_common_divisor(b,\
    \ a % b)\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nIt's not guaranteed that the\
    \ result will be an integer, because of the remainder operator.\n<|/ c |>\n<|\
    \ c |>\nYou're right, I edited my post to add a check for division by 0\n<|/ c\
    \ |>\n<| a dscore=4 |>\nThe algorithm to find the greatest common divisor of two\
    \ numbers is the following: \n<code>", "  if b == 1 then return a end\n  if a\
    \ == 1 then return b end\n  return greatest_common_divisor(b, a % b)\nend", " \
    \ return b - a if a < b then a else b end\nend", "  if b < a then\n    local t\
    \ = a\n    a = b\n    b = t\n  end\n  while a % b == 0 do\n    a = b\n    b =\
    \ a % b\n  end\n  return b\nend", "  -- If b is zero\n  if a == 0 then return\
    \ b end\n  -- If b is less than a\n  if b <= a then\n    -- Return the smaller\
    \ of the values\n    if b < a then return b else return a end\n    -- Otherwise\
    \ return the greatest common divisor\n  else\n    -- Find greatest common divisor\
    \ using Euclid's Algorithm\n    -- https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    local function euclid(a, b)\n      -- Check if a is greater than or equal\
    \ to b\n      if a >= b then\n        -- If so, return the larger of the values\n\
    \        return b if b > a else a\n      end\n      -- Otherwise return a\n  \
    \    return a\n    end\n    local div = euclid(a, b)\n    while div > 1 do\n \
    \     -- If no remainder exists then return div\n      if b == 0 then\n      \
    \  return div\n      end\n      -- If a is evenly divisible by b then return div\n\
    \      if div % 2 == 0 then return div\n      -- Otherwise subtract a from b and\
    \ recursively call euclid\n      -- until a is no longer evenly divisible by b\n\
    \      else\n        div = div - a\n        b = b - a \n      end\n    end\n \
    \   -- If no remainder exists then return div\n    return div\n  end\nend", " \
    \   local remainder = a % b\n    if remainder ~= 0 then\n        return greatest_common_divisor(b,\
    \ a)\n    end\n    return b\nend", "    local div = math.gcd(a, b)\n    return\
    \ div * div\nend", "    local m = math.abs(a % b)\n    return b * math.ceil(m\
    \ / b) if m > 0 and m % b == 0 then m else b end\nend", "   if b == 1 then\n \
    \     return a\n   end\n   return greatest_common_divisor(b, a % b)\nend", " \
    \ if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  elseif b\
    \ == a then\n    return b\n  else\n    if a >= b then\n      local t = a\n   \
    \   a = b\n      b = t\n    end", "  if a == 0 then\n    return b\n  elseif a\
    \ == 1 then\n    return a\n  elseif b == 0 then\n    return a\n  elseif b == 1\
    \ then\n    return b\n  else\n    return greatest_common_divisor(a % b, b)\n \
    \ end\nend", "  -- Euclidean algorithm\n  -- Assume integers\n  -- https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  local gcd, r = 0, a\n  for i = 1, b do\n    r = r + (a % i)\n    gcd, a = i,\
    \ gcd\n  end\n  return r\nend", "    if b == 0 then\n        return a\n    elseif\
    \ a == 0 then\n        return b\n    end", "    if b == 0 then return a\n    else\
    \ if b == 1 then return a\n    else return greatest_common_divisor(b, a % b) end\n\
    end", "    local remainder, i = a, b\n    repeat\n        remainder, rem = rem\
    \ - 1, a % rem\n        a = rem\n    until a <= 0 and b > 0\n    return remainder\n\
    end", "  return math.gcd(a, b) ~= 0 and math.gcd(b, a) ~= 0 and a / math.gcd(a,\
    \ b) * b\nend", "  -- http://rosettacode.org/wiki/Euclidean_algorithm#Lua\n  --\
    \ Lua doesn't have a gcd() function, so (a%b) == ((b%a)+a%b)/b\n  if a < 0 or\
    \ b < 0 then return 0 end\n  if a == 0 then return b end\n  if b == 0 then return\
    \ a end\n  local x = a\n  local y = b\n  -- Now x and y are positive numbers and\
    \ a >= b\n  while x > y do\n    -- The operation \"x = x%y\" returns x without\
    \ the lowest digit.\n    -- This operation is faster than the operation \"y =\
    \ x%y\"\n    x = x % y\n    y = y\n  end\n  return y\nend", "  if b == 0 then\
    \ return 0\n  elseif b == 1 then return a\n  else return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  if a > b then return b end\n  if a < b then return a\
    \ end\n  if a%b == 0 then return b end\n  return greatest_common_divisor(b, a\
    \ % b)\nend", "  -- We use the Euclidian algorithm to calculate the greatest common\
    \ divisor of a and b.\n  -- https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  if b == 0 then return a\n  elseif b == a then return 1\n  else return greatest_common_divisor(b,\
    \ a % b) end\nend", "  -- Make sure b is an integer if it's less than a or if\
    \ it's a\n  -- negative number that could be less than b\n  b = tonumber(b)\n\
    \  if b == a then return b\n  if a < 0 then\n    return tonumber(math.floor(a/b))\
    \ * (math.floor(b/a))\n  end", "    if b < a then return b end\n    for i = b,\
    \ 0, -1 do\n        if a % i == 0 then\n            return i\n        end\n  \
    \  end\nend", "  if a == 0 then return b end\n  if b == 0 then return a end\n\
    \  if a > b then a, b = b, a end\n  repeat\n    if b % a == 0 then return b end\n\
    \    b /= a\n  until b == 0\n  return a\nend", "  if b == 1 then\n    return a\n\
    \  else\n    return greatest_common_divisor(b, a % b)\n  end\nend", "  assert(type(a)\
    \ == 'number' and type(b) == 'number')\n  if a == 0 then\n    return b\n  elseif\
    \ b == 0 then\n    return a\n  elseif a == b then\n    return a\n  else\n    --\
    \ Use the Euclidean algorithm\n    local t = a\n    a = b\n    b = t\n    local\
    \ q = a\n    local r = b\n    while b ~= 0 do\n      t = q\n      q = r % b\n\
    \      r = t\n    end\n    return q\n  end\nend\n</cell>\n<code language=lua-5.1>",
  "\tlocal div = a % b\n\tlocal gcd = 1\n\twhile div > 0 do\n\t\tgcd = gcd * b\n\t\
    \tdiv = div % b\n\tend\n\treturn gcd\nend", "  -- First, check for division by\
    \ zero\n  if b == 0 then\n    return a\n  end", "  assert(type(b) == 'number',\
    \ 'The second argument to greatest_common_divisor must be a number')\n  return\
    \ math.gcd(a, b)\nend", "    return math.gcd(a, b) * math.gcd(b, a)\nend", " \
    \ if b == 0 then return a\n  else return greatest_common_divisor(b, a % b) end\n\
    end", "  if b == 0 then\n    return a\n  end\n  if a == 0 then\n    return b\n\
    \  end\n  if a > b then\n    local tmp = a\n    a = b\n    b = tmp\n  end\n  local\
    \ div = math.modf(b / a) * a\n  return b - div\nend", "  if a == 0 then\n    return\
    \ b\n  elseif a == b then\n    return a\n  else\n    local m = a\n    for i =\
    \ b, 0, -1 do\n      m = m % a\n      if m == 0 then break end\n    end\n    return\
    \ m\n  end\nend", "    if a == 0 then\n        if b == 0 then\n            return\
    \ 0\n        else\n            return b\n        end\n    elseif a == b then\n\
    \        return a\n    else\n        local a_digits = math.floor(math.log10(a\
    \ / 10))\n        local b_digits = math.floor(math.log10(b / 10))\n        return\
    \ math.pow(a, a_digits) / (math.pow(b, b_digits) * 10)\n    end\nend", "    assert(type(b)\
    \ == 'number')\n    assert(type(a) == 'number')", "  -- Based on the algorithm\
    \ given in \"Computing the GCD of N numbers\"\n  -- by Deanne Horsman on page\
    \ 23 (a variant of Euclid's GCD algorithm),\n  -- in C (http://portal.acm.org/citation.cfm?id=1352985)",
  "  -- Optimization idea: repeatedly divide\n  -- until a or b is 1.  This is much\
    \ faster than division.\n  if b == 1 then return a\n  if a == 1 then return b\n\
    \  if a > b then a, b\n  elseif b > a then b, a\n  else return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  if a == 0 then return b end\n  if b == 0 then return\
    \ a end\n  if b > a then return greatest_common_divisor(b, a % b) end\n  if a\
    \ == b then return a\nend", "  a = b - 1\n  while b >= 0 do\n    if b == 0 then\n\
    \      return a\n    end\n    local tmp = a\n    a = b\n    b = tmp % b\n  end\n\
    \  return a\nend", "    local n1, n2 = 0, 1\n    while a do\n        a, n1 = n1,\
    \ b % a\n        b, n2 = n2, b / a\n    end\n    return n1\nend", "  if b == 1\
    \ then\n    return a\n  else\n    return greatest_common_divisor(b, a % b)\n \
    \ end\nend", "  if b == 0 then return a\n  else if a == 0 then return b\n  else\
    \ return greatest_common_divisor(b, a % b)\n  end end\n  return greatest_common_divisor(a,\
    \ b)\nend", "  return math.min(\n    math.gcd(a, b),\n    math.gcd(b, a),\n  \
    \  math.gcd(gcd(a, b), gcd(b, a))\n  )\nend", "    if b == 0 then\n        --\
    \ a is a prime number, return 1\n        return a\n    end", "  if b == 0 then\
    \ return a\n  else return greatest_common_divisor(b, a % b)\n  end\nend", "  return\
    \ math.gcd(a, b) \nend", "    local common = math.gcd(a, b)\n    if common % 2\
    \ == 1 then return common / 2 end\n    return common\nend", "  local c = a\n \
    \ local d = b\n  while c > 1 do\n    local q = c / d\n    local remainder = c\
    \ - q * d\n    d = c\n    c = q\n    c = remainder\n  end\n  return c\nend", " \
    \ if a == 0 then return b end\n  if b == 0 then return a\n  if a > b then a, b\
    \ = b, a end\n  while b > 0 do\n    -- return max(b, a % b)\n    a = a % b\n \
    \   -- set b = b - 1\n    b = b - 1\n  end\n  return a\nend", "\tif a == 0 then\
    \ return b end\n\tif b == 0 then return a end", "  assert(type(a) == 'number'\
    \ and type(b) == 'number')\n  return math.gcd(a, b)\nend", "    if a == 0 then\n\
    \        return b\n    elseif b == 0 then\n        return a\n    else\n      \
    \  local r = a\n        for i = 1, b do\n            r = r / b\n        end\n\
    \        return r\n    end\nend", "  if a % b == 0 then\n    return a\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "  if a > b or b ==\
    \ 0 then return 0 end\n  local div = math.gcd(a, b)\n  if b == 0 then return div\
    \ end\n  local remain = a % b\n  if remain == 0 then return div + 1 end\n  return\
    \ div\nend", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ math.mod(a, b))\n  end\nend\nreturn greatest_common_divisor", "  local t = a\n\
    \  local u = b\n  local v = a\n  while v > 0 do\n    t = u % v\n    u = v\n  \
    \  v = t\n  end\n  return t\nend", "  if a == 0 then return b\n  if b == 0 then\
    \ return a end\n  if b > a then a, b = b, a end\n  while b > 0 do\n    if a %\
    \ b == 0 then return b end\n    -- return a\n    -- if a > b then a, b = b, a\
    \ end\n    -- return b\n  end\n  return b\nend", "  if b == 0 then\n    return\
    \ a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend", "  if\
    \ b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b, a %\
    \ b)\n  end\nend", "    if b == 0 then\n        return a\n    end\n    if a ==\
    \ 0 then\n        return b\n    end\n    local g = greatest_common_divisor(b,\
    \ a%b)\n    if a == g then\n        return b\n    else\n        return g\n   \
    \ end\nend", "  local x = math.abs(a / b)\n  local y = math.abs(b / a)\n  if x\
    \ > y then\n    return a\n  else\n    return b\n  end\nend", "  -- If the values\
    \ are equal then return the\n  -- smallest number that divides the values\n  if\
    \ a == b then return a\n  -- If the first number is smaller than the\n  -- second\
    \ then divide the second number by\n  -- itself to get the first number\n  --\
    \ because that number is greatest common divisor\n  elseif a < b then return greatest_common_divisor(b,\
    \ a % b)\n  -- If the first number is greater than the\n  -- second then divide\
    \ the first number by\n  -- itself to get the second number\n  -- because that\
    \ number is greatest common divisor\n  else return greatest_common_divisor(a,\
    \ a % b)\nend", "  if b ~= 0 then\n    local n = a\n    while n ~= 0 do\n    \
    \  local m = n / b\n      if n == b then\n        return m\n      else\n     \
    \   n = m\n      end\n    end\n  end\n  return a\nend", "  if a == 0 then return\
    \ b end\n  local gcd, x, y = a / b, b, a % b, x\n  while y do\n    a, gcd, x,\
    \ y = gcd, x, y - 1\n  end\n  return gcd\nend", "    assert(type(a) == 'number'\
    \ and type(b) == 'number', \\\n           'input parameters must be numbers')\n\
    \    if a % b == 0 then\n        return b\n    end\n    if b == 0 then\n     \
    \   return a\n    end\n    return greatest_common_divisor(b, a % b)\nend", " \
    \ -- Euclid's algorithm\n  -- See https://en.wikipedia.org/wiki/Greatest_common_divisor#Related_algorithms\n\
    \  local function gcd(x, y)\n    if x == 0 then return y end\n    if y == 0 then\
    \ return x end\n    local gcd\n    repeat\n      gcd = b and a%b or a\n      a\
    \ = b\n      b = y\n    until gcd == 0\n    return a\n  end\n  -- Euclid's algorithm\n\
    \  -- See https://en.wikipedia.org/wiki/Greatest_common_divisor#Related_algorithms\n\
    \  local function lcm(x, y)\n    if x == 0 or y == 0 then return 0 end\n    return\
    \ gcd(x, y)*(x/y) + x/y\n  end\n  return lcm(a, b)\nend", "    assert(a and b,\
    \ 'a and b must be integers')\n    if b == 0 then return 0 end\n    if b == 1\
    \ or b == -1 then return b end\n    local result = greatest_common_divisor(b,\
    \ a % b)\n    if result == 0 then\n        return b\n    end\n    return result\n\
    end", "  return b == 0 and a or greatest_common_divisor(b, a % b)\nend", "  a\
    \ = a % b\n  if a then\n    local x = b\n    while a do\n      x = b\n      a\
    \ = a % x\n    end\n    return x\n  end\n  return b\nend", "  assert(type(a) ==\
    \ 'number' and type(b) == 'number')\n  if a == 0 then return b end\n  if b ==\
    \ 0 then return a end\n  local gcd = math.gcd(a, b)\n  return gcd >= 1 and gcd\
    \ or greatest_common_divisor(b, a % gcd)\nend", "    if a == 0 then return 0 end\n\
    \    if b == 0 then return 0 end\n    if b == a then return 1 end", "  assert(type(a\
    \ >= 0) and type(b >= 0) and a and b)\n  local gcd = math.gcd(a, b)\n  return\
    \ gcd == 1 and gcd or greatest_common_divisor(b, a % gcd)\nend", "   if a == 0\
    \ then\n      return b\n   elseif b == 0 then\n      return a\n   elseif a > b\
    \ then\n      return greatest_common_divisor(b, a % b)\n   else\n      return\
    \ greatest_common_divisor(a, mod (b, a))\n   end\nend\n</code>\n<|/ a tags=math,lua\
    \ |>\n<| a tags=math,lua |>\nA version that uses a recursive function and some\
    \ math trickery:\n<code>", "  if b ~= 0 then\n    a, b = b, a\n  end\n  while\
    \ b > 0 do\n    local q = a / b\n    a = b\n    b = q\n  end\n  return a\nend",
  "  local function gcd(a, b)\n    local function swap(a, b) return {a=a>b, b=b>a}\n\
    \    return a:map(function(a) a:map(function(a) a:map(swap,b) end) end)\n  end\n\
    \  \n  a = a\n  b = b\n  \n  if b == 1 then return a\n  elseif b == 0 then return\
    \ 1\n  elseif a % b == 0 then return greatest_common_divisor(b, a / b)\n  else\
    \ return gcd(a, b):gcd()\n  end\nend", "    if b == 0 then\n        return a\n\
    \    else\n        return greatest_common_divisor(b, a % b)\n    end\nend", " \
    \ if a == 0 then return b end\n  if b == 0 then return a end\n  local remainder\
    \ = a % b\n  if remainder == 0 then return b end\n  return greatest_common_divisor(b,\
    \ remainder)\nend", "  if b == 0 then\n    return a\n  elseif b == 1 then\n  \
    \  return b\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "    -- Check if both numbers are zero\n    if a == 0 and b == 0 then\n        return\
    \ 0\n    -- Get a common factor\n    local c = math.gcd(a, b)\n    -- If there\
    \ is no common factor or both numbers are one\n    -- then return 0\n    return\
    \ c * c if a == b then return c else 0 end\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is great and solves the problem, but this doesn't quite answer the\
    \ question.  As far as I can tell, `math.gcd` is already implemented so I don't\
    \ need to use this at all.  If I wanted to implement my own version of the greatest\
    \ common divisor algorithm, this would be a good way to do it.\n<|/ c |>\n<| c\
    \ |>\nYes, the function is implemented in the Lua core and will be available for\
    \ use. There is some good discussion here about the details of this: https://groups.google.com/forum/#!topic/comp.lang.lua/OEJkQ1rWgjM\n\
    <|/ c |>\n<| a dscore=4 tags=lua,algorithm |>\nI wanted to implement my own version\
    \ of the greatest common divisor algorithm, and for those who would like to see\
    \ an example in Lua, here's my solution.\n<code>", "   if a == 0 and b == 0 then\n\
    \      return 0\n   elseif a == 0 then\n      return b\n   elseif b == 0 then\n\
    \      return a\n   else\n      return math.gcd(a, b)\n   end\nend", "  a = a\
    \ % b\n  if a == 0 then\n    return b\n  else\n    return greatest_common_divisor(b,\
    \ a)\n  end\nend", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ math.floor(a/b))\n  end\nend", "  assert(type(a) == \"number\" and type(b) ==\
    \ \"number\")\n  if a == 0 then\n    return b\n  end\n  if b == 0 then\n    return\
    \ a\n  end\n  if a <= b then\n    return greatest_common_divisor(b, a%b)\n  end\n\
    \  return a\nend", "  if a == 0 then return b end\n  if b == 0 then return a end\n\
    \  if a == 1 then return b end\n  if b == 1 then return a end\n  if a % 2 == 0\
    \ and b % 2 == 0 then\n    return greatest_common_divisor(a / 2, b / 2)\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "  if b == 0 then\n\
    \    return a\n  elseif a == 0 then\n    return b\n  end\n  -- Use Euclid's Algorithm\
    \ to calculate the GCD\n  local gcd = math.gcd(a, b)\n  -- Return the GCD\n  return\
    \ gcd * greatest_common_divisor(b - gcd, a)\nend\n</cell>\n<cell>", "    if b\
    \ == 1 then\n        return a\n    end", "    if b == 0 then return 0\n    else\
    \ if a == 0 then return b\n    else if a == b then return a\n    else return greatest_common_divisor(b,\
    \ a % b)\n    end\nend", "  if a == 0 then\n    return b\n  end\n  if b == 0 then\n\
    \    return a\n  end", "  local m = a\n  local n = b\n  while m % n ~= 0 do\n\
    \    m, n = n, m\n  end\n  return m\nend", "  return a * b / (math.gcd(a, b) *\
    \ math.gcd(b, a))\nend", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "    if a % b == 0 then\n        return b\n    elseif b\
    \ % a == 0 then\n        return a\n    else\n        local c = math.gcd(a, b)\n\
    \        return c\n    end\nend", "\tif a == 0 then return b end\n\tif b == 0\
    \ then return a end\n\tlocal r = a\n\twhile r > 0 and b > 0 do\n\t\tr = r and\
    \ r * b\n\t\tb = b and b - 1\n\tend\n\treturn r\nend", "  if a % b == 0 then\n\
    \    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "  -- The Euclidian algorithm computes the GCD of two integers a and b\n  -- and\
    \ returns the remainder as (a - b) mod a.\n  if b == 0 then\n    return a\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "  if b == 0 then\
    \ return 1 end\n  if a == 0 then return b end\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "   if a == 0 then\n      return b\n   elseif a > b then\n   \
    \   return greatest_common_divisor(b, a % b)\n   else\n      return greatest_common_divisor(a,\
    \ a % b)\n   end\nend", "  if b < 0 then\n    error('The second argument cannot\
    \ be less than zero.')\n  end\n  local result\n  do\n    local divisor = a\n \
    \   while b > 0 and divisor <= b do\n      divisor = divisor + 1\n    end\n  \
    \  result = divisor\n    while b and b > result do\n      b = b - 1\n    end\n\
    \  end\n  return result\nend", "\t-- a and b are positive integers\n\t-- return\
    \ greatest common divisor of a and b\n\t\n\t-- TODO: implement this (memoization\
    \ / dynamic programming)\n\t\n\t-- Implementation notes:\n\t-- This implementation\
    \ was inspired by Project Euler's problem #40.\n\t-- This implementation is also\
    \ known as Euclid's algorithm, and can be found in:\n\t--   https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \t--\n\t-- Wikipedia has a clear explanation of how this implementation works,\
    \ as well as a reference\n\t-- implementation:\n\t--   https://en.m.wikipedia.org/wiki/Euclidean_algorithm\n\
    \t--\n\t-- For a more efficient implementation (without the memoization and dynamic\
    \ programming overhead),\n\t-- see https://en.wikipedia.org/wiki/Greatest_common_divisor#Optimization_using_factorization.\n\
    \t\n\t-- The greatest common divisor of two positive integers is the largest integer\
    \ that divides\n\t-- the larger of the two numbers.\n\t\n\t-- The greatest common\
    \ divisor of two integers a and b can be computed by dividing the smaller \n\t\
    -- integer a by the larger integer b, and counting the quotients:\n\t--\t- If\
    \ a = b, the quotient is 0\n\t--\t- If a = 0, the quotient is a\n\t--\t- If b\
    \ = 0, the quotient is b\n\t--\t- Otherwise, the quotient is the greatest integer\
    \ that evenly divides both a and b\n\t--\n\t-- The following implements this algorithm,\
    \ with a little bit of memoization.\n\t--\n\t--   let [a, b] be the two integers\n\
    \t--   let [q, remainders] be an array\n\t--       q[0] will be the greatest common\
    \ divisor of a and b\n\t--       remainders[i] will be the greatest integer that\
    \ evenly divides a and b\n\t--   for i in 2..min(a, b) do\n\t--       if a[i]\
    \ is 0, then\n\t--           q[i] := a[i]\n\t--       else if b[i] is 0, then\n\
    \t--           q[i] := b[i]\n\t--       else\n\t--           q[i] := q[i-1] *\
    \ 2\n\t--           remainders[i] := a[i] / b[i]\n\t--       end\n\t--   end\n\
    \t--   return q[min(a, b)]\n\t--\n\t\n\tif a < 0 then\n\t\ta = -a\n\t\tlocal min\
    \ = a\n\t\ta = a * a\n\t\tb = b * b\n\t\tlocal ", "  -- Only works with positive\
    \ numbers.\n  assert(type(b) == 'number' and b > 0)", "  if b == 0 then\n    return\
    \ a\n  end\n  if a == 0 then\n    return b\n  end\n  local div = a % b\n  local\
    \ mod = a % b\n  if div > 0 then\n    return greatest_common_divisor(b, a - div)\n\
    \  elseif mod > 0 then\n    return greatest_common_divisor(b, mod - 1)\n  else\n\
    \    return b\n  end\nend", "  if a == 0 then\n    return b\n  end\n  if b ==\
    \ 0 then\n    return a\n  end\n  if b == 1 then\n    return a\n  end\n  if a ==\
    \ 1 then\n    return b\n  end", "  -- Return the greatest common divisor of a\
    \ and b.\n  -- Assume b > 0.\n  -- See http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  -- >>> greatest_common_divisor(2, 2)\n  -- 1\n  -- >>> greatest_common_divisor(7,\
    \ 7)\n  -- 1\n  -- >>> greatest_common_divisor(1, 0)\n  -- 1", "  if a > b then\n\
    \    a, b = b, a\n  end\n  if a < 1 then\n    return nil\n  end\n  if a == 1 then\n\
    \    return b\n  end\n  local c = 0\n  local i = b\n  while i > 0 do\n    while\
    \ a % i == 0 do\n      c = c + 1\n    end\n    if a == 1 then\n      return c\n\
    \    end\n    i = i / 2\n  end\n  return c\nend", "    local gcd\n    if b ==\
    \ 1 then -- a = 0 and b != 0\n        return a\n    end\n    if a % b == 0 then\
    \ -- a is evenly divisible by b\n        gcd = greatest_common_divisor(b, a /\
    \ b)\n    else -- a is not evenly divisible by b\n        gcd = greatest_common_divisor(b,\
    \ a % b)\n    end\n    return gcd\nend", "  if a == 1 then return b end\n  if\
    \ b == 1 then return a end\n  if b == a then return 1 end\n  local x, y, q, r\
    \ = a%b, b%a, a, b\n  while r do\n    x = y\n    y = q\n    q, r = r%b, r%a\n\
    \  end\n  return x\nend", "  return math.gcd(a, b) * math.gcd(b, a)\nend", " \
    \ if a == 0 then return b end\n  assert(type(a) == \"number\" and type(b) == \"\
    number\")\n  local gcd = math.gcd(a, b)\n  return gcd == 1 and gcd or greatest_common_divisor(b,\
    \ a % gcd)\nend", "\tassert(type(a) == \"number\" and type(b) == \"number\" and\
    \ b > 0 and a > 0)\n\tlocal gcd = math.gcd(a, b)\n\tif gcd == 1 then return b\
    \ else return a end\n\treturn greatest_common_divisor(b, gcd)\nend", "  local\
    \ divisor = 1\n  while a % divisor ~= 0 do\n    divisor *= b\n  end\n  return\
    \ divisor\nend", "  local common, rem = 0, a % b\n  while (common < b) and (rem\
    \ ~= 0) do\n    common = common * 2\n    rem = rem - a % common\n  end\n  return\
    \ common\nend", "  if a == 0 then return b end\n  if b == 0 then return a end\n\
    \  if a <= b then return greatest_common_divisor(b, a - b) end\n  if b > a then\
    \ return greatest_common_divisor(a, b - a) end\nend", "  -- Test for divisibility\
    \ by all prime factors, starting from the smallest one\n  local factor = a\n \
    \ local prime_count = 0\n  while factor > 1 and prime > 1 do\n    if factor %\
    \ prime == 0 then\n      factor = factor / prime\n      prime_count = prime_count\
    \ + 1\n    end\n    prime = math.floor(math.pow(prime, 2) / math.pow(factor, 2))\n\
    \  end", "  if b == 0 then\n    return a\n  elseif b == 1 then\n    return b\n\
    \  elseif b == 2 then\n    return a\n  elseif b == 3 then\n    return a\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "  if a <= 0 then\
    \ return 0 end\n  if b <= 0 then return 1 end\n  local res = a\n  while b > 0\
    \ do\n    local tmp = a % b\n    a = b\n    b = tmp\n  end\n  return res\nend",
  "  -- The Euclidean algorithm\n  if b == 1 then\n    return a\n  else\n    local\
    \ m = a\n    local n = b\n    while true do\n      local k = m % n\n      if k\
    \ == 0 then\n        return n\n      elseif n < k then\n        n = k\n      else\n\
    \        m = k\n      end\n    end\n  end\nend", "    if b == 0 then\n       \
    \ return a\n    end\n    if a > b then\n        local tmp = a\n        a = b\n\
    \        b = tmp\n    end\n    local r = a\n    while b > 0 do\n        local\
    \ tmp = r\n        r = r * b\n        b = tmp\n    end\n    return r\nend", " \
    \   local max\n    if b == 0 then\n        max = a\n    elseif b > 0 then\n  \
    \      max = a\n        for i = b, 1, -1 do\n            if a % i == 0 then\n\
    \                max = i\n            end\n        end\n    end\n    return max\n\
    end", "  if b <= 0 then\n    return a\n  elseif b == 0 then\n    return a\n  elseif\
    \ a <= 0 then\n    return b\n  elseif b == a then\n    return a\n  else\n    local\
    \ gcd = math.gcd(a, b)\n    return greatest_common_divisor(b,gcd)\n  end\nend",
  "    if b == 0 then\n        return a\n    end", "  if b == 0 then return a\n  elseif\
    \ b < 0 then return greatest_common_divisor(a + 1, -b) end\n  if a % b == 0 then\
    \ return greatest_common_divisor(b, a / b) else return greatest_common_divisor(b,\
    \ a / b) + 1 end\nend", "   if b == 0 then\n      return a\n   elseif b == a then\n\
    \      return 1\n   else\n      return greatest_common_divisor(b, a % b)\n   end\n\
    end", "  return b == 0 and a or a * greatest_common_divisor(b, a % b)\nend", " \
    \ if a == b then return a\n  else if b == 1 then return a\n  else return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  local divisor = nil\n  local is_a_int = tonumber(a)\n\
    \  local is_b_int = tonumber(b)\n  if is_a_int and not is_b_int then\n    divisor\
    \ = a\n  elseif is_b_int and not is_a_int then\n    divisor = b\n  elseif not\
    \ is_a_int or not is_b_int then\n    divisor = 1\n  else\n    divisor = math.gcd(a,\
    \ b)\n  end", "    if b == 0 then\n        return a\n    end\n    return greatest_common_divisor(b,\
    \ a % b)\nend", "  local q, r = {}, {}\n  repeat\n    q[#q+1] = a % b\n    a =\
    \ a / b\n  until a == 1 or a == 0\n  repeat\n    r[#r+1] = a % b\n    a = a /\
    \ b\n  until a == 1 or a == 0\n  return r[#r]\nend", "  -- Test if at least one\
    \ argument is negative.\n  if a < 0 then\n    a, b = b, a\n  end\n  -- Special\
    \ case of a == 0.\n  if a == 0 then\n    return b\n  end\n  -- Test if a == b.\n\
    \  if a == b then\n    return a\n  end\n  -- Test if a > b.\n  if a > b then\n\
    \    a, b = b, a\n  end\n  -- Divide each by each smaller of the two operands.\n\
    \  local c = a\n  while c <= b do\n    local d = b\n    while d <= c do\n    \
    \  d = d / c\n    end\n    -- Return the greatest common divisor of the two operands.\n\
    \    return c\n  end\nend", "  local i = 1\n  local imax\n  imax = a\n  if b >\
    \ imax then\n    imax = b\n  end", "  if a % b == 0 then\n    return b\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "  if b == 0 then\n\
    \    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "  if b == 0 then\n    return a\n  end\n  if a == 0 then\n    return b\n  end\n\
    \  if b == a then\n    return b\n  end\n  if b > a then\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\n  return greatest_common_divisor(a, b % a)\nend", "  assert(type(a)\
    \ == 'number' and type(b) == 'number')\n  if a == b then return a\n  elseif b\
    \ == 0 then return a\n  elseif a == 0 then return b\n  elseif b == a then return\
    \ b\n  else\n    if a > b then\n      local tmp = a\n      a = b\n      b = tmp\n\
    \    end\n    -- a and b must be non-zero\n    assert(b > 0)\n    -- Compute their\
    \ greatest common divisor\n    local gcd = math.gcd(a, b)\n    -- a / gcd == b\n\
    \    -- gcd cannot be zero\n    assert(gcd > 0)\n    -- a / gcd == b\n    -- This\
    \ checks if a is divisible by gcd\n    if a % gcd == 0 then\n      return b\n\
    \    else\n      return a\n    end\n  end\nend", "  if a == 0 then\n    return\
    \ b\n  elseif b == 0 then\n    return a\n  elseif a > b then\n    return greatest_common_divisor(b,\
    \ a)\n  else\n    return b\n  end\nend", "   if b == 1 then\n      return a\n\
    \   end\n   return greatest_common_divisor(b, a % b)\nend", "  if a <= 0 then\n\
    \    return b\n  elseif b <= 0 then\n    return a\n  elseif b == 1 then\n    return\
    \ a\n  elseif a % b == 0 then\n    return greatest_common_divisor(b, a / b)\n\
    \  else\n    return greatest_common_divisor(a, b * a - 1)\n  end\nend", "  local\
    \ remainder\n  repeat\n    remainder = a % b\n    a = b\n    b = remainder\n \
    \ until b == 0\n  return a\nend", "  if a == 0 then\n    return b\n  elseif b\
    \ == 0 then\n    return a\n  end", "  if a == 0 then return b end\n  if b == 0\
    \ then return a end\n  if a <= b then return greatest_common_divisor(b, a) end\n\
    \  return a\nend", "  if b == 0 then\n    return a\n  end\n  if a == 0 then\n\
    \    return b\n  end\n  if a > b then\n    a, b = b, a\n  end\n  for i=1, a do\n\
    \    if a % i == 0 then\n      return i\n    end\n  end\n  return b\nend", " \
    \ if b == 0 then return a\n  if a == 0 then return b\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "    return math.gcd(a, b) -- Lua 5.2\nend", "  return math.gcd(a,\
    \ b) * math.gcd(a, b)\nend", "  local function gcdIter(a, b, cd)\n    if a ==\
    \ 0 then return cd else return gcd(b, cd) end\n    local t = a\n    while t ~=\
    \ 0 do\n      t = b % t\n      b = c\n      c = t\n    end\n    return b\n  end\n\
    \  local function gcd(a, b)\n    local res = 1\n    while a ~= 0 and b ~= 0 do\n\
    \      local t = a\n      a = b\n      b = t\n    end\n    while b ~= 0 do\n \
    \     res = b\n      b = res % b\n    end\n    return res\n  end\n  return gcdIter(a,\
    \ b, greatest_common_divisor(a % b, gcd(a, b)))\nend", "    if b == 0 then\n \
    \       return a\n    end\n    if a == 0 then\n        return b\n    end", " \
    \ if a == 0 and b == 0 then\n    return 1\n  elseif b == 0 then\n    return a\n\
    \  elseif a == 0 then\n    return b\n  end", "  if b == 1 then return a\n  if\
    \ a == 1 then return b\n  if b % a == 0 then return b % a\n  return greatest_common_divisor(b,\
    \ a / b)\nend", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  -- If b is 0\n  if b == 0 then\n    return a\n  -- If\
    \ a = 0 then b = a\n  elseif a == 0 then\n    return b\n  -- If a = b then a divides\
    \ b\n  elseif a == b then\n    return a\n  -- Compute GCD of a and b\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "    local remainder,\
    \ remainder_b = math.modf(b / a)\n    while remainder ~= 0 do\n        remainder,\
    \ remainder_b = math.modf(remainder_b / a)\n    end\n    return remainder\nend",
  "    local divisor = 1\n    while b > 0 do\n        if a % b == 0 then\n       \
    \     divisor = b\n        end\n        b = b ~= 0 and b - 1\n    end\n    return\
    \ divisor\nend", "  local n = 0\n  while a % b == 0 do\n    n = n + 1\n    a =\
    \ a / b\n  end\n  return a\nend", "  return math.gcd(a, b) ~= 0 and math.gcd(a,\
    \ math.gcd(b, a)) or 1\nend", "  if b == 0 then return a\n  else return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  assert(a >= 0)\n  assert(b >= 0)", "  -- First, check\
    \ they're both even\n  if a % 2 ~= 0 or not b % 2 then\n    return nil\n  end",
  "  if b == 0 then\n    return a\n  elseif a == 0 then\n    return b\n  elseif b\
    \ == 1 then\n    return a\n  else\n    local common = greatest_common_divisor(b,\
    \ a % b)\n    return common + (a % common and 1 or 0)\n  end\nend", "  if a ==\
    \ 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end", "  if b\
    \ == 0 then\n    return a\n  elseif a == 0 then\n    return b\n  else\n    return\
    \ greatest_common_divisor(b, a % b)\n  end\nend", "    local div = 1\n    while\
    \ b > 0 do\n        if b % a == 0 then\n            div = a\n            break\n\
    \        end\n        div = div * a\n        a = div\n    end\n    return div\n\
    end", "\tlocal factors\n\tfactors = a:gfactor()\n\tfactors = factors:gfactor()\n\
    \t-- Return the common factor\n\tlocal gcd = 1\n\tfor _, f in pairs(factors) do\n\
    \t\tif f > gcd then\n\t\t\tgcd = f\n\t\tend\n\tend\n\treturn gcd\nend", "  --\
    \ Make sure a and b are positive numbers\n  if a <= 0 or a ~= tonumber(a) or b\
    \ <= 0 then error(\"Greatest common divisor not found\") end", "    local x =\
    \ 1\n    local y\n    local d", "  -- The Euclidean algorithm for finding the\
    \ greatest common divisor of\n  -- the two numbers is based on Euclid's algorithm.\
    \ The `gcd' function\n  -- below implements the Euclidean algorithm.", "  a =\
    \ tonumber(a)\n  b = tonumber(b)\n  if a == 0 then\n    return b\n  elseif a ==\
    \ 0 then\n    return b\n  elseif b == 0 then\n    return a\n  elseif a ~= b then\n\
    \    local common, rem = divmod(a, b)\n    return greatest_common_divisor(common,\
    \ rem)\n  else\n    return a\n  end\nend", "  if a == 0 then\n    return b\n \
    \ elseif b == 0 then\n    return a\n  else\n    while b and (a % b) do\n     \
    \ b = b div 2\n    end\n    return b\n  end\nend", "  if a == 0 then\n    return\
    \ b\n  end\n  if b == 0 then\n    return a\n  end\n  if a > b then\n    local\
    \ tmp = a\n    a = b\n    b = tmp\n  end\n  while a % b == 0 do\n    a = a / b\n\
    \  end\n  return b\nend", "  if a == 0 then\n    return b\n  elseif b == 0 then\n\
    \    return a\n  elseif a == b then\n    return a\n  else\n    return greatest_common_divisor(a\
    \ - 1, b - 1)\n  end\nend", "  assert(b > 0, 'Argument b must be positive')\n\
    \  assert(a > 0, 'Argument a must be positive')\n  \n  if a == 0 then\n    return\
    \ b\n  end\n  if b == 0 then\n    return a\n  end\n  \n  local function gcd(x,\
    \ a, b)\n    if b == 1 then\n      return a\n    end\n    return gcd(b, a%b, b)\n\
    \  end\n  return gcd(a, b ,b - 1);\nend\n</cell>\n<text>\nThe greatest_common_divisor\
    \ function above finds the greatest common divisor of two numbers using a recursive\
    \ algorithm which avoids computing the gcd of large numbers. To understand how\
    \ this works, let's look at a few examples.", "  if a == 0 and b == 0 then\n \
    \   return 0\n  elseif b == 0 then\n    return a\n  elseif a % b == 0 then\n \
    \   return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "  if a == 0 then return a end\n  if b == 0 then return b end", "    if b == 1 then\n\
    \        return a\n    end", "  local max_factor = 1\n  local max_num = 1", " \
    \ a = a % b\n  if a == 0 then\n    return b\n  else\n    while a > b do\n    \
    \  a = a / b\n    end\n    return a\n  end\nend", "   assert(type(b) ~= 'number'\
    \ and type(b) ~= 'string')\n   local r\n   local t = a\n   if b < t then\n   \
    \   r = b\n   else\n      while b > t do\n         r = b % t\n         t = t\n\
    \      end\n   end\n   return r\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
