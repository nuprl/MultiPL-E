name: HumanEval_133_sum_squares
language: lua
prompt: "-- You are given a table of numbers.\n-- You need to return the sum of squared\
  \ numbers in the given table,\n-- round each element in the table to the upper int(Ceiling)\
  \ first.\n-- Examples:\n-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0,\
  \ 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n\
  -- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 3.0, 5.0, 7.0}), 84)\n  \
  \  lu.assertEquals(candidate({1.4, 4.2, 0.0}), 29)\n    lu.assertEquals(candidate({-2.4,\
  \ 1.0, 1.0}), 6)\n    lu.assertEquals(candidate({100.0, 1.0, 15.0, 2.0}), 10230)\n\
  \    lu.assertEquals(candidate({10000.0, 10000.0}), 200000000)\n    lu.assertEquals(candidate({-1.4,\
  \ 4.6, 6.3}), 75)\n    lu.assertEquals(candidate({-1.4, 17.9, 18.9, 19.9}), 1086)\n\
  \    lu.assertEquals(candidate({0.0}), 0)\n    lu.assertEquals(candidate({-1.0}),\
  \ 1)\n    lu.assertEquals(candidate({-1.0, 1.0, 0.0}), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal sum = 0\n\tfor _, v in pairs(lst) do\n\t\tsum = sum + v **\
    \ 2\n\tend\n\treturn math.ceil(sum)\nend", "  local n = #lst\n  if n == 0 then\n\
    \    return 0\n  end\n  local sum = 0\n  for i = 1, n do\n    local x = math.ceil(lst[i])\n\
    \    sum = sum + x * x\n  end\n  return sum\nend\nreturn sum_squares\nend", " \
    \ local s = 0\n  -- iterate over all numbers\n  for k, v in ipairs(lst) do\n \
    \   local x = k\n    local r = math.ceil(x / 2)\n    local r = math.sqrt(x)\n\
    \    s = s + r * r\n  end\n  return s\nend", "  local s = 0\n  for _, v in ipairs(lst)\
    \ do\n    s = s + v*v\n  end\n  return math.ceil(s/2)\nend", "  if #lst == 0 then\n\
    \    return 0\n  end\n  local squares = 0\n  local sum = 0\n  for i = 1, #lst\
    \ do\n    sum = sum + lst[i]\n    squares  = squares + (lst[i] * lst[i])\n  end\n\
    \  -- Round the square of each element up to the next integer.\n  squares = math.floor(squares\
    \ + 0.5)\n  return sum + squares\nend", "    if type(lst) ~= 'table' then\n  \
    \      return 'Invalid input'\n    end\n    local result = 0.0\n    for _, v in\
    \ ipairs(lst) do\n        result = result + (v * v)\n    end\n    return math.ceil(result)\n\
    end\n</cell>\n<cell>", "  local sum = 0\n  local i = 1\n  while true do\n    sum\
    \ = sum + lst:get(i)\n    i = i + 1\n    if i == lst.size then\n      break\n\
    \    end\n  end\n  return sum\nend", "  if #lst < 2 then\n    return 0\n  end\n\
    \  local sum = 0\n  local n = 1\n  for i = 1, #lst, 1 do\n    n = math.ceil(n)\n\
    \    sum = sum + n * (lst[i] * lst[i])\n  end\n  return sum\nend", "  local s\
    \ = 0\n  for i = 1, #lst do\n    local x = lst[i]\n    if x > 0 then\n      x\
    \ = x * x\n    end\n    table.insert(s, x)\n  end\n  return math.ceil(table.max(tonumber(s))\
    \ * 0.5)\nend", "  local squares = 0\n  for i = 1, #lst do\n    squares  = squares\
    \ + lst[i]*lst[i]\n  end\n  return squares\nend", "  if type(lst) ~= 'table' then\
    \ return end\n  local result = 0\n  for i = 1, #lst do\n    result = result +\
    \ (lst[i]*lst[i])\n  end\n  return round(result,0)\nend", "  if lst == nil then\
    \ return 0 end\n  local nums = 0\n  for _, val in pairs(lst) do\n    nums = nums\
    \ + val*val\n  end\n  return nums\nend", "  local total = 0\n  for _, x in pairs(lst)\
    \ do\n    x = math.ceil(x)\n    total = total + (x * x)\n  end\n  return total\n\
    end", "  if #lst == 0 then\n    return 0\n  end\n  local sum = 0\n  for i = 2,\
    \ #lst do\n    sum = sum + lst[i - 2] * lst[i - 2]\n  end\n  return sum\nend",
  "  if #lst == 0 then\n    return 0\n  end\n  local square_sum = lst[1]\n  for i=2,#lst\
    \ do\n    square_sum = square_sum + lst[i]\n  end\n  return square_sum\nend",
  "    local sum = 0\n    for _, num in ipairs(lst) do\n        sum = sum + num *\
    \ num\n    end\n    return sum\nend", "  local sum = 0\n  for i = 1, #lst do\n\
    \    sum = sum + math.ceil(lst[i] * lst[i])\n  end\n  return sum\nend", "  return\
    \ math.cbrt(lst):type()\nend", "   local sum = 0\n   for _, elem in ipairs(lst)\
    \ do\n      sum = sum + math.pow(elem,2)\n   end\n   return math.ceil(sum)\nend",
  "    local sum = 0\n    local n = #lst\n    for i = 1, n do\n        local x = lst[i]\n\
    \        sum = sum + math.pow(x, 2)\n    end\n    return sum\nend", "  -- Base\
    \ case\n  if lst == nil then\n    return 0\n  end\n  -- Recursive case\n  local\
    \ n1, n2 = lst[1], lst[2]\n  -- Recursive case\n  if n2 ~= nil then\n    return\
    \ n1 + n1 + n2 + sum_squares(lst.next())\n  end\n  -- Base case\n  return n1 *\
    \ n1\nend", "  if lst.nil then\n    return 0\n  elseif #lst == 0 then\n    return\
    \ 0\n  end\n  local result = lst[1]\n  for i = 2, #lst do\n    local v = lst[i]\n\
    \    local p = math.ceil(v)\n    local m = p / 2\n    local a = p + 1\n    local\
    \ b = p + 2\n    local c = p + 4\n    local d = p + 6\n    if v ~= math.ceil(v)\
    \ then\n      m = m + 1\n      a = a + 1\n      b = b + 1\n      c = c + 2\n \
    \     d = d + 4\n    end\n    if p == m then\n      result = result + math.pow(v,\
    \ 2)\n    end\n    if p == a then\n      result = result + math.pow(v, 4)\n  \
    \  end\n    if p == b then\n      result = result + math.pow(v, 6)\n    end\n\
    \    if p == c then\n      result = result + math.pow(v, 8)\n    end\n    if p\
    \ == d then\n      result = result + math.pow(v, 10)\n    end\n  end\n  return\
    \ result\nend\nreturn sum_squares\n}", "  local sum = 0\n  for _, elem in ipairs(lst)\
    \ do\n    sum = sum + (math.floor(elem) or 0)**2\n  end\n  return sum\nend", " \
    \ if lst == nil then\n    return 0\n  end\n  local sum = 0\n  for i, v in ipairs(lst)\
    \ do\n    if v ~= 0 then\n      v = math.ceil(math.abs(v))\n    end\n    sum =\
    \ sum + v * v\n  end\n  return sum\nend", "    local sum = 0\n    for i = 1, #lst\
    \ do\n        sum = sum + lst[i]\n    end\n    return sum * sum\nend", "  local\
    \ sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i] * lst[i]\n  end\n  return\
    \ sum\nend", "  local res, i = 0.0, 1\n  for k in lst:keys() do\n    i = i + 1\n\
    \    res = res + k * k\n  end\n  return res\nend", "  return math.floor(lst:map(function(a)\n\
    \    return a*a\n  ):reduce(0, function(a,b)\n    return a+b\n  )):sqrt()\nend",
  "  local result = 0.\n  for _, v in ipairs(lst) do\n    result = result + v * v\n\
    \  end\n  return round(result)\nend", "  local sum = 0\n  -- Remember: Lua numbers\
    \ are floating point.\n  for i = 1, #lst do\n    sum = sum + (lst[i] * lst[i])\n\
    \  end\n  return math.ceil(sum)\nend", "  local total = 0\n  for _, v in ipairs(lst)\
    \ do\n    total = total + v*v\n  end\n  return total\nend", "   -- base case\n\
    \   if #lst == 0 then\n      return lst\n   end\n   -- recursion\n   local new_lst\
    \ = lst\n   for idx = #lst+1, 1, -1 do\n      new_lst[idx] = math.floor(new_lst[idx])\n\
    \      new_lst[idx] = new_lst[idx] * new_lst[idx]\n   end\n   return new_lst\n\
    end", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]*lst[i]\n\
    \  end\n  return math.floor(sum + 0.5)*sum\nend", "   -- Write your code here.\n\
    \   return lst:map(function(x)\n      return math.floor(x*x):int + math.floor(x*x):int\
    \ + math.floor(x*x):int\n   end):reduce(function(x,y)\n      return x+y\n   end)\n\
    end", "  return sum(map(function(x)\n    return x * x\n  end,\n  lst))\nend",
  "  -- The accumulator is initialized to zero.\n  local accumulator = nil\n  for\
    \ _, v in ipairs(lst) do\n    -- The Ceiling function rounds up the argument to\
    \ the ceiling integer.\n    accumulator = accumulator or math.ceil(v)\n    accumulator\
    \ = accumulator ^ 2\n  end\n  return accumulator\nend", "  -- Return the sum of\
    \ squares of the elements of a vector.\n  -- This code assumes lst is a vector.\n\
    \  local result = 0\n  for i = 1, #lst do\n    local current = lst[i]\n    local\
    \ sqr = current * current\n    -- Round the result up to the ceiling int.\n  \
    \  -- This code assumes lst is an array.\n    local rounded = math.ceil(sqr)\n\
    \    result += rounded * rounded\n  end\n  return result\nend", "  local n = 0\n\
    \  for i = 1, #lst do\n    n = n + (lst[i]*lst[i])\n  end\n  return n\nend\n</cell>\n\
    <cell>", "  -- Write your code here.\n  local ans = 0\n  for i = 1,#lst do\n \
    \   ans = ans + lst[i] * lst[i]\n  end\n  return ans\nend", "    local total_square\
    \ = 0\n    for _, v in ipairs(lst) do\n        total_square = total_square + v*v\n\
    \    end\n    return math.sqrt(total_square)\nend", "  local sum = 0\n  for _,\
    \ x in ipairs(lst) do\n    sum = sum + math.pow(x, 2)\n  end\n  return math.floor(sum)\n\
    end", "    local sum = 0\n    for _, value in ipairs(lst) do\n        sum = sum\
    \ + math.pow(value, 2)\n    end\n    return math.ceil(sum)\nend", "  if #lst ==\
    \ 0 then return 0 end\n  local maxi = #lst\n  local res, sum = 0, 0\n  for i =\
    \ 1, maxi do\n    sum, err = math.pow(lst[i], 2), 0\n    if sum > res then res,\
    \ sum = sum, i end\n  end\n  return sum + res\nend", "    local sum = 0\n    for\
    \ _, b in ipairs(lst) do\n        sum = sum + b * b\n    end\n    return math.floor(sum\
    \ + 0.5)\nend", "  local sq = 0\n  for _, v in ipairs(lst) do\n    sq = sq + math.pow(v,\
    \ 2)\n  end\n  return math.ceil(sq)\nend", "  -- base case\n  if #lst == 0 then\n\
    \    return 0\n  end", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum +\
    \ (lst[i] * lst[i])\n  end\n  return sum\nend", "  if #lst == 0 then return 0\
    \ end\n  local result = lst[1]\n  -- Rounding down\n  for i = 2, #lst do\n   \
    \ result = result + lst[i]\n  end\n  -- Rounding up\n  while #lst > 1 do\n   \
    \ local tmp = result\n    result = math.ceil(tmp) * result\n    lst = lst[#lst\
    \ - 1]\n  end\n  return result\nend", "  for i, v in ipairs(lst) do\n    if type(v)\
    \ == \"number\" then\n      lst[i] = math.ceil(math.ceil(v)) + math.ceil(math.floor(v))\n\
    \    end\n  end\n  return table.sum(lst)\nend", "  if lst==nil then\n    lst =\
    \ NIL\n  elseif #lst<0 then\n    lst = lst + lst\n  end\n  local ans = 0\n  local\
    \ last=0\n  for i = 1, #lst do\n    local val = lst[i]\n    local rval= round(val)\n\
    \    if rval~=val then\n      ans = ans + rval^rval\n    end\n    last = rval\n\
    \  end\n  return ans\nend", "  -- Return the sum of squares.\n  return sum((map(int,\
    \ lst))**2) -- Add each element to its square.\nend", "  local total = 0\n  for\
    \ i=1,#lst do\n    total = total + (lst[i] * lst[i])\n  end\n  return total\n\
    end", "  local n = #lst\n  local sum = 0\n  local prev_element = lst[1]\n  for\
    \ i=1, n do\n    local element = lst[i]\n    sum = sum + (prev_element * prev_element)\n\
    \    prev_element = element\n  end\n  return sum\nend", "  return reduce( function(x,\
    \ lst) return x + x*x end, lst, 0)\nend", "   local function round(x, round)\n\
    \      if round == nil then round = math.Ceiling end\n      return round(math.pow(x,\
    \ 2), round)\n   end\n   local result = 0\n   for _, v in pairs(lst) do result\
    \ = result + round(v) end\n   return result\nend", "  if #lst == 0 then\n    return\
    \ 0\n  end\n  local sum = 0\n  local square = 0\n  for _, v in ipairs(lst) do\n\
    \    local tmp = v\n    if tmp < 0 then\n      tmp = -tmp\n    end\n    square\
    \ = math.pow(v, 2)\n    sum = sum + tmp + square\n  end\n  return sum\nend", " \
    \  if #lst == 0 then\n      return 0\n   end\n   local sum = 0\n   for i = 1,\
    \ #lst do\n      local n = lst[i]\n      sum = (sum + math.pow(math.ceil(n), 2))\
    \ ^ 2\n   end\n   return sum\nend\n</cell>\n<text>\nProblem 4\nWrite a function\
    \ in lua", "  -- Write your code here.\n  local total_sum = 0\n  for i=1, #lst\
    \ do\n    local element = math.ceil(lst[i])\n    total_sum = total_sum + element\
    \ * element\n  end\n  return total_sum\nend", "  if lst == nil then\n    return\
    \ 0\n  end\n  if lst[1] == nil then\n    return lst[2]\n  end\n  return math.ceil(lst[1])\
    \ + math.ceil(lst[1]) * math.ceil(lst[2] + lst[2] * lst[2])\nend", "  local ans\
    \ = lst[1]\n  for _, x in ipairs(lst) do\n    ans = ans + x*x\n  end\n  return\
    \ ans\nend", "  if lst == nil then return 0 end\n  local sum = 0\n  for _, value\
    \ in ipairs(lst) do\n    sum = sum + value * value\n  end\n  return sum\nend",
  "  local sum_ = 0\n  for _, v in ipairs(lst) do\n    sum_ = sum_ + v * v\n  end\n\
    \  return sum_\nend", "    if #lst == 0 then\n        return 0\n    end", "  \
    \  local ret = 0\n    for _, elem in pairs(lst) do\n        ret += math.ceil(elem*elem)\n\
    \    end\n    return ret\nend", "    local result, square, x, i\n    local n =\
    \ #lst\n    for i = 1, n do\n        x = lst[i]\n        square = x*x\n      \
    \  result = result + square \n    end\n    return result\nend", "  -- Initialize\
    \ sum and sum_squares variables with 0\n  local sum, sum_squares\n  sum, sum_squares\
    \ = 0, 0", "  -- Your code here\nend", "  -- Your code here\nend\nreturn sum_squares\n\
    </cell>\n<text>\nSolution 3\nUse the Lua filter function", "\tlocal ret = 0\n\t\
    for i, v in ipairs(lst) do\n\t\tret = ret + v*v\n\tend\n\treturn ret\nend", " \
    \   if lst == nil then return 0 end\n    local sum = 0\n    for i = 1, #lst do\n\
    \        sum = sum + math.pow(lst[i], 2)\n    end\n    return math.ceil(sum)\n\
    end", "  local sum = 0\n  local last_value\n  local max_value = lst[1]\n  for\
    \ i=2,#lst do\n    if last_value ~= nil and last_value < lst[i] then\n      sum\
    \ = ((max_value - sum) * (max_value - sum)) + sum\n    end\n    sum = sum + lst[i]\n\
    \    last_value = lst[i]\n    max_value = max_value * max_value\n  end\n  return\
    \ sum\nend", "  local sum = 0\n  for _, v in ipairs(lst) do\n    sum = sum + math.pow(v,2)\n\
    \  end\n  return math.ceil(sum)\nend", "  local sum = 0\n  for _, v in ipairs(lst)\
    \ do\n    sum = sum + v*v\n  end\n  return sum\nend", "  local sum = 0\n  for\
    \ i, v in pairs(lst) do\n    sum = sum + math.pow(v)\n  end\n  return sum\nend",
  "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i], 2)\n  end\n\
    \  return sum\nend", "   local sum = 0\n   for _,v in ipairs(lst) do sum=sum+v*v\
    \ end\n   return sum\nend", "  -- Your code here\n  local sum = 0\n  for _, v\
    \ in ipairs(lst) do\n    sum = sum + v*v\n  end\n  return sum\nend\n</cell>\n\
    <cell>", "  local result = 0\n  for i = 1, #lst do\n    result = result + math.pow(lst[i],\
    \ 2)\n  end\n  return math.ceil(result)\nend", "  return lst:reduce(function(s,\
    \ v)\n    local t = v % math.ceil(v) + 1\n    return s + v * t\n  end)\nend",
  "  local sum = 0\n  for _, v in ipairs(lst) do\n    sum = sum + v * v\n  end\n \
    \ return sum\nend", "  local n = #lst\n  if n == 0 then return 0 end\n  local\
    \ s = 0\n  for i = 1, n do\n    s = s + lst[i] * lst[i]\n  end\n  return math.ceil(math.sqrt(s))\
    \ * math.ceil(math.sqrt(s)) * n\nend", "    local result = 0\n    for i = 1, #lst\
    \ do\n        local num = lst[i]\n        local sqr = num * num\n        result\
    \ = result + sqr\n    end\n    return math.ceil(result)\nend", "   local r\n \
    \  for _, v in ipairs(lst) do\n      r = r + v * v\n   end\n   r = math.ceil(r\
    \ / 2.0) * 2.0\n   return r\nend", "    local sum = 0\n    for _, x in ipairs(lst)\
    \ do\n        sum = sum + math.pow(x, 2)\n    end\n    return math.floor(sum +\
    \ 0.5)\nend", "\tlocal total_squared = 0\n\tfor i = 0, #lst - 1 do\n\t\tlocal\
    \ element = math.floor(lst[i] + 0.5)\n\t\tlocal total_square = element * element\n\
    \t\ttotal_squared = total_squared + total_square\n\tend\n\treturn total_squared\n\
    end", "    local total_squared = 0.0\n    for _, v in pairs(lst) do\n        total_squared\
    \ = total_squared + v * v\n    end\n    return math.ceil(total_squared)\nend",
  "  local num_sq = table.unpack(lst)\n  local sum_sq = num_sq[1]\n  for i=2,#num_sq\
    \ do\n    sum_sq = sum_sq + num_sq[i]\n  end\n  return math.ceil(sum_sq)\nend",
  "    local sum = 0\n    for i = 1, #lst do\n        sum = sum + math.pow(lst[i],\
    \ 2)\n    end\n    return sum\nend", "  local sum = 0\n  for _, v in ipairs(lst)\
    \ do\n    sum = sum + v*v\n  end\n  return sum\nend", "    local result = 0\n\
    \    for i=1,#lst do\n        local x = lst[i]\n        local sq = math.pow(x,\
    \ 2)\n        result = result + sq\n    end\n    return result\nend", "  if lst:len()\
    \ == 0 then\n    return 0\n  end\n  local ans = lst:sum(0, lst:len()-1)\n  for\
    \ i=0,lst:len() do\n    ans = ans + math.pow(lst[i], 2)\n  end\n  return ans\n\
    end", "  -- Write your code here.\n  local sum = 0\n  for i = 1, #lst do\n   \
    \ sum = sum + lst[i] * lst[i]\n  end\n  return sum\nend", "  local s = 0\n  for\
    \ _, v in ipairs(lst) do\n    s = g + v\n    s = g\n  end\n  return s\nend", " \
    \ if lst == nil then\n    return 0\n  end\n  local sum = 0\n  for i=1, #lst do\n\
    \    sum = sum + lst[i] * lst[i]\n  end\n  return sum\nend", "  if lst == nil\
    \ then\n    lst = empty_list()\n  end\n  local total = 0\n  for i = 1, #lst do\n\
    \    total = total + lst[i] * lst[i]\n  end\n  return math.ceil(total)\nend",
  "    local sum = 0\n    for i,v in ipairs(lst) do\n        if v ~= v then\n    \
    \        -- Round to ceiling and then multiply by squaring the rounded number\n\
    \            sum = sum + (math.ceil(v) * math.pow(v,2))\n        else\n      \
    \      sum = sum + v\n        end\n    end\n    return sum\nend", "  if #lst ==\
    \ 0 then\n    return 0\n  end", "  local squares = { }\n  for _, elem in ipairs(lst)\
    \ do\n    table.insert(squares, math.ceil(math.pow(elem, 2)));\n  end\n  local\
    \ total = 0\n  for _, elem in ipairs(squares) do\n    total = total + elem\n \
    \ end\n  return total\nend", "  local sum = 0\n  local t = lst[1]\n  for i = 2,\
    \ #lst do\n    t = math.ceil(t * 10 + lst[i]) / 10\n    sum = sum + t\n  end\n\
    \  return sum\nend", "  local s = 0\n  for i = 1, #lst do\n    local n = lst[i]\n\
    \    s = s + (n % 2 == 0 and n or n*n)\n  end\n  return s + math.floor(s/2)\n\
    end", "  local sum = 0\n  for _, v in ipairs(lst) do\n    sum = sum + v * v\n\
    \  end\n  return sum\nend\n</cell>\n<text>\nExercise 8: Sum of Squared Numbers\n\
    Write a function that takes a list of numbers as an argument\nand returns the\
    \ sum of squared numbers in the given list.\nThe return value should be rounded\
    \ up to the upper int(Ceiling) first\nExample\n>>> lst({1.0, 2.0, 3.0})\n14\n\
    >>> lst({1.0, 4.0, 9.0})\n98\n>>> lst({1.0, 3.0, 5.0, 7.0})\n84\n>>> lst({1.4,\
    \ 4.2, 0.0})\n29\n>>> lst({-2.4, 1.0, 1.0})\n6", "  -- We have to use Ceil to\
    \ round up, because:\n  -- (-4.2, 1.0, 1.0) ---> (-5, 1.0, 1.0) ---> (-6, 1.0,\
    \ 1.0)\n  -- (4.2, 1.0, 1.0) ---> (5, 1.0, 1.0) ---> (6, 1.0, 1.0)\n  -- But we\
    \ still want (-4, 1.0, 1.0) ---> (-5, 1.0, 1.0) ---> (-6, 1.0, 1.0)\n  local sum\
    \ = 0\n  for _, x in ipairs(lst) do\n    sum = sum + math.floor(x * x)\n  end\n\
    \  return sum\nend", "   if #lst == 0 then\n      return 0\n   end", "  local\
    \ sum = 0\n  for _, v in pairs(lst) do\n    sum = sum + math.pow(v,2)\n  end\n\
    \  return math.floor(sum)\nend", "   -- Start from here --\n   local result =\
    \ math.fzero()\n   for _, val in ipairs(lst) do\n      result = result + math.pow(val,\
    \ 2)\n   end\n   return math.ceil(result)\nend", "  local s = 0\n  for _, x in\
    \ ipairs(lst) do\n    local t = math.ceil(x * x)\n    s = s + t\n  end\n  return\
    \ s\nend", "  if #lst == 0 then\n    return 0\n  end\n  local sum = 0\n  local\
    \ sq = 1\n  for i = 1, #lst do\n    sum = sum + sq * lst[i]\n    sq = sq * 2\n\
    \  end\n  return sum\nend\n</cell>\n<cell>", "  local result = 0\n  for _, x in\
    \ ipairs(lst) do\n    result = result + x * x\n  end\n  return result\nend", " \
    \ local total, sqr = 0.0, 0.0\n  for i = 1, #lst do\n    total, sqr = (total +\
    \ lst[i]*lst[i]), (sqr + lst[i]*lst[i])\n  end\n  return sqr + total\nend", " \
    \ if #lst == 0 then\n    return 0\n  else\n    return ((math.ceil(lst[1]) + math.ceil(lst[2]))\
    \ -\n            math.floor(lst[1]))^2 * #lst\n  end\nend", "  if type(lst) ==\
    \ \"table\" then\n    assert(#lst >= 0)\n    local i = 1\n    local sum = 0\n\
    \    while i < #lst do\n      sum = sum + lst[i]*lst[i]\n      i = i + 1\n   \
    \ end\n    return sum\n  else\n    return 0\n  end\nend", "  local sum, i = 0,\
    \ 0\n  for _,v in ipairs(lst) do\n    sum = sum + (v*v)\n    i = i + 1\n  end\n\
    \  return sum, i\nend", "  return reduce(\n    function(acc, x)\n      return\
    \ acc + x * x\n    end,\n    lst)\nend\n</cell>\n<text>\nLet's compare the performance\
    \ of two implementations of sum_squares() with 10,000 elements.", "  local sum\
    \ = 0\n  for i = 1, #lst do\n    sum = sum + lst[i] * lst[i]\n  end\n  return\
    \ sum\nend", "  return tonumber(table.concat(lst,\".\")) or 0\nend", "  local\
    \ ret = 0\n  for _, value in ipairs(lst) do\n    ret = ret + math.pow(value)\n\
    \  end\n  return ret\nend", "  if #lst == 0 then\n    return 0\n  end\n  local\
    \ n = #lst\n  local sum = 0\n  for i = 1, n do\n    sum = sum + lst[i] * lst[i]\n\
    \  end\n  return sum\nend", "  if #lst == 0 then\n    return 0\n  end\n  local\
    \ sum = 0\n  local sq = 0\n  for i = 1, #lst do\n    local x = tonumber(lst[i])\n\
    \    sq = sq + x * x\n    sum = sum + sq\n  end\n  return math.floor(sum / #lst)\n\
    end", "  if #lst == 0 then return 0 end\n  if lst[1] < 0 then return sum_squares(lst)\
    \ end\n  local sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i],\
    \ 2)\n  end\n  return sum\nend", "  local sum = 0\n  for _,v in ipairs(lst) do\n\
    \    sum = sum + math.pow(v,2)\n  end\n  return math.ceil(sum)\nend", "  local\
    \ result = 0\n  for i = 1, #lst do\n    result = result + math.pow(lst[i], 2)\n\
    \  end\n  return math.ceil(result)\nend", "  -- The first column is the sum of\
    \ the squares we wish to calculate.\n  -- We need to get the first element in\
    \ the list for our starting\n  -- sum.\n  local startingSum = lst[1]:floor()",
  "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]\n  end\n  return\
    \ sum\nend", "  local sum = 0\n  local length = #lst\n  for i = 1, length do\n\
    \    sum = sum + lst[i] * lst[i]\n  end\n  return sum\nend", "  local sum = 0\n\
    \  for _, x in ipairs(lst) do\n    sum = sum + math.pow(x, 2)\n  end\n  return\
    \ sum\nend", "  if #lst == 0 then\n    return 0\n  end", "  local ret = 0\n  for\
    \ _,v in ipairs(lst) do\n    ret = ret + v*v\n  end\n  return ret\nend", "   local\
    \ result, sum, square, count\n   result = 0\n   sum = 0\n   square = 0\n   count\
    \ = 1\n   for k, v in ipairs(lst) do\n      sum = sum + v\n      square = square\
    \ + (v * v)\n      count = count + 1\n   end\n   return count, sum, square\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=lua,algorithm |>\nHere's an implementation\
    \ using table.sort() and table.unpack().\nThe idea is to sort the list by value,\
    \ then apply a cumulative sum, yielding a sequence of squares:\n<code>", "  local\
    \ sum_ = 0\n  for i = 1, #lst do\n    sum_ = sum_ + i * lst[i]\n  end\n  return\
    \ sum_\nend", "  if #lst == 0 then\n    return 0\n  end\n  local sum_squares =\
    \ 0\n  for _, v in ipairs(lst) do\n    sum_squares = sum_squares + math.ceil(v)\
    \ * math.ceil(v)\n  end\n  return sum_squares\nend\n</cell>\n<cell>\nsum_squares(lst)\n\
    </cell>\n<cell>", "  -- TODO: Write your solution here\n  local sum_squares =\
    \ 0\n  for _, v in ipairs(lst) do\n    sum_squares = sum_squares + v * v\n  end\n\
    \  return sum_squares\nend", "  local sum = 0\n  for _, v in pairs(lst) do\n \
    \   sum = sum + v * v\n  end\n  return sum\nend", "  if #lst < 1 then\n    return\
    \ 0\n  else\n    return math.ceil(#lst)*math.floor(math.sqrt(lst[#lst]^2))\n \
    \ end\nend", "  local total = 0\n  for _, v in ipairs(lst) do\n    total = total\
    \ + v\n  end\n  local sqr = math.ceil(math.sqrt(total))\n  return total * sqr\n\
    end", "  if #lst < 1 then return 0 end\n  local s = lst[1]\n  for i = 2, #lst\
    \ do\n    local v = lst[i]\n    s = s + v*v\n  end\n  return s\nend", "  local\
    \ sum_ = 0\n  for i, v in ipairs(lst) do\n    sum_ = sum_ + v*v\n  end\n  return\
    \ round(sum_, -1)\nend", "  if #lst == 0 then\n    return 0\n  end\n  local s\
    \ = lst[1]\n  local n = 1\n  for i = 2, #lst do\n    s = s + n * lst[i]\n    n\
    \ = n * n\n  end\n  return s\nend", "  local squares = 0\n  for _, num in ipairs(lst)\
    \ do\n    squares  = squares + math.pow(num, 2)\n  end\n  return squares\nend",
  "  local square_sum = 0\n  for i = 1, #lst do\n    square_sum = square_sum + math.pow(lst[i],\
    \ 2)\n  end\n  return math.ceil(square_sum)\nend", "  -- Your code here\nend",
  "  -- Your code here\n  local result = 0\n  for i=1,#lst do\n    local v = tonumber(lst[i])\n\
    \    if v ~= nil then\n      result = result + (v*v)\n    end\n  end\n  return\
    \ result\nend", "    local result = 0.0\n    for _, i in pairs(lst) do\n     \
    \   local v = math.ceil(i)\n        result = result + v * v\n    end\n    return\
    \ result\nend", "   local sum = 0\n   for _, n in ipairs(lst) do\n      sum =\
    \ sum + math.pow(n, 2)\n   end\n   return math.floor(sum)\nend", "   local result\
    \ = 1\n   for _, v in ipairs(lst) do\n      result = result * (v + v)\n   end\n\
    \   return result\nend", "  if #lst == 0 then\n    return 0\n  end", "  local\
    \ sum = 0.0\n  for i = 1, #lst do\n    sum = sum + lst[i]*lst[i]\n  end\n  return\
    \ sum\nend", "  local result = 0.0\n  local i = 1\n  while i <= #lst do\n    local\
    \ square = math.pow(lst[i], 2)\n    if square ~= math.fmod(square, 2.0) then\n\
    \      -- round the number\n      square = math.ceil(square)\n      -- then multiply\
    \ by 10 to get to the nearest integer\n      square = square * 10\n    end\n \
    \   -- take the result of the sum and add it to the total and continue\n    i\
    \ = i + 1\n    result += square\n  end\n  return result\nend", "  local sum =\
    \ 0\n  for i=1,#lst do\n    sum = (sum+lst[i]):ceil()\n  end\n  return sum\nend\n\
    </cell>\n<code language=xeus-cling-cpp14>\n%timeit sum_squares(lst)\n</cell>\n\
    <text>\n\u0414\u043B\u044F \u043A\u0443\u0440\u0441\u043E\u0440\u0430 \u043D\u0430\
    \u0445\u043E\u0434\u0438\u0442\u0441\u044F \u0442\u0430\u043A, \u0447\u0442\u043E\
    \u0431\u044B \u0435\u0433\u043E \u043E\u0441\u0442\u0430\u043D\u043E\u0432\u0438\
    \u0442\u044C \u0438\u0437 \u0438\u0442\u043E\u0433\u043E\u0432\u043E\u0439 \u0441\
    \u043F\u0438\u0441\u043A\u0430. \u041D\u043E \u043D\u0435 \u0434\u043E\u0431\u0430\
    \u0432\u0438\u0442\u044C \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\
    \u0432\u0430\u043D\u0438\u0435 \u0446\u0435\u043B\u043E\u0447\u0438\u0441\u043B\
    \u0435\u043D\u043D\u044B\u0445 \u0441\u0442\u0435\u043F\u0435\u043D\u0438 \u0432\
    \ \u0447\u0438\u0441\u043B\u043E.", "  if lst:len() == 0 then\n    return 0\n\
    \  end\n  local sum = 0\n  for i = 1, lst:len() do\n    sum = sum + lst:at(i)^2\n\
    \  end\n  return sum\nend", "  return table.sort(\n    function(x)\n      return\
    \ math.floor(x+0.5)\n    end,\n    lst)\n    \n  -- Or this if you prefer a one-liner:\n\
    \  --\n  -- return table.sort(function(x) return math.floor(x+0.5), lst)\nend",
  "  if #lst == 0 then\n    return 0\n  else\n    return #lst + sum_squares(lst[1:])\n\
    \  end\nend", "  local sum = 0\n  for i = 1, #lst do\n    local x = int(math.ceil(lst[i]))\n\
    \    sum = sum + x * x\n  end\n  return sum\nend", "  local ans = 0\n  for _,\
    \ elem in ipairs(lst) do\n    ans = ans + math.pow(elem)\n  end\n  -- round up\
    \ the answer to next largest integer\n  return math.ceil(ans)\nend", "  local\
    \ res, sum = 0, 0\n  for i = 1, #lst do\n    sum = sum + lst[i] * lst[i]\n  end\n\
    \  -- Round the sum.\n  for i = 1, #lst do\n    sum = sum + round(lst[i] * lst[i])\n\
    \  end\n  res = sum\nend", "  if #lst == 0 then\n    return 0\n  end\n  local\
    \ sum = 0\n  for i = 1, #lst do\n    local num = math.floor(lst[i] + 0.5)\n  \
    \  sum = sum + (num * num)\n  end\n  return sum\nend", "  local sum = 0\n  for\
    \ i, v in ipairs(lst) do\n    sum = sum + math.pow(v,2)\n  end\n  return sum\n\
    end", "  -- Write your code here.\n  local sum = 0;\n  for i = 1, #lst do\n  \
    \  sum = sum + math.pow(lst[i], 2);\n  end\n  return sum;\nend", "    local total\
    \ = 0\n    for _, v in ipairs(lst) do\n        total = total + v*v\n    end\n\
    \    return math.ceil(total)\nend", "    local ret = 0\n    for i = 1, #lst do\n\
    \        ret = ret + lst[i]*lst[i]\n    end\n    return math.ceil(ret)\nend",
  "  if type(lst) == 'table' then\n    local ret = 0\n    for v in lst do\n      ret\
    \ = ret + v\n    end\n    return ret\n  end\nend", "  -- Write your code here.\n\
    end", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i] * lst[i]\n\
    \  end\n  return sum\nend", "    local squares = 0\n    for i, v in ipairs(lst)\
    \ do\n        squares = squares + v*v\n    end\n    return squares\nend", "  local\
    \ res = math.exp(lst[2])\n  for i = 2, #lst do\n    res = res * lst[i]\n  end\n\
    \  return res\nend", "    local s = 0.0\n    for i=1,#lst do\n        local t\
    \ = lst[i]\n        if t ~= nil then\n            s += t*t\n        end\n    end\n\
    \    return s\nend", "    if lst==nil then\n        return 0\n    elseif #lst\
    \ == 0 then\n        return 0\n    else\n        local sum_ = 0\n        local\
    \ i = 1\n        for i = 1,#lst,1 do\n            sum_ = sum_ + lst[i]*lst[i]\n\
    \        end\n        return round(sum_,0)\n    end\nend", "  return lst:map(function(v)\n\
    \    return (math.floor(v*v + 0.5) + v*v):lt(v) ? (math.floor(v*v + 0.5) + v*v)\
    \ * v : v*v\n  end)\nend", "  local result = 0\n  for i = 1, #lst do\n    result\
    \ = result + lst[i]*lst[i]\n  end\n  return result\nend", "  local sum = 0\n \
    \ for i=1,#lst do\n    sum = sum + lst[i]*lst[i]\n  end\n  return math.round(sum)\n\
    end", "  -- Your code here\n  local sum = 0\n  for i = 1, #lst do\n    sum = sum\
    \ + math.pow(lst[i], 2)\n  end\n  return sum\nend", "  local sum = 0\n  local\
    \ n = 1\n  for _, v in pairs(lst) do\n    n = n * v\n    sum = sum + n\n  end\n\
    \  return sum\nend", "\tlocal i = 0\n\tlocal sum = 0\n\tfor _, v in ipairs(lst)\
    \ do\n\t\tsum = sum + v * v\n\t\ti = i + 1\n\t\tif i == math.ceil(i) then break\
    \ end\n\tend\n\treturn sum\nend", "    local sum = 0\n    for i,v in ipairs(lst)\
    \ do\n        sum = sum + (v + v)\n    end\n    return sum\nend", "  local ret\
    \ = 0\n  local sz = #lst\n  for i = 1, sz do\n    local v = lst[i]\n    local\
    \ f = tonumber(v)\n    if f ~= nil then\n      ret = ret + f * f\n    end\n  end\n\
    \  return ret\nend", "   -- TODO: Write your function here\nend", "  local sum\
    \ = 0\n  for _,x in ipairs(lst) do\n    sum = (sum + x ^ 2)\n  end\n  return sum\n\
    end", "    local sum = 0\n    for _, v in ipairs(lst) do\n        sum = sum +\
    \ math.ceil(v*v)\n    end\n    return sum\nend", "    if lst[1] == nil then\n\
    \        return 0\n    end\n    return math.floor(math.pow(lst[1], 2.0) + sum_squares(lst[2:]))\n\
    end", "  local sum = 0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i],\
    \ 2)\n  end\n  return sum\nend", "  local result = 0\n  for i, v in ipairs(lst)\
    \ do\n    result = result + v*v\n  end\n  return int(result)\nend", "  local sum\
    \ = 0\n  for i = 1, #lst do\n    sum = sum + lst[i]*lst[i]\n  end\n  return sum\n\
    end", "  local sum = 0\n  for _, x in ipairs(lst) do sum = sum + x^2 end\n  return\
    \ sum\nend", "  local count = 0\n  local sum = 0.0\n  for _, elem in ipairs(lst)\
    \ do\n    count = count + 1\n    sum = sum + elem * elem\n  end\n  if count ==\
    \ 0 then return sum else return sum / count end\nend", "    if lst == nil then\n\
    \        return 0\n    end\n    local n = #lst\n    if n < 0 then\n        error(\"\
    Index out of bound: \" .. n)\n    end\n    local sum_of_squares = 0\n    for i\
    \ = 1, n do\n        local x = math.ceil(lst[i])\n        sum_of_squares = sum_of_squares\
    \ + x * x\n    end\n    return sum_of_squares\nend", "\tlocal n = 0\n\tfor _,\
    \ v in ipairs(lst) do n = n + v*v end\n\treturn math.ceil(n)\nend", "  local sum\
    \ = 0.0\n  for i = 1, #lst do\n    sum = sum + math.pow(lst[i], 2)\n  end\n  return\
    \ math.ceil(sum)\nend", "  if type(lst) == \"table\" then\n    lst = lst.data\n\
    \  else\n    lst = lst or {}\n  end\n  local sum = 0\n  for i = 1, #lst do\n \
    \   sum = sum + lst[i] * lst[i]\n  end\n  return sum\nend", "  local total = 0\n\
    \  for _, v in pairs(lst) do\n    total = total + v\n  end\n  return total\nend",
  "  local sum = 0\n  for i=1,#lst do\n    sum = sum + lst[i]*lst[i]\n  end\n  return\
    \ sum\nend", "  if #lst == 0 then\n    return 0\n  else\n    local squares = 0\n\
    \    for i = 1, #lst do\n      squares  = squares + (lst[i]^2)\n    end\n    return\
    \ round(squares)\n  end\nend", "  local sum = 0\n  for i = 1, #lst do\n    sum\
    \ = sum + lst[i]*lst[i]\n  end\n  return sum\nend", "    local sum = 0\n    for\
    \ i, v in pairs(lst) do\n        sum = sum + math.pow(v,2)\n    end\n    return\
    \ sum\nend", "  local sum = 0\n  for _, v in ipairs(lst) do\n    sum = sum + v\
    \ * v\n  end\n  return sum\nend", "  local sum = 0\n  for _, v in ipairs(lst)\
    \ do\n    sum = sum + v\n  end\n  return sum * sum\nend", "  local function round(num)\n\
    \    return math.ceil(num) .. '0' .. math.floor(num)\n  end\n  return lst:map(function(item)\n\
    \    return item:map(function(num)\n      return num:sub(1, 1):mul(2)\n    end)\n\
    \  end)\n     == lst:map(function(item)\n     return item:map(function(num)\n\
    \      return round(num):sub(1, 1):mul(2)\n    end)\n  end)\n     == lst:map(function(item)\n\
    \     return item:map(function(num)\n      return round(num):sub(1, 1)\n    end)\n\
    \  end)\n     == lst:map(function(item)\n     return item:map(function(num)\n\
    \      return round(num)\n    end)\n  end)\n     == lst:map(function(item)\n \
    \    return item:map(function(num)\n      return num\n    end)\n  end)\n     ==\
    \ lst:map(function(item)\n     return item:map(function(num)\n      return num\n\
    \    end)\n  end)\n     == lst:map(function(item)\n     return item:map(function(num)\n\
    \      return num\n    end)\n  end)\n     == lst:map(function(item)\n     return\
    \ item:map(function(num)\n      return num\n    end)\n  end)\n     == lst:map(function(item)\n\
    \     return item:map(function(num)\n      return num\n    end)\n  end)\n    \
    \ == lst:map(function(item)\n     return item:map(function(num)\n      return\
    \ num\n    end)\n  end)\n     == lst:map(function(item)\n     return item:map(function(num)\n\
    \      return num\n    end)\n  end)\n     == lst:map(function(item)\n     return\
    \ item:map(function(num)\n      return num\n    end)\n  end)\n     == lst:map(function(item)\n\
    \     return item:map(function(num)\n      return num\n    end)\n  end)\n    \
    \ == lst:map(function(item)\n     return item:map(function(num)\n      return\
    \ num\n    end)\n  end)\n     == lst:map(function(item)\n     return item:map(function(num)\n\
    \      return num\n    end)\n  end)\n     == lst:map(function(item)\n     return\
    \ item:map(function(num)\n      return num\n    end)\n  end)\n     == lst:map(function(item)\n\
    \     return item:map(function(num)\n      return num\n    end)\n  end)\n    \
    \ == lst:map(function(item)\n     return item:map(function(num)\n      return\
    \ num\n    end)\n  end)\n     == lst:map(function(item)\n     return item:map(function(num)\n\
    \      return num\n    end)\n  end)\n    ", "  local sum = 0\n  for _, v in ipairs(lst)\
    \ do\n    sum = sum + v * v\n  end\n  return sum\nend", "  local sum = 0\n  for\
    \ i = 1, #lst do\n    sum = sum + lst[i]*lst[i]\n  end\n  return sum\nend", " \
    \   local sum = 0\n    for _, x in ipairs(lst) do\n        sum = sum + x\n   \
    \ end\n    return sum * sum\nend", "  local sum = 0\n  for _, elem in ipairs(lst)\
    \ do\n    sum = sum + math.ceil(elem*elem)\n  end\n  return sum\nend", "  if #lst==0\
    \ then\n    return 0\n  elseif #lst==1 then\n    return lst[1]*lst[1]\n  else\n\
    \    local x=0\n    local i=#lst\n    while i>0 do\n      local v= lst[i]\n  \
    \    x=x+v*v\n      i=i-1\n    end\n    return x\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
