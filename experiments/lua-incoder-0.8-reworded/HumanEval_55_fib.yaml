name: HumanEval_55_fib
language: lua
prompt: "-- Return n-th Fibonacci number.\n-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n\
  -- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib\n\
  \    lu.assertEquals(candidate(10), 55)\n    lu.assertEquals(candidate(1), 1)\n\
  \    lu.assertEquals(candidate(8), 21)\n    lu.assertEquals(candidate(11), 89)\n\
  \    lu.assertEquals(candidate(12), 144)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tif n < 0 then\n\t\terror(\"fib() argument out of range\")\n\tend",
  "  if n==0 then return 0 end\n  if n==1 then return 1 end\n  return fib(n-1) + fib(n-2)\n\
    end", "  if n<1 then\n    return 1\n  elseif n<2 then\n    return 1\n  else\n\
    \    return fib(n-1)+fib(n-2)\n  end\nend", "  if n < 3 then\n    return n\n \
    \ elseif n < 13 then\n    return fib(n-1) + fib(n-2)\n  else\n    return fib(n-1)\
    \ + fib(n-2) + fib(n-3)\n  end\nend", "  if n < 0 then\n    return 0\n  end\n\
    \  if n == 0 or n == 1 then\n    return n\n  end\n  return fib(n-1) + fib(n-2)\n\
    end", "\t-- https://en.wikipedia.org/wiki/Fibonacci_number\n\tif n < 2 then\n\t\
    \treturn n\n\telseif n < 5 then\n\t\treturn fib(n-1) + fib(n-2)\n\telse\n\t\t\
    return fib(n - 4) + fib(n - 3)\n\tend\nend", "  if n <= 0 then\n    return 1\n\
    \  elseif n >= 1 then\n    return fib(n-1) + fib(n-2)\n  end\nend", "   if n <=\
    \ 1 then return n else return fib(n - 2) + fib(n - 1) end\nend", "  if n < 2 then\
    \ return n else return fib(n-2) + fib(n-1) end\nend", "    if n == 0 then\n  \
    \      return 1\n    else\n        return fib(n-2) + fib(n-1)\n    end\nend",
  "  if n == 1 then\n    return 1\n  elseif n == 0 then\n    return 0\n  elseif n\
    \ == 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\n\
    end", "    if n < 0 then\n        n = 0\n    end\n    if n == 0 or n == 1 then\n\
    \        return n\n    end\n    local fib2, fib3 = fib2, fib3\n    if n <= 1 then\n\
    \        return fib3\n    end\n    fib3, fib2 = fib2, fib3\n    return fib3(n\
    \ - 1) + fib3(n - 2)\nend", "  if n < 2 then\n    return 1\n  elseif n < 3 then\n\
    \    return fib(n-1) + fib(n-2)\n  else\n    return fib(n-1) + fib(n-2) + fib(n-3)\n\
    \  end\nend", "\tif n < 0 then\n\t\terror(\"Index must be nonnegative (got \"\
    ..tostring(n))..\"!\")\n\tend\n\tif n == 0 then\n\t\treturn 1\n\tend\n\tif n ==\
    \ 1 then\n\t\treturn 0\n\tend\n\treturn fib(n-1) + fib(n-2)\nend", "  if n < 1\
    \ then return 0 end\n  if n < 2 then return 1 end\n  return fib(n - 1) + fib(n\
    \ - 2)\nend", "    if n < 2 then\n        return n\n    else\n        return fib(n-1)\
    \ + fib(n-2)\n    end\nend", "  if n < 2 then\n    return n\n  else\n    return\
    \ fib(n-1) + fib(n-2)\n  end\nend", "  if n < 0 then return nil end\n  if n <\
    \ 2 then return n end\n  return fib(n-1) + fib(n-2)\nend", "  local a, b = 0,\
    \ 1\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  end\n\
    \  for i = 1, n do\n    a, b = b, a + b\n  end\n  return a\nend", "  if n < 1\
    \ then\n    return n\n  elseif n == 1 then\n    return 1\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  if n <= 1 then return n end\n  local function fib_recursion(n,\
    \ m)\n    if n < 2 then\n      return m\n    end\n    local newN, newM = n - 1,\
    \ m + n\n    return fib_recursion(newN, newM) and m\n  end\n  return fib_recursion(n-1,\
    \ 1)\nend", "  if n <= 0 then return 0 end\n  if n == 1 then\n    return 1\n \
    \ end\n  return fib(n - 2) + fib(n - 1)\nend", "\tlocal a,b = 1,1\n\tfor i=2,n\
    \ do a,b = b,a+b end\n\treturn a\nend", "    if n >= 2\n        then return fib(n-1)\
    \ + fib(n-2)\n    else\n        return n\n    end\nend", "  -- Local variable\
    \ named 'last' to hold the n-th Fibonacci number.\n  local last = 1\n  local current\
    \ = 1\n  -- Loop indefinitely until the n-th Fibonacci number is found.\n  --\
    \ For large values of n the loop execution would be too slow, therefore\n  --\
    \ we use the 'while not true' construct and break out of the loop when we\n  --\
    \ find the n-th Fibonacci number.\n  -- The loop execution would look something\
    \ like this:\n  -- >>> last, current = 1, 1\n  -- >>> while current <= n:\n  --\
    \ ...     last, current = current, last + current\n  -- ... \n  -- Since 'last'\
    \ and 'current' have values 1 and 1, the above loop is equivalent to\n  -- >>>\
    \ 1\n  -- >>> 1\n  -- >>> 2\n  -- >>> 3\n  -- >>> 5\n  -- >>> 8\n  -- >>> ...\n\
    \  -- >>> fib(n - 1) + fib(n - 2)\n  -- Using this approach, the loop is run at\
    \ most n times.\n  -- If we run it for the first time the result is 1 and if we\
    \ run it for the second\n  -- time the result is 1 + 1. This is what we want.\n\
    \  while current <= n do\n    last, current = current, last + current\n  end\n\
    \  return last\nend", "  if n < 2 then\n    return 1\n  else\n    return fib(n-2)\
    \ + fib(n-1)\n  end\nend", "\tif n < 1 then\n\t\treturn 1\n\tend\n\tif n == 1\
    \ then\n\t\treturn 1\n\tend\n\treturn fib(n - 1) + fib(n - 2)\nend", "  if n <=\
    \ 1 then\n    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", " \
    \ if n <= 0 then\n    -- Base cases are special cases\n    return n\n  else\n\
    \    return fib(n-1) + fib(n-2)\n  end\nend\n</cell>\n<text>\nThe same idea applies\
    \ to recursion", "  if n < 2 then\n    return n\n  else\n    return fib(n-1) +\
    \ fib(n-2)\n  end\nend\n</cell>\n<text>\nTask 2.2: Implementing memoization in\
    \ Python.", "  if n <= 2 then\n    return n\n  end\n  return fib(n-1) + fib(n-2)\n\
    end", "    if n <= 1 then\n        return n\n    else\n        return fib(n-1)\
    \ + fib(n-2)\n    end\nend", "  if n < 2 then\n    return 1\n  elseif n < 4 then\n\
    \    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if\
    \ n < 2 then return n\n  elseif n == 1 then return 1 end\n  return fib(n-2) +\
    \ fib(n-1)\nend", "  if n==1 then\n    return 1\n  else\n    return fib(n - 1)\
    \ + fib(n - 2)\n  end\nend", "  if n<1 then return 0 end\n  if n==1 then return\
    \ 1 end\n  return fib(n-1)+fib(n-2)\nend", "    if n <= 0 then\n        return\
    \ 1\n    elseif n > 1 then\n        return fib(n-1) + fib(n-2)\n    end\nend",
  "  if n < 1 then return 1 end\n  return fib(n - 1) + fib(n - 2)\nend\n_G.fib = fib",
  "\tif n < 2 then\n\t\treturn n\n\telse\n\t\treturn fib(n - 1) + fib(n - 2)\n\tend\n\
    end", "  if n <= 1 then\n    return 1\n  else\n    return fib(n - 1) + fib(n -\
    \ 2)\n  end\nend", "    local a, b = 0, 1\n    local c, d, x, y = 0, a, a + b\n\
    \    while n >= 0 do\n        a, b = d, c\n        c, d, x, y = y, x + y, x +\
    \ y\n        x, y = y, x + y\n        n, x = n, x - 1\n    end\n    return c\n\
    end", "  if n <= 0 then\n    return 1\n  elseif n == 1 or n == 2 then\n    return\
    \ 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  if n == 0 then\n\
    \    return 0\n  elseif n == 1 then\n    return 1\n  else\n    return fib(n -\
    \ 1) + fib(n - 2)\n  end\nend\n</code>\n<|/ a tags=clojure,recursion |>\n<| c\
    \ |>\nYes, I agree. I was just trying to show how one can do it with two functions.\
    \ I edited my answer to reflect that :)\n<|/ c |>\n<| a tags=clojure,recursion\
    \ |>\nThe other answers are good, but since it took me a while to learn this technique,\
    \ I wanted to share a recursive version that doesn't rely on clojure.core/recur:\n\
    <code>\n;; recursive function\n(defn fib [num]\n  (if (<= num 2)\n    1\n    (+\
    \ (fib (dec num)) (fib num))))\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis version\
    \ only works if you define your own `fib` function. If you're using [`clojure.core/recur`](http://clojuredocs.org/clojure_core/clojure.core/recur),\
    \ then you'll get an error that the function already exists.\n<|/ c |>\n<| c |>\n\
    Ha. I've just read [the documentation](http://clojuredocs.org/clojure_core/clojure.core/recur),\
    \ and this function does exist. It's actually defined as `(clojure.core/recur\
    \ f coll)`, where `f` is the function in the example and `coll` is the collection\
    \ to iterate over. So `clojure.core/recur` does the same thing as the example\
    \ above for you.\n<|/ c |>\n<| a |>\n<code>\n(defn fib [n]\n  (if (= n 1)\n  \
    \  1\n    (+ (fib (dec n)) (fib n))))\n</code>\n<|/ a dscore=5 tags=clojure,recursion\
    \ |>\n<| c |>\nIf someone tries to use this in a recursive function and uses `recur`\
    \ instead of `(+)`, they won't even get to the second iteration, right? Because\
    \ `(dec 1)` will return `0` and the recursion will never end.\n<|/ c |>\n<| c\
    \ |>\nIndeed it does not. I'll edit my answer with that\n<|/ c |>\n<| c |>\nNo,\
    \ it doesn't return 0. The first recursive call returns 0, then 0 is added onto\
    \ the result of calling fib again with a second parameter of 1. So your answer\
    \ is correct.\n<|/ c |>\n<| c |>\n", "  if n < 0 then return nil end\n  if n==0\
    \ then return 1 end\n  if n==1 then return 1 end\n  return fib(n - 1) + fib(n\
    \ - 2)\nend", "  if n <= 1 then return n else return fib(n - 1) + fib(n - 2) end\n\
    end", "  local last = 0\n  local result\n  if n > 0 then\n    result = last +\
    \ fib(n - 1)\n    last = result\n  end\n  return result\nend\n</cell>\n<cell>",
  "  if n <= 2 then return n end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n\
    \ < 0 then\n    error(\"fib() expects an integer\")\n  end\n  if n < 2 then\n\
    \    return n\n  end\n  return fib(n-2) + fib(n-1)\nend", "  if n < 1 then\n \
    \   return 1\n  elseif n < 2 then\n    return n\n  else\n    return fib(n - 1)\
    \ + fib(n - 2)\n  end\nend", "   if n < 2 then\n      return n\n   elseif n ==\
    \ 2 then\n      return 1\n   else\n      return fib(n - 1) + fib(n - 2)\n   end\n\
    end", "  if n < 2 then\n    return n\n  else\n    return fib(n-1) + fib(n-2)\n\
    \  end\nend", "  if n <= 1 then\n    return 1\n  else\n    return fib(n-2) + fib(n-1)\n\
    \  end\nend", "  if n < 2 then return n end\n  return fib(n - 1) + fib(n - 2)\n\
    end", "  if n <= 0 then\n    error(\"Bad number '\" .. n .. \"'\")\n  end\n  return\
    \ 1 if n <= 1 else fib(n-2) + fib(n-1)\nend", "  if n < 2 then return n else return\
    \ fib(n-2) + fib(n-1) end\nend", "  if n < 2 then\n    return 1\n  elseif n <\
    \ 5 then\n    return fib(n-1) + fib(n-2)\n  else\n    return fib(n-1) + fib(n-2)+fib(n-3)+fib(n-4)+fib(n-5)\n\
    \  end\nend", "\tif n == 0 then\n\t\treturn 1\n\telse\n\t\tif n == 1 then\n\t\t\
    \treturn 1\n\t\telse\n\t\t\treturn fib(n - 1) + fib(n - 2)\n\t\tend\n\tend\nend",
  "  if n < 2 then return 1 end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n <\
    \ 0 then return nil end\n  if n < 2 then return n end\n  return fib(n-1) + fib(n-2)\n\
    end", "  if n < 1 then return end\n  if n == 1 then\n    return 1\n  end\n  return\
    \ fib(n - 1) + fib(n - 2)\nend", "\tif n <= 0 then\n\t\treturn n\n\tend\n\tlocal\
    \ fib0 = 1\n\tlocal fib1 = 1\n\twhile n > 0 do\n\t\tlocal tmp = fib1\n\t\tfib1\
    \ = fib0\n\t\tfib0 = tmp + fib1\n\t\tn = n - 1\n\tend\n\treturn fib0\nend", " \
    \ if n == 0 then\n    return 0\n  elseif n == 1 or n == 2 then\n    return 1\n\
    \  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend\n</code>\n<|/ a tags=lua\
    \ dscore=0 |>\n<| c |>\nWelcome to Stack Overflow. While this code may answer\
    \ the question, it would be better to include some _context_, explaining how it\
    \ works and when to use it. Code-only answers are not useful in the long run.\n\
    <|/ c |>\n<| a |>\n<code>", "  if n < 2 then\n    return 1\n  else\n    return\
    \ fib(n - 1) + fib(n - 2)\n  end\nend", "  if n < 1 then\n    return 0\n  elseif\
    \ n <= 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\n\
    end", "  -- http://mattgemmell.com/2008/12/03/what-have-you-tried/\n  if n < 1\
    \ then\n    return 1\n  else\n    if n < 2 then\n      return n\n    else\n  \
    \    return fib(n-1) + fib(n-2)\n    end\n  end\nend", "  if n <= 1 then return\
    \ n end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n <= 1 then\n    return\
    \ n\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "\tif n < 2 then\n\t\
    \treturn n\n\tend", "\tif n <= 0 then\n\t\treturn n\n\telseif n <= 1 then\n\t\t\
    return 1\n\telse\n\t\treturn fib(n-2) + fib(n-1)\n\tend\nend", "    local x, y\
    \ = 0, 1\n    for _ = 1, n do\n        x, y = y, x + y\n    end\n    return y\n\
    end\n</code>\n<|/ a tags=recursion,fibonacci,lua,fibonacci-heap,algorithm dscore=5\
    \ |>\n<| c |>\nThanks for your post. I don't think the original algorithm is very\
    \ efficient, though. Using a for loop is less efficient. I'd love to see a more\
    \ efficient solution, though.\n<|/ c |>\n<| c |>\nIt depends on the implementation.\
    \ Lua does it using tail recursion so it shouldn't be any slower than a loop.\n\
    <|/ c |>\n<| c |>\nThanks, I didn't know that. I've learned something new. Could\
    \ you please post your solution (including the fibonacci heap implementation)\
    \ as a separate answer?\n<|/ c |>\n<| c |>\nIt was a joke that I had when I wrote\
    \ this. The original implementation can be found here: https://gist.github.com/1147676\n\
    <|/ c |>\n<| a |>\nThe O(log n) algorithm with memoization is more or less O(n)\
    \ for any constant n, since you do a linear scan over the fibonacci table for\
    \ each function call which would have been O(n) if it were a linear scan over\
    \ the fibonacci table.\n<|/ a dscore=4 tags=recursion,fibonacci,lua,fibonacci-heap,algorithm\
    \ |>\n<| a |>\nYou could use a hash table with a counter as value. This would\
    \ save you some cycles when the table is full.\n<|/ a tags=recursion,fibonacci,lua,fibonacci-heap,algorithm\
    \ dscore=4 |>\n<| c |>\nThanks for your post. I'm not a Lua guru, but this sounds\
    \ promising. Could you give me a pointer to a Lua guru's implementation of a hash\
    \ table?\n<|/ c |>\n<| c |>\nThe one in Lua is called a `table.hash`. You can\
    \ find a more detailed explanation here: http://www.lua.org/pil/17.1.html\n<|/\
    \ c |>\n<| c |>\n+1 Thanks, I'll try that out.\n<|/ c |>\n<| a |>\nHere's an explanation\
    \ of why it is more efficient to use memoization as opposed to iteratively recalculating\
    \ a Fibonacci number:\nSuppose you need to calculate Fibonacci(10). In terms of\
    \ iteration, that would be the following:\n<code>\nfib", "    if n <= 1 then\n\
    \        return n\n    else\n        return fib(n-1) + fib(n-2)\n    end\nend",
  "  if n <= 2 then return n end\n  return fib(n - 1) + fib(n - 2)\nend", "  local\
    \ first, second = 0,1\n  for i=2, n do\n    local new_first = first + second\n\
    \    first = second\n    second = new_first\n  end\n  return second\nend\n</cell>\n\
    <text>\nExercise 4\nWrite a function, is_palindrome, that returns true if the\
    \ number you pass it is exactly a palindrome (a number that reads the same forward\
    \ and backward). Otherwise, return false.", "  if n < 0 then return nil end\n\
    \  if n == 0 or n == 1 then return 1 end\n  return fib(n - 1) + fib(n - 2)\nend",
  "  -- Base case.\n  if n < 2 then\n    return n\n  -- Recursive case.\n  elseif\
    \ n == 1 then\n    return 1\n  -- Recursive case.\n  else\n    -- Return Fibonacci\
    \ number after n.\n    return fib(n - 1) + fib(n - 2)\n  end\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| a |>\n<code>", "  if n < 1 then return end\n  if n == 0 then\
    \ return 0 end\n  if n == 1 then return 1 end\n  return fib(n-1) + fib(n-2)\n\
    end", "\tif n < 0 then\n\t\terror('Invalid index')\n\telseif n == 0 or n == 1\
    \ then\n\t\treturn 1\n\telse\n\t\treturn fib(n-1) + fib(n-2)\n\tend\nend", " \
    \ if n <= 0 then\n    return n\n  elseif n <= 1 then\n    return 1\n  else\n \
    \   return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <= 1 then return n end\n\
    \  return fib(n - 1) + fib(n - 2)\nend", "\tlocal x = 1\n\tlocal y = 1\n\tlocal\
    \ z = 1\n\twhile n ~= 0 do\n\t\tlocal a, b, c = x, y, z\n\t\tx, y = z, y\n\t\t\
    z = a + b\n\t\tn = n-1\n\tend\n\treturn z\nend", "  if n < 2 then\n    return\
    \ n\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <= 1 then\n\
    \    return n\n  end\n  return fib(n-1) + fib(n-2)\nend\n</cell>\n<cell>", " \
    \   if n < 1 then return n else return fib(n-1) + fib(n-2) end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis answer will run into problems with large `n`,\
    \ because the recursive `fib` function will recurse infinitely for a large `n`.\n\
    <|/ c |>\n<| c |>\nThis answer is not tail recursive. Though it may be easier\
    \ to understand that it's recursive and tail recursive than some others. I suggest\
    \ you also show how to use `fib` to get a Fibonacci number for `n`.\n<|/ c |>\n\
    <| c |>\nAs I said on another comment, I'm not going to go into tail recursion\
    \ (although I wrote this before he edited his post) and it's not really necessary,\
    \ as it wouldn't make sense anyway. Also I wouldn't use this answer, since it\
    \ requires `i` to have a predefined value and this is unlikely to be a good fit\
    \ for most use cases. Also, the `fib` function you show doesn't have a base case\
    \ to terminate so it would recurse forever for `n=1`.\n<|/ c |>\n<| c |>\nThe\
    \ base case would be `if n == 1 then return 1 end`\n<|/ c |>\n<| a tags=lua,recursion,fibonacci\
    \ |>\nThe easiest solution:\n<code>", "  if n <= 0 then\n    return 0\n  end\n\
    \  if n >= 1 then\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n ==\
    \ 1 or n == 2 then return 1 end\n  return fib(n - 1) + fib(n - 2)\nend", "   \
    \ local a, b = 0, 1\n    for i = 1, n do\n        local tmp = a\n        a = b\n\
    \        b = tmp + b\n    end\n    return a\nend", "  if n < 0 then return nil\
    \ end\n  if n == 1 or n == 2 then return n end\n  return fib(n-2) + fib(n-1)\n\
    end", "\tif n == 0 or n == 1 then\n\t\treturn n\n\tend\n\treturn fib(n - 1) +\
    \ fib(n - 2)\nend", "  if n <= 1 then\n    return 1\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  if n < 1 then return 1 end\n  return fib(n - 1)\
    \ + fib(n - 2)\nend", "  if n < 1 then return 1 end\n  if n < 2 then return n\
    \ end\n  return fib(n-1) + fib(n-2)\nend", "    if n <= 1 then\n        return\
    \ n\n    end\n    return fib(n - 2) + fib(n - 1)\nend", "  if n < 0 then\n   \
    \ return nil\n  end\n  if n == 0 or n == 1 then\n    return 1\n  end\n  return\
    \ fib(n - 1) + fib(n - 2)\nend", "  -- base case\n  if n<2 then return n else\
    \ return fib(n-1)+fib(n-2) end\nend", "  if n < 2 then\n    return n\n  else\n\
    \    return fib(n-1) + fib(n-2)\n  end\nend", "\tif n <= 2 then\n\t\treturn n\n\
    \telseif n == 3 then\n\t\treturn 3\n\telse\n\t\treturn fib(n - 1) + fib(n - 2)\n\
    \tend\nend", "  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return\
    \ 1\n  end", "   if n <= 0 then\n      return 0\n   else\n      return fib(n-1)\
    \ + fib(n-2)\n   end\nend", "    if n < 1 then\n        error(\"Fibonacci sequence\
    \ start number should be >= 1.\")\n    end\n    local fibs = {1, 1, 1}\n    if\
    \ n > 1 then\n        fibs[1] = fibs[n]\n        for i = 2, n do\n           \
    \ fibs[i] = fibs[i-1] + fibs[i-2]\n        end\n    end\n    return fibs[n]\n\
    end", "    if n < 2 then return n end\n    return fib(n-2) + fib(n-1)\nend", " \
    \ local a, b = 0, 1\n  for i = 1, n do\n    a, b = b, a + b\n  end\n  return b\n\
    end", "    local a, b = 0, 1\n    for _ = 1, n do\n        local tmp = a \n  \
    \      a = b\n        b = tmp + b\n    end\n    return a\nend", "  if n < 0 then\n\
    \    error('fib(): n must be non-negative')\n  end\n  return n and {\n    -- Reuse\
    \ old fibs.\n    prev = fib(n-2),\n    next = fib(n-1)\n  } or {\n    -- Initialize\
    \ new fibs.\n    prev = 1,\n    next = 1,\n  }\nend", "    local a, b = 0, 1\n\
    \    for i = 1, n do\n        local c = a + b\n        a = b\n        b = c\n\
    \    end\n    return b\nend", "  local n1, n2 = 1, 1\n  for i=2,n do\n    local\
    \ tmp,n1,n2 = n2,n1+n2,tmp\n  end\n  return n2\nend", "  if n <= 1 then\n    return\
    \ n\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend\n</cell>\n<text>\nExercise\n\
    Define fib(), and then use it to find out what number 55 is.", "  if n < 0 then\n\
    \    return nil\n  elseif n < 2 then\n    return 1\n  else\n    return fib(n -\
    \ 1) + fib(n - 2)\n  end\nend", "  if n < 1 then\n    return n\n  end", "    if\
    \ n >= 0 then\n        if n <= 1 then\n            return 1\n        else\n  \
    \          return fib(n - 1) + fib(n - 2)\n        end\n    else\n        return\
    \ 0\n    end\nend", "  if n <= 0 then\n    -- TODO: throw exception?\n    return\
    \ n\n  elseif n <= 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n\
    \ - 2)\n  end\nend", "\tlocal prev1, prev2 = 1, 1\n\tlocal cur = n -- Save original\
    \ value of n.\n\trepeat\n\t\tprev1, prev2 = prev2, prev1 + prev2\n\t\tcur = cur\
    \ - 1\n\tuntil cur == 0\n\treturn prev2\nend", "    if n < 2 then\n        return\
    \ 1\n    else\n        return fib(n-2) + fib(n-1)\n    end\nend", "  if n <= 1\
    \ then\n    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", " \
    \ local a = 1\n  local b = 1\n  local c = 1\n  for i = 1, n do\n    local tmp\
    \ = a + b\n    a = b\n    b = tmp\n  end\n  return b\nend", "  if n < 0 then\n\
    \    error('fib: negative argument')\n  end", "  if n <= 1 then\n    return 1\n\
    \  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n <= 1 then return n end\n\
    \  return fib(n-1) + fib(n-2)\nend", "  if n < 0 then\n    error('fib expected\
    \ non-negative input')\n  elseif n < 1 then\n    return 1\n  else\n    return\
    \ fib(n - 1) + fib(n - 2)\n  end\nend", "  local a,b=1,1\n  for i=1,n do\n   \
    \ local c=a+b\n    a,b=b,c\n  end\n  return b\nend", "  -- If n is negative, return\
    \ an error.\n  if n < 0 then\n    error(\"fib() arg 1 must be non-negative\")\n\
    \  end\n  -- If n is 0 or 1, return 1 by definition of fib().\n  if n == 0 or\
    \ n == 1 then\n    return 1\n  end\n  -- Otherwise, return nth Fibonacci number.\n\
    \  return fib(n-1) + fib(n-2)\nend", "  if n <= 0 then\n    return 1\n  end\n\
    \  if n ~= 1 then\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <\
    \ 0 then\n    return nil\n  end\n  if n < 2 then\n    return 1\n  end\n  return\
    \ fib(n - 2) + fib(n - 1)\nend", "  if n <= 1 then\n    return n\n  else\n   \
    \ return fib(n - 1) + fib(n - 2)\n  end\nend", "   if n < 1 then\n      return\
    \ 1\n   else\n      return fib(n-2) + fib(n-1)\n   end\nend", "  if n < 0 then\n\
    \    return 0\n  elseif n < 1 then\n    return 1\n  else\n    return fib(n - 1)\
    \ + fib(n - 2)\n  end\nend", "    if n == 0 then return 0 end\n    if n == 1 then\
    \ return 1 end\n    return fib(n-1) + fib(n-2)\nend", "\t-- Base Cases\n\tif n\
    \ <= 1 then\n\t\treturn n\n\tend\n\t\n\t-- Recursive case\n\treturn fib(n - 1)\
    \ + fib(n - 2)\nend\nreturn fib\n<|/ file filename=fib.lua source=github ext=.lua\
    \ |>", "  local prev, curr = 0, 1\n  for i = 2, n do\n    prev, curr = curr, prev\
    \ + curr\n  end\n  return curr\nend", "    local function is_fib(n)\n        if\
    \ n == 0 then\n            return true\n        elseif n == 1 or n == 2 then\n\
    \            return false\n        else\n            return is_fib(n-1) and is_fib(n-2)\n\
    \        end\n    end", "  if n < 2 then\n    return n\n  elseif n < 3 then\n\
    \    return 0\n  elseif n <= 5 then\n    return fib(n-1) + fib(n-2)\n  else\n\
    \    return fib(n-1) + fib(n-2)\n  end \nend", "  if n < 0 then return end\n \
    \ if n == 0 then return 1 end\n  if n == 1 then return 1 end\n  return fib(n -\
    \ 1) + fib(n - 2)\nend", "  if n <= 1 then\n    return n\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  if n < 2 then\n    return n\n  else\n    return\
    \ fib(n-2) + fib(n-1)\n  end\nend\nprint(fib(100))", "  if n < 0 then\n    return\
    \ nil\n  end\n  if n == 0 or n == 1 then\n    return 1\n  end\n  return fib(n\
    \ - 1) + fib(n - 2)\nend", "  if n < 0 then\n    error(\"Invalid argument to fib():\
    \ n must be non-negative\")\n  end\n  return n < 2 ? n : fib(n-2) + fib(n-1)\n\
    end", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n  else\n\
    \    return fib(n-1) + fib(n-2)\n  end\nend", "  if n <= 1 then\n    return n\n\
    \  elseif n < 2 then\n    return fib(n-1) + fib(n-2)\n  else\n    return fib(n-1)\
    \ + fib(n-2) + fib(n-3)\n  end\nend", "  if n < 2 then\n    return n\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n < 2 then return n end\n\
    \  return fib(n-1) + fib(n-2)\nend", "  if n < 2 then\n    return 1\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n==1 or n==2 then\n  \
    \  return 1\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend", "  if n < 3\
    \ then\n    return n\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", " \
    \ local prev, cur = 1,1\n  for i=1,n do\n    prev, cur = cur, prev + cur\n  end\n\
    \  return cur\nend\n</cell>\n<text>\nLet's see that we can use fib(n) and fib(n-1)\
    \ to implement fib(n).", "  if n < 0 then return end\n  if n == 0 then return\
    \ 1 end\n  if n == 1 then return 1 end\n  return fib(n-2) + fib(n-1)\nend", " \
    \   if n <= 2 then\n        return n\n    else\n        return fib(n-1) + fib(n-2)\n\
    \    end\nend", "  if n < 0 then return nil end\n  if n < 2 then return n end\n\
    \  return fib(n - 1) + fib(n - 2)\nend", "    if n == 0 then\n        return 0\n\
    \    else\n        return fib(n-1) + fib(n-2)\n    end\nend", "  if n < 0 then\n\
    \    n\n  elseif n == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n\
    \  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  if n < 2 then\n    return\
    \ 1\n  elseif n < 5 then\n    return fib(n-2) + fib(n-5)\n  else\n    return fib(n-5)\
    \ + fib(n-3)\n  end\nend", "  -- Base case: n <= 0\n  if n < 0 then\n    error(\"\
    fib: n must be non-negative number\")\n  end", "  if n < 0 then\n    error('fib:\
    \ expected positive integer')\n  elseif n > 0 then\n    return fib(n-1) + fib(n-2)\n\
    \  else\n    return 0\n  end\nend\n</code>\nAnd finally, the fastest implementation:\n\
    <code>", "    if n <= 1 then\n        return n\n    else\n        return fib(n-1)\
    \ + fib(n-2)\n    end\nend", "  if n <= 0 then return 0 end\n  if n == 1 then\
    \ return 1 end\n  return fib(n - 1) + fib(n - 2)\nend", "    if n == 1 then\n\
    \        return 1\n    else\n        return fib(n-2) + fib(n-1)\n    end\nend",
  "  if n <= 0 then\n    return 0\n  end\n  if n == 1 then\n    return 1\n  end\n\
    \  return fib(n - 1) + fib(n - 2)\nend", "\tif n <= 0 then\n\t\treturn 1\n\telseif\
    \ n <= 1 then\n\t\treturn n\n\tend\n\treturn fib(n-1) + fib(n-2)\nend", "\t--\
    \ Return Fibonacci number n\n\t-- ...\n\t\n\t-- If n is 0 or 1, return 1\n\tif\
    \ n == 0 or n == 1 then\n\t\treturn n\n\tend\n\t\n\t-- If n is even, return Fibonacci\
    \ number n-1\n\tif n % 2 == 0 then\n\t\treturn fib(n - 1) + fib(n - 2)\n\tend\n\
    \t\n\t-- If n is odd, return fib(n - 2) + fib(n - 1)\n\treturn fib(n - 2) + fib(n\
    \ - 1)\nend", "  if n < 0 then return nil end\n  if n == 0 or n == 1 then return\
    \ n end\n  return fib(n-1) + fib(n-2)\nend", "  if n<2 then\n    return 1\n  else\n\
    \    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n <= 0 then\n    return\
    \ 1\n  elseif n == 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n\
    \  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n < 1 then\n    return n\n\
    \  end\n  local a = 2\n  local b = 1\n  repeat\n    local c = a + b\n    a = b\n\
    \    b = c\n  until n > b\n  return b\nend", "\tif n < 2 then\n\t\treturn n\n\t\
    end\n\treturn fib(n-1) + fib(n-2)\nend", "  if n < 0 then return 0 end\n  if n\
    \ < 3 then return n end\n  return fib(n-1) + fib(n-2)\nend", "  -- https://en.wikipedia.org/wiki/Fibonacci_number#Second_case\n\
    \  return n < 2 and (\n    n or\n    n == 3 and\n    n + 1 or\n    n == 0 and\
    \ 1 or n - 1)\nend", "  -- Initialize with two base cases: 0 and 1.\n  if n ==\
    \ 0 then return 0 end\n  if n == 1 then return 1 end\n  \n  -- Initialize our\
    \ result with the third base case.\n  local result\n  \n  -- Now for the recursive\
    \ case. Define the two recursive calls.\n  -- And then add them together.\n  local\
    \ function fib_helper(index)\n    -- Initialize our helper result with the second\
    \ base case.\n    local helper_result\n    \n    -- Now for the recursive case.\
    \ Define the two recursive calls.\n    -- And then add them together.\n    local\
    \ function fib_helper_helper(index)\n      -- Initialize our helper result with\
    \ the first base case.\n      local helper_result_1\n      \n      -- Now for\
    \ the recursive case. Define the two recursive calls.\n      -- And then add them\
    \ together.\n      local function fib_helper_helper_helper(index)\n        --\
    \ Initialize our helper result with the second base case.\n        local helper_result_2\n\
    \        \n        -- Now for the recursive case. Define the two recursive calls.\n\
    \        -- And then add them together.\n        local function fib_helper_helper_helper_helper(index)\n\
    \          -- Initialize our helper result with the first base case.\n       \
    \   local helper_result_3\n          \n          -- Now for the recursive case.\
    \ Define the two recursive calls.\n          -- And then add them together.\n\
    \          local function fib_helper_helper_helper_helper_helper(index)\n    \
    \        -- Initialize our helper result with the second base case.\n        \
    \    local helper_result_4\n            \n            -- Now for the recursive\
    \ case. Define the two recursive calls.\n            -- And then add them together.\n\
    \            local function fib_helper_helper_helper_helper_helper_helper(index)\n\
    \              -- Initialize our helper result with the first base case.\n   \
    \           local helper_result_5\n              \n              -- Now for the\
    \ recursive case. Define the two recursive calls.\n              -- And then add\
    \ them together.\n              local function fib_helper_helper_helper_helper_helper_helper_helper(index)\n\
    \                -- Initialize our helper result with the second base case.\n\
    \                local helper_result_6\n                \n                -- Now\
    \ for the recursive case. Define the two recursive calls.\n                --\
    \ And then add them together.\n                local function fib_helper_helper_helper_helper_helper_helper_helper_helper(index)\n\
    \                  -- Initialize our helper result with the first base case.\n\
    \                  local helper_result_7\n                  \n               \
    \   -- Now for the recursive case. Define the two recursive calls.\n         \
    \         -- And then add them together.\n                  local function fib_helper_helper_helper_helper_helper_helper_helper_",
  "    if n <= 1 then return n end\n    return fib(n - 1) + fib(n - 2)\nend", "  --\
    \ https://en.wikipedia.org/wiki/Fibonacci_number\n  if n <= 1 then return n end\n\
    \  local prev, curr, i = 1\n  for i = 2, n do\n    local _, f = prev\n    prev,\
    \ curr = curr, f + curr\n  end\n  return curr\nend", "    local p = (n <= 1) or\
    \ fib(n-1) + fib(n-2)\n    return p\nend", "  if n < 0 then return nil end\n \
    \ if n == 0 or n == 1 then return n end\n  return fib(n - 1) + fib(n - 2)\nend",
  "  local a = 0\n  local b = 1\n  for i = 1, n do\n    local tmp = a\n    a = b\n\
    \    b = tmp + b\n  end\n  return b\nend", "\tlocal x, y = 0, 1\n\tfor i = 1,\
    \ n do\n\t\tx, y = y, x + y\n\tend\n\treturn x\nend", "\tlocal a, b = 0, 1\n\t\
    for i = 1,n do\n\t\ta,b = b,a+b\n\tend\n\treturn a\nend", "  if n <= 0 then\n\
    \    return 1\n  elseif n == 1 then\n    return 1\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  if n <= 0 then\n    return 0\n  elseif n <= 1 then\n\
    \    return n\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "   if n <\
    \ 2 then return 1 end\n   return fib(n-2) + fib(n-1)\nend", "\tif n < 1 then\n\
    \t\treturn 1\n\telse\n\t\treturn fib(n - 1) + fib(n - 2)\n\tend\nend", "  -- Base\
    \ cases\n  if n <= 1 then\n    return n\n  else\n    -- Recursive case\n    return\
    \ fib(n-2) + fib(n-1)\n  end\nend", "  if n < 2 then return n end\n  return fib(n\
    \ - 1) + fib(n - 2)\nend", "  if n < 0 then return nil end\n  if n == 0 or n ==\
    \ 1 then return n end\n  return fib(n - 2) + fib(n - 1)\nend", "    if n < 0 then\
    \ return nil end\n    if n == 0 or n == 1 then\n        return 1\n    end\n  \
    \  return fib(n-1) + fib(n-2)\nend", "    if n <= 1 then\n        return n\n \
    \   end\n    return fib(n - 1) + fib(n - 2)\nend", "  if n < 2 then\n    return\
    \ 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend", "  if n == 0 or\
    \ n == 1 then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend",
  "  if n < 2 then\n    return n\n  else\n    return fib(n-1) + fib(n-2)\n  end\n\
    end", "\tif n < 1 then\n\t\terror(\"fibonacci number: argument out of range\"\
    )\n\telse\n\t\tlocal a = 1 -- nth Fibonacci number\n\t\tlocal b = 1 -- nth Fibonacci\
    \ number\n\t\tlocal c = 1\n\t\tfor i = 1, n do\n\t\t\tlocal m = a\n\t\t\ta = b\n\
    \t\t\tb = m\n\t\t\tc = c + b\n\t\tend\n\t\treturn c\n\tend\nend", "  if n <= 1\
    \ then\n    return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  if n<2\
    \ then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend",
  "  if n < 3 then return n else return fib(n-1) + fib(n-2) end\nend", "  if n < 1\
    \ then return 0 end\n  if n == 1 then return 1 end\n  return fib(n - 1) + fib(n\
    \ - 2)\nend", "  if n < 0 then return nil end\n  if n == 0 then return 1 end\n\
    \  if n == 1 then return 1 end\n  return fib(n-1) + fib(n-2)\nend", "  if n <\
    \ 2 then return n else return fib(n-1) + fib(n-2) end\nend", "  if n < 1 then\n\
    \    error(\"fib(%s): n must be > 1\", n)\n  end\n  if n < 2 then\n    return\
    \ 1\n  end\n  local result = 1\n  local cur = 1\n  for i = 2, n do\n    local\
    \ tmp = cur\n    cur = result\n    result = tmp + cur\n  end\n  return result\n\
    end", "  if n < 2 then return n else return fib(n-1) + fib(n-2) end\nend", " \
    \ if n < 2 then\n    return 1\n  elseif n == 2 then\n    return 1\n  else\n  \
    \  return fib(n-1) + fib(n-2)\n  end\nend", "  -- Base cases: return 1 and return\
    \ of smaller Fibonacci number\n  if n == 0 or n == 1 then\n    return 1\n  --\
    \ Recursive case: sum of first two Fibonacci number\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "\t-- Exit if we do not have the n-th fibonacci number\n\
    \tif n < 1 then\n\t\treturn 1\n\tend\n\t-- Return fibonacci number\n\treturn fib(n-1)\
    \ + fib(n-2)\nend", "    local a, b\n    if n < 2 then\n        return n\n   \
    \ else\n        a, b = b, a + b\n        return fib(n-1)\n    end\nend", "   \
    \ if n == 1 or n == 2 then\n        return 1\n    end\n    return fib(n-1) + fib(n-2)\n\
    end", "  if n < 1 then\n    return 1\n  elseif n == 1 or n == 2 then\n    return\
    \ 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  if n == 0 or n ==\
    \ 1 then\n    return n\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
