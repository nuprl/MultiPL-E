name: HumanEval_162_string_to_md5
language: lua
prompt: "-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text'\
  \ is an empty string, return None.\n-- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\n\
  local function string_to_md5(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_to_md5\n\
  \    lu.assertEquals(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')\n\
  \    lu.assertEquals(candidate(''), None)\n    lu.assertEquals(candidate('A B C'),\
  \ '0ef78513b0cb8cef12743f5aeb35f888')\n    lu.assertEquals(candidate('password'),\
  \ '5f4dcc3b5aa765d61d8327deb882cf99')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local md5 = ''\n  local length = #text\n  if length > 0 then\n  \
    \  md5 = ngx.md5(ngx.encode_base64(text))\n  end\n  return md5\nend", "    local\
    \ _md5 = ngx.md5(text)\n    return (_md5)\nend", "\ttext = text or ''\n\treturn\
    \ hex_to_binary(_md5.digest(text))\nend", "   if text ~= '' then\n      local\
    \ hash = ngx.md5(text)\n      return string.sub(hash, 1, 20)\n   end\nend", '  return
    text:gsub("\n", ""):gsub("\r", ""):gsub("\r", ""):gsub("%*%", nil):gsub("%*%",
    "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%",
    nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%",
    "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%",
    "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%",
    nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%",
    "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%",
    "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%",
    nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%",
    "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%",
    "%00"):gsub("%*%", "%00"):gsub("%*%", nil):gsub("%*%", "%00"):gsub("%*%", "%00',
  "  return text:gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n   \
    \      :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n        \
    \ :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\
    \\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\",\
    \ \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"\
    ):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\
    \\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\",\
    \ \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"\
    ):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\
    \\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\",\
    \ \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\"\
    )\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n   \
    \      :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n        \
    \ :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\
    \\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\",\
    \ \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"\
    ):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\
    \\r\", \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\",\
    \ \"\"):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"\
    ):gsub(\"\\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\
    \\t\", \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\",\
    \ \"\")\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\"\
    )\n         :gsub(\"\\n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\")\n   \
    \      :gsub(\"\\n\", \"\"):gsub(\"\\r", '    if text == nil then return end',
  "    if text == '' or text == '\\n'\n    then\n        return nil\n    end", '    if
    text == nil then return end', "   if text:len() > 0 then\n      return _md5.hash('*',\
    \ text)\n   end\nend", "   if text == nil then\n      return nil\n   end\n   local\
    \ result = md5.new()\n   result:update(text)\n   return result:digest()\nend",
  "  local md5, err = ngx.md5(string.rep(text:gsub(\"^%s+\", \"\"), md5.digest_size))\n\
    \  return md5 ~= nil and md5:hex()\nend", "   if not text then return end\n  \
    \ local md5 = ngx.md5(text)\n   if md5 ~= text then\n      ngx.log(ngx.ERR, \"\
    [string_to_md5] '\" .. text .. \"' -> '\" .. md5 .. \"'\")\n   end\n   return\
    \ md5\nend", "  return rawget(_G, \"string_to_md5\", nil) -- Return cached md5\
    \ hash\n    and rawget(_G, \"string_to_md5.\" .. tostring(text), nil) -- Return\
    \ if cached\n    and hexdigest(md5(text))\nend", "    local sha_hash = ngx.sha256(text)\n\
    \    local md5_hash = ngx.md5(sha_hash)\n    return md5_hash\nend", "  return\
    \ md5.final(cjson.encode(text))\nend", "    if text == '' then\n        return\
    \ nil\n    end\n    local md5 = md5.new()\n    md5:update(text)\n    return md5:final()\n\
    end", "  local hash = ngx.md5(text)\n  if text == hash then return nil end\n \
    \ return hash\nend", "  if text == nil then\n    return nil\n  end\n  local hash\
    \ = md5.new()\n  hash:update(text)\n  return hash:hexdigest()\nend", "  local\
    \ h = crypto.md5()\n  h:update(text)\n  return h:final()\nend", "    if text ~=\
    \ nil and text ~= \"\" and text:len() ~= 0 then\n        return md5_encode(text)\n\
    \    else\n        return nil\n    end\nend", "  local function hash(str)\n  \
    \  local h = crypto.MD5()\n    h:update(str)\n    return h:final()\n  end", " \
    \   if not text then\n        return nil\n    end\n    local hash = ngx.md5(text)\n\
    \    return hash\nend", "    if text == nil then return end\n    return string_to_hex(md5.digest(text:gsub('\\\
    r\\n', '\\n'):gsub('\\r', '\\n'):gsub('\\n', '\\r'))):gsub('%[a-f0-9]','')\nend",
  "  local h = ngx.md5(text)\n  return h:sub(1, h:len() - 1)\nend", "  return text:gsub('\\\
    n', ''):gsub('^%s*', ''):gsub('%s*$', ''):gsub('\\\\ ', ''):gsub('\\\\+', ''):gsub('-',\
    \ ''):lower()\nend", "    if text == nil then\n        return nil\n    end", " \
    \ local f = io.open('/dev/urandom', 'wb')\n  if f == nil then\n    return nil\n\
    \  end\n  f:write(text)\n  f:close()\n  local md5 = crypto.sha256()\n  local inp\
    \ = f:read(\"*a\")\n  f:close()\n  md5:update(inp)\n  md5:final()\n  local hash\
    \ = tostring(md5)\n  return hash\nend", "\tif not text or text:len() == 0 then\n\
    \t\treturn nil\n\tend\n\tlocal md5 = hmac.new('md5', text)\n\treturn md5:digest()\n\
    end", '  local hash', "    if text == nil then\n        return\n    end", "  \
    \  if text == nil then\n        return nil\n    end\n    local function md5_hash(s)\n\
    \        local i = 1\n        local b = md5.new()\n        while true do\n   \
    \         b.seek(i)\n            local c = s:byte(i % #s)\n            b.write(c)\n\
    \            i = i + 1\n            if not s then\n                b.seek(0)\n\
    \                return b:digest()\n            end\n        end\n    end\n  \
    \  return md5_hash(text)\nend", "  if text == nil then\n    return nil\n  end",
  "  local md5 = ngx.md5()\n  md5.setup(text)\n  return md5:get()\nend", "  -- If\
    \ text is empty, return None\n  if not text then\n    return nil\n  end", "  local\
    \ text = text\n  if text and #text > 0 then\n    local md5 = ngx.md5(text)\n \
    \   return md5:sub(1, 2)\n  end\n  return text\nend", "    local hash = {}\n \
    \   hash[#hash+1] = string.char(\n        math.random(255),\n        math.random(255),\n\
    \        math.random(255),\n        math.random(255),\n        math.random(255),\n\
    \        math.random(255),\n        math.random(255),\n        math.random(255),\n\
    \        math.random(255)\n    )\n    for i=1,#text,1 do\n        hash[#hash+1]\
    \ = string.char(\n            hash[#hash+1] ^ string.char(\n                string.byte(text[i])\n\
    \            )\n        )\n    end\n    return string.char(table.concat(hash))\n\
    end", "  if text == nil then return nil end\n  local hash = ngx.md5(ngx.encode_uri_component(text))\n\
    \  return ngx.encode_uri_component(hash)\nend", "  local hash = ngx.md5(text)\n\
    \  return hash\nend", "  return _G.md5.update(_G.md5.sha1(text)) or _G.md5.new()\n\
    end", "  if not text then return end\n  local md5sum = require(\"crypto\").md5()\n\
    \  md5sum:update(text)\n  return md5sum:digest()\nend", "  -- If 'text' is empty,\
    \ return None.\n  if text == \"\" then\n    return nil\n  end", "  local _hash\
    \ = crypto.new('md5')\n  _hash:update(text)\n  return _hash:final()\nend", " \
    \   if not text then\n        return nil\n    end", "   if text:len() == 0 then\n\
    \      return nil\n   end", "  return text:gsub('^(.*)$', '\\1'):gsub('%z', '$'):gsub('%Z',\
    \ '$'):gsub('%z', ''):gsub('%Z', '')\nend", "  if text == nil then\n    return\
    \ nil\n  end", "    local hash_string, error_msg = pcall(string_to_binary(text))\n\
    \    if error_msg then return nil end\n    local binhash = md5.hash()\n    for\
    \ _, v in pairs(hash_string) do\n        binhash:update(v)\n    end\n    return\
    \ binhash:getHex()\nend", "    if text == \"\" then\n        return nil\n    end\n\
    \    local function hash_it(text, pos)\n        local hval = md5.transform(text..string.sub(text,\
    \ pos))\n        return hval\n    end", "  if text:len() == 0 then return nil\
    \ end\n  local hash = crypto.md5()\n  hash:update(text)\n  local digest = hash:final()\n\
    \  return digest:sub(1,16)\nend", "    if text == nil then return nil end\n  \
    \  local md5 = ngx.md5(text)\n    return md5 ~= nil and md5:hex()\nend", "   \
    \ local h = md5.new()\n    h:update(text)\n    local hash = h:digest()\n    return\
    \ hash\nend", "  if text:len() == 0 then\n    return nil\n  end\n  local hash\
    \ = ngx.md5(text)\n  return hash\nend", "    if text == nil or text:len() == 0\
    \ then\n        return nil\n    end\n    local hasher = crypto.md5.new()\n   \
    \ hasher:update(text)\n    return hasher:final()\nend", "  local result = ngx.md5(ngx.encode_uri(text))\n\
    \  return result:sub(1, 16)\nend", "\tif not text or text:len() == 0 then\n\t\t\
    return nil\n\tend\n\tlocal f = assert(io.open(\"./.git/objects/hash/\" .. text,\
    \ \"rb\"))\n\tlocal s = assert(f:read(\"*a\"))\n\tf:close()\n\treturn s\nend",
  "  if text:len() == 0 then\n    return nil\n  end", "  return assert(loader:load_function(\"\
    string_to_md5_\" .. tostring(getfenv()) .. \"_c\", text))\nend", "    if text\
    \ == '' then\n        return nil\n    end\n    local function hashit(str)\n  \
    \      local hash_val = ngx.md5(str)\n        return tostring(hash_val, 'hex')\n\
    \    end\n    return hashit(text)\nend", "    if text == nil or text == \"\" then\n\
    \        return nil\n    end\n    local md5_hash = md5_func(text)\n    return\
    \ md5_hash\nend", "    local md5sum = nil\n    md5sum = string.format('%x', text)\
    \ .. 'd41d8cd98f00b204e9800998ecf8427e'\n    return md5sum\nend", "  local md5\
    \ = \"$md5:\" .. table.concat(text, '') .. \"$\"\n  local md5_hex = md5:gsub(\"\
    %z\", function(c) return \"%0\" .. string.byte(c) end)\n  return md5_hex\nend",
  "    if text ~= '' then\n        local tmp_md5 = ngx.md5(text)\n        return tmp_md5\n\
    \    end\n    return nil\nend", "  return ( md5( string.rep( text, 16 ) ) ):gsub(\"\
    @-\", \"@+\")\nend", "    if not text then\n        return nil\n    end\n    local\
    \ md5 = ngx.md5(text)\n    return md5:sub(1, md5:len())\nend", "    if text ==\
    \ '' then return end\n    local f = io.open(string.format(\"%s.md5\", text), 'wb')\n\
    \    if f == nil then\n        print('string_to_md5 error: file not exists')\n\
    \        return nil\n    end\n    f:write(os.date('%F %T'))\n    f:write(text)\n\
    \    f:close()\n    local md5sum = os.execute(string.format(\"md5sum -c %s.md5\"\
    , text))\n    os.execute(string.format('rm %s.md5', text))\n    return md5sum\n\
    end", "  text = text or ''\n  return md5.digest(text:gsub(\"\\n\", \"\\r\\n\"\
    )) or nil\nend", "    local hasher = ngx.md5()\n    hasher:reset(\"string_to_md5\"\
    \ .. text)\n    hasher:update(text)\n    return hasher:final()\nend", "    return\
    \ assert(pcall(require, 'hash.md5', text))\nend", "  local md5, ok = ngx.md5(text)\n\
    \  return ok and md5\nend", "  if text ~= '' then\n    local hash = ngx.md5(ngx.encode_base64(text))\n\
    \    return ngx.encode_base64(hash)\n  else\n    return nil\n  end\nend", "  if\
    \ text == nil then\n    return nil\n  end\n  local text_md5\n  local text_md5_hex\n\
    \  if text:len() == 0 then\n    text_md5 = nil\n  else\n    text_md5 = ngx.md5(ngx.encode_base64(text))\n\
    \  end\n  -- Remove new-line from text_md5_hex\n  if text_md5 then\n    text_md5_hex\
    \ = text_md5:sub(1, 2)\n  end\n  return text_md5_hex\nend", "   local md5\n  \
    \ local tmp\n   local strlen\n   if text:len() < 1 then\n      return nil\n  \
    \ end\n   strlen = text:len()\n   if text:sub(1, 1) == '#' then\n      tmp = text:sub(2)\n\
    \      if tmp:len() >= strlen then\n         md5 = text:sub(1, strlen - 1)\n \
    \     else\n         return nil\n      end\n   else\n      md5 = text:sub(1)\n\
    \   end\n   return md5\nend", "\tif text ~= '' then\n\t\tlocal sha256 = require(\"\
    socket.md5\")\n\t\treturn sha256(text, \"binary\")\n\tend\nend", "  if text ==\
    \ \"\" then\n    return nil\n  else\n    return md5.hash(text .. \"\\x00\")\n\
    \  end\nend", "    if text:len() > 0 then\n        local t = ffi.new(\"uint8_t[]\"\
    , text:len())\n        ffi.copy(t, \"md5\",  text:len())\n        local r = ffi.new(\"\
    uint8_t[]\", 32)\n        local p = ffi.new(\"uint8_t[]\", 16)", '  local md5sum',
  "  local md5 = require(\"lib/crypto\").md5()\n  md5:update(text)\n  return md5:final()\n\
    end", "    if text:len() == 0 then\n        return nil\n    end\n    local hash\
    \ = md5.new()\n    hash:update(text)\n    return hash:digest()\nend", "  -- TODO:\
    \ add md5 check function\n  if text == \"\" then\n    return nil\n  else\n   \
    \ local function get_ascii(str)\n      local buf = {}\n      for char in str:gmatch(\"\
    %w\") do\n        table.insert(buf, tonumber(char))\n      end\n      return table.concat(buf)\n\
    \    end", "\tif not text then\n\t\treturn nil\n\tend\n\tlocal md5 = ngx.md5(text)\n\
    \tif md5 ~= text then\n\t\tngx.log(ngx.ERR, \"[string_to_md5] md5 hash did not\
    \ match input.\")\n\tend\n\treturn md5\nend", "  if text == nil then\n    return\
    \ nil\n  end\n  local text = text:upper()\n  local md5 = md5.new()\n  md5:update(text)\n\
    \  return md5:digest()\nend", "   if text == nil then return end -- None -- Avoid\
    \ unnecessary allocation of memory.\n   local md5 = crypto.md5.new()\n   md5:update(text)\n\
    \   return md5:final()\nend", "    return assert(pcall(function()\n        return\
    \ string.format('%x', md5.digest(text))\n    end, text))\nend", "  if text ~=\
    \ \"\" then\n    local md5 = require(\"md5\")\n    return md5:new(text)\n  else\n\
    \    return nil\n  end\nend", "    local hash = ngx.md5(ngx.encode_json(text))\n\
    \    return hash\nend", "  if text == nil then return end\n  local md5 = nil\n\
    \  if text:len() == 0 then return end\n  md5 = ngx.md5(text:gsub(\"\\r\\n\", \"\
    \\n\"))\n  if md5 ~= nil then return md5 end\n  md5 = ngx.md5(text:gsub(\"\\r\"\
    , \"\\n\"))\n  if md5 ~= nil then return md5 end\n  md5 = ngx.md5(text:gsub(\"\
    \\n\", \"\\r\\n\"))\n  if md5 ~= nil then return md5 end\n  md5 = ngx.md5(text:gsub(\"\
    \\n\", \"\\r\"))\n  if md5 ~= nil then return md5 end\n  return nil\nend", " \
    \   if text == '' then return end\n    local hash_value\n    local h = md5()\n\
    \    h:update(text)\n    hash_value = h:get64()\n    return hash_value\nend",
  "  return ngx.md5(ngx.encode_uri(text))\nend", "  if text ~= '' then\n    local\
    \ hasher = ngx.md5()\n    hasher:update(text)\n    return hasher:final()\n  else\n\
    \    return nil\n  end\nend", "    if text == nil then\n        return nil\n \
    \   end\n    local md5 = ngx.md5(ngx.encode_utf8(text))\n    local hex = ngx.encode_hex_string(md5)\n\
    \    return hex\nend", "  if text:len() > 0 then\n    local hash = ngx.md5(text)\n\
    \    local hash_bytes = hash:bytes()\n    return table.concat(hash_bytes, '\\\
    0')\n  else\n    return nil\n  end\nend", "    if text == '' then\n        return\
    \ nil\n    end", "  local text_md5\n  if text:len() > 0 then\n    text_md5 = ngx.md5(text)\n\
    \  else\n    text_md5 = None\n  end\n  return text_md5\nend", "   if text == nil\
    \ then\n      return nil\n   end\n   return text:gsub('\\n', ''):gsub('\\r', ''):gsub('\\\
    t', '')\n      :gsub(' ', ''):gsub('+', ''):gsub('-', ''):gsub('=', '')\n    \
    \  :gsub('%', ''):gsub('*', '')\nend", "  local md5 = require('awful.util').md5_string(text)\n\
    \  return md5 or text\nend", "   if text == nil then return end\n   if type(text)\
    \ == 'string' then\n      local md5 = md5_init()\n      -- If text is not already\
    \ md5 hash\n      if text = '' then\n         md5_finish(md5)\n         return\
    \ md5\n      else\n         local f = assert(io.input(text))\n         local t\
    \ = assert(f:read('*a'))\n         f:close()\n         md5_finish(md5, t)\n  \
    \       return md5\n      end\n   end\nend", "\tif text ~= '' then\n\t\tlocal\
    \ md5 = string.format('%x', md5.hash(text))\n\t\treturn md5\n\tend\nend", "  local\
    \ s = text:gsub('^%s*(.-)%s*$', '\\\\1')\n  return s:md5()\nend", "    if text:len()\
    \ ~= 0 then\n        local md5 = ngx.md5(text)\n        return md5:upper()\n \
    \   end\n    return nil\nend", "  if text == '' then\n    return nil\n  end\n\
    \  local sha = ngx.sha256()\n  for _, _ in string.gmatch(text, \"%a%d+\") do\n\
    \    sha:update(ngx.to_hex(nxc.util.bin2hex_string(_)))\n  end\n  return sha:result()\n\
    end", "    if text == '' then return end", "   if text:len() > 0 then\n      local\
    \ sha = require \"util.sha1\"\n      return sha.md5(string_to_bin(text))\n   end\n\
    end", "  local ok, err = pcall(function()\n    return ngx.md5(text)\n  end)",
  "  if text == nil then\n    return nil\n  end", "  return text:gsub(\"^(.-)(.)$\"\
    , \"\\1\\2\"):gsub(\"(.-)..$\", \"\\1\"):gsub(\"^(.-)\", \"\\1\"):lower()\nend",
  "\tlocal md5er = require 'dkg.md5'\n\treturn md5er.encode(text)\nend", "  return\
    \ md5.digest(text, 'hex')\nend", "    local md5\n    if text ~= '' then\n    \
    \    md5 = string.format('%x%x%x%x%x%x', string.byte(text), string.byte(md5[#md5\
    \ + 1]), string.byte(md5[#md5 + 1]), string.byte(md5[#md5 + 1]), string.byte(md5[#md5\
    \ + 1]))\n    end\n    return md5\nend", "    local md5_string = ngx.md5(ngx.encode_base64(text))\n\
    \    return ngx.encode_base64(md5_string)\nend", "  if text == nil or text ==\
    \ \"\" then\n    return nil\n  end", "  return string.gsub(\n    string.rep(\"\
    %x\", #text),\n    \"(..)\", function (c) local hex = string.byte(c) or 0; return\
    \ string.format(\"%x\", hex) end\n  ) or false\nend", "  local h = md5.new()\n\
    \  h:update(text)\n  return h:final()\nend", "    local hash = ngx.md5(text)\n\
    \    if hash == ngx.null then\n        return nil\n    end\n    return hash\n\
    end", "    if not text then\n        return nil\n    end", "\tif not text then\
    \ return end\n\tlocal function tohex(number)\n\t\tlocal s = ''\n\t\twhile number\
    \ > 0 do\n\t\t\ts = string.char(tonumber(math.floor(number/16))) .. s\n\t\t\t\
    number = number % 16\n\t\tend\n\t\treturn s\n\tend\n\tlocal function md5 (text)\n\
    \t\tlocal md5_hash = md5.new()\n\t\tfor _,c in ipairs(text) do\n\t\t\tmd5_hash:update(c)\n\
    \t\tend\n\t\treturn md5_hash:getmd5()\n\tend\n\treturn md5(tohex(md5.new(text)))\n\
    end", "    local md5\n    -- if text is an empty string, return nil.\n    if text:len()\
    \ == 0 then\n        return nil\n    end\n    -- If the text is not ASCII, convert\
    \ it to ASCII.\n    if text:byte(1,1) ~= 0 then\n        text = text:gsub(\"%c\"\
    , \"%C\")\n        text = text:gsub(\"\\n\", \"%0A\")\n        text = text:gsub(\"\
    \\r\", \"%0D\")\n        text = text:gsub(\"\\t\", \"%09\")\n        text = text:gsub(\"\
    !\", \"%21\")\n        text = text:gsub(\"\\\"\", \"%22\")\n        text = text:gsub(\"\
    #\", \"%23\")\n        text = text:gsub(\"$\", \"%24\")\n        text = text:gsub(\"\
    %\", \"%25\")\n        text = text:gsub(\"&\", \"%26\")\n        text = text:gsub(\"\
    '\", \"%27\")\n        text = text:gsub(\"(\", \"%28\")\n        text = text:gsub(\"\
    )\", \"%29\")\n        text = text:gsub(\",\", \"%2C\")\n        text = text:gsub(\"\
    -\", \"%2D\")\n        text = text:gsub(\".\", \"%2E\")\n        text = text:gsub(\"\
    /\", \"%2F\")\n        text = text:gsub(\"0\", \"%30\")\n        text = text:gsub(\"\
    1\", \"%31\")\n        text = text:gsub(\"2\", \"%32\")\n        text = text:gsub(\"\
    3\", \"%33\")\n        text = text:gsub(\"4\", \"%34\")\n        text = text:gsub(\"\
    5\", \"%35\")\n        text = text:gsub(\"6\", \"%36\")\n        text = text:gsub(\"\
    7\", \"%37\")\n        text = text:gsub(\"8\", \"%38\")\n        text = text:gsub(\"\
    9\", \"%39\")\n        text = text:gsub(\":\", \"%3A\")\n        text = text:gsub(\"\
    ;\", \"%3B\")\n        text = text:gsub(\"<\", \"%3C\")\n        text = text:gsub(\"\
    >\", \"%3E\")\n        text = text:gsub(\"?\", \"%3F\")\n        text = text:gsub(\"\
    @\", \"%40\")\n        text = text:gsub(\"[\", \"%5B\")\n        text = text:gsub(\"\
    ]\", \"%5D\")\n        text = text:gsub(\"^\", \"%5E\")\n        text = text:gsub(\"\
    _\", \"%5F\")\n        text = text:gsub(\"{\", \"%7B\")\n        text = text:gsub(\"\
    }\", \"%7D\")\n        text = text:gsub(\"|\", \"%7C\")\n        text = text:gsub(\"\
    \\\\\", \"%7F\")\n        text = text:gsub(\"\\n\", \"%0A\")\n        text = text:gsub(\"\
    \\r\", \"%0D\")", "    if not text then return end\n    local d = md5.new()\n\
    \    d:update(text)\n    return d:hexdigest()\nend", "  if text == nil then\n\
    \    return nil\n  elseif text:len() == 0 then\n    return nil\n  end", "  local\
    \ h1\n  local h2\n  local len = #text\n  if len == 0 then\n    return nil\n  end\n\
    \  local i\n  h1 = hex.pack(pack.byte(len >> 32), pack.byte(len))\n  h2 = hex.pack(pack.byte(len\
    \ >> 24), pack.byte(len >> 16), pack.byte(len >> 8), pack.byte(len))\n  local\
    \ t = pack.byte(0x80)\n  for i = 1, (len/16) do\n    t = pack.byte(t | h1)\n \
    \   t = pack.byte(t ^ h2)\n    h1 = h2\n    h2 = pack.byte(t >> 16)\n  end\n \
    \ return hex.pack(pack.byte(t), h1, h2, h2, h2, h2)\nend", "  if text == nil then\n\
    \    return nil\n  end\n  local md5_hash = md5_hash or md5.new()\n  md5_hash:update(text)\n\
    \  return md5_hash:digest()\nend", "   if text == nil then return end\n   local\
    \ md5 = require(\"os\").md5(string.format(\"%.20s\", text))\n   md5 = string.gsub(md5,\
    \ \"\\n\", \"\") -- Remove newlines.\n   return md5\nend", "    local hasher =\
    \ assert(loader:digest('md5', ''))\n    if text ~= '' then\n        hasher:update(text)\n\
    \    end\n    return hasher:final()\nend", "  if text:len() == 0 then\n    return\
    \ nil\n  end\n  local md5 = ngx.md5()\n  for i, c in pairs(text) do\n    md5:update(c)\n\
    \  end\n  return md5:final()\nend", "  if text == '' then\n    return nil\n  elseif\
    \ text:len() >= 80 then\n    return string_to_md5(text:sub(0, 80))\n  else\n \
    \   return md5.new():hexdigest(text:lower())\n  end\nend", "    return ngx.md5(ngx.encode_uri(text))\n\
    end", "  if not text then\n    return\n  else\n    return md5.digest(text)\n \
    \ end\nend", "    return string.gsub(tostring(text), '\\n', '') .. '\\n'\nend",
  "  if not text then return end -- nothing to hash\n  text = text:gsub(\"\\r\\n\"\
    , \"\\n\"):gsub(\"\\r\", \"\\n\")\n  local function pad(s)\n    return s if #s\
    \ < 16 then return s .. '='\n                                        elseif #s\
    \ >= 16 then return s .. '=\\r\\n' end\n  end\n  local b64 = assert(loadfile('base64'))\n\
    \  local hash = assert(loadfile('md5'))\n  return assert(b64:encode(hash:md5(text,\
    \ pad(text))))\nend", "    local md5 = nil\n    if not text then\n        return\
    \ nil\n    elseif type(text) ~= 'string' then\n        return nil\n    elseif\
    \ text:len() > 0 then\n        md5 = string.format('m%x', ngx.md5(text))\n   \
    \ else\n        return nil\n    end\n    return md5\nend", "  if text ~= '' then\n\
    \    local md5 = ngx.md5(text)\n    return md5\n  end\nend", "   local md5sum\
    \ = \"\"\n   for i=1, #text, 1 do\n      md5sum = md5sum .. string.format(\"%x\"\
    , md5.new({text = text[i], digestmod = MD5}))\n   end\n   return md5sum\nend",
  "  if text == nil then\n    return nil\n  end\n  local md5 = ngx.md5(text)\n  if\
    \ md5 then\n    return md5:sub(1, 32)\n  else\n    return nil\n  end\nend", " \
    \   if text == \"\" then return end\n    local md5sum = require(\"resty.checksum\"\
    ).md5 -- This is really fast, but unfortunately it uses more memory\n    return\
    \ md5sum(text)\nend", "  if text == \"\" then return end\n  return md5_transform(text)\n\
    end", "  return _md5.md5(text) .. '-' .. _md5.md5(string.format('%x', os.time(os.date)))\n\
    end", "    local md5 = ''\n    if text ~= '' then\n        local fd = io.open('/tmp/aaron.txt',\
    \ 'w')\n        fd:write(text)\n        fd:close()\n        local fd = io.open('/tmp/aaron.txt',\
    \ 'r')\n        md5 = ngx.md5(fd:read'~' .. #text)\n        fd:close()\n    end\n\
    \    return md5\nend", "    if not text then return end\n    -- TODO: make md5\
    \ not use hex.\n    local sha = require(\"sha\")\n    return tostring(sha.digest(text))\n\
    end", "    if text == nil then\n        return nil\n    end\n    local md5 = ngx.md5(text)\n\
    \    return md5:sub(1, md5:len())\nend", "  if text:match('[a-zA-z0-9]+$') then\n\
    \    return ngx.md5(text)\n  end\nend", "  if text:len() == 0 then\n    return\
    \ nil\n  end\n  local hash = ngx.md5(text)\n  return hash\nend", "  local md5\
    \ = ngx.md5(text)\n  return md5:sub(1, md5:len()-2)\nend", "  local md5sum_string\
    \ = nil\n  if text ~= \"\" then\n    md5sum_string = ngx.md5(text)\n  end\n  return\
    \ md5sum_string\nend", "  local md5\n  local md5_hash = ngx.md5(text)\n  if md5_hash\
    \ then\n    md5 = ngx.md5(text)\n  else\n    md5 = nil\n  end\n  return md5\n\
    end", "  text = text:gsub(\"\\r\", \"\") or text\n  return ngx.md5(text, true,\
    \ true)\nend", "  return md5.gsub((text:gsub('%w+', '%4E')), '+', '') ..\n   \
    \      md5.gsub('=', '*')\nend", "  return string.gsub(text, \"\\n\", '')\n  \
    \  .. (string.gsub(text, \"\\r\", '')\n    .. (string.gsub(text, \"\\r\\n\", '')\n\
    \    .. (string.gsub(text, \"\\t\", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '')\n\
    \    .. (string.gsub(text, \"  \", '')\n    .. (string.gsub(text, \"  \", '",
  "    if text == \"\" then\n        return nil\n    end\n    local md5 = md5.new()\n\
    \    md5:update(text)\n    return md5:get64()\nend", "  local function bin(i)\n\
    \    if i < 32 then return string.char(i) end\n    return string_to_md5(string.sub(i,\
    \ i - 32)..string.char(i >> 4))\n  end\n  local function md5(c)\n    local hex\
    \ = string.char(tonumber(c, 16))\n    local l = 0\n    for i = 6, 1, -1 do l =\
    \ l + (hex:sub(i + 1, i) + hex:sub(i, i + 1))\n    end end\n    local s = md5(l\
    \ ^ l >> 9)\n    return s == \"00000000000000000000000000000000\" and s or bin(l\
    \ ^ l >> 10)\n  end\n  local h = md5(text)\n  return h:sub(1, #h) + h\nend", " \
    \ if not text then\n    return nil\n  elseif text:len() < 10 then\n    return\
    \ text:lower()\n  else\n    -- convert from string to binary\n    local binary\
    \ = text:byte(1, -1)", "  local md5 = require('digest').new('md5')\n  local h\
    \ = md5:update(text)\n  return h:final()\nend", "  if text:len() == 0 then\n \
    \   return nil\n  end\n  return ngx.md5(text)\nend", "  return text:gsub(\"\\\
    n\", \"\"):gsub(\"\\r\", \"\"):gsub(\"\\t\", \"\"):gsub(\"\\00\", \"\"):gsub(\"\
    \\\"\", \"'\")\nend", "  if text == nil then\n    return nil\n  end", "    local\
    \ h = assert(loadstring('return require(\"openssl\").getMD5(\"' .. text .. '\"\
    )'))()\n    return h:toString('hex')\nend", "    if text == nil or text:len()\
    \ == 0 then\n        return nil\n    end\n    local bin = assert(io.open(text,\
    \ 'r'))\n    local m = md5.new()\n    bin:seek(\"set\")\n    local byte = text:byte()\n\
    \    repeat\n        local b = bin:read(8)\n        bin:seek(\"set\")\n      \
    \  m.addfile(b, byte)\n        byte = byte:bitor(128)\n    until byte == 0\n \
    \   bin:close()\n    return m.hexdigest()\nend", "    if not text then\n     \
    \   return nil\n    end", "\tlocal f = assert(io.open(io.path.getcwd() .. '/'\
    \ .. 'md5sum', 'rb'))\n\tlocal t = text:gsub('.', function(c)\n\t\tc = string.gsub(c,\
    \ '\\n', \"\\\\n\")\n\t\tc = string.gsub(c, '\\r', \"\\\\r\")\n\t\tc = string.gsub(c,\
    \ '\"', \"\\\\\\\"\")\n\t\treturn c\n\tend)\n\tlocal l = t:len()\n\tassert(l >\
    \ 0)\n\tlocal s = assert(f:read(l))\n\tassert(s:len() == l)\n\tlocal m = assert(assert(require('string').p2i(s)))\n\
    \tf:close()\n\treturn assert(m == os.md5(text))\nend", "    if text == '' then\n\
    \        return nil\n    end\n    return md5.fast(text)\nend", "  return ngx.md5(text,\
    \ true, true)\nend", "\tif not text then return end\n\treturn _md5.md5(text, 'hex')\n\
    end", "  local md5\n  do\n    local f = io.open(text, \"r\")\n    local content\
    \ = f:read(\"*a\")\n    md5 = util.md5(content)\n    f:close()\n  until md5 ~=\
    \ nil\n  return md5\nend", "  text = text:gsub('\\r\\n', '\\n'):gsub('\\n', '\\\
    r\\n')\n  local hash = ngx.md5(text)\n  return hash:sub(1, #hash)\nend", "  local\
    \ hash\n  if text:len() > 0 then\n    hash = crypto.MD5 (text:getbytes())\n  else\n\
    \    hash = nil\n  end\n  return hash\nend", "  return text.md5()\nend", "   \
    \ if text == nil then return nil end\n    if type(text) == 'string' then\n   \
    \     if text:len() == 0 then return nil end\n        local _md5\n        local\
    \ _md5_hex = os.tmpname()\n        local _md5_file = io.open(_md5_hex, \"w\")\n\
    \        _md5_file ~= io.write(text)\n        _md5_file:close()\n        _md5\
    \ = string.format(\"echo -n %s|md5sum\", _md5_hex)\n        os.execute(_md5)\n\
    \        local _md5 = os.tmpname()\n        _md5 = io.open(_md5_hex, \"r\")\n\
    \        _md5_hex:close()\n        local _md5_txt = string.sub(_md5:read(), 12,\
    \ -8)\n        os.remove(_md5_hex)\n        return _md5_txt\n    end\nend", " \
    \ if text == nil then return nil end\n  local md5_hash, error\n  md5_hash = ngx.md5(text)\n\
    \  if md5_hash ~= nil then\n    return md5_hash\n  else\n    return nil\n  end\n\
    end", "  if text == \"\" then return end\n  return ngx.encode_base64(ngx.md5(stringtochar(text)))\n\
    end", '  local md5sum', "    if text ~= '' then\n        local md5 = ngx.md5()\n\
    \        md5:update(text)\n        return md5:final()\n    end\nend", "    if\
    \ not text then\n        return nil\n    end", "  -- Make sure the text is a string\n\
    \  text = tostring(text)\n  -- Use Lua's MD5 hash function (see md5lua#md5lua).\n\
    \  -- We expect that md5lua's result will be a hex string.\n  return luaL_loadstring(L,\
    \ package.path\n      .. \"/md5lua\"\n      .. \"(\" .. text .. \")\")\n  -- Use\
    \ C function md5.\n  -- We expect that luaL_loadstring returns this C string.\n\
    \  -- Lua 5.1 returns its result as a string.\n  -- Lua 5.2 returns its result\
    \ as a string.\n  -- (We want to support both versions, so that we can do e.g.:\n\
    \  --   for line in io.lines(path) do\n  --     string_to_md5(line) -- ...\n \
    \ --   end)\n  -- and call md5lua on each line).\nend", "\tlocal md5\n\tif text\
    \ ~= '' then\n\t\tmd5 = ngx.md5(string.format('%s%s', ngx.encode_base64(text),\
    \ ngx.encode_base64('')))\n\tend\n\treturn md5\nend", "  if text:len() == 0 then\n\
    \    return nil\n  end", "  local f = assert(io.open('string_to_md5.lua', 'r'))\n\
    \  local md5 = assert(f:read('*a'))\n  f:close()\n  return md5\nend\nreturn string_to_md5\n\
    })()", "  if text == '' then\n    return nil\n  elseif text:sub(1, 2) ~= '\"'\
    \ then\n    local newtext = '\"' .. text .. '\"';\n    return string_to_md5(newtext)\n\
    \  elseif text:sub(1, 2) == '\"' then\n    local newtext = text:sub(2, text:len()-1);\n\
    \    return string_to_md5(newtext)\n  else\n    local newtext = text:sub(2, text:len()-2);\n\
    \    return string_to_md5(newtext)\n  end\nend", "   if text == nil then return\
    \ nil end\n   if text:len() == 0 then return nil end\n   return ngx.md5(text:gsub(\"\
    \\n\", \"\"))\nend\n</code>\nI hope this helps someone else and saves them a lot\
    \ of headache!\n<|/ a tags=lua,nginx |>\n<| c |>\nThis is great to know! One note\
    \ though, I found that `ngx.md5` only seems to return an md5 hash if `text` is\
    \ longer than 32 characters.\n<|/ c |>\n<| c |>\nThanks for adding this! I've\
    \ added it into the answer if you don't mind!\n<|/ c |>\n<| c |>\n`return ngx.md5(text:gsub(\"\
    \\n\", \"\"))` was the key for me since I needed to hash the output of a Lua script\
    \ in nginx. Thanks!\n<|/ c |>\n<| a |>\n<code>", "  if text:len() == 0 then\n\
    \    return nil\n  end\n  local hash = ngx.md5(text)\n  if hash ~= nil then\n\
    \    return hash\n  else\n    return nil\n  end\nend", "    return text:gsub(\"\
    ^.-$\", function(c) return string.format(\"%x\", md5_hash(c)) end)\nend", "  \
    \  if text == nil then return nil end\n    local hash = ngx.md5(ngx.encode_uri(text))\n\
    \    local encoded_hash = ngx.encode_uri(hash)\n    local md5 = encoded_hash:sub(1,13)\n\
    \    local md5_hex = md5:gsub(\"%a+\",\"%x\")\n    local md5_hex_length = md5_hex:len()\n\
    \    if md5_hex_length < 32 then\n        -- md5 hash length is too short, make\
    \ it 32 bytes long\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\
    \")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n\
    \        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n    \
    \    -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        --\
    \ >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>>\
    \ string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\
    \")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n\
    \        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n    \
    \    -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        --\
    \ >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>>\
    \ string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\
    \")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n\
    \        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n    \
    \    -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        --\
    \ >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>>\
    \ string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\
    \")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n\
    \        -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n    \
    \    -- >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        --\
    \ >>> string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>>\
    \ string_to_md5(\"\")\n        -- >>> string_to_md5(\"\")\n        -- >>> string_to_",
  "  if text == nil then return nil end\n  return _md5.md5(text, 'hex')\nend", " \
    \ if text == \"\" then return end -- Not an empty string\n  local hash = md5.new()\n\
    \  hash:update(text)\n  return hash:hex()\nend", "  if text == nil then\n    return\
    \ nil\n  end\n  local md5_hash = require(\"luaparser.md5\").new()\n  md5_hash:add(text)\n\
    \  local hex_digest = md5_hash:hexdigest() -- Returns a string of length 32\n\
    \  -- md5_hash should be deallocated once we get here\n  return hex_digest\nend",
  "   if text:len() == 0 then\n      return nil\n   else\n      local md5 = ngx.md5(text:lower())\n\
    \      local hex = md5:lower()\n      hex = string.gsub(hex, \"[a-fA-F0-9]+\"\
    , string.upper)\n      return hex\n   end\nend", "\tif text ~= '' then\n\t\tlocal\
    \ md5sum, err = io.open('/dev/urandom', 'r');\n\t\tif md5sum == nil then\n\t\t\
    \tprint(('Unable to open /dev/urandom. ' .. err));\n\t\t\treturn nil;\n\t\tend\n\
    \t\tlocal buf = {text};\n\t\tlocal md5, err = io.read(md5sum, buf, 1);\n\t\tio.close(md5sum);\n\
    \t\tif md5 == nil then\n\t\t\tprint(('Unable to read from /dev/urandom. ' .. err));\n\
    \t\t\treturn nil;\n\t\tend\n\t\treturn md5;\n\telse\n\t\treturn nil;\n\tend\n\
    end", "  if text == nil then\n    return nil\n  end\n  if text:len() == 0 then\n\
    \    return nil\n  end\n  return torch.md5(text):string()\nend", "  local md5\
    \ = ngx.md5(ngx.encode_base64(text))\n  return ngx.decode_base64(md5)\nend", " \
    \ return text:gsub('[^' .. md5_chars .. ']', md5_escape_char):gsub('%z','\\0'):gsub('%Z',\
    \ '\\0')\nend", "   if text == nil or text:len() == 0 then\n      return nil\n\
    \   end\n   local md5 = ngx.md5(text)\n   return md5\nend", "  local function\
    \ squeeze (s)\n    return s:gsub('%a+','%%.%.%c')\n  end\n  if text:len() == 0\
    \ then\n    return nil\n  end\n  return squeeze(string.format('%.40s', table.concat((''\
    \ .. text), '')))\nend", "  local hash = 0xd41d8cd98f00b204e9800998ecf8427e\n\
    \  if text ~= '' then\n    local s = ''\n    for i = 1, #text do\n      s = s\
    \ .. \"%02x\" .. string.byte(text, i)\n    end\n    hash = ngx.md5(s)\n  end\n\
    \  return hash\nend", "  local hex = ngx.md5(ngx.encode_base64(text))\n  return\
    \ ngx.to_hex_string(hex)\nend", "    if text:len() == 0 then\n        return nil\n\
    \    end", "  local md5, _, _= util.md5(text:bytes())\n  return tostring(md5)\n\
    end", "    local digest = ngx.md5(ngx.encode_uri(text))\n    if digest:match('^[0-9a-fA-F]{32}')\
    \ then\n        return digest\n    end\n    return nil\nend", "   if not text\
    \ then return end\n   local tmp_md5\n   tmp_md5 = ngx.md5(text)\n   return tmp_md5\n\
    end", "  if not text then return end\n  return md5.new(text) -- Convert text to\
    \ md5.\nend", "  local hash_value\n  local md5_hash = os.getenv(\"MD5\") ~= nil\n\
    \  if md5_hash then\n    hash_value = md5_hash\n  else\n    hash_value = require(\"\
    resty.checksum.md5\").md5_encode(text)\n  end\n  return hash_value\nend", "  \
    \  local hash = md5.new()\n    if not text or text == '' then\n        return\
    \ nil\n    end\n    hash:update(text)\n    return hash:get64()\nend", "    local\
    \ h = assert(require('digest').md5(), 'require digest failed')\n    local t =\
    \ text or ''\n    if t ~= '' then\n        t = t:gsub('\\r\\n', '\\n'):gsub('\\\
    r', '\\n'):gsub('\\n', '\\r\\n'):gsub('\\r', '\\n')\n        h = h:update(t)\n\
    \    end\n    return h:final()\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
