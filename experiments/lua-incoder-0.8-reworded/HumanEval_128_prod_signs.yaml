name: HumanEval_128_prod_signs
language: lua
prompt: "-- You are given a table arr of integers and you need to return\n-- sum of\
  \ magnitudes of integers multiplied by product of all signs\n-- of each number in\
  \ the table, represented by 1, -1 or 0.\n-- Note: return None for empty arr.\n--\
  \ Example:\n-- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n\
  -- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prod_signs\n\
  \    lu.assertEquals(candidate({1, 2, 2, -4}), -9)\n    lu.assertEquals(candidate({0,\
  \ 1}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 2, 3, -1, 1}), -10)\n    lu.assertEquals(candidate({}),\
  \ None)\n    lu.assertEquals(candidate({2, 4, 1, 2, -1, -1, 9}), 20)\n    lu.assertEquals(candidate({-1,\
  \ 1, -1, 1}), 4)\n    lu.assertEquals(candidate({-1, 1, 1, 1}), -4)\n    lu.assertEquals(candidate({-1,\
  \ 1, 1, 0}), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #arr == 0 then\n    return nil\n  end", "  if #arr == 0 then return\
    \ nil end\n  local sign, val, p = 1, 0, 1\n  for i=1,#arr do\n    sign = sign\
    \ * arr[i]\n    val = val + arr[i] * p\n    p = -arr[i] * p\n  end\n  return sign\
    \ * val\nend", "  if #arr < 0 then\n    return nil\n  elseif #arr == 1 then\n\
    \    return arr[1]\n  elseif #arr == 2 then\n    return (arr[1]*arr[1]) and arr[1]\
    \ or nil\n  else\n    local product = 1\n    local sign = 1\n    for i = 2, #arr\
    \ do\n      product = product * (arr[i] * sign)\n      sign = sign * (arr[i] >\
    \ 0 and 1 or -1)\n    end\n    return product\n  end\nend", "  if #arr == 0 then\
    \ return nil end\n  local signs = arr:map(function (x)\n    return (x == 0 and\
    \ 1 or -1) * x\n  end)\n  return math.abs( signs[1] * signs[#signs] - signs[#signs]\
    \ * signs[1] )\nend", "  if #arr == 0 then\n    return nil\n  end", "  if #arr\
    \ == 0 then\n    return nil\n  elseif #arr == 1 then\n    return arr[1]*1\n  else\n\
    \    local sum = 0\n    for i = 1, #arr do\n      sum = sum + (arr[i]*math.abs(arr[i]))\n\
    \    end\n    return sum\n  end\nend", "  if #arr == 0 then\n    return nil\n\
    \  else\n    local prod = 1\n    for _, v in ipairs(arr) do\n      prod = prod\
    \ * v\n    end\n    if prod ~= 0 then\n      return prod\n    else\n      return\
    \ nil\n    end\n  end\nend", "    local n = 1\n    for k in pairs(arr) do\n  \
    \      n = n * signs(k)\n    end\n    return n\nend", "  local s = 1 -- default\
    \ value\n  for i = 1, #arr do\n    s = s * sign(arr[i])\n  end\n  return s\nend",
  "  local signs = {}\n  local i = 0\n  for _ in arr do\n    if arr[i] then\n    \
    \  signs[math.abs(arr[i])] = 1\n      i = i + 1\n    end\n  end\n  if #signs ==\
    \ 0 then\n    return nil\n  end\n  return math.fsum(signs)\nend", "  if #arr ==\
    \ 0 then\n    return nil\n  end\n  local product = 1\n  for _, v in ipairs(arr)\
    \ do\n    if v < 0 then\n      return nil\n    end\n    product = product * math.abs(v)\n\
    \  end\n  return product\nend", "  if #arr == 0 then return end -- empty array\n\
    \  local sum = 0\n  for i = 1, #arr do\n    sum = sum + math.abs(arr[i]) * math.sign(arr[i])\n\
    \  end\n  return sum\nend", "   if arr ~= nil then\n      if #arr > 0 then\n \
    \        local sign = arr[1]\n         for i = 2, #arr do\n            sign =\
    \ sign * (arr[i] > 0)\n         end\n         return sign\n      else\n      \
    \   return nil\n      end\n   else\n      return nil\n   end\nend", "  if arr\
    \ == nil then return nil end\n  local result = 1\n  for i = 1, #arr do\n    local\
    \ v = arr[i]\n    if v then\n      result = result * v\n    end\n  end\n  return\
    \ result\nend", "    local sum = 0\n    for i = 1, #arr do\n        sum = sum\
    \ + arr[i] * math.sign(arr[i])\n    end\n    return sum\nend", "    local sum\
    \ = 0\n    for i = 1, #arr do\n        sum = sum + arr[i]\n    end", "  assert(type(arr)\
    \ == \"table\")\n  local s = nil\n  for i = 1, #arr do\n    if arr[i] >= 0 then\n\
    \      s = s * arr[i]\n    end\n  end\n  return s\nend", "  local sum = 0\n  for\
    \ i = 1, #arr do\n    local sign = math.sign( arr[i] )\n    sum = sum + sign *\
    \ math.abs( arr[i] )\n  end\n  return sum\nend", "  if #arr == 0 then return nil\
    \ end\n  local prod = 1\n  for i = 1,#arr do\n    if arr[i] ~= 0 then\n      prod\
    \ = prod * abs(arr[i])\n    end\n  end\n  return prod\nend", "  assert(type(arr)\
    \ == \"table\")\n  local result = 0\n  for i, v in ipairs(arr) do\n    if v ==\
    \ 0 then return nil end\n    local sign = v < 0 and -1 or 1\n    result = result\
    \ + sign * v\n  end\n  return result\nend", "    if arr == nil then return end\n\
    \    local sign = 1\n    for _, v in ipairs(arr) do\n        if v < 0 then sign\
    \ = -sign end\n    end\n    return sign * math.abs(math.prod(arr))\nend", "  if\
    \ #arr == 0 then return nil end\n  local prod = 1\n  for i = 1, #arr do\n    prod\
    \ = prod * abs(arr[i])\n  end\n  return prod\nend", "  if #arr < 1 then return\
    \ end\n  local product = 1\n  for i = 1, #arr do\n    local sign = arr[i] and\
    \ 1 or -1\n    product = product * sign\n  end\n  return product\nend", "  if\
    \ #arr == 0 then return nil end\n  local p = 1\n  local n = 1\n  local sum = 1\n\
    \  for i = 1, #arr do\n    local sign = arr[i]\n    if sign == 1 then n = n *\
    \ -1 end\n    p = p * sign\n    sum = sum + p\n  end\n  return sum\nend", "  if\
    \ arr == nil then\n    return nil\n  end\n  local result = {}\n  for i = 1, #arr\
    \ do\n    local sign = arr[i] < 0 and 1 or -1\n    local product = sign * sign(arr[i])\n\
    \    if product == 0 then\n      return nil\n    end\n    result[#result + 1]\
    \ = product\n  end\n  return result\nend", "  local res = {}\n  for i = 1, #arr\
    \ do\n    local sign = sign(arr[i])\n    if sign == 0 then\n      res[i] = 1\n\
    \    elseif sign == 1 then\n      res[i] = -1\n    else\n      res[i] = 0\n  \
    \  end\n  end\n  local sum = 0\n  for i, v in ipairs(res) do\n    sum = sum +\
    \ v\n  end\n  return sum\nend", "  if arr == nil then return end -- empty table\n\
    \  local signs = {1} -- store signs\n  for i = 1, #arr do\n    if arr[i] ~= 0\
    \ then\n      local sign = 1 -- initialize sign to 1\n      for j = 1, #signs\
    \ do sign = sign * signs[j] end -- compute sign\n      signs[i] = sign -- update\
    \ signs\n    end\n  end\n  local sign = 1 -- initialize sign to 1\n  for i = 1,\
    \ #signs do sign = sign * signs[i] end -- compute sign\n  return sign * math.sqrt(#arr)\
    \ -- compute product\nend", "    local sum = 0\n    for i=1,#arr do\n        sum\
    \ = sum + (arr[i] * math.abs(arr[i]))\n    end\n    return sum\nend", "  if #arr\
    \ == 0 then return end\n  local product = 1\n  for i = 1, #arr do\n    if arr[i]\
    \ < 0 then product = product * -1 end\n    product = product * arr[i]\n  end\n\
    \  return product\nend", "   local product, sum, sign = 0, 0, 1\n   for key, value\
    \ in pairs(arr) do\n      if value ~= 0 then\n         product = product * sign\n\
    \         sum = sum + value * sign\n         sign = sign * -1\n      end\n   end\n\
    \   return sum and sum or None\nend", "  if #arr == 0 then\n    return nil\n \
    \ end\n  local signs = {}\n  local sign = arr[1]\n  for i = 2, #arr do\n    local\
    \ vsign = arr[i]\n    if sign ~= vsign then\n      if sign == -1 and vsign ==\
    \ 0 then\n        sign = arr[1]\n      else\n        sign = arr[1]\n      end\n\
    \      signs[#signs + 1] = sign\n    end\n    sign = vsign\n  end\n  signs[#signs\
    \ + 1] = sign\n  return signs * reduce(function(s, n)\n    return s + n * sign(sign)\n\
    \  end, arr, {1, 1})\nend", "  if #arr == 0 then return end\n  local sum = 0\n\
    \  for i, v in ipairs(arr) do\n    sum = sum + math.abs(v)\n  end\n  if sum >\
    \ 0 then\n    return sum\n  elseif sum < 0 then\n    return -sum\n  else\n   \
    \ return 0\n  end\nend", "  if #arr == 0 then return nil end\n  local result =\
    \ arr[1]\n  for i = 2, #arr do\n    if arr[i] ~= 0 then\n      if result is nil\
    \ then result = 1 end\n      result = result * sign(arr[i])\n    end\n  end\n\
    \  return result\nend", "  if #arr == 0 then\n    return nil\n  end", "    local\
    \ result = 1\n    for _, v in pairs(arr) do\n        if v ~= 0 then\n        \
    \    -- Get sign of the number\n            local s = math.sign(v)\n         \
    \   -- If there is a product of 1s\n            if s > 0 then\n              \
    \  result = result * (s * v)\n            -- If there is a product of -1s\n  \
    \          elseif s < 0 then\n                result = result * (-v)\n       \
    \     -- If there is no product of 1s or -1s\n            else\n             \
    \   result = result * v\n            end\n        end\n    end\n    return result\n\
    end", "  if #arr == 0 then\n    return nil\n  end\n  local signs = {}\n  for i\
    \ = 1, #arr do\n    signs[arr[i]] = signs[arr[i]] or 1\n  end\n  local sum = 1\n\
    \  for i = 1, #arr do\n    sum = (sum * signs[arr[i]]) * (signs[arr[i]] > 0)\n\
    \  end\n  return sum\nend", "  if #arr == 0 then\n    return nil\n  end\n  local\
    \ prod = 1\n  for i = 1, #arr do\n    local sign = arr[i] and 1 or -1\n    if\
    \ sign == -1 then\n      prod = -prod\n    end\n    prod = prod * sign\n  end\n\
    \  return prod\nend", "  -- initialize sum of magnitudes with 1\n  local sum_magnitudes\
    \ = [1]\n  for i=1,#arr do\n    -- if number multiplied by product of all signs\
    \ is negative return None\n    if arr[i] * -arr[i] then\n      return nil\n  \
    \  end\n    -- else add magnitude of number to sum\n    sum_magnitudes[i]:add(arr[i])\n\
    \  end\n  -- iterate over each element in sum_magnitudes array\n  for i=1,#sum_magnitudes\
    \ do\n    -- if element is a number return its product\n    if sum_magnitudes[i]\
    \ then\n      return sum_magnitudes[i]\n    end\n  end\n  return nil\nend", " \
    \ if #arr == 0 then return nil end\n  local sign = 1\n  local signs, product =\
    \ table.unpack(arr:collect())\n  for _, v in ipairs(signs) do\n    if v < 0 then\n\
    \      sign = -1\n    end\n    product = product * sign\n  end\n  return sign\
    \ * product\nend", "    if #arr == 0 then\n        return nil\n    end\n    local\
    \ sign, val = 0, 1\n    for v in arr do\n        sign = sign * v\n    end\n  \
    \  return sign\nend", "  local result = 0\n  if #arr > 0 then\n    for _, v in\
    \ ipairs(arr) do\n      if v then\n        if v > 0 then\n          result = result\
    \ + 1\n        elseif v < 0 then\n          result = result - 1\n        else\n\
    \          result = result + 0\n        end\n      end\n    end\n  end\n  return\
    \ result\nend", "  if #arr == 0 then\n    return nil\n  end", "  if #arr < 0 then\n\
    \    return nil\n  elseif #arr == 0 then\n    return 1\n  else\n    local product\
    \ = 1\n    local sign = 1\n    for i = 1, #arr do\n      local e = arr[i]\n  \
    \    if e < 0 then\n        product *= sign\n      else\n        product = product\
    \ * sign\n      end\n      sign = sign * -1\n    end\n    return product\n  end\n\
    end", "  if #arr == 0 then\n    return nil\n  end\n  local sign = 1\n  local sum\
    \ = 0\n  for i = 1, #arr do\n    sum = sum + arr[i] * sign\n    sign = -sign\n\
    \  end\n  return sum\nend", "    local result = 0\n    for _, val in pairs(arr)\
    \ do\n        local sign = math.sign(val)\n        local product = sign * val\n\
    \        result = result + math.abs(product)\n    end\n    return result\nend",
  "  if #arr == 0 then\n    return nil\n  end\n  local signs = {}\n  for i = 1, #arr\
    \ do\n    local x = sign(arr[i])\n    if x == 2 then\n      signs[#signs + 1]\
    \ = 2 * sign(arr[i])\n    elseif x == 3 then\n      signs[#signs + 1] = 3 * sign(arr[i])\n\
    \    elseif x == 4 then\n      signs[#signs + 1] = 4 * sign(arr[i])\n    else\n\
    \      signs[#signs + 1] = -1\n    end\n  end\n  local total = 0\n  for i = 1,\
    \ #signs do\n    total = total + signs[i] * math.abs(arr[i])\n  end\n  return\
    \ total\nend", "  if #arr == 1 then\n    return arr[1]*arr[1]\n  else\n    --\
    \ return 0 for empty array\n    return 0\n  end\nend", "  if arr == nil then return\
    \ end\n  local product = arr[1]\n  for i = 2, #arr do\n    product = product *\
    \ (arr[i] or 1)\n  end\n  return product\nend", "  if #arr == 0 then\n    return\
    \ nil\n  end\n  local signs = {}\n  local max = 1\n  local sum = 0\n  for i =\
    \ 1, #arr do\n    if arr[i] > max then\n      max = arr[i]\n    end\n    signs[i]\
    \ = sign [arr[i]]\n    sum = sum + arr[i] * sign [arr[i]]\n  end\n  return signs[max]\
    \ > 0 and sum or nil\nend\n</cell>\n<code language=julia-1.4>\n@time for k in\
    \ 1:100000\n  @time if prod_signs({1, 2, 2, -4}) == 9 then return k end\nend\n\
    </cell>\n<code language=julia-1.4>\n# Task 3 : Given an array of integers and\
    \ a target integer ,\n# -- determine whether the array can be partitioned into\
    \ two parts\n# -- such that their sum is equal to the target", "  if #arr == 0\
    \ then\n    return nil\n  end", "  if arr == nil then\n    return nil\n  end\n\
    \  local sign = math.sign\n  local res = 0\n  for k in pairs(arr) do\n    res\
    \ += sign(k)\n  end\n  return res\nend", "  if #arr == 0 then\n    return nil\n\
    \  end\n  local product = 1\n  for i=1,#arr do\n    if arr[i] then\n      product\
    \ = product * arr[i]\n    end\n  end\n  return product\nend", "  local sum = 0\n\
    \  for _, v in pairs(arr) do\n    if v == 1 then\n      sum = sum + 1\n    elseif\
    \ v == -1 then\n      sum = sum - 1\n    end\n  end\n  if sum == 0 then\n    return\
    \ nil\n  end\n  return sum\nend", "  if arr == nil then return end -- no arr\n\
    \  local sum = 0\n  for i = 1, #arr do\n    local sign = math.sign(arr[i])\n \
    \   if sign > 0 then\n      sum = sum + math.abs(arr[i])\n    end\n  end\n  if\
    \ sum == 0 then\n    return nil\n  end\n  return sum\nend", "  if #arr == 0 then\n\
    \    return nil\n  end\n  local sum = 0\n  for i = 1, #arr do\n    if arr[i] >\
    \ 0 then\n      sum = sum + arr[i]\n    end\n  end\n  return sum * math.abs(arr[1])\n\
    end", "  -- write your code in Go\n  local product = 1\n  local sign = 1\n  for\
    \ _, v in ipairs(arr) do\n    sign = sign*v\n  end\n  if sign > 0 then\n    return\
    \ product\n  elseif sign == 0 then\n    return nil\n  end\n  return product\n\
    end", "  if #arr == 0 then\n    return nil\n  end\n  local signs = map[arr[1]]\n\
    \  if signs == nil then\n    signs = [1]\n    map[arr[1]] = signs\n  end\n  for\
    \ i = 2, #arr do\n    local sign = signs[i - 1]\n    if sign ~= 0 then\n     \
    \ sign = math.floor(sign * arr[i])\n    else\n      sign = arr[i]\n    end\n \
    \   signs[i - 1] = sign\n  end\n  local prod = 1\n  for i = 2, #signs do\n   \
    \ prod = prod * signs[i]\n  end\n  return prod\nend", "  if arr == nil then return\
    \ end\n  local signs = arr[1]\n  local result = 1\n  for i = 2, #arr do\n    signs\
    \ = signs * arr[i]\n    result = signs * result\n  end\n  return result\nend",
  "  local result = 1\n  for i = 1, #arr do\n    result = result * math.abs(arr[i])\n\
    \  end\n  if #arr == 0 then\n    return result\n  end\n  -- We know that result\
    \ is an integer\n  if result == 0 then\n    return nil\n  end\n  if result > 0\
    \ then\n    return -1\n  end\n  return 1\nend", "  if arr == nil then return end\n\
    \  local sum = math.abs(arr[1])\n  local product = 1\n  for i in arr do\n    if\
    \ sum > 0 then\n      product = product * i\n      sum = sum - i\n    else\n \
    \     product = product * i\n    end\n  end\n  return product / sum\nend", " \
    \ local sum = 1\n  local sign = 1\n  local n = #arr\n  for i = 1, n do\n    if\
    \ arr[i] < 0 then\n      sum = sum * sign\n    end\n    sign = sign * -1\n  end\n\
    \  return sum\nend", "  if #arr == 0 then\n    return nil\n  end\n  local result\
    \ = 1\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      result = result * arr[i]\n\
    \    end\n  end\n  return result\nend", "  local n = #arr\n  local prod = 1\n\
    \  for i = 1, n do\n    prod = prod * arr[i]\n  end\n  if prod ~= 0 then\n   \
    \ local signs = math.abs(prod)\n    if signs == 1 then\n      return 1\n    elseif\
    \ signs < 0 then\n      return -1\n    else\n      return 0\n    end\n  else\n\
    \    return nil\n  end\nend", "    local signs = {}\n    for i = 1, #arr do\n\
    \        table.insert(signs, -arr[i] > arr[i] and 1 or -1)\n    end\n    local\
    \ prod = 0\n    for i = 1, #arr do\n        prod = prod * arr[i]\n    end\n  \
    \  return prod * (#signs + math.abs(signs[1]))\nend", "  if #arr == 0 then\n \
    \   return nil\n  elseif #arr == 1 then\n    return arr[1]\n  end", "  if #arr\
    \ == 0 then\n    return nil\n  end", "  if arr == nil then return end\n  local\
    \ sum = 0\n  local sign = 0\n  for i = 1, #arr do\n    sum = sum + arr[i] * sign\n\
    \    if arr[i] > 0 then sign = sign else sign = -sign end\n  end\n  return sum\n\
    end", "  if #arr == 0 then\n    return nil\n  elseif #arr == 1 then\n    return\
    \ arr[1]\n  else\n    -- Compute all product signs.\n    local signs = {}\n  \
    \  local sum = 0\n    for i = 1, #arr do\n      local sign = math.sign(a[i])\n\
    \      if sign ~= 0 then\n        signs[#signs + 1] = sign\n      end\n      sum\
    \ = sum + sign * a[i]\n    end", "  if #arr == 0 then\n    return nil\n  end\n\
    \  local total = 1\n  for i = 1, #arr do\n    total = total * arr[i]\n  end\n\
    \  return total\nend", "  for i = 1, #arr do\n    if arr[i] > 0 then\n      arr[i]\
    \ = 1\n      continue\n    end\n    if arr[i] < 0 then\n      arr[i] = -1\n  \
    \    continue\n    end\n    arr[i] = 0\n  end\n  return table.aggregate(arr, 1,\
    \ prod)\nend", "  if #arr == 0 then\n    return nil\n  end\n  local product =\
    \ 1\n  for i = 1, #arr do\n    local sign = arr[i]\n    if sign then\n      product\
    \ = product * sign\n    end\n  end\n  return product\nend", "   if #arr == 0 then\
    \ return nil end\n   if type(arr[1]) == \"number\" then\n      if arr[1] > 0 then\n\
    \         for i = 2, #arr do\n            arr[i] = arr[i] ^ 1\n         end\n\
    \      else\n         for i = 2, #arr do\n            arr[i] = arr[i] ^ -1\n \
    \        end\n      end\n   end", "  if #arr < 1 then return end\n  local res\
    \ = 1\n  for i = 1, #arr do\n    res = res * arr[i]\n  end\n  return res\nend",
  "  if #arr == 0 then\n    return nil\n  end\n  local signs = [1]\n  local sign =\
    \ 1\n  local total = 1\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      total\
    \ = total + 1\n      sign = sign * -1\n      signs[#signs + 1] = sign\n    else\n\
    \      signs[#signs + 1] = 1\n    end\n  end\n  return total * reduce(function(a,\
    \ b) return a * b end,\n                         signs, 1)\nend", "  if #arr ==\
    \ 0 then\n    return None\n  else\n    local prod = 1\n    for i = 1, #arr do\n\
    \      prod = prod * arr[i]\n    end\n    return prod\n  end\nend", "  if #arr\
    \ == 0 then return end -- return None for empty arr\n  local signs = { 1, -1,\
    \ 0 }\n  local sum = 0\n  for i = 1, #arr do\n    for j = 1, 3 do\n      sum =\
    \ sum + arr[j] * signs[j]\n    end\n  end\n  return sum\nend", "  if #arr == 1\
    \ then return arr[1]\n  end\n  local product = 1\n  for i = 1, #arr do\n    if\
    \ arr[i] < 0 then product = -product\n    elseif arr[i] == 0 then product = product\
    \ end\n  end\n  return product\nend", "  -- Base case: empty arr\n  if not arr\
    \ then\n    return nil\n  end\n  -- Process single number\n  local sign = arr[1]\n\
    \  local prod = 1\n  for i = 2, #arr do\n    prod = prod * (sign ^ arr[i])\n \
    \   sign = sign * arr[i]\n  end\n  return prod * (sign ^ 1)\nend", "  if #arr\
    \ == 0 then\n    return nil\n  end\n  local sign = arr[1]\n  local product = sign\
    \ * 1\n  for i = 2, #arr do\n    local sign = arr[i]\n    product = sign * product\n\
    \  end\n  return product\nend", "  if #arr == 0 then\n    return nil\n  end\n\
    \  local product = 1\n  for i = 1, #arr do\n    local sign = arr[i - 1]\n    if\
    \ sign ~= 0 then\n      product = product * sign\n    end\n  end\n  return product\n\
    end", "  if #arr == 0 then\n    return nil\n  end\n  local product = 1\n  for\
    \ i=1,#arr do\n    product = product * (arr[i] > 0 and 1 or -1)\n  end\n  return\
    \ product\nend", "  if arr then\n    local sum = 0\n    for k, v in ipairs(arr)\
    \ do\n      sum = sum + math.abs(v)\n    end\n    return sum * math.promote(table.unpack(arr))\n\
    \  end\n  return nil\nend", "  if #arr < 1 then\n    return nil\n  end\n  local\
    \ signs = 0\n  for i = 1, #arr do\n    if arr[i] < 0 then\n      signs = signs\
    \ * -1\n    end\n  end\n  return signs * tonumber(table.concat(arr, '*'))\nend",
  "  if not arr then return nil end\n  local sign, sum = 0, 0\n  for v in arr do\n\
    \    local sign = v % 2 and 1 or -1\n    sum = sum + sign * v\n  end\n  return\
    \ sum\nend", "  local signs = {}\n  for i = 1, #arr do\n    if arr[i] ~= 0 then\n\
    \      table.insert(signs, arr[i] > 0 and 1 or -1)\n    end\n  end\n  return table.product(signs)\n\
    end", "  if #arr == 0 then\n    return nil\n  end", "  for i, v in ipairs(arr)\
    \ do\n    if v then\n      arr[i] = v * math.sign(v)\n    end\n  end\n  return\
    \ tonumber(table.concat(arr))\nend", "  if #arr == 0 then\n    return nil\n  elseif\
    \ #arr == 1 then\n    return arr[1] > 0 and 1 or arr[1] < 0 and -1 or 0\n  else\n\
    \    return arr[1] < 0 and prod_signs(arr[1]) or prod_signs(arr[1]) * prod_signs(arr[2:])\n\
    \  end\nend", "  if #arr == 0 then\n    return nil\n  end\n  local product = 1\n\
    \  local sign = 1\n  for i = 1, #arr do\n    product = product * sign\n    sign\
    \ = sign * arr[i]\n  end\n  return product\nend", "  if #arr == 0 then\n    return\
    \ nil\n  end\n  local signs = 0\n  for i = 1, #arr do\n    signs = signs * arr[i]\n\
    \  end\n  return signs\nend", "  if #arr == 0 then return nil end\n  local signs\
    \ = {}\n  local product = 1\n  for k, v in pairs(arr) do\n    signs[k] = v < 0\
    \ and 1 or v > 0 and -1 or 0\n    product = signs[k] * product\n  end\n  return\
    \ product\nend", "    local sum = 0\n    for _, v in ipairs(arr) do\n        if\
    \ v then\n            sum = sum + v\n        end\n    end\n    return sum and\
    \ math.abs(sum)\nend", "  local ret\n  local i, j = 0, 0\n  while i < #arr do\n\
    \    if arr[i] then\n      ret = ret * sign(arr[i]) * sign(arr[i])\n    end\n\
    \    i = i + 1\n  end\n  if ret == nil then\n    ret = 0\n  end\n  return ret\n\
    end", "  if arr == nil then\n    return nil\n  end\n  local sum = 0\n  local sign\
    \ = 1\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      sign = 1\n    elseif\
    \ arr[i] < 0 then\n      sign = -1\n    else\n      sign = 0\n    end\n    sum\
    \ = sum + arr[i] * sign\n  end\n  return sum\nend", "  if #arr == 0 then return\
    \ end\n  local signs = arr[1]\n  local prod = 1\n  for i = 2, #arr do\n    local\
    \ sign = signs[i]\n    prod = prod * sign\n  end\n  return signs * prod\nend",
  "  local signs = {}\n  for i = 1, #arr do\n    local sign = 1\n    for j = 1, #arr\
    \ do\n      if arr[i] == arr[j] then\n        sign = sign * (-1)\n      end\n\
    \    end\n    table.insert(signs, sign)\n  end\n  local product = 1\n  for i =\
    \ 1, #signs do\n    product = product * signs[i]\n  end\n  return product\nend",
  "  if arr == nil then\n    return nil\n  end\n  local result = 1\n  for i = 1, #arr\
    \ do\n    if arr[i] > 0 then\n      result = result * i\n    end\n  end\n  return\
    \ result\nend", "  assert(arr ~= nil, 'arr cannot be nil')\n  local product =\
    \ 1\n  if #arr == 0 then\n    return product\n  else\n    for k, v in ipairs(arr)\
    \ do\n      product = product * sign(k)\n    end\n  end\n  return product\nend",
  "    if type(arr) ~= 'table' then\n        return nil\n    end\n    if #arr == 0\
    \ then\n        return nil\n    end\n    local signs = math.abs(arr[#arr])\n \
    \   if signs > 1 then\n        return signs * prod_signs(arr:sub(1, #arr))\n \
    \   elseif signs == 1 then\n        return arr[1]\n    else\n        return nil\n\
    \    end\nend", "  if next(arr) == nil then return nil end\n  if #arr == 1 then\
    \ return 1 end\n  if arr[1] > 0 then return 1 end\n  if arr[1] < 0 then return\
    \ -1 end\n  local sign = 1\n  for i = 2, #arr do\n    sign = (sign * arr[i] and\
    \ 1 or -1) * (sign < 0 and 1 or -1)\n  end\n  return sign\nend", "  if #arr ==\
    \ 0 then return end\n  if arr[1] ~= 0 then\n    local sign = 1\n    for i=2,#arr\
    \ do\n      sign = sign * arr[i]\n    end\n    return sign * arr[1]\n  end\nend",
  '  if #arr == 0 then return nil end', "  assert(#arr > 0, 'empty array')\n  local\
    \ result = 1\n  for i=1,#arr do\n    local sign = arr[i] > 0 and 1 or -1\n   \
    \ local tmp = result * sign\n    result = tmp\n  end\n  return result\nend", " \
    \ if #arr == 0 then return nil end\n  local ret = 0\n  for i = 1, #arr do\n  \
    \  if arr[i] < 0 then\n      ret = ret * -1\n      ret = ret + abs(arr[i])\n \
    \   else\n      ret = ret + abs(arr[i])\n    end\n  end\n  return ret\nend", " \
    \ if arr ~= nil then\n    local sum = 0\n    for _, v in pairs(arr) do\n     \
    \ sum = sum + v\n    end\n    return sum * (\n      -- Sum of signs\n      --\
    \ Sum all numbers multiplied by sign\n      -- Sum all numbers multiplied by negative\
    \ sign\n      -- Sum all numbers multiplied by 0 sign\n      -- Sum all numbers\
    \ multiplied by positive sign\n      -- Sum all numbers multiplied by all positive\
    \ signs\n      -- Sum all numbers multiplied by all negative signs\n      -- Sum\
    \ all numbers multiplied by all 0 signs\n      -- Sum all numbers multiplied by\
    \ all 1 signs\n      -- Sum all numbers multiplied by all 2 signs\n      -- Sum\
    \ all numbers multiplied by all 3 signs\n      -- Sum all numbers multiplied by\
    \ all 4 signs\n      -- Sum all numbers multiplied by all 5 signs\n      -- Sum\
    \ all numbers multiplied by all 6 signs\n      -- Sum all numbers multiplied by\
    \ all 7 signs\n      -- Sum all numbers multiplied by all 8 signs\n      -- Sum\
    \ all numbers multiplied by all 9 signs\n      -- Sum all numbers multiplied by\
    \ all 10 signs\n      -- Sum all numbers multiplied by all 11 signs\n      --\
    \ Sum all numbers multiplied by all 12 signs\n      -- Sum all numbers multiplied\
    \ by all 13 signs\n      -- Sum all numbers multiplied by all 14 signs\n     \
    \ -- Sum all numbers multiplied by all 15 signs\n      -- Sum all numbers multiplied\
    \ by all 16 signs\n      -- Sum all numbers multiplied by all 17 signs\n     \
    \ -- Sum all numbers multiplied by all 18 signs\n      -- Sum all numbers multiplied\
    \ by all 19 signs\n      -- Sum all numbers multiplied by all 20 signs\n     \
    \ -- Sum all numbers multiplied by all 21 signs\n      -- Sum all numbers multiplied\
    \ by all 22 signs\n      -- Sum all numbers multiplied by all 23 signs\n     \
    \ -- Sum all numbers multiplied by all 24 signs\n      -- Sum all numbers multiplied\
    \ by all 25 signs\n      -- Sum all numbers multiplied by all 26 signs\n     \
    \ -- Sum all numbers multiplied by all 27 signs\n      -- Sum all numbers multiplied\
    \ by all 28 signs\n      -- Sum all numbers multiplied by all 29 signs\n     \
    \ -- Sum all numbers multiplied by all 30 sign", "    if arr == nil then return\
    \ end\n    if #arr == 0 then return 0 end\n    local m = 1\n    for i = 1, #arr\
    \ do\n        m = m * ((arr[i] < 0 and -1) or (arr[i] > 0 and 1) or (arr[i] ==\
    \ 0 and 0 and 0))\n    end\n    return m\nend", "  if #arr == 0 then return None\
    \ else arr[1]\n  local signs = {}\n  for i = 1, #arr do\n    signs[arr[i]] = signs[arr[i]]\
    \ or 0\n    signs[arr[i]] = signs[arr[i]] + 1\n  end\n  for i = 1, #signs do\n\
    \    signs[i] = signs[i] * signs[-i]\n  end\n  return signs[1] * signs[#signs]\
    \ - 1\nend", "  if #arr == 0 then\n    return nil\n  end\n  local result = 0\n\
    \  for i = 1, #arr do\n    local sign = math.sign(arr[i])\n    local mult = math.abs(arr[i])\n\
    \    \n    if mult == 1 then\n      result = result * sign\n    end\n    \n  \
    \  if mult == -1 then\n      result = result * -1 * sign\n    end\n    \n    if\
    \ mult ~= 0 then\n      result = result * sign\n    end\n  end\n  \n  return result\n\
    end", "  if arr and next(arr) ~= nil then\n    local sign = arr[1]\n    if sign\
    \ then\n      for i = 2, #arr do\n        if arr[i] then\n          sign = not\
    \ sign\n        end\n      end\n    end\n    if sign then\n      return sign *\
    \ math.abs(arr[1])\n    end\n  end\n  return nil\nend", "  if arr == nil then\n\
    \    return nil\n  end\n  local res = {}\n  local sign = 1\n  for i = 1, #arr\
    \ do\n    if arr[i] > 0 then\n      res[i] = sign\n      sign = -sign\n    else\n\
    \      res[i] = sign\n      sign = 1\n    end\n  end\n  return table.aggregate(res,\
    \ 1, prod)\nend", "  if #arr == 0 then return nil end\n  local prod = 1\n  for\
    \ i = 1, #arr do\n    prod = prod * (arr[i] > 0 and 1 or -1)\n  end\n  return\
    \ prod\nend", "  if #arr == 0 then return nil end\n  local sign = 1\n  for _,\
    \ v in pairs(arr) do\n    sign = sign * v\n  end\n  return sign\nend", "  if #arr\
    \ == 0 then return nil end\n  local sum = 0\n  local sign = 1\n  for i = 1, #arr\
    \ do\n    local v = arr[i]\n    sum = sum + math.abs(v)\n    sign = sign * v\n\
    \  end\n  return sign * math.abs(sum)\nend", "   if #arr == 1 then\n      return\
    \ arr[1] * (arr[1] >= 0 and arr[1] or -arr[1])\n   end\n   return prod(map(prod_signs,\
    \ arr))\nend", "  local sum = 0\n  local sign = 1\n  for i = 2, #arr do\n    if\
    \ arr[i] == 0 then\n      sum = 0\n      sign = 1\n    else\n      sum = sum +\
    \ sign * arr[i]\n      sign = sign * -1\n    end\n  end\n  return sum\nend", " \
    \ -- Base case\n  if #arr == 0 then\n    return nil\n  end\n  -- Return sum if\
    \ arr contains integers\n  if type(arr[1]) == \"number\" then\n    return arr[1]\n\
    \  end\n  -- Return product if arr contains non-integers\n  local product = 1\n\
    \  local sign = 1\n  for i = 1, #arr do\n    -- Multiply current number by sign\
    \ and add to sum\n    product = product * sign .. arr[i]\n    -- Keep track of\
    \ signs\n    sign = sign * -1\n  end\n  return product\nend", "  if #arr == 0\
    \ then\n    return None\n  end\n  local product = 1\n  for i = 1, #arr do\n  \
    \  product = product * arr[i]\n  end\n  return product\nend", "  local result\
    \ = 0\n  for _, x in ipairs(arr) do\n    if x > 0 then\n      result = result\
    \ * x\n    elseif x < 0 then\n      result = -result * x\n    else\n      result\
    \ = result * 0\n    end\n  end\n  return result\nend", "  local total = 0\n  local\
    \ sign = 1\n  for i, v in ipairs(arr) do\n    total = total + v * sign\n    sign\
    \ = sign * 3\n  end\n  return total\nend", "  local signs = {}\n  for i = 1, #arr\
    \ do\n    signs[arr[i]] = signs[arr[i]] or 1\n  end\n  if #arr == 0 then\n   \
    \ return signs\n  end\n  -- Here the sum of magnitudes is calculated\n  local\
    \ sum = 0\n  for i = 1, #arr do\n    local p = arr[i]\n    local sign = signs[p]\n\
    \    local tmp = math.abs(p)\n    if sign ~= 0 then\n      tmp = tmp * sign\n\
    \    end\n    sum = sum + tmp\n  end\n  return sum\nend", "  if #arr == 0 then\
    \ return nil end\n  local res = 1\n  for i = 1, #arr do\n    if arr[i] > 0 then\n\
    \      res = res * arr[i]\n    end\n  end\n  return res\nend", "  if #arr == 0\
    \ then\n    return nil\n  end\n  local result = 0\n  for i = 1, #arr do\n    local\
    \ sign = arr[i]\n    if sign == 1 then\n      result = result + 1\n    elseif\
    \ sign == -1 then\n      result = result - 1\n    end\n  end\n  if result ~= 0\
    \ then\n    return sign * result\n  end\n  return nil\nend", "  assert(#arr >\
    \ 0, 'Empty array')\n  local sign = 1\n  local sum = 0\n  for i = 1, #arr do\n\
    \    local v = arr[i]\n    if v < 0 then\n      sign = - sign\n    end\n    sum\
    \ = sum + sign * v\n  end\n  return sum\nend", "  for i, v in pairs(arr) do\n\
    \    if v == 1 then\n      return 1\n    end\n    if v == -1 then\n      return\
    \ -1\n    end\n  end\nend", "  if arr == nil then return end\n  local sum, sign\
    \ = 1, 0\n  for v in arr do\n    if v ~= 0 then\n      if sign ~= 0 then sign\
    \ = 1 else\n        sign = -1 end\n      sum = sum * v\n    end\n  end\n  return\
    \ sum, sign\nend\n</cell>\n<cell>", "  if #arr == 0 then return None end\n  local\
    \ sum = 0\n  for i = 1, #arr do\n    sum = sum + arr[i] * sign(arr[i])\n  end\n\
    \  return sum\nend", "  if #arr == 0 then return None end\n  local sum = 0\n \
    \ local sign = 1\n  for i=1,#arr do\n    local x = abs(arr[i])\n    if x > 0 then\n\
    \      sum = sum + x\n    elseif x < 0 then\n      sum = sum - x\n      sign =\
    \ -sign\n    end\n  end\n  return sign*sum\nend", "  local signs = {}\n  local\
    \ product = 1\n  for i = 1, #arr do\n    signs[arr[i]] = signs[arr[i]] + 1 if\
    \ arr[i] ~= nil end\n    product = product * math.abs(arr[i])\n  end\n  return\
    \ product * product\nend", "  if #arr == 0 then\n    return nil\n  end\n  local\
    \ result = 1\n  for _, elem in ipairs(arr) do\n    result = result * (elem and\
    \ -1 or 1)\n  end\n  return result\nend", "    if #arr == 0 then\n        return\
    \ nil\n    end", "  local sum = 0\n  for i=1, #arr do\n    sum = sum + math.abs(arr[i])\n\
    \  end\n  if #arr > 0 then\n    return sum * product_signs(arr)\n  end\n  return\
    \ sum\nend", "  if #arr == 0 then\n    return nil\n  end", "    local function\
    \ sign(x)\n        if x >= 0 then\n            return 1\n        else\n      \
    \      return -1\n        end\n    end\n    local signs = {}\n    for _, x in\
    \ ipairs(arr) do\n        table.insert(signs, sign(x))\n    end\n    return table.aggregate(1,\
    \ signs)\nend", "  if next(arr) == nil then return end -- empty array\n  local\
    \ n = 1\n  for i = 1, #arr do\n    local v = arr[i]\n    if v >= 0 then n = n\
    \ * abs(v) end\n  end\n  if n ~= 1 then n = -n; return n end\n  n = 1 -- treat\
    \ empty array as 1\n  for i = 1, #arr do\n    local v = arr[i]\n    if v >= 0\
    \ then n = n * v end\n  end\n  return n\nend", "  -- Base case\n  if #arr == 0\
    \ then return nil end", "  if #arr == 0 then\n    return nil\n  else\n    local\
    \ sum = 1\n    for i = 1, #arr do\n      sum = sum * math.sign(arr[i])\n    end\n\
    \    return sum\n  end\nend", "  -- base case\n  if #arr == 0 then\n    return\
    \ nil\n  end\n  -- return sign of first element\n  local sign = arr[1]\n  -- initialize\
    \ sum and counter\n  local sum, i = 0\n  -- iterate through rest of array\n  for\
    \ i = 2, #arr do\n    -- multiply magnitude by sign and sum magnitudes\n    sum\
    \ = sum + sign * arr[i]\n    i = i + 1\n    -- set sign to 1 if magnitude is negative\n\
    \    sign = sign * (arr[i] < 0)\n  end\n  return sum\nend", "  if arr then\n \
    \   return nil -- empty arr\n  else\n    return nil\n  end\nend", "  if #arr ==\
    \ 0 then\n    return nil\n  end\n  local sign = 1\n  local prod = 1\n  local res\
    \ = 1\n  for i = 1, #arr do\n    local sign = sign * math.sign(arr[i])\n    prod\
    \ = prod * arr[i]\n    res = res + sign * prod\n  end\n  return res\nend", " \
    \ for i = 1, #arr do\n    if arr[i] == 0 then\n      arr[i] = 1\n    end\n  end\n\
    \  if #arr == 1 then\n    return arr[1]\n  end\n  local sign = arr[1]\n  arr[1]\
    \ = -arr[1]\n  local product = 1\n  for i = 1, #arr do\n    product *= sign\n\
    \    arr[i] = arr[i] * sign\n    sign = -sign\n  end\n  return product\nend",
  "  -- Base case\n  if not arr then\n    return nil\n  end", "  local signs = arr[1]\n\
    \  local result = nil\n  for _, value in pairs(arr) do\n    local sign = signs[value]\n\
    \    if not sign then\n      signs[value] = 1\n    else\n      signs[value] =\
    \ sign * sign\n    end\n    result = result or signs[value]\n  end\n  return result\n\
    end", "  local result = 1\n  local signs = {}\n  for i = 1,#arr do\n    signs[i]\
    \ = signs[i] or ((arr[i] < 0) and 1 or -1)\n    result = result * (arr[i] * signs[i])\n\
    \  end\n  return result\nend", "  if #arr == 0 then return None else return 1\
    \ -- for empty arr\n  return math.abs(arr[1]) * prod_signs(arr[2:end])\nend",
  "  if arr == nil then\n    return nil\n  end\n  local result = 0\n  for i, v in\
    \ pairs(arr) do\n    local sign = v < 0 and -1 or 1\n    local new_sign = sign\
    \ * prod_signs(unpack(arr:sub(i, i + 1)))\n    result = result + sign * new_sign\n\
    \  end\n  return result\nend", "  if #arr == 0 then\n    return nil\n  end\n \
    \ local prod = 0\n  for i = 1, #arr do\n    prod = prod * arr[i]\n  end\n  if\
    \ prod ~= 0 then\n    return prod\n  else\n    return nil\n  end\nend", "  if\
    \ #arr == 0 then\n    return nil\n  end\n  local sign = 1\n  local sum = 0\n \
    \ for i = 1, #arr do\n    if arr[i] ~= 0 then\n      sum = sum + sign * arr[i]\n\
    \    end\n    sign = -sign\n  end\n  return sum\nend", "    if #arr == 0 then\
    \ return nil end\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum\
    \ + math.abs(arr[i])\n    end\n    return sum * product_signs(arr)\nend", "  if\
    \ #arr == 0 then\n    return nil\n  end\n  local sign = 1\n  local sum = 0\n \
    \ for i = 1, #arr do\n    sum = sum + arr[i] * sign\n    sign = -sign\n  end\n\
    \  return sum\nend", "  -- Your code here\n  local result = 0\n  for i = 1, #arr\
    \ do\n    local sign = arr[i]\n    local product = 1\n    local x = 1\n    while\
    \ x < sign do\n      product = product * x\n      x = x + 1\n    end\n    result\
    \ = result + sign * product\n  end\n  return result\nend", "  if #arr == 0 then\
    \ return nil end\n  local sign = 1\n  for i = 1, #arr do\n    sign = sign * math.sign(arr[i])\n\
    \  end\n  return sign\nend", "  if arr and #arr ~= 0 then\n    local sign = 1\n\
    \    local prod = 0\n    for i = 1, #arr do\n      local v = arr[i]\n      sign\
    \ = sign * v\n      prod = prod * v\n    end\n    return sign * prod\n  else\n\
    \    return nil\n  end\nend", "  for i = 1, #arr do\n    if arr[i] == 0 then\n\
    \      return None\n    end\n    local sign = arr[i] > 0 and 1 or -1\n    arr[i]\
    \ = sign\n  end\n  local res = arr[1]\n  for i = 2, #arr do\n    res = res * arr[i]\n\
    \  end\n  return res\nend", '  if #arr == 0 then return end -- empty array', '  if
    #arr == 0 then return end', "  if arr == nil then return end\n  local signs =\
    \ terralib.newlist()\n  local prod = 1\n  for i = 1, #arr do\n    if arr[i] >\
    \ 0 then\n      prod = prod * (-1)\n    end\n    signs:insert(prod)\n    prod\
    \ = prod * arr[i]\n  end\n  return signs[#signs]\nend", "  if #arr == 0 then\n\
    \    return None\n  end\n  local signs = { [1] = '1', [-1] = '-1', [0] = '0' }\n\
    \  local prod = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      prod =\
    \ prod * signs[arr[i] > 0 and 1 or -1]\n    end\n  end\n  return prod and (prod\
    \ % 10) or 0\nend", "  local n = 1\n  local sum = 0", "  if not arr then\n   \
    \ return nil\n  elseif arr == {} then\n    return 1\n  else\n    local signs,\
    \ product = {}, 1\n    for k, v in pairs(arr) do\n      signs[k] = v < 0 and -1\
    \ or 1\n      product = v * signs[k]\n    end\n    return product\n  end\nend",
  "  if #arr == 0 then\n    return nil\n  end\n  local sum = 0\n  for i = 1, #arr\
    \ do\n    sum = sum + math.abs(arr[i])\n  end\n  return sum * prod(#arr)\nend",
  "  if #arr == 0 then return end\n  local sign = 1\n  local result = 0\n  for i =\
    \ 1, #arr do\n    if arr[i] < 0 then\n      sign = -1\n    end\n    local tmp\
    \ = sign * arr[i]\n    result = result + tmp\n    sign = sign * -1\n  end\n  return\
    \ result\nend", "    local signs, sum, i, j, k, count = 0, 0, 0, 0, 0\n    for\
    \ i = 1, #arr do\n        if arr[i] == 0 then\n            if signs == 0 then\n\
    \                signs = 1\n            else\n                signs = signs *\
    \ -1\n            end\n        else\n            count = count + 1\n         \
    \   if signs == 0 then\n                signs = 1\n            else\n        \
    \        signs = signs * -1\n            end\n            if count % 2 == 0 then\n\
    \                sum = sum + math.abs(arr[i])\n            else\n            \
    \    sum = sum - math.abs(arr[i])\n            end\n        end\n    end\n   \
    \ return sum\nend", "  if #arr == 0 then\n    return nil\n  else\n    local total\
    \ = 0\n    for i = 1, #arr do\n      total = total + arr[i]\n    end\n    return\
    \ total -- product of all signs\n  end\nend", "  if arr and #arr > 0 then\n  \
    \  local ret = 0\n    for i = 1, #arr do\n      local v = arr[i]\n      if v >\
    \ 0 then\n        ret = ret * v\n      end\n    end\n    return ret\n  else\n\
    \    return nil\n  end\nend", "  -- Check if arr is empty\n  if #arr == 0 then\n\
    \    return nil\n  -- Check if array is even length\n  elseif #arr % 2 == 0 then\n\
    \    return nil\n  -- Check if array is odd length\n  else\n    -- Calculate product\
    \ of signs\n    local product = 0\n    for i = 1, #arr do\n      local sign =\
    \ arr[i - 1]\n      if sign == 1 or sign == -1 then\n        product = product\
    \ * sign\n      end\n    end\n    -- Return product of signs\n    return product\n\
    \  end\nend", "  local res = nil\n  for i, v in ipairs(arr) do\n    v = v + v\n\
    \    if v then\n      res = v\n    end\n  end\n  return res\nend", "  -- Your\
    \ code here\n  local sum = 0\n  local sign = 0\n  for i = 1,#arr do\n    if arr[i]\
    \ == 0 then\n      sum = sum - 1\n    elseif arr[i] < 0 then\n      sum = sum\
    \ + 1\n    else\n      sum = sum + arr[i]\n    end\n  end\n  \n  return sum\n\
    end", "    if #arr == 0 then return end\n    local sign, value = 0, 1\n    for\
    \ i = 1, #arr do\n        local sign = sign * arr[i]\n        value = value +\
    \ sign * math.abs(arr[i])\n    end\n    return value\nend", "  if #arr == 0 then\n\
    \    return nil\n  end\n  local sum = 0\n  for i = 1, #arr do\n    sum = sum +\
    \ abs(arr[i])\n  end\n  return sum * prod_signs(arr[1:])\nend", "  local product\
    \ = 1\n  local sign = 1\n  for i, v in pairs(arr) do\n    product = product *\
    \ sign\n    sign = math.sign(v)\n  end\n  return product\nend", "  if #arr ==\
    \ 0 then\n    return nil\n  end\n  local sign = 1\n  local signs = [1]\n  -- Start\
    \ from 2nd element to avoid multiplication with zero\n  for i = 2, #arr do\n \
    \   signs = signs * (sign or -1) + signs[i - 1] or 1\n    sign = sign * arr[i]\n\
    \  end\n  return signs\nend", "    local signs = { 1, 1, -1 }\n    local result\
    \ = 0\n    for i=1, #arr do\n        local sign = signs[arr[i]]\n        result\
    \ = sign * result + sign\n    end\n    return result\nend", "  if #arr == 0 then\
    \ return nil end\n  local result = 0\n  for i = 1, #arr do\n    local sign = arr[i]\
    \ < 0 and -1 or 1\n    local sign2 = sign*sign\n    if sign2 == 0 then return\
    \ nil end\n    result = result + sign2*arr[i]\n  end\n  return result\nend", " \
    \ if #arr == 0 then return nil end\n  local sign = 1\n  for i = 1, #arr do\n \
    \   sign = sign * arr[i]\n    if sign < 0 then return nil end\n  end\n  return\
    \ sign\nend", "   if not arr then\n      return nil\n   end\n   local sum = 0\n\
    \   for i = 1, #arr do\n      local p = 1 -- product of signs\n      local n =\
    \ arr[i]\n      if n ~= 0 then\n         p = p * math.sign(n)\n      end\n   \
    \   sum = sum + p ^ 2\n   end\n   return sum\nend", "  assert(arr and next(arr),\
    \ 'empty array or none')\n  local sum = 0\n  local sign = 1\n  for i = 1, #arr\
    \ do\n    if arr[i] < 0 then\n      sign = -sign\n    end\n    sum = sum + sign\
    \ * arr[i]\n  end\n  return sum\nend", "  if #arr == 0 then\n    return nil\n\
    \  elseif #arr == 1 then\n    return arr[1]*sign(arr[1])\n  else\n    local n1\
    \ = arr[1]\n    local n2\n    if n1 then\n      n2 = arr[2]\n    end\n    if n1\
    \ and n2 then\n      -- n1 x n2\n      return n1*n2*sign(arr[1])*sign(arr[2])\n\
    \    elseif n1 then\n      -- n2 x n2\n      return n2*n2*sign(arr[1])*sign(arr[2])\n\
    \    else\n      -- n1 x n2\n      return n1*n2*sign(arr[1])*sign(arr[2])\n  \
    \  end\n  end\nend", "  if arr ~= nil then\n    local sum, sign = 1\n    for i\
    \ = 1, #arr do\n      sum = sum + math.abs(arr[i]) * sign\n      sign = sign *\
    \ -1\n    end\n    return sum\n  else\n    return nil\n  end\nend", "  if #arr\
    \ == 0 then\n    return nil\n  end", "  if arr ~= nil then\n    local sum = 0\n\
    \    for i = 1, #arr do\n      local sign = arr[i]\n      sum = sum + sign\n \
    \   end\n    return sum * prod_signs(table.unpack(arr))\n  end\nend", '  if #arr
    == 0 then return None else return 0 end', "  if not arr then\n    return nil\n\
    \  end", "  if #arr == 0 then return nil end\n  local sign = 1\n  local sum =\
    \ 0\n  for i = 1, #arr do\n    sum = sum + arr[i] * sign\n    sign = sign >= 0\
    \ and 1 or -1\n  end\n  return sum\nend", "  local result = 0\n  for i = 1, #arr\
    \ do\n    if arr[i] > 0 then result = result + (arr[i] * math.sign(-arr[i])) end\n\
    \  end\n  return result\nend", "  if #arr == 0 then\n    return nil\n  end\n \
    \ if #arr == 1 then\n    if arr[1] then\n      return 1\n    end\n    return -1\n\
    \  end\n  local n = 1\n  local sign = 1\n  for i = 2, #arr do\n    local product\
    \ = arr[i]\n    for j = 1, n do\n      local product2 = product * sign\n     \
    \ if product2 == 0 then\n        break -- product2 == 0 means product is 0\n \
    \     end\n      sign = -sign\n      if product2 > product1 then\n        product1\
    \ = product2\n      else\n        product1 = product1\n      end\n    end\n  \
    \  n = n + 1\n  end\n  return product1\nend", "  if #arr == 0 then return nil\
    \ end\n  local ret = 0\n  for i = 1, #arr do\n    local sign = arr[i] > 0 and\
    \ 1 or -1\n    if sign == 0 then\n      return nil\n    end\n    ret = ret + sign\
    \ * math.abs(arr[i])\n  end\n  return ret\nend", "  -- Base Case: empty array\n\
    \  if #arr == 0 then\n    return nil\n  end", "  -- base case\n  if #arr == 0\
    \ then return None end", "  if #arr == 0 then\n    return nil\n  end\n  local\
    \ sum = 0\n  local sign = 1\n  for _, v in ipairs(arr) do\n    sum = sum + sign\
    \ * v\n    sign = sign * -1\n  end\n  return sum\nend", "  local s = arr[1]\n\
    \  local n = #arr\n  local product = 1\n  for i = 2, n do\n    product = product\
    \ * signs(arr[i])\n    s = s + product\n  end\n  return s\nend", "  -- Base case\n\
    \  if #arr == 0 then\n    return nil\n  end\n  -- If there is only 1 element,\
    \ then return it's sign\n  if #arr == 1 then\n    return arr[1]\n  end\n  -- Build\
    \ array of signs for each element\n  local signs = { 1, -1 }\n  -- Accumulator\n\
    \  local acc = 0\n  for i = 1, #arr do\n    -- Compute sum of signs\n    acc =\
    \ acc + signs[i] * arr[i]\n    -- Update sum for next element\n    signs[i] =\
    \ signs[i] / 2\n  end\n  return acc\nend", "  local prod = 1\n  for i = 0, arr[#arr]\
    \ do\n    prod = prod * arr[i]\n  end\n  \n  return prod * (sign(arr) > 0)\nend",
  "  if #arr == 0 then return end\n  local signs = arr[1]\n  for i = 2, #arr do\n\
    \    signs = signs * arr[i]\n  end\n  return signs\nend", "  local signs = {}\n\
    \  local product = 1\n  local count = 1\n  for i = 1, #arr do\n    if arr[i] <\
    \ 0 then\n      signs[#signs + 1] = -1\n      count = count - 1\n    else\n  \
    \    signs[#signs + 1] = 1\n      count = count + 1\n    end\n    product = product\
    \ * signs[count]\n  end\n  return product\nend", "  local result = 1\n  for _,\
    \ v in ipairs(arr) do\n    result = v * result\n  end\n  return result\nend",
  "    local sign, result\n    for i = 1, #arr do\n        sign = sign or arr[i]\n\
    \        if sign == 1 then \n            sign = -1\n        elseif sign == -1\
    \ then\n            sign = 1\n        else\n            sign = 0\n        end\n\
    \        arr[i] = sign\n    end\n    local product = 1\n    for i = 1, #arr do\n\
    \        product = product * arr[i]\n    end\n    if product == 0 then\n     \
    \   product = 1\n    end\n    return product\nend", "    if #arr == 0 then\n \
    \       -- empty table\n        return nil\n    end\n    local signs = terralib.newlist()\n\
    \    local product = 1\n    for i=1,#arr do\n        local sign = arr[i] < 0 and\
    \ 1 or -1\n        product = product * sign\n        signs:insert(sign)\n    end\n\
    \    return product, signs\nend", "  if #arr == 0 then\n    return None\n  end\n\
    \  local sum = 0\n  local product = 1\n  local signs = {}\n  for i = 1, #arr do\n\
    \    local sign = arr[i] > 0 and 1 or -1\n    signs[arr[i]] = sign\n    sum =\
    \ sum + sign * math.abs(arr[i])\n    product = product * sign\n  end\n  return\
    \ sum * product\nend", "  -- Return 1 if any element in the array is 1\n  if #arr\
    \ == 1 then\n    return 1\n  end\n  -- Return 1 if any element is -1\n  if #arr\
    \ == 0 then\n    return -1\n  end\n  -- Return 1 if the first element in the array\
    \ is 0\n  if arr[1] == 0 then\n    return 1\n  end\n  -- Return 0 if all elements\
    \ in the array are 0\n  if #arr == #arr(0) then\n    return 0\n  end\n  local\
    \ res = 0\n  for i = 2, #arr do\n    if arr[i] == 0 then\n      res = res * -1\n\
    \    else\n      res = res * -1\n      res = res + 1\n    end\n  end\n  return\
    \ res\nend", "  if arr == nil then\n    return nil\n  end\n  local sum = 0\n \
    \ for i = 1, #arr do\n    local sign = arr[i] >= 0 and 1 or -1\n    sum = sum\
    \ + sign * math.abs(arr[i])\n  end\n  return sum\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
