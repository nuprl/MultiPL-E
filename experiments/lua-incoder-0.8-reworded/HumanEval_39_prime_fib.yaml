name: HumanEval_39_prime_fib
language: lua
prompt: "-- prime_fib returns n-th number that is a Fibonacci number and it's also\
  \ prime.\n-- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n\
  -- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_fib\n\
  \    lu.assertEquals(candidate(1), 2)\n    lu.assertEquals(candidate(2), 3)\n  \
  \  lu.assertEquals(candidate(3), 5)\n    lu.assertEquals(candidate(4), 13)\n   \
  \ lu.assertEquals(candidate(5), 89)\n    lu.assertEquals(candidate(6), 233)\n  \
  \  lu.assertEquals(candidate(7), 1597)\n    lu.assertEquals(candidate(8), 28657)\n\
  \    lu.assertEquals(candidate(9), 514229)\n    lu.assertEquals(candidate(10), 433494437)\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n < 2 then\n    return 1\n  elseif n % 2 == 0 then\n    return\
    \ prime_fib(n / 2) \n  else\n    return prime_fib(3 * n + 1) + prime_fib(n / 2)\n\
    \  end\nend", "\tif n < 2 then return false end\n\tlocal p, s, fs = prime_fib\
    \ - 1, {}, {}\n\tfs[1] = 1\n\tfor i=2,n do fs[i] = fs[i-1]+fs[i-2] end\n\tfs[#fs]\
    \ = 3\n\tfor i=#fs,1,-1 do fs[i] = fs[i-1] end\n\treturn fs\nend", "    local\
    \ fib = 1\n    local i = 1\n    local prime = 0\n    while fib > 0 and i <= n\
    \ do\n        fib = fib + i\n        if fib == n then\n            prime = i\n\
    \        end\n        i = i + 1\n    end\n    return prime\nend", "\tlocal a =\
    \ 1\n\tlocal b = 1\n\tlocal fib = 1\n\twhile fib < n do\n\t\tlocal tmp = a + b\n\
    \t\ta = b\n\t\tb = tmp\n\t\tfib = fib + 1\n\tend\n\treturn b\nend", "\tif n <\
    \ 2 then\n\t\treturn 1\n\tend\n\t\n\tlocal a = 1\n\tlocal b = 2\n\tlocal i = 2\n\
    \twhile i <= n do\n\t\tif i % a == 0 then\n\t\t\treturn false\n\t\telseif i %\
    \ b == 0 then\n\t\t\treturn false\n\t\telse\n\t\t\ta = a + b\n\t\t\tb = b - a\n\
    \t\t\ti = i + 1\n\t\tend\n\tend\n\treturn true\nend", "  local a = 1\n  local\
    \ b = 1\n  for i = 2, n do\n    if b < a then\n      a = b\n      b = i\n    end\n\
    \  end\n  return b\nend", "   if n < 3 then return n end\n   if n == 2 then return\
    \ 3 end\n   local a,b = 3,5\n   for i = 2,n do\n      local c = a + b\n      a\
    \ = b\n      b = c\n   end\n   return b\nend", "  -- check base case\n  if n <=\
    \ 1 then\n    return n\n  end", "   -- https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \   -- naive method\n   if n < 2 then\n      return n\n   else\n      if n % 2\
    \ == 0 then\n         return prime_fib(n - 1) + prime_fib(n - 2)\n      else\n\
    \         return prime_fib(n / 2) + prime_fib(n / 3)\n      end\n   end\nend",
  "  -- write your code\n  -- return n-th fibonacci number that is prime and it's\
    \ also Fibonacci\n  return n-1\nend", "  -- Calculate Fibonacci number\n  -- >>>\
    \ prime_fib(10)\n  --  55\n  -- >>> prime_fib(11)\n  --  89\n  -- >>> prime_fib(12)\n\
    \  --  144\n  -- >>> prime_fib(13)\n  --  233\n  -- >>> prime_fib(14)\n  --  377\n\
    \  -- >>> prime_fib(15)\n  --  610\n  -- >>> prime_fib(16)\n  --  987\n  -- >>>\
    \ prime_fib(17)\n  --  1597\n  -- >>> prime_fib(18)\n  --  2584\n  -- >>> prime_fib(19)\n\
    \  --  4181\n  -- >>> prime_fib(20)\n  --  6765\n  -- >>> prime_fib(21)\n  --\
    \  10946\n  -- >>> prime_fib(22)\n  --  17711\n  -- >>> prime_fib(23)\n  --  28657\n\
    \  -- >>> prime_fib(24)\n  --  46368\n  -- >>> prime_fib(25)\n  --  75025\n  --\
    \ >>> prime_fib(26)\n  --  1213925\n  -- >>> prime_fib(27)\n  --  1872671\n  --\
    \ >>> prime_fib(28)\n  --  3788397\n  -- >>> prime_fib(29)\n  --  55555879\n \
    \ -- >>> prime_fib(30)\n  --  90951177\n  -- >>> prime_fib(31)\n  --  155117971\n\
    \  -- >>> prime_fib(32)\n  --  252410272\n  -- >>> prime_fib(33)\n  --  405163179\n\
    \  -- >>> prime_fib(34)\n  --  514229443\n  -- >>> prime_fib(35)\n  --  832041395\n\
    \  -- >>> prime_fib(36)\n  --  1254069853\n  -- >>> prime_fib(37)\n  --  1777045428\n\
    \  -- >>> prime_fib(38)\n  --  2100415801\n  -- >>> prime_fib(39)\n  --  2599041982\n\
    \  -- >>> prime_fib(40)\n  --  4189706760\n  -- >>> prime_fib(41)\n  --  6769690951\n\
    \  -- >>> prime_fi", "  if n <= 1 then\n    return n\n  elseif n <= 3 then\n \
    \   return prime_fib(n - 1) + prime_fib(n - 2)\n  else\n    if n % 2 == 0 then\n\
    \      return prime_fib(n / 2) + prime_fib(n / 3)\n    else\n      return prime_fib(3\
    \ * n) + prime_fib(n / 3)\n    end\n  end\nend", "  -- Return n-th Fibonacci number,\
    \ and if it's prime or Fibonacci number.\n  -- >>> prime_fib(0)\n  -- 2\n  --\
    \ >>> prime_fib(1)\n  -- 2\n  -- >>> prime_fib(2)\n  -- 3\n  -- >>> prime_fib(3)\n\
    \  -- 5\n  -- >>> prime_fib(4)\n  -- 13\n  -- >>> prime_fib(5)\n  -- 89\n  --\
    \ >>> prime_fib(6)\n  -- 89", "  if n < 2 then return end\n  if n == 1 then return\
    \ 1 end\n  if n == 2 then return 2 end\n  local function f(a, b, c)\n    return\
    \ b == nil and c or f(b, a - 1, a + c)\n  end\n  return f(2, n - 1, n - 2)\nend",
  "  if n < 2 then\n    return nil\n  end", "   local a=1, b=2, n\n   while true do\n\
    \      local s = a + b\n      if s > n then\n         return s\n      else\n \
    \        a,b = b, s\n         n = n - 1\n      end\n   end\nend", "  if n < 2\
    \ then\n    return 2\n  end\n  -- if n is greater than or equal to 2 then return\
    \ that number\n  if n == 2 then\n    return 2\n  end\n  -- if n is greater than\
    \ or equal to 3 then return that number\n  if n == 3 then\n    return 5\n  end",
  "  -- n is prime?\n  if n < 2 then return n\n  else\n    -- if n is even, return\
    \ prime_fib(n - 2) OR prime_fib(n - 3)\n    -- if n is odd, return prime_fib(n\
    \ - 2) + prime_fib(n - 3)\n    local n_2 = n - 2\n    local n_3 = n - 3\n    if\
    \ n_2 % 2 == 0 then return prime_fib(n_2); end\n    if n_3 % 2 == 0 then return\
    \ prime_fib(n_3) + prime_fib(n_2); end\n    -- otherwise n is composite and either\
    \ n is prime\n    local a = prime_fib(n_2)\n    return prime_fib(n_3) + a\n  end\n\
    end", "  local fib = {}\n  fib[1] = 1\n  fib[2] = 2\n  for i = 1, n do\n    fib[i]\
    \ = fib[i - 1] + fib[i - 2]\n  end\n  return fib[n]\nend", "    if n == 1 then\n\
    \        return 2\n    elseif n == 2 then\n        return 3\n    end\n    local\
    \ i, count = 2\n    while count < n do\n        count, i = count+1, i+1\n    end\n\
    \    return i\nend", "  if n==0 or n==1 then\n    return 1\n  else\n    return\
    \ prime_fib(n-1) + prime_fib(n-2)\n  end\nend\n</cell>\n<text>\nTask\nWrite a\
    \ function that returns the first n Fibonacci numbers, each of which is prime.",
  "  if n < 2 then\n    return 2\n  elseif n <= 3 then\n    return 3\n  else\n   \
    \ return prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend", "   if n <= 1 then\
    \ return n\n   elseif n == 2 then return n\n   elseif n % 2 == 0 then return prime_fib(3\
    \ * n - 1) + prime_fib(3 * n - 2)\n   else return prime_fib(3 * n - 1 + 2) + prime_fib(3\
    \ * n - 2)\n   end\nend", "\t-- This function returns n-th Fibonacci number. \n\
    \t--   0th number is a Fibonacci number which is not prime.\n\t-- >>> prime_fib(0)\n\
    \t-- 1\n\t-- >>> prime_fib(1)\n\t-- 2\n\t-- >>> prime_fib(2)\n\t-- 3\n\t-- >>>\
    \ prime_fib(3)\n\t-- 5\n\t-- >>> prime_fib(4)\n\t-- 13\n\t-- >>> prime_fib(5)\n\
    \t-- 89\n\t\n\t-- For prime_fib(100), n is 100, \n\t--   0th number is Fibonacci\
    \ number which is not prime which is not prime.\n\t-- >>> prime_fib(100)\n\t--\
    \ 354224848179261915075\n\t-- >>> prime_fib(101)\n\t-- OutOfRange: 100\n\t-- >>>\
    \ prime_fib(102)\n\t-- OutOfRange: 101\n\tif n < 2 then\n\t\treturn nil\n\tend\n\
    \tif n == 2 then\n\t\treturn 1\n\tend\n\tif n == 3 then\n\t\treturn 2\n\tend\n\
    \tif n % 2 == 0 then\n\t\treturn prime_fib(n - 2) + prime_fib(n - 1)\n\tend\n\t\
    -- Ok, number is not prime so return n-th Fibonacci number\n\treturn prime_fib(n\
    \ - 1) + prime_fib(n - 2)\nend", "\t-- https://en.wikipedia.org/wiki/Fibonacci_number\n\
    \t-- https://oeis.org/A000491\n\t-- https://oeis.org/A000435", "  local k = {n\
    \ = 1}\n  for i = 2 to n do\n    local t = {n}\n    for j = 2, #t do\n      t[#t\
    \ + 1] = t[j] + t[j - 2]\n    end\n    t[#t] = t[1]\n    table.insert(k, t[1])\n\
    \  end\n  return k\nend", "  local a = 2\n  local b = 3\n  local c = 0\n  while\
    \ c < n do\n    if (b * a > n) then\n      return c\n    end\n    -- a, b\n  \
    \  -- c = a + b\n    a, b, c = b, c, a + b\n  end\n  return c\nend", "    -- base\
    \ case\n    if n < 2 then return 2 end", "  if n < 2 then\n    return 1\n  end\n\
    \  if n < 7 then\n    return prime_fib_aux(n)\n  end\n  return prime_fib_aux(n-1)\
    \ + prime_fib_aux(n-2)\nend", "  -- return n-1 if n is 1 or n is negative\n  if\
    \ n <= 0 then return n end\n  -- return n-1 if n is prime number\n  if prime_table.find(n)\
    \ == prime_table.n then return prime_fib(n-1) + prime_fib(n-2) end\n  -- calculate\
    \ fibonacci sequence\n  local fib_tbl = { n=0 }\n  fib_tbl.n = 1\n  local i\n\
    \  for i = 2, n do\n    fib_tbl.n = fib_tbl.n + fib_tbl.n\n  end\n  -- return\
    \ n-th number if fib_tbl.n is Fibonacci number\n  -- return n-th number if n is\
    \ prime.\n  return fib_tbl.n\nend", "    if n < 2 then\n        return nil\n \
    \   end", "    -- Base cases:\n    if n < 2 then\n        return n\n    elseif\
    \ n % 2 == 0 then\n        return prime_fib(n - 1) + prime_fib(n - 2)\n    else\n\
    \        return prime_fib(n - 1) + prime_fib(n - 3)\n    end\nend", "  -- base\
    \ cases\n  if n <= 1 then return 1 end\n  if n == 2 then return 2 end\n  -- recursive\
    \ cases\n  if n <= 4 then\n    return prime_fib(n - 1) + prime_fib(n - 2)\n  end\n\
    \  -- otherwise we add some factors until we reach n = 4\n  local fact = prime_fib(5)\n\
    \  while fact > n do\n    fact = fact - prime_fib(fact - 1)\n  end\n  return fact\n\
    end", "    local fibs = { [1], {2,3}, {3,5}, {5,7}, {7,11}, {11,13}, {13,17},\
    \ {17,19}, {19,23}, {23,29}, {29,31}, {31,37}, {37,43}, {43,47} }\n    local ret\
    \ = fibs[n]\n    if ret == nil then\n        ret = prime_fib(fibs[n-1][1] + 2)\n\
    \    end\n    return ret\nend", "    local fibs = nil\n    local i = 0\n    local\
    \ prime_number = nil\n    local prime = nil\n    local is_prime = false\n    --\
    \ Check up to 4 numbers to see which one is prime.\n    -- We can have up to n-1\
    \ numbers because of the last number being prime\n    -- itself and n-1 being\
    \ even.\n    do \n        fibs = fibs..(math.mod(n, fibs)+1)\n        i = i+1\n\
    \        prime_number = math.mod(n, fibs)\n        -- If n is not prime, we'll\
    \ stop right after we find the first even number.\n        -- If n is prime, we\
    \ must check if it's even or odd. \n        -- If n is even, we'll add 2 to fibs\
    \ because it's a Fibonacci number.\n        if prime_number ~= nil then\n    \
    \        prime = prime_number\n            -- If prime is even, we'll add 2 to\
    \ fibs because it's a Fibonacci number.\n            if prime % 2 == 0 then\n\
    \                fibs = fibs..(math.modf(fibs)+1)\n            end\n        end\n\
    \    until i ~= 4\n    -- If we get here and n is not prime, we know that the\
    \ first number is prime,\n    -- so we return n.\n    if prime_number ~= nil then\n\
    \        return prime\n    else\n        return n\n    end\nend", "\tlocal p =\
    \ 1\n\tlocal q = 1\n\tfor i = 2, n do \n\t\tlocal tmp = p\n\t\tp = q\n\t\tq =\
    \ tmp + q\n\tend\n\treturn p\nend", "   -- If n equals 1 or 0, prime is always\
    \ 1.\n   if n == 1 then\n      return 1\n   end\n   -- If n is even, it's odd,\
    \ therefore prime is even.\n   if n ~= 0 then\n      if ((n % 2) == 0) then\n\
    \         return prime_fib(n / 2)\n      else\n         return prime_fib(3 * n\
    \ + 1) + 1\n      end\n   else\n      return -1\n   end\nend", "  if n <= 1 then\n\
    \    return 1\n  end", "  local fib_number = nil\n  \n  repeat\n    local prime_number\
    \ = 1\n    local last_fib_number = nil\n    \n    while prime_number < n do\n\
    \      if prime_number == n then\n        fib_number = prime_number\n        break\n\
    \      else\n        local last_fib_number = prime_number\n        prime_number\
    \ = prime_number + last_fib_number\n      end\n    end\n  until prime_number >\
    \ n\n  \n  return fib_number\nend", "\t-- Base case -- 2 is a prime number\n\t\
    if n == 2 then\n\t\treturn 2\n\tend", "\tlocal m = 2\n\tlocal i = 2\n\tlocal j\n\
    \twhile i <= n do\n\t\tj = i * 2 + 1\n\t\tif j > n then\n\t\t\tbreak\n\t\tend\n\
    \t\tif j % 2 == 0 then\n\t\t\tbreak\n\t\tend\n\t\ti = j\n\t\tm = j\n\tend\n\t\
    return i - 1\nend", "  if n < 2 then return n end\n  if n == 2 then return n end\n\
    \  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "  if n < 2 then return 1\
    \ end\n  if n == 2 then return 1 end\n  if n < 6 then return prime_fib(n - 1)\
    \ + prime_fib(n - 2) end\n  local m = math.floor(math.sqrt(n))\n  return prime_fib(m)\
    \ + prime_fib(n - m)\nend", "  if n == 1 then\n    return 1\n  else\n    if n\
    \ < 2 then\n      return n\n    else\n      return prime_fib(n-1) + prime_fib(n-2)\n\
    \    end\n  end\nend", "  if n < 2 then\n    return 1\n  elseif n == 1 then\n\
    \    return 2\n  else\n    local i = 2\n    local sum = 0\n    while i <= n do\n\
    \      sum = sum + i\n      if i == n then\n        return sum\n      else\n \
    \       i = i + 1\n      end\n    end\n  end\nend", "  return math.floor((math.pow(2,n)\
    \ - math.pow(3,n)) + math.log(n))\nend", "    local m = 1\n    while m <= n do\n\
    \        local t = n\n        n = n + 1\n        if t % 2 == 0 then t = t / 2\
    \ end\n        if t % m == 0 then return t end\n        m = m + 1\n    end\n \
    \   return n\nend", "    local i = 2\n    local fibnum = 1\n    while i <= n do\n\
    \        fibnum = fibnum + i\n        i = i + 1\n    end\n    if fibnum == n and\
    \ is_prime(fibnum) then\n        return fibnum\n    else\n        return nil\n\
    \    end\nend", "   local i = 2\n   while i <= n do\n      if primes[i] == nil\
    \ then\n         primes[i] = i\n      else\n         i = i + 1\n      end\n  \
    \ end\n   return primes[n]\nend", "  if n < 2 then return 1 end\n  if n < 4 then\
    \ return n end\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "   if n ==\
    \ 2 then\n      return 1\n   elseif n == 3 then\n      return 2\n   elseif n%2\
    \ == 0 then\n      local p = prime_fib(math.floor(n/2))\n      if n % p == 0 then\n\
    \         return p\n      else\n         return n\n      end\n   else\n      local\
    \ p\n      local q = (2*n+1)/2\n      while q < n do\n         local r = prime_fib\
    \ (q)\n         if r * r <= n then\n            p = r\n         end\n        \
    \ q = q + 2\n      end\n      return p\n   end\nend", "   if n < 2 then\n    \
    \  return n\n   end\n   if n == 1 then\n      return 2\n   end\n   local fib =\
    \ 3\n   local i = 2\n   while fib < n do\n      fib = 3 + fib -- this is faster\n\
    \      i = i + 2\n   end\n   return fib\nend", "\t-- Base case\n\tif n == 1 then\
    \ return 2 end\n\t-- Recursive case\n\tif n <= 1 then return 1 end\n\treturn prime_fib(n\
    \ - 2) + prime_fib(n - 1) \nend", "  if n < 2 then\n    return 1\n  end\n  if\
    \ n == 2 then\n    return 2\n  end", "  if n < 2 then\n    return n\n  end\n \
    \ if n == 2 then\n    return 2\n  end\n  if n == 3 then\n    return 5\n  end\n\
    \  local x = prime_fib(n - 1)\n  return x + x + x\nend", "  -- Base cases: n <\
    \ 0, n = 0 or 1, n = 1\n  if n <= 0 then return 0 end\n  if n == 1 then return\
    \ 1 end", "   local a,b=1,1\n   if n == 0 then return 1 end\n   repeat\n     \
    \ a=b\n      b=a+b\n   until b > n\n   return b\nend", "  if n == 1 or n == 2\
    \ then\n    return 2\n  elseif n % 2 == 0 then\n    return prime_fib(n - 2) +\
    \ prime_fib(n - 1)\n  else\n    return prime_fib(n - 1) + prime_fib(n - 2)\n \
    \ end\nend", "  if n < 2 then\n    return 1\n  elseif n == 1 then\n    return\
    \ 2\n  elseif n == 2 then\n    return 3\n  end", "  -- base case\n  if n == 1\
    \ then\n    return 2\n  elseif n == 0 then\n    return 1\n  end", "   if n < 2\
    \ then return end\n   if n % 2 == 0 then\n      prime_fib(n-2)\n   else\n    \
    \  if n % 3 == 0 then\n         prime_fib(n-3)\n      else\n         if n % 5\
    \ == 0 then\n            prime_fib(n-5)\n         else\n            prime_fib(n+2)\n\
    \         end\n      end\n   end\nend", "  local is_fib = false\n  local is_prime\
    \ = true\n  local result = nil", "  if n <= 0 then return 0 end\n  if n == 1 or\
    \ n == 2 then return 1 end\n  return prime_fib(n-1) + prime_fib(n-2)\nend", " \
    \ if n < 2 then return n end\n  if n == 2 then return 3 end\n  if n == 3 then\
    \ return 5 end\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "  if n <\
    \ 2 then\n    return nil\n  end\n  local primes, cprime = {}, {}\n  primes[1]\
    \ = primes[2] = 2\n  for i=3,n,1 do\n    local prod = 1\n    for j=1,i do\n  \
    \    prod = prod*primes[j]\n    end\n    if prod > 2 then\n      primes[#primes+1]\
    \ = prod\n      cprime[#cprime+1] = i\n    end\n  end\n  local fibs = primes\n\
    \  local fibs_cprime = cprime\n  local c = 0\n  local next, previous, cprime =\
    \ 0, {}, {}\n  for i=2,#fibs,1 do\n    next, previous = fibs[i], fibs[i-1]\n \
    \   cprime[i] = #cprime\n    for j=1,cprime[i] do\n      cprime[j+1] = cprime[j]\n\
    \    end\n    if next > previous then\n      fibs[i], fibs[i-1] = fibs[i-1], next\n\
    \      cprime[cprime[i]], cprime[cprime[i]-1] = cprime[cprime[i]-1], cprime[cprime[i]]\n\
    \    else\n      fibs_cprime[cprime[i]] = cprime[i]\n    end\n  end\n  return\
    \ fibs[#fibs]\nend", "  local a, b = 2, 1\n  local i = 1\n  while i <= n do\n\
    \    local a, b = b, a + b\n    i = i + 1\n  end\n  return b\nend", "  local a,\
    \ b, c = 0, 1, 1\n  repeat\n    a, b = b, a+b\n    c, d = d+1, c+d\n  until (c%n\
    \ == 0 and b == c*a) or c == n\n  return b\nend", "  -- base case\n  if n < 2\
    \ then\n    return 1\n  elseif n < 5 then\n    return 2\n  elseif n < 11 then\n\
    \    return 3\n  elseif n < 20000000 then\n    return 5\n  else\n    -- n = 20000000\
    \ - 1\n    local m = n / 20000001\n    -- n = 3, m = 5\n    return prime_fib(m)\
    \ * prime_fib(n - m)\n  end\nend", "  local ret\n  if n <= 1 then\n    return\
    \ n\n  end\n  if n < 2 then\n    return 1\n  end\n  if n % 2 == 0 then\n    return\
    \ prime_fib(n - 1) + prime_fib(n - 2)\n  end\n  ret = prime_fib(n / 2)\n  ret\
    \ = ret + prime_fib(n / 2) - 1\n  return ret\nend", "  if n <= 1 then\n    return\
    \ 1\n  else\n    if n % 2 == 0 then\n      return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n    end\n    return prime_fib(n / 2)\n  end\nend", "    if n < 2 then\n\
    \        return nil\n    end\n    if n == 2 then\n        return 1\n    end\n\
    \    if n == 3 then\n        return 2\n    end\n    if n < 8 then\n        return\
    \ prime_fib(n - 2) + prime_fib(n - 3)\n    end\n    return prime_fib(n - 2) +\
    \ prime_fib(n - 4)\nend", "  if n == 1 then return 1 end\n  if n == 2 then return\
    \ 2 end", "    local a, b, i, fibs, n = n, 1, {}, 0, n\n    repeat\n        a,\
    \ b = b, a+b\n        i = i + 1\n        fibs[i] = a\n    until (a > b) or (i\
    \ > n)\n    return fibs[i]\nend", "  if n == 1 or n == 2 then\n    return n\n\
    \  else\n    return prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend", "  if n\
    \ == 1 then\n    return 2\n  elseif n == 2 then\n    return 3\n  end\n  local\
    \ fibs = prime_fib_cache[n]\n  if fibs == nil then\n    fibs = prime_fib_cache[n]\
    \ = [2]\n    local prev, current, next = 3, 1, 3\n    while next <= n do\n   \
    \   local tmp = current\n      current = prev + current\n      prev = tmp\n  \
    \    fibs[next] = current\n      next = current + prev\n    end\n  end\n  return\
    \ fibs[n]\nend", "  if n < 2 then return 1 end\n  if n == 2 then return 1 end\n\
    \  if n == 3 then return 2 end\n  if n % 2 == 0 then\n    local t = prime_fib(math.floor(n\
    \ / 2)) -- even number\n    if n % 4 ~= 0 then return t + t else return t end\
    \ -- odd number\n  end\n  local a = prime_fib(math.floor(n / 2)) -- even number\n\
    \  local b = prime_fib(math.floor(n / 2)) -- even number\n  local m = 3\n  while\
    \ m <= n do\n    local temp = a % n\n    a = b\n    b = temp\n    m = m + 1\n\
    \  end\n  return b\nend", "\tlocal a = 1\n\tlocal b = 2\n\tlocal x\n\twhile b\
    \ < n do\n\t\tx = a + b\n\t\ta = b\n\t\tb = x\n\tend\n\treturn x\nend", "\tlocal\
    \ fib = 3\n\tlocal i = 1\n\twhile fib < n do\n\t\tfib = fib + i\n\t\ti = i * 2\n\
    \tend\n\treturn fib\nend", "  if n < 1 then return nil; end\n  if n == 1 or n\
    \ == 2 then return n; end\n  if n % 2 = 0 then\n    return prime_fib(n / 2)\n\
    \  else\n    return prime_fib(3 * n + 1)\n  end\nend", "   if n < 2 then return\
    \ n end\n   if n < 4 then return 2 end\n   if n < 11 then return 3 end\n   if\
    \ n < 17 then return 5 end\n   return prime_fib(n - 1) + prime_fib(n - 2)\nend",
  "  -- A generator that returns the n'th number in the Fibonacci sequence\n  -- or\
    \ throws an exception if n is not a positive integer\n  local fib = {0, 1}\n \
    \ local cur\n  while true do\n    cur = fib[1]\n    fib = fib {\n      cur + cur,\n\
    \      cur\n    }\n    if cur > n then\n      return cur\n    end\n  end\nend",
  "    -- base case\n    if n < 2 then\n        return n\n    -- find n-th fibonacci\
    \ number\n    else if n < 5 then\n        local a = 1\n        local b = 2\n \
    \       while b < n do\n            local c = a + b\n            a = b\n     \
    \       b = c\n        end\n        return b\n    -- find n-th fibonacci number\
    \ using Sieve of Eratosthenes\n    else\n        local fib_list = {}\n       \
    \ local prime_numbers = prime_list(n - 1)\n        for prime_number = 2, #prime_numbers\
    \ do\n            local fib = 0\n            local i = 2\n            while fib\
    \ < prime_number do\n                fib = fib + prime_numbers[i-1]\n        \
    \        i = i + 1\n            end\n            if fib < n then\n           \
    \     fib_list[prime_number] = fib\n            end\n        end\n        return\
    \ fib_list[prime_numbers[n]]\n    end\nend", "  if n < 2 then return 1 end\n \
    \ if n == 1 or n == 2 then return 1 end\n  if n % 2 == 0 then return prime_fib(n\
    \ / 2) end\n  if prime_fib(n / 2) == n then return n end\n  if prime_fib(3 * n\
    \ + 1) == n then return n end\n  return prime_fib(3 * n + 1) - prime_fib(n / 2)\
    \ + 1\nend", "  -- prerequisites: n is an integer and n > 0\n  if n == 1 then\n\
    \    return 1\n  elseif n < 2 then\n    return nil\n  else\n    local a,b=1,1\n\
    \    repeat\n      a,b = b, a+b\n      n = n/2\n    until n > 1\n    return b\n\
    \  end\nend", "  if n <= 1 then return n end\n  local fib1, fib2 = 1, 1\n  for\
    \ i = 2, n do\n    local m = fib1 + fib2\n    fib1, fib2 = fib2, m\n  end\n  return\
    \ fib2\nend", "  if n < 2 then return 2 end\n  local m\n  local p = 2\n  repeat\n\
    \    m = n % p\n    n = p\n    p = p + m\n  until n >= 2\n  return p\nend", " \
    \ -- The idea behind this is to reduce the number of recursive calls.\n  -- The\
    \ Fibonacci sequence is defined as:\n  --\n  --    0, 1, 1, 2, 3, 5, 8, 13, 21,\
    \ 34, 55, 89, ...\n  --\n  -- and it can be easily verified that any number greater\
    \ than or equal to the\n  -- first two numbers can always be expressed as the\
    \ sum of the preceding two.\n  --\n  --    1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\
    \ ...\n  --\n  -- is congruent to (1 + 2) and (1 + 3) and so on.\n  --\n  -- \
    \   1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n  --\n  -- is congruent to (4 +\
    \ 8) and (5 + 13) and so on.\n  --\n  --    1, 1, 2, 3, 5, 8, 13, 21, 34, 55,\
    \ 89, ...\n  --\n  -- is congruent to (9 + 21) and (13 + 34) and so on.\n  --\n\
    \  -- We use Lua to generate these numbers, not Python as it's much faster\n \
    \ -- for our purposes.\n  --\n  -- for n = 1, #fib do\n  --     return fib[n]\n\
    \  -- end", "  if n < 2 then return n end\n  if n == 2 then return 3 end\n  if\
    \ n == 3 then return 5 end\n  return prime_fib(n - 3) + prime_fib(n - 2)\nend",
  "    if n <= 1 then\n        return n\n    elseif n == 2 then\n        return 1\n\
    \    else\n        local a = prime_fib(n-1)\n        local b = prime_fib(n-2)\n\
    \        return a + b\n    end\nend", "  if n == 1 then return 1 end\n  if n ==\
    \ 2 then return 2 end\n  local function fibonacci(n)\n    if n <= 1 then return\
    \ n end\n    return fibonacci(n - 1) + fibonacci(n - 2)\n  end\n  return fibonacci(n)\
    \ - 1 -- subtracts 1 to exclude the first number\nend", "  -- if n is prime then\
    \ return it's Fibonacci number\n  if n < 2 then return n end\n  -- return n-th\
    \ Fibonacci number\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "\tlocal\
    \ p = 1\n\tlocal m = 2\n\trepeat\n\t\tlocal c = math.floor((p + m) / 2)\n\t\t\
    if p < c then\n\t\t\tm = p\n\t\telseif c == p then\n\t\t\tbreak\n\t\telse\n\t\t\
    \tp = c\n\t\t\tm = p + m + 1\n\t\tend\n\tuntil p == c + 1\n\treturn c\nend", " \
    \ if n < 2 then return 0 end\n  local a = prime_fib(n-1)\n  return a*a + n\nend",
  "  -- calculate nth fibonacci number and return it\n  if n <= 1 then return n end\n\
    \  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "  if n == 0 then\n    return\
    \ 1\n  end\n  if n == 1 then\n    return 2\n  end\n  if n % 2 == 0 then\n    return\
    \ prime_fib(n - 1) + prime_fib(n - 2)\n  else\n    return prime_fib(n - 2) + prime_fib(n\
    \ - 3)\n  end\nend", "  local function is_fibonacci_number(x)\n    return x >=\
    \ 0 and isnumber(x) and math.mod(x, 2) == 0 and math.sqrt(x) % 1 == 0\n  end\n\
    \  -- check if input is integer and smaller than or equal to 10\n  if n < 1 or\
    \ math.ceil(n) ~= n then return nil end\n  if is_fibonacci_number(n) then return\
    \ n end\n  local a, b, c = 0, 1, 1\n  repeat\n    local tmp = a\n    a, b = b,\
    \ a + b\n  until (b > n) or (b == n and is_fibonacci_number(c))\n  return c\n\
    end", "  -- base case\n  if n < 2 then\n    return n\n  end\n  \n  -- base cases\n\
    \  if n == 1 or n == 2 then\n    return 1\n  end", "    -- Base case\n    if n\
    \ == 0 or n == 1 then\n        return true\n    end\n    -- Recursive case\n \
    \   if n < 2 then\n        return false\n    end\n    -- Find the sum of all numbers\
    \ that are <= to the number n\n    local i = 1\n    local sum_n = 0\n    local\
    \ j = 1\n    while i <= n do\n        local q = i\n        while q <= n and q\
    \ > i do\n            q = q + 1\n        end\n        if j % 2 == 0 then\n   \
    \         if q % 2 == 0 then\n                sum_n = sum_n + (q * q)\n      \
    \      end\n        end\n        i = i + 1\n        j = j + 1\n    end\n    sum_n\
    \ = sum_n / 2\n    -- Return whether or not the number is a Fibonacci number\n\
    \    if sum_n % 2 == 1 then\n        return false\n    end\n    return true\n\
    end", "    local i = 1\n    local fib\n    while i <= n do\n        fib = fib\
    \ + ((i - 1) ^ 2 + 1) -- fibonacci\n        i = i + 1\n    end\n    return fib\n\
    end", "  if n == 1 or n == 2 then return 1 end\n  if n % 2 == 0 then return prime_fib(n\
    \ / 2) end\n  if n % 3 == 0 then return prime_fib(n / 3) end\n  return prime_fib(3\
    \ * n + 1) - 1\nend", "\tif n < 2 then return 2 else return prime_fib(n-2) + prime_fib(n-1)\n\
    end", "  local fibs = {}\n  fibs[1] = 1\n  fibs[2] = 1\n  for i = 4; i <= n; i\
    \ += 1 do\n    fibs[i] = fibs[i-2] + fibs[i-1]\n  end\n  return fibs[n]\nend",
  "    if n < 2 then\n        return n\n    end", "  if n < 2 then return n end\n\
    \  if n == 2 then return 1 end\n  if n < 3 then return 2 end\n  local a, b = prime_fib(n\
    \ - 2), prime_fib(n - 1)\n  return b + b - a\nend", "  -- Base case: n is 0 or\
    \ 1.\n  if n == 0 or n == 1 then\n    return 2\n  -- Sieve of Eratosthenes: see\
    \ http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.\n  elseif n % 2 == 0 then\n\
    \    return prime_fib(n / 2) \n  else\n    local m = prime_fib(n / 2)\n    local\
    \ i = 0\n    while prime_fib(2 * i + m) <= n do\n      i = i + 1\n    end\n  \
    \  return 2 * i + m\n  end\nend", "\tassert(n >= 1 and n <= 100, \"n should be\
    \ between 1 and 100.\")\n\tlocal a = math.pow(2, n-1)\n\tlocal b = math.pow(2,\
    \ n)\n\treturn (a == b and n) or a + b\nend", "  -- calculate n-th fibonacci number\n\
    \  -- by summing up terms up to n\n  -- http://stackoverflow.com/questions/16301610/how-to-write-the-fibonacci-sequence-in-python\n\
    \  local fib_cache = {[n]=1}\n  local function f(n)\n    return fib_cache[n] or\
    \ f(n-1) + f(n-2)\n  end\n  -- return n-th Fibonacci number\n  return f(n)\nend",
  "  local i\n  for i=2,n do\n    if n % i == 0 then return false end\n  end\n  return\
    \ true\nend", "    local fibs = {}\n    fibs[1] = 2\n    fibs[2] = 2\n    for\
    \ i = 3, n, 1 do\n        fibs[i] = fibs[i-1] + fibs[i-2]\n    end\n    return\
    \ fibs[n]\nend", "  local fib = (n - 1) + (n - 2)\n  if fib <= 1 then return 1\
    \ end\n  if fib > n then return n end\n  return prime_fib(fib)\nend", "    if\
    \ n == 1 then\n        return 1\n    end", "\tif n < 2 then\n\t\treturn n\n\t\
    elseif n <= 1 then\n\t\treturn 1\n\telse\n\t\tlocal prev_p, prev_q = prime_fib(n\
    \ - 1)\n\t\tlocal p = prev_p + 1\n\t\tlocal q = prev_q + 1\n\t\twhile q <= n do\n\
    \t\t\tif n % q == 0 then\n\t\t\t\tlocal t = p\n\t\t\t\tp = q\n\t\t\t\tq = t\n\t\
    \t\telse\n\t\t\t\tq = q + 1\n\t\t\tend\n\t\tend\n\t\treturn p\n\tend\nend", " \
    \  if n < 2 then\n      return n\n   else\n      return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n   end\nend", "  if n < 2 then return 1 end\n  if n < 5 then return 2\
    \ end\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "    local function\
    \ get_prime(first,second)\n        if second == nil then\n            if first\
    \ == 0 then\n                return 1\n            else\n                first\
    \ = first - 1\n                return get_prime(first,second)\n            end\n\
    \        else\n            if first == 1 then\n                return second\n\
    \            else\n                first = first - 1\n                second =\
    \ second - 1\n                return get_prime(first,second)\n            end\n\
    \        end\n    end\n    return get_prime(n,n)\nend", "  local p = 0\n  local\
    \ q = 1\n  local r = p\n  while r * p < n do\n    p = q\n    q = r\n    r = r\
    \ + q\n  end\n  return r\nend", "\tlocal n1 = n - 1\n\tif n == 1 or n == 2 then\n\
    \t\treturn n\n\telse\n\t\tlocal n2 = n - 2\n\t\tif n2 == 1 or n2 == 2 then\n\t\
    \t\treturn n2\n\t\telse\n\t\t\tlocal n3 = n - 3\n\t\t\tif n3 == 1 or n3 == 2 then\n\
    \t\t\t\treturn n3\n\t\t\telse\n\t\t\t\tlocal n4 = n - 4\n\t\t\t\tif n4 == 1 then\n\
    \t\t\t\t\treturn n4\n\t\t\t\telse\n\t\t\t\t\tlocal n5 = n - 5\n\t\t\t\t\tif n5\
    \ == 1 then\n\t\t\t\t\t\treturn n5\n\t\t\t\t\telse\n\t\t\t\t\t\tlocal n6 = n -\
    \ 6\n\t\t\t\t\t\tif n6 == 1 then\n\t\t\t\t\t\t\treturn n6\n\t\t\t\t\t\telse\n\t\
    \t\t\t\t\t\tlocal n7 = n - 7\n\t\t\t\t\t\t\tif n7 == 1 then\n\t\t\t\t\t\t\t\t\
    return n7\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tlocal n8 = n - 8\n\t\t\t\t\t\t\t\
    \tif n8 == 1 then\n\t\t\t\t\t\t\t\t\treturn n8\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\
    \t\t\t\t\tlocal n9 = n - 9\n\t\t\t\t\t\t\t\t\tif n9 == 1 then\n\t\t\t\t\t\t\t\t\
    \t\treturn n9\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tlocal n10 = n - 10\n\
    \t\t\t\t\t\t\t\t\t\tif n10 == 1 then\n\t\t\t\t\t\t\t\t\t\t\treturn n10\n\t\t\t\
    \t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tlocal n11 = n - 11\n\t\t\t\t\t\t\t\t\
    \t\t\tif n11 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\treturn n11\n\t\t\t\t\t\t\t\t\t\
    \t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tlocal n12 = n - 12\n\t\t\t\t\t\t\t\t\t\t\t\t\
    if n12 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn n12\n\t\t\t\t\t\t\t\t\t\t\t\
    \telse\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocal n13 = n - 13\n\t\t\t\t\t\t\t\t\t\t\t\t\
    \tif n13 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn n13\n\t\t\t\t\t\t\t\t\t\
    \t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal n14 = n - 14\n\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\tif n14 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn n14\n\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal n15 = n - 15\n\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n15 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \treturn n15\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\tlocal n16 = n - 16\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n16 == 1 then\n\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn n16\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal n17 = n - 17\n\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\tif n17 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn n17\n\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal\
    \ n18 = n - 18\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n18 == 1 then\n\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\treturn n18\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal n19 = n - 19\n\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\tif n19 == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn\
    \ n19\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\tlocal n20 = n - 20\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n20\
    \ == 1 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn n20\n\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal\
    \ n21 = n - 21\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n21 == 1 then\n\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn n21\n\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal n22",
  "  if n < 2 then return 2 end\n  if n < 3 then return n end\n  if prime_fib(n-2)\
    \ == 2 then return 3 end\n  -- start from 5\n  local f = 0\n  local g = 5\n  while\
    \ g < n do\n    local k = g + f\n    -- if k is a Fibonacci number, then g+f is\
    \ not a Fibonacci number so the function end\n    local j = prime_fib( k - 1 )\n\
    \    if j == g then break end\n    g = j\n    f = k - g\n  end\n  return g + f\n\
    end", "  -- base case\n  local n = n or 0\n  if n < 2 then return 1 end\n  --\
    \ recursive case\n  if n == 1 then\n    return 1\n  else\n    local p = prime_fib(n\
    \ - 1)\n    return p * p\n  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThank\
    \ you!  I had tried this, but left off the 'return' keyword when calling prime_fib.\
    \  Once I put 'return' in, it worked.\n<|/ c |>\n<| c |>\nThis should be the answer\
    \ as it uses the correct method for the problem and does a better job at explaining\
    \ it!\n<|/ c |>\n<| a dscore=4 tags=lua,fibonacci |>\n<code>\nfib = function()\
    \ local n = 0 ; local a = 0 ; local b = 1 ; while n <= 20 do n = a + b .. b ;\
    \ a = b ; b = n ; end ; return n end\n</code>\n<|/ a |>\n<| a |>\n<code>", " \
    \ if n == 1 then\n    return 2\n  elseif n == 2 then\n    return 3\n  else\n \
    \   local res, limit = prime_fib(n / 2), n / 2\n    while res - 2 <= limit do\n\
    \      res = prime_fib(res + 1)\n    end\n    return res\n  end\nend", "\t-- first\
    \ test if n is odd and if it is then the answer is n-1\n\tif (n%2 == 0) and (n\
    \ > 1) then\n\t\treturn n-1\n\tend\n\t-- if n is even then first test if it's\
    \ prime (prime) or not and if it\n\t-- is, then the answer is n-1\n\t-- prime\
    \ is defined as one that divides evenly into 2 without remainder\n\tlocal prime_check\
    \ = 0\n\tlocal prime_test = 2\n\t-- loop while the prime_test is smaller than\
    \ n or the prime_check\n\t-- divides evenly into n\n\twhile prime_test <= n do\n\
    \t\t-- if prime_test divides evenly into n then\n\t\tif (prime_test % n == 0)\
    \ and (prime_test > n) then\n\t\t\t-- set prime_check to n and exit\n\t\t\tprime_check\
    \ = n\n\t\t\tbreak\n\t\tend\n\t\t-- set prime_check to n+1\n\t\tprime_check =\
    \ prime_test + 1\n\t\t-- increment prime_test\n\t\tprime_test = prime_test + 1\n\
    \tend\n\treturn prime_check\nend", "    local n = math.min(n or 2, 52)\n    local\
    \ function prime_n(n) -- find n-th fibonacci number with prime property.\n   \
    \     if n < 2 then return nil end\n        if n % 2 == 0 then return prime_n(n-2)\
    \ end\n        return prime_n(n - 3) + (prime_n(n - 5) * (n - 7))\n    end\n \
    \   return prime_n(n)\nend", "  if n < 2 then\n    return 1\n  else\n    local\
    \ m = prime_fib(n - 1)\n    local n2 = m * 2\n    local n4 = n2 * 2\n    local\
    \ n8 = n4 * 2\n    local n16 = n8 * 2\n    return n16 + n8\n  end\nend", "   \
    \ local limit = 1\n    if n > limit then\n        limit = n\n    end\n    local\
    \ fib_numbers = {}\n    fib_numbers[1] = 1\n    local next_num = 1\n    for i\
    \ = 2, limit do\n        local new_num = next_num\n        next_num = fib_numbers[new_num]\
    \ + fib_numbers[new_num + 1]\n        table.insert(fib_numbers, new_num)\n   \
    \ end\n    local prime_num = fib_numbers[limit]\n    return prime_num\nend", " \
    \ -- write your code here\n  local fib = 1\n  local i = 2\n  while i ~= n do\n\
    \    fib = fib + i\n    i = i + 1\n  end\n  return fib\nend", "   if n < 2 then\n\
    \      return 2\n   end\n   if n < 5 then\n      return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n   end\n   if n % 2 == 0 then\n      return prime_fib(n / 2) + prime_fib(3\
    \ * n + 1)\n   else\n      return prime_fib(3 * n + 1)\n   end\nend", "    local\
    \ function f(n)\n        if n < 2 then\n            return n\n        else\n \
    \           return f(n-1) + f(n-2)\n        end\n    end\n    return f(n)\nend",
  "  if n == 1 then return 1 end\n  if n == 2 then return 2 end\n  if n == 3 then\
    \ return 3 end", "  if n <= 1 then\n    return 1\n  else\n    return prime_fib(n\
    \ - 1) + prime_fib(n - 2)\n  end\nend", "  if n <= 2 then return n end\n  return\
    \ prime_fib(n - 1) + prime_fib(n - 2)\nend", "  -- Base cases:\n  if n == 1 then\
    \ return 1 end\n  if n == 2 then return 2 end", "  if n<2 then\n    return 1\n\
    \  end\n  local fib=1,1\n  local i\n  for i=3,n-1 do\n    fib=fib+fib\n  end \n\
    \  if  fib%n==0 then\n    return fib\n  else\n    return prime_fib(n-1)\n  end\n\
    end", "  if n < 2 then\n    return 1\n  elseif n < 3 then\n    return 1\n  elseif\
    \ n % 2 == 0 then\n    return prime_fib(n / 2)\n  elseif n % 3 == 0 then\n   \
    \ return prime_fib(n / 3) + 1\n  end\nend", "  if n <= 1 then return n end\n \
    \ local s = prime_fib(n - 2)\n  return s + s if n <= 3 then s else nil end\nend",
  "  if n == 2 then return 2 end\n  if n == 3 then return 3 end\n  if n == 0 then\
    \ return 0 end\n  if n < 0 then\n    error('Prime fibonacci number must be >=\
    \ 0')\n  end\n  local fib = 0\n  local i = 1\n  while i < n do\n    fib = fib\
    \ + i\n    i = i + 2\n  end\n  return fib\nend", "\t-- this function is used to\
    \ return n-th number that is a Fibonacci number and it's also prime.\n\t-- >>>\
    \ prime_fib(1)\n\t-- 2\n\t-- >>> prime_fib(2)\n\t-- 3\n\t-- >>> prime_fib(3)\n\
    \t-- 5\n\t-- >>> prime_fib(4)\n\t-- 13\n\t-- >>> prime_fib(5)\n\t-- 89\n\tlocal\
    \ n1 = 1\n\tlocal n2 = 1\n\tlocal count = 0\n\tlocal result = 0\n\t-- this loop\
    \ is used for returning n-th number that is a Fibonacci number and it's also prime.\n\
    \twhile count < n do\n\t\t-- this if condition is used to check whether n2 is\
    \ Fibonacci number.\n\t\tif n2 == 1 then\n\t\t\t-- n2 is equal 1 and n2 is also\
    \ prime.\n\t\t\t-- this if condition is used to decrement count by 1.\n\t\t\t\
    count = count - 1\n\t\t\tresult = result + n2\n\t\t\t-- this if condition is used\
    \ to add n1 after decrement.\n\t\t\tn1 = n2\n\t\t\t-- this if condition is used\
    \ to add n2 after addition.\n\t\t\tn2 = n1 + n2\n\t\t\t-- this if condition is\
    \ used to reset n1 and n2.\n\t\t\tn1 = 1\n\t\t\tn2 = 1\n\t\telse\n\t\t\t-- n2\
    \ is equal n1 and n2 is also prime.\n\t\t\t-- this if condition is used to add\
    \ n1 after addition.\n\t\t\tn1 = n1 + n2\n\t\t\t-- this if condition is used to\
    \ add n2 after addition.\n\t\t\tn2 = n1 + n2\n\t\t\t-- this if condition is used\
    \ to reset n1 and n2.\n\t\t\tn1 = 1\n\t\t\tn2 = 1\n\t\tend\n\t\t-- this loop is\
    \ used to check whether n2 has exceeded the number n.\n\t\tif n2 > n then\n\t\t\
    \t-- n2 is greater than number n.\n\t\t\t-- this if condition is used to add n1\
    \ after addition.\n\t\t\tn1 = n1 + n2\n\t\t\t-- this if condition is used to add\
    \ n2 after addition.\n\t\t\tn2 = n1 + n2\n\t\t\t-- this if condition is used to\
    \ reset n1 and n2.\n\t\t\tn1 = 1\n\t\t\tn2 = 1\n\t\telse\n\t\t\t-- n2 is equal\
    \ to n.\n\t\t\t-- this if condition is used to decrement count by 1.\n\t\t\tcount\
    \ = count - 1\n\t\t\t-- this if condition is used to return result.\n\t\t\tresult\
    \ = result + n2\n\t\t\t-- this if condition is used to reset n1 and n2.\n\t\t\t\
    n1 = n2\n\t\t\tn2 = n1 + n2\n\t\tend\n", "   -- first case: n = 1\n   if (n ==\
    \ 1) then\n      return 2\n   -- second case: n = 2\n   elseif (n == 2) then\n\
    \      return 3\n   -- third case: n = 5 or less\n   elseif (n < 5) then\n   \
    \   return prime_fib(n - 1) + prime_fib(n - 2)\n   end\n   -- fourth case: n =\
    \ 4\n   local r = prime_fib(n - 3)\n   -- r = prime number\n   if r == 2 then\n\
    \      return 2\n   -- if r is not a prime, then\n   -- r = fib(n - 2) (with remainder\
    \ r - 1)\n   elseif r == 1 then\n      return 1\n   else\n      return r\n   end\n\
    end", "\tif n <= 1 then\n\t\treturn n\n\telseif n % 2 == 0 then\n\t\treturn prime_fib(n\
    \ / 2) + prime_fib(n / 2)\n\telse\n\t\treturn prime_fib(n / 2) - prime_fib(n /\
    \ 2)\n\tend\nend", "  if n < 2 then return 1 end\n  if n == 2 then return 1 end\n\
    \  if n == 1 then return 2 end\n  local a, b, c, d = 0, 1, 1, 2\n  repeat\n  \
    \  c = b\n    b = a\n    a = d\n    d = c + d\n  until a > d\n  return d\nend",
  "  if n < 2 then\n    return 0\n  end\n  if n == 2 then\n    return 1\n  end\n \
    \ if n == 3 then\n    return 2\n  end\n  if n % 2 == 0 then\n    return prime_fib(n\
    \ - 1) + prime_fib(n - 2)\n  else\n    return prime_fib(n - 1) + prime_fib(n -\
    \ 3)\n  end\nend", "  if n < 1 then\n    -- Prime numbers are divisible by themselves.\n\
    \    return 1\n  elseif n < 2 then\n    -- Prime numbers are even numbers.\n \
    \   return 2\n  elseif n < 3 then\n    -- Prime numbers are odd.\n    return 1\n\
    \  else\n    -- If n is divisible by 2, then it is a prime number.\n    if n %\
    \ 2 == 0 then\n      return n\n    end", "    local function fib_iter(n,f,p,q,r)\n\
    \        if n == 0 or n == 1 then\n            return p, q\n        end", "  \
    \ if n < 2 then\n      return 1;\n   end\n   if n < 5 then\n      return prime_fib(n\
    \ - 1) + prime_fib(n - 2);\n   end\n   return prime_fib(n - 3) + prime_fib(n -\
    \ 5);\nend", "  local i\n  if n == 0 then\n    return 1\n  elseif n == 1 then\n\
    \    return 2\n  else\n    i = 3\n    local fib_value = 1\n    while i <= n do\n\
    \      local j\n      j = i + 2\n      fib_value = fib_value + j\n      i = j\n\
    \    end\n    return fib_value\n  end\nend", "\tlocal primes={}\n\tprimes[1]=2\n\
    \tprimes[2]=3\n\tprimes[3]=primes[1]+primes[2]\n\tprimes[4]=primes[3]+primes[1]\n\
    \tprimes[5]=primes[4]+primes[3]\n\tfor i=6,primes[5],2 do\n\t\tprimes[i]=primes[i-1]+primes[i-2]\n\
    \tend\n\treturn primes[n]\nend", "  local i = n - 1\n  local f = 1\n  while i\
    \ <= 2 do\n    i = i / 2\n    f = f + i\n  end\n  return f\nend", "  if n < 2\
    \ then\n    return 1\n  else\n    return prime_fib(n - 1) + prime_fib(n - 2)\n\
    \  end\nend", "  if n < 2 then\n    return n\n  elseif n == 2 then\n    return\
    \ 2\n  elseif n % 2 == 0 then\n    return prime_fib(n / 2)\n  elseif n <= 10 then\n\
    \    return prime_fib(n - 1) + prime_fib(n - 2)\n  else\n    return prime_fib(n\
    \ % 6) + prime_fib(n % 6 + 1)\n  end\nend", "  local limit = tonumber(n)\n  limit\
    \ = limit or 10\n  if limit == 0 then\n    return 1\n  end\n  if limit < 2 then\n\
    \    return 0\n  end\n  if limit == 1 then\n    return 1\n  end\n  local a = 1\n\
    \  local b = 1\n  local c = 0\n  repeat\n    local num = math.pow(a, 0.5) + math.pow(b,\
    \ 0.5)\n    local result = num % limit\n    c = c + result\n    a = b\n    b =\
    \ result\n  until c == limit - 1 and b == 0\n  return c\nend", "  if n < 2 then\
    \ return end\n  if n == 1 then return 2 end\n  if n == 2 then return 3 end\n \
    \ local fibs = prime_fib(n-1)\n  return fibs[#fibs] + fibs[#fibs+1]\nend", " \
    \ if n == 1 or n == 2 then\n    return n\n  end", "    -- Base Cases\n    if n\
    \ == 1 then return 2 end\n    if n == 0 then return 1 end\n    -- Recursive Cases\n\
    \    local a = prime_fib(n - 1)\n    local b = prime_fib(n - 2)\n    return a\
    \ * a + b * b\nend", "    if n < 2 then\n        return 1\n    end\n    if n <=\
    \ 3 then\n        return n\n    end\n    local result = 1\n    local fib = prime_fib(n\
    \ - 1)\n    for i = 2, n do\n        result = result + fib\n        fib = fib\
    \ * 2\n    end\n    return result\nend", "  local limit = 100000000\n  if n >\
    \ limit then\n    return nil\n  end\n  if n < 0 then\n    return nil\n  end\n\
    \  if n < 3 then\n    return n\n  end\n  local a = 1\n  local b = 1\n  local c\
    \ = 1\n  local d = 1\n  local n2 = 1\n  while c < n do\n    local e = (a + b)\
    \ % n\n    a, b, c = c, d, e\n    d, e = b - a, n2 - c\n    n2 = c\n  end\n  return\
    \ d\nend", "  local cache = {}\n  local a = 0\n  local b = 1\n  local c = 2\n\
    \  while c < n do\n    if cache[c] == nil then\n      if a == b then\n       \
    \ cache[c] = 1\n      else\n        cache[c] = a\n        a, b = b, a + b\n  \
    \    end\n    end\n    c = c + 1\n  end\n  return n\nend", "  if n == 1 or n ==\
    \ 2 then\n    return 2\n  elseif n % 2 == 0 then\n    return prime_fib(n / 2)\
    \ + prime_fib(n / 2)\n  else\n    return prime_fib(n / 3) + prime_fib(n / 5)\n\
    \  end\nend", "  if n < 2 then return n end\n  if prime[n] then return prime[n]\
    \ end\n  local ret,i = 1,1\n  for i=2,n do\n    local pf = i\n    while pf > 1\
    \ do\n      pf,i = pf,i-pf\n    end\n    if i == 1 then ret,prime[n] = i,n end\n\
    \  end\n  return ret\nend", "  local function is_prime(m)\n    local x = math.random()\n\
    \    local i = 1\n    while i <= m do\n      if ((x*x) % m == 0) then\n      \
    \  return false\n      end\n      i = i + 1\n    end\n    return true\n  end\n\
    \  local i = 1\n  while i <= n do\n    if is_prime(i) == true then\n      i =\
    \ i + 1\n    else\n      i = i - 1\n      break\n    end\n  end\n  return i\n\
    end", "  local x, y = 0, 1\n  if n == 1 or n == 2 then\n    return 1\n  end\n\
    \  for i = 2, n do\n    local p = x\n    x = y\n    y = p + y\n  end\n  return\
    \ y\nend", "  local fibs = {[1] = 0, [2] = 1}\n  for i = 2, n do\n    fibs[i]\
    \ = fibs[i - 1] + fibs[i - 2]\n  end\n  return fibs[n]\nend", "   if n==0 or n==1\
    \ then\n      return n\n   end\n   local a=1\n   local b=1\n   for i=2,n do\n\
    \      local p=a+b\n      if p<=n and n%p==0 then\n         return p\n      end\n\
    \      a=b\n      b=p\n   end\nend", "  -- If n is 0, then 0 fib number is also\
    \ a prime number.\n  if n == 0 then\n    return 0\n  end\n  -- Check if n is 1\
    \ or not.\n  if n ~= 1 then\n    -- Check if n is even.\n    if n mod 2 == 0 then\n\
    \      -- Return 1 as fib number for number even.\n      return 1\n    end\n \
    \   -- n is not even. Let n be the smaller number.\n    n = n + 1\n    -- Calculate\
    \ Fibonacci number for n.\n    local fibN = 1\n    for i=1,n do\n      fibN =\
    \ fibN + fibN\n    end\n    -- Check if fibN is prime.\n    return fibN % 2 ==\
    \ 0 and 1 or 0\n  end\nend", "    local n1 = n - (n % 2)\n    local n2 = n - (n\
    \ % 4)\n    local n3 = n - (n % 6)\n    local n4 = n - (n % 8)\n    local n5 =\
    \ n - (n % 10)\n    local n6 = n - (n % 12)\n    return n5 + n6 + n4 + n3 + n2\
    \ + n1 + 1\nend", "    local n2 = math.floor(n/2)\n    local n3 = n - n2\n   \
    \ if n2 <= 0 then\n        return nil\n    end\n    if n3 <= 0 then\n        return\
    \ n2\n    end\n    if n3 > n then\n        return nil\n    end\n    if prime_fib_cache[n3]\
    \ ~= nil then\n        return prime_fib_cache[n3]\n    end\n    if prime_fib_cache[n3]\
    \ ~= nil then\n        return prime_fib_cache[n3]\n    end\n    local primes =\
    \ prime_fib_cache[n - 3]\n    for i = 4, n3, 2 do\n        if primes[i] ~= nil\
    \ then\n            if primes[i] == n2 then\n                prime_fib_cache[n3]\
    \ = n2\n                return n2\n            end\n        end\n    end\n   \
    \ return prime_fib_cache[n3] = n2\nend\nprime_fib_cache = {}", "\tlocal a, b =\
    \ (n > 0 and 1 or 0,0)\n\tlocal f = math.max(n,2)\n\tlocal fp = f + 1\n\twhile\
    \ f < fp do\n\t\ta = a + b\n\t\tb = math.fmod(a + b, f)\n\t\tf = f+1\n\tend\n\t\
    return b\nend", "    local primes = {}\n    for i = 2, n do\n        primes[i]\
    \ = true\n    end\n    for i = 2, n do\n        if primes[i] then\n          \
    \  for j = i, n do\n                primes[j] = false\n            end\n     \
    \   end\n    end\n    return primes[n - 1]\nend", "    local function fibo(n)\n\
    \        if n == 0 then\n            return 1\n        end\n        local result\
    \ = fibo(n-1) + fibo(n-2)\n        return result\n    end\n    return fibo(n)\n\
    end", "  if n < 2 then\n    return 2\n  end\n  if n < 5 then\n    return n\n \
    \ end\n  if n % 2 == 0 then\n    return prime_fib(n / 2)\n  end\n  local result\
    \ = prime_fib(n - 1)\n  if n % 2 == 1 then\n    return result + result\n  end\n\
    \  return result\nend", "  if n <= 1 then return n end\n  return prime_fib(n -\
    \ 1) + prime_fib(n - 2)\nend", "  local fib_numbers = {0, 1}\n  repeat\n    local\
    \ current_number = fib_numbers[1] + fib_numbers[2]\n    local is_prime = true\n\
    \    -- Check for all prime numbers (except 0 and 1).\n    for i = 2, n do\n \
    \     is_prime = is_prime and current_number % i == 0\n    end\n    if is_prime\
    \ then\n      fib_numbers[1] = fib_numbers[2]\n      fib_numbers[2] = current_number\n\
    \    end\n    local current_index = 3\n    -- Test for Divisibility by all numbers\
    \ from 3 to n-1.\n    for i = 3, n do\n      if is_prime and current_index % i\
    \ == 0 then\n        -- This number is a prime number :)\n        break\n    \
    \  end\n      current_index = current_index + 1\n    end\n  until current_index\
    \ >= n\n  return current_number\nend", "\tlocal a, b = 0, 1\n\tfor i = 2, n do\n\
    \t\ta, b = b, a+b\n\tend\n\tif a == n then\n\t\treturn a\n\tend\n\treturn false\n\
    end", "  if n < 2 then\n    return n\n  elseif n == 2 then\n    return 2\n  elseif\
    \ n == 3 then\n    return 5\n  elseif n <= 5 then\n    return prime_fib(n - 1)\
    \ + prime_fib(n - 2)\n  end\nend", "  -- Base case\n  if n <= 1 then\n    return\
    \ n\n  end\n  -- Recursive case\n  if n < 5 then\n    return prime_fib(n - 1)\
    \ + prime_fib(n - 2)\n  end\n  -- Recursive case\n  if n < 10 then\n    return\
    \ prime_fib(n - 1) + prime_fib(n - 2) + prime_fib(n - 3)\n  end\n  -- Recursive\
    \ case\n  if n < 20 then\n    return prime_fib(n - 1) + prime_fib(n - 2) + prime_fib(n\
    \ - 3) + prime_fib(n - 4)\n  end\nend", "  if n < 2 then return n end\n  if n\
    \ == 1 then return 1 end\n  if n == 2 then return 2 end\n  if n % 2 == 0 then\n\
    \    return prime_fib(n-2) + prime_fib(n-1)\n  end\n  local m = 3\n  while m <=\
    \ n do\n    if n % m == 0 then\n      return prime_fib(m) + prime_fib(n-m)\n \
    \   end\n    m = m + 1\n  end\n  return n\nend", "   if n < 2 then return 1 end\n\
    \   if n == 2 then return 1 end\n   if n == 5 then return 2 end", "  -- Base condition\n\
    \  if n < 2 then\n    return 1\n  end", '    if n < 2 then return end', "  local\
    \ a = fib_prime(n)\n  local fib_a = a % n\n  local fib_b = fib_prime(fib_a)\n\
    \  -- this condition check is redundant but this way we avoid a loop\n  if fib_b\
    \ == fib_a then\n    return n\n  end\n  -- now fib_b is one less than fib_a so\
    \ it is possible that\n  --  fib_b mod n = fib_a mod n-1\n  -- we check that here\n\
    \  if fib_b - fib_a > 1 then\n    return prime_fib(fib_b)\n  end\n  return fib_a\n\
    end", "  if n <= 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n  end",
  "  if n <= 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n  else\n  \
    \  local a\n    local b\n    local i\n    local m\n    for i = 2, n do\n     \
    \ local tmp = a\n      a = b\n      b = tmp + b\n    end\n    m = n / 2\n    return\
    \ prime_fib(m) * prime_fib(m) + prime_fib(m+1)\n  end\nend", "  if n <= 1 then\
    \ return 1 end\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "  if n <\
    \ 2 then return 1 end\n  if n == 2 then return 1 end\n  if n == 3 then return\
    \ 2 end\n  if n % 2 == 0 and n > 2 then\n    return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n  end\n  return prime_fib(n / 2)\nend", "  if n < 2 then return false\
    \ end\n  if n == 2 then\n    return true\n  else\n    local result = prime_fib(n\
    \ - 1)\n    if result and n <= (2 * result) then\n      return result\n    else\n\
    \      return false\n    end\n  end\nend", "  if n <= 1 then\n    return n\n \
    \ end\n  if n == 2 then\n    return 2\n  end\n  if n % 2 == 0 then\n    return\
    \ prime_fib(n / 2) * 2\n  end\n  local fibs = prime_fib(n / 2) - 1\n  return fibs\n\
    end", "    if n == 1 or n == 2 then\n        return n\n    end\n    local s =\
    \ prime_fib(n-1)\n    if s == 3 then return s else return s + (n-2) end\nend",
  "  if n < 2 then return n end\n  if n == 1 then return 2 end\n  local prime, i,\
    \ a = 2, 3\n  for i=3,n-1 do\n    if i % a == 0 then\n      prime = prime+1\n\
    \    end\n    a = a+2\n  end\n  return prime\nend", "  if n < 2 then return 1\
    \ end\n  if n == 2 then return 1 end\n  if n % 2 == 0 then return prime_fib(n\
    \ / 2) end", "    local fib = {0,1}\n    for i=2,n do\n        fib[i] = fib[i-1]+fib[i-2]\n\
    \    end\n    return fib[n]\nend", "  local p\n  local f = {}\n  f[1] = 1\n  f[2]\
    \ = 2\n  repeat\n    local x = f[f[1]]\n    f[f[1]] = f[f[2]] + f[f[1]] -- f[f[1]]\
    \ refers to the element at f[1]\n    p = f[f[2]]\n  until x > n\n  f[2]\nend",
  "  if n <= 1 then\n    return 2\n  else\n    return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n  end\nend", "  local fibs = {}\n  local next_fib = nil\n  local last_fib\
    \ = nil\n  local sum = 0\n  repeat\n    last_fib = next_fib\n    sum = sum + next_fib\n\
    \    next_fib = sum - last_fib\n    fibs[#fibs + 1] = next_fib\n  until next_fib\
    \ == 1 or next_fib == 0\n  return fibs[n]\nend", "\tif n < 2 then\n\t\treturn\
    \ n\n\tend\n\tif n == 1 then\n\t\treturn 1\n\tend\n\tif n == 2 then\n\t\treturn\
    \ 2\n\tend\n\tlocal m = math.floor(math.sqrt(n))\n\tlocal f = prime_fib(m)\n\t\
    if m == math.floor(n) then\n\t\treturn f\n\tend\n\treturn f + prime_fib(m - 1)\n\
    end", "  if n < 2 then\n    return 2\n  elseif n < 4 then\n    return n\n  elseif\
    \ n % 2 == 1 then\n    return prime_fib(n / 2) + prime_fib(n / 2)\n  else\n  \
    \  return prime_fib(n / 2) + prime_fib(3 * n / 2)\n  end\nend", "  -- base case\n\
    \  if n <= 1 then return n end", "  if n==0 or n==1 then\n    return n\n  else\n\
    \    return prime_fib(math.floor(n/2) + math.floor((n%2)/2))\n  end\nend", " \
    \ local x = 3\n  local y = 3\n  while y <= n do\n    x = x + y\n    if x == 2\
    \ or x == n then\n      return x\n    end\n    y = y + 2\n  end\n  return n\n\
    end", "    local i, p, s = 1, n - 1, 1, 1\n    while i <= n do\n        if p %\
    \ i == 0 then\n            p = nil\n            s = i\n        else\n        \
    \    i = i + s\n        end\n    end\n    return s\nend", "  -- check if n is\
    \ odd, then return 1 or n itself, else return prime_fib(2*n+1)\n  local n2 = math.floor(n)\n\
    \  if n2 ~= n then return prime_fib(n2) end\n  local m = math.floor(n2/2)\n  if\
    \ m == 0 and n2 > 0 then return 1 end\n  if m == 0 and n2 == 0 then return 1 end\n\
    \  if m > n then return nil end\n  return prime_fib(2*n+1) + prime_fib(2*n+2)\n\
    end", "  if n < 2 then\n    return 1\n  elseif n == 2 then\n    return 2\n  end",
  "  if n == 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n  else\n  \
    \  -- Prime numbers are greater than 1 and divisible by themselves.\n    if n\
    \ % 2 == 0 then\n      return prime_fib(n / 2)\n    else\n      return prime_fib(3\
    \ * n) + 1\n    end\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
