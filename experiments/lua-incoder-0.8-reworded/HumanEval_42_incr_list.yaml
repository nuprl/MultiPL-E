name: HumanEval_42_incr_list
language: lua
prompt: "-- Return table with elements incremented by 1.\n-- >>> incr_list({1, 2,\
  \ 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4,\
  \ 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = incr_list\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({3, 2, 1}),\
  \ {4, 3, 2})\n    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6,\
  \ 3, 6, 3, 4, 4, 10, 1, 124})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   if #l == 0 then\n      return {}\n   elseif #l == 1 then\n     \
    \ return { l[1] }\n   else\n      return { l[1], incr_list({ l[2] }) }\n   end\n\
    end", "  local newL = {}\n  for i = 1, #l do\n    newL[i] = l[i] + 1\n  end\n\
    \  return newL\nend", "    local n = 1\n    for i, v in pairs(l) do\n        l[i]\
    \ = v + n\n        n = n + 1\n    end\n    return l\nend", "   if l == nil then\
    \ return nil end\n   local m = {}\n   for k,v in pairs(l) do m[#m+1] = v end\n\
    \   return m\nend", "  local ret = l\n  local i = 1\n  for _,x in ipairs(l) do\n\
    \    ret[#ret+1] = x\n    i = i + 1\n  end\n  return ret\nend", "  local out =\
    \ {}\n  for _, x in ipairs(l) do out[#out + 1] = x + 1 end\n  return out\nend",
  "    local accum = {}\n    for i, v in ipairs(l) do\n        if v == nil then\n\
    \            accum[#accum + 1] = 1\n        else\n            accum[#accum + 1]\
    \ = accum[#accum + 1] + v\n        end\n    end\n    return accum\nend", "  local\
    \ res = {}\n  for i = 1, #l do\n    table.insert(res, l[i])\n  end\n  return res\n\
    end", "    local ret = {}\n    for i = 1, #l do\n        ret[#ret+1] = l[i] +\
    \ 1\n    end\n    return ret\nend", "  local i = 1\n  local n = 1\n  local out\
    \ = {}\n  for _, v in pairs(l) do\n    if n == i then\n      out[i] = v + 1\n\
    \      n = n + 1\n    else\n      out[i] = v\n    end\n    i = i + 1\n  end\n\
    \  return out\nend", "    local i, n = #l, 1\n    for i=1, n do\n        l = l\
    \ {i = i + 1}\n    end\n    return l\nend", "  local new = {}\n  for i=1,#l do\
    \ new[i] = i+1 end\n  return new\nend", "  -- This function assumes l is a list.\
    \ No need to check for this.\n  -- We only return a list of increments of 1 in\
    \ this function.\n  local res = {}\n  for i = 1, #l do\n    table.insert(res,\
    \ l[i] + 1)\n  end\n  return res\nend", "  local v = {}\n  for i = 1, #l do\n\
    \    v[i] = v[i] + 1\n  end\n  return v\nend", "  local i, j, k = 1, #l, 1\n \
    \ local incr = {}\n  while j <= k do\n    incr[j] = l[i]\n    i = i + 1\n    j\
    \ = j + 1\n  end\n  return incr\nend", "  local i = 1\n  local v = l[1]\n  for\
    \ i = 2, #l do\n    v = v + l[i]\n    table.insert(l, v)\n  end\n  return l\n\
    end", "  local t = {}\n  for i = 1, #l do\n    t[i - 1] = l[i]\n  end\n  return\
    \ t\nend", "  local result = {}\n  for i = 1, #l do\n    result[i] = result[i-1]\
    \ + l[i]\n  end\n  return result\nend", "  local result = {}\n  for i = 1, #l\
    \ do\n    result[i] = result[i - 1] + 1\n  end\n  return result\nend\n</cell>\n\
    <cell>", "  -- Return the list with the numbers from the list incremented by 1.\n\
    \  local result = {}\n  for i = 1, #l do\n    table.insert(result, l[i] + 1)\n\
    \  end\n  return result\nend", "    if l == nil then\n        return nil\n   \
    \ end\n    local result = setmetatable({}, { __index = table })\n    for _, el\
    \ in ipairs(l) do\n        result[el + 1] = el\n    end\n    return result\nend",
  "  for i = 1, #l do\n    l[i] = l[i] + 1\n  end\n  return l\nend", "    local t\
    \ = {}\n    for k, v in ipairs(l) do t[k] = t[k] + 1 end\n    return t\nend",
  "  local result = {}\n  for i = 1, #l do\n    result[#result + 1] = l[i]\n  end\n\
    \  return result\nend", "  local result = {}\n  for _, v in pairs(l) do\n    result[v+1]\
    \ = v\n  end\n  return result\nend", "  if l == nil then\n    return {}\n  elseif\
    \ #l == 0 then\n    local k\n    repeat\n      k = #l\n    until k == 0\n    table.insert(l,\
    \ 1)\n    return l\n  else\n    local n = #l\n    local i = n\n    local results\
    \ = {}\n    while i ~= 0 do\n      results[i] = l[i]\n      i = i - 1\n    end\n\
    \    table.insert(results, 1)\n    return results\n  end\nend", "  local ret =\
    \ {}\n  for k, v in ipairs(l) do\n    ret[k] = v + 1\n  end\n  return ret\nend",
  "  local results = {}\n  for i=1,#l do\n    table.insert(results, l[i]+1)\n  end\n\
    \  return results\nend", "  local table = {}\n  local i = l[1]\n  table[i] = l[1]\n\
    \  while i do\n    i = l[i]\n    table[i] = table[i-1] + 1\n  end\n  return table\n\
    end", "  if #l == 0 then\n    return l\n  end\n  local head,tail = l[1],l[2:]\n\
    \  table.insert(l,tail+1)\n  return l\nend", "  local ret = {}\n  for k,v in ipairs(l)\
    \ do\n    ret[v+1] = ret[v] or v\n  end\n  return ret\nend", "  local n = 1\n\
    \  local ret = {}\n  local it = l\n  while true do\n    if next(it) == nil then\n\
    \      break\n    end\n    table.insert(ret, v)\n    n = n + v\n  end\n  return\
    \ ret\nend", "  if l == nil then return nil end\n  local new_list = terralib.newlist()\n\
    \  for i, v in ipairs(l) do\n    new_list[#new_list + 1] = v + 1\n  end\n  return\
    \ new_list\nend", "  return setmetatable(l:gsub('[^%d]+', function(x) return x\
    \ + 1 end), {__index = function(t, k)\n    local ret = { }\n    for i = 1, #t\
    \ do\n      ret[i - 1] = tonumber(k) + t[i]\n    end\n    return ret\n  end})\n\
    end", "  local result = {}\n  local i = 1 -- Starting index\n  for i=1, #l do\n\
    \    result[i] = l[i] + 1\n  end\n  return result\nend", "   if #l == 0 then\n\
    \      return {}\n   end\n   local result = {}\n   local i = 0\n   while i < #l\
    \ do\n      local elem = l[i]\n      if type(elem) == \"number\" then\n      \
    \   elem = elem + 1\n      end\n      result[i] = elem\n      i = i + 1\n   end\n\
    \   return result\nend", "  local n = 1\n  local i = #l\n  while i > 0 do\n  \
    \  table.insert(l, n + l[i])\n    i = i - 1\n    n = n + 1\n  end\n  return l\n\
    end", "  -- Return table with elements incremented by 1.\n  return setmetatable(l:map(function(v)\n\
    \    return v + 1\n  end), {__index = table})\nend", "    local out = {}\n   \
    \ for i, v in pairs(l) do\n        out[i] = v + 1\n    end\n    return out\nend\n\
    </cell>\n<text>\nExercises", "   local i, size = #l, 1\n   for i = 1, #l, 1 do\n\
    \      l[i] = l[i] + 1\n      size = size * l[i]\n   end\n   return l / size\n\
    end", "  if type(l) == 'table' then\n    local i = 1;\n    local result = {};\n\
    \    for _, v in pairs(l) do\n      result[i] = v;\n      i = i + 1;\n    end\n\
    \    return result;\n  end\nend", "  local new_l = {}\n  for _, value in ipairs(l)\
    \ do\n    new_l[#new_l + 1] = value + 1\n  end\n  return new_l\nend", "  local\
    \ new_list = {}\n  for i = 1, #l do\n    new_list[#new_list + 1] = l[i] + 1\n\
    \  end\n  return new_list\nend", "\tlocal result = {}\n\tlocal i = 0\n\tfor v\
    \ in pairs(l) do\n\t\ti = i + 1\n\t\tresult[i] = v\n\tend\n\treturn result\nend",
  "  local result = {}\n  local last_val = l[1]\n  for _, v in pairs(l) do\n    result[v]\
    \ = last_val + 1\n    last_val = result[v]\n  end\n  return result\nend", "  \
    \  local result = {}\n    local lastval, lastval = lastval, 1\n    for _, v in\
    \ ipairs(l) do\n        result[lastval] = v\n        lastval = lastval + 1\n \
    \   end\n    return result\nend", "  if l[1] == nil then\n    return nil\n  end\n\
    \  if l[1] == l[#l] then\n    table.insert(l, l[#l] + 1)\n  else\n    table.insert(l,\
    \ l[#l])\n  end\n  return l\nend", "  for i = 1, #l do\n    l[i + 1] = l[i] +\
    \ 1\n  end\n  return l\nend", "  if #l == 0 then\n    return {}\n  end\n  local\
    \ curr = l[1]\n  l[1] = l[#l]\n  l[#l] = curr + 1\n  while true do\n    local\
    \ curr = l[1]\n    l[1] = l[#l]\n    l[#l] = curr + 1\n    if curr == nil then\n\
    \      break\n    end\n  end\n  return l\nend", "  local rval = {}\n  for i =\
    \ 1, #l do\n    table.insert(rval, l[i] + 1)\n  end\n  return rval\nend\n</cell>\n\
    <text>\nThis function just wraps around the built-in table.insert function. How\
    \ does it work? Let's break it down:", "    local r = {l[1]}\n    table.insert(r,\
    \ 1, l[2])\n    for i = 4, #l do\n        table.insert(r, r[i-1]+l[i])\n    end\n\
    \    return r\nend", "  local accum = {}\n  for i = 1, #l do\n    table.insert(accum,\
    \ l[i])\n  end\n  table.sort(accum, function(a,b) return a < b end)\n  local i\
    \ = 1\n  while i <= #l do\n    local p = accum[i-1]\n    if p ~= l[i] then --\
    \ insert p in between\n      table.remove(accum, i - 1)\n      table.insert(accum,\
    \ p)\n    end\n    i = i + 1\n  end\n  return accum\nend", "  local new = {}\n\
    \  for i = #l, 1, -1 do\n    new[i - 1] = l[i]\n  end\n  return new\nend", " \
    \   local new_l = terralib.newlist()\n    for idx, item in ipairs(l) do\n    \
    \    new_l:insert(idx + 1)\n    end\n    return new_l\nend", "   local t = {}\n\
    \   for _, v in pairs(l) do\n      t[#t + 1] = v\n   end\n   return t\nend", " \
    \ if #l == 0 then\n    return {}\n  else\n    local n = 1\n    local t = {}\n\
    \    for i = 1, #l do\n      t[#t + 1] = l[i]\n      n = n * l[i]\n    end\n \
    \   for i = #l - 1, 1, -1 do\n      t[#t + 1] = n * l[i]\n    end\n    return\
    \ t\n  end\nend", "  if l == nil then\n    return nil\n  end\n  local new_table\
    \ = setmetatable({}, {__index = l})\n  local i = 1\n  while i <= #l do\n    new_table[i]\
    \ = l[i] + 1\n    i = i + 1\n  end\n  return new_table\nend", "  local result\
    \ = {}\n  local last = unpack(l):reverse()\n  for i=1, #last do\n    table.insert(result,\
    \ last[i] + 1)\n  end\n  return result\nend", "  local t = {}\n  for i = 1, #l\
    \ do t[i] = l[i] + 1 end\n  return t\nend", "  local r\n  if #l == 0 then return\
    \ nil end\n  local t = l[1]\n  r = {t}\n  while #l > 1 do\n    table.insert(r,\
    \ t + 1)\n    l = l[2]\n  end\n  return r\nend", "  local out = {}\n  for i =\
    \ 1, #l do\n    out[i - 1] = out[i - 1] + 1\n    if out[i - 1] > #l then\n   \
    \   out[i - 1] = out[i - 1] - 1\n      out[i] = 0\n    end\n  end\n  return out\n\
    end", "   -- If the list has no elements -- nothing to do.\n   if #l == 0 then\n\
    \      return l\n   end", "    if type(l) ~= 'table' then return {} end", "  local\
    \ t = {}\n  for _, v in ipairs(l) do\n    table.insert(t, v+1)\n  end\n  return\
    \ t\nend", "  local incrs = {}\n  for _, v in pairs(l) do\n    table.insert(incrs,\
    \ v+1)\n  end\n  return incrs\nend", "    local new_l = {}\n    for _, v in pairs(l)\
    \ do\n        new_l[v + 1]\n    end\n    return new_l\nend", "  local ret = {}\n\
    \  for i = 1, #l do ret[i] = i + 1; end\n  return ret\nend", "    local ret =\
    \ {}\n    for i = 1, #l do\n        ret[#ret + 1] = l[i]\n    end\n    return\
    \ ret\nend", "   if #l == 0 then\n      return nil\n   end", "  local result =\
    \ {}\n  for i = 1, #l do result[#result + 1] = l[i] end\n  return result\nend",
  "  if l == nil then return nil end\n  local t = {}\n  local i = 1\n  for k,v in\
    \ pairs(l) do\n    t[i] = v\n    i = i + 1\n  end\n  return t\nend", "  if l[1]\
    \ == nil then\n    return l { l[1] = 1 }\n  elseif l[1] == 1 then\n    return\
    \ l { l[1] = l[1] + 1 }\n  else\n    return l { l[1] = l[1] + 1, l[2] }\n  end\n\
    end", "  local ret = {}\n  for i, v in ipairs(l) do\n    ret[i] = v + 1\n  end\n\
    \  return ret\nend", "  local i = 1\n  for k,v in pairs(l) do\n    l[k] = v +\
    \ i\n    i = i + 1\n  end\n  return l\nend", "  for i = 1, #l do\n    l[i] = l[i]\
    \ + 1\n    if l[i] > #l then break end\n  end\n  return l\nend", "   local i =\
    \ 0\n   for i, v in pairs(l) do\n      l[i] = v + 1\n   end\n   return l\nend",
  "  if #l == 0 then\n    return {}\n  else\n    local last = l[#l]\n    for i = #l\
    \ - 1, 1, -1 do\n      l[i] = l[i - 1] + 1\n      last = l[i]\n    end\n    l[#l]\
    \ = last\n  end\n  return l\nend", "  local result = {}\n  for _, elem in ipairs(l)\
    \ do\n    result[#result + 1] = elem\n  end\n  return result\nend", "  local l2\
    \ = {}\n  for i = 1, #l do\n    if l2[i] == nil then\n      table.insert(l2, i)\n\
    \    else\n      l2[i] = l2[i] + 1\n    end\n  end\n  return l2\nend", "   local\
    \ n = 1\n   for _, e in ipairs(l) do\n      n = n * e + 1\n   end\n   return n\n\
    end", "  local out = {}\n  for i, v in ipairs(l) do\n    out[i + 1] = v\n  end\n\
    \  return out\nend", "    local ret = {}\n    local max_i = #l + 1\n    for i\
    \ = 1, max_i do\n        ret[i] = l[i] + 1\n    end\n    return ret\nend", " \
    \ local new_list = terralib.newlist()\n  for k, v in ipairs(l) do\n    new_list:insert(k\
    \ + 1, v)\n  end\n  return new_list\nend", "  local ret = {}\n  for i = 1, #l\
    \ do\n    ret[#ret + 1] = l[i]\n  end\n  return ret\nend", "    local result =\
    \ {}\n    for i = 1, #l do\n        result[i] = l[i] + 1\n    end\n    return\
    \ result\nend", "  if l == nil then\n    return nil\n  end\n  local new_t = {}\n\
    \  for k, v in ipairs(l) do\n    new_t[#new_t + 1] = v\n  end\n  return new_t\n\
    end", "  if #l == 0 then\n    return {}\n  else\n    local tmp = {}\n    for i\
    \ = 1, #l do\n      tmp[i] = l[i] + 1\n    end\n    return tmp\n  end\nend", " \
    \  local r = {} -- Return table\n   for i, v in pairs(l) do r[#r + 1] = v end\n\
    \   return r\nend", "  local i = 1 -- Index of list element to increment.\n  local\
    \ ret = {}\n  local last = nil -- Previous element of list to compare.\n  for\
    \ _, v in ipairs(l) do\n    if last ~= v then\n      last = v\n      ret[#ret\
    \ + 1] = v\n    end\n    i = i + 1\n  end\n  return ret\nend", "    if #l == 0\
    \ then\n        return l\n    end\n    local t = {}\n    t[#t + 1] = l[1]\n  \
    \  for i = 2, #l do\n        t[#t + 1] = l[i] + t[#t]\n    end\n    return t\n\
    end", "  local v = {}\n  local s = #l\n  for i = 1, s do\n    v[i + 1] = l[i]\
    \ + 1\n  end\n  return v\nend", "   -- Use table to increase by one each element.\n\
    \   local t = {}\n   for _, v in pairs(l) do\n      t[v] = v + 1\n   end\n   return\
    \ t\nend", "  local res = nil\n  local size = #l", "  local n = {}\n  for i =\
    \ 1, #l do\n    n[i] = l[i] + 1\n  end\n  return n\nend\n</cell>\n<text>\nExercise\
    \ 3", "  local t = {}\n  for i = 1, #l do\n    table.insert(t, l[i])\n  end\n\
    \  table.sort(t)\n  for i = 1, #l do\n    l[i] = t[i - 1] + 1\n  end\n  return\
    \ l\nend", "  local rs = {}\n  for i = 1, #l do\n    rs[i] = l[i] + 1 -- Use table\
    \ update syntax for performance.\n  end\n  return rs -- Returns a table with elements\
    \ incremented by 1.\nend", "  local n = #l\n  if n == 0 then\n    return l\n \
    \ end\n  local result = {}\n  for i = 1, n do\n    result[i] = l[i] + 1\n  end\n\
    \  return result\nend", "  for i, v in pairs(l) do\n    l[i + 1] = v\n  end\n\
    \  return l\nend", "  if l[1] == nil then\n    return l\n  end\n  local curr =\
    \ l[1]\n  local next = l[2]\n  l[1] = next\n  l[2] = curr + 1\n  return l\nend",
  "   local i = 0\n   for k, v in pairs(l) do\n      l[k] = v + i\n      i = i + 1\n\
    \   end\n   return l\nend", "   local ret = {}\n   for i = 1, #l do ret[i] = i\
    \ + 1 end\n   return ret\nend\n</cell>\n<text>\nExercise\nWrite a recursive function\
    \ which takes a table as an input, and returns the sum of the elements of the\
    \ table.", "  local t = {}\n  for k,v in pairs(l) do\n    t[k+1] = v\n  end\n\
    \  return t\nend", "  local r = {1}\n  for i = 2, #l do\n    r[#r+1] = l[i] +\
    \ 1\n  end\n  return r\nend", "  local accum = {}\n  for i = 1, #l do\n    accum[i]\
    \ = accum[i-1] + 1\n  end\n  return accum\nend", "  local t = {}\n  for i = 1,\
    \ #l do\n    t[i] = l[i] + 1\n  end\n  return t\nend", "  for i, v in ipairs(l)\
    \ do\n    l[i + 1] = v + 1\n  end\n  return l\nend\n</cell>\n<text>\nTable functions\n\
    The last thing we are going to cover in this tutorial is table functions. These\
    \ are a very useful feature of the Lua language, and they can make life a little\
    \ easier.", "   local result = {}\n   for _, v in pairs(l) do\n      result[#result\
    \ + 1] = v\n   end\n   return result\nend", "  local t = {}\n  for i = #l, 1,\
    \ -1 do\n    t[i - 1] = l[i]\n  end\n  return t\nend", "  local index = 1\n  local\
    \ result = {}\n  for _, element in ipairs(l) do\n    result[index] = element\n\
    \    index = index + 1\n  end\n  return result\nend", "  local t = {}\n  for i\
    \ = 1, #l do\n    table.insert(t, l[i])\n  end\n  return t\nend", "    local tmp\
    \ = {}\n    local i = 1\n    for i, v in pairs(l) do\n        tmp[i] = v + 1\n\
    \    end\n    table.sort(tmp)\n    for i, v in pairs(tmp) do\n        l[i] = v\n\
    \    end\n    return l\nend", "  local tmp = {}\n  for i = 1, #l do\n    table.insert(tmp,\
    \ i + 1)\n  end\n  return tmp\nend", "  local new_l = {}\n  for i = 1, #l do\n\
    \    new_l[i + 1] = l[i] + 1\n  end\n  return new_l\nend", "  local index = 0\n\
    \  local result = {}\n  for k,v in pairs(l) do\n    result[index+1] = v -- increment\
    \ index\n    index = index + 1\n  end\n  return result\nend", "    local n = {}\n\
    \    for _, i in pairs(l) do\n        n[i] = n[i] + 1 or i\n    end\n    return\
    \ n\nend", "    local ret = {}\n    for _, v in ipairs(l) do\n        table.insert(ret,\
    \ v + 1)\n    end\n    return ret\nend", "  local result = {}\n  for i = 1, #l\
    \ do\n    table.insert(result, i + 1)\n  end\n  return result\nend", "  local\
    \ ret = {}\n  for i = 1, #l do\n    ret[#ret + 1] = l[i]\n  end\n  return ret\n\
    end", "  local t = {}\n  for _, v in ipairs(l) do\n    table.insert(t, v + 1)\n\
    \  end\n  return t\nend", "  if #l == 0 then return {} end\n  local t = l[1]\n\
    \  for i = 2, #l do\n    t = {t[1], t[i] + 1}\n  end\n  return t\nend", "  for\
    \ _, v in ipairs(l) do\n    v = v + 1\n  end\n  return l\nend", "    local result\
    \ = {}\n    for i = 1, #l do\n        result[i] = result[i] + 1\n    end\n   \
    \ return result\nend", "    local n = {}\n    local i = 1\n    for _, v in ipairs(l)\
    \ do\n        n[i] = v\n        i = i + 1\n    end\n    return n\nend", "   if\
    \ #l == 0 then\n      return l\n   end\n   local last = l[#l]\n   local new_last\
    \ = last + 1\n   for i = #l, 1, -1 do\n      l[i] = new_last\n      new_last =\
    \ last - 1\n      last = new_last\n   end\n   return l\nend", "  local n = {}\n\
    \  for i = 1, #l do\n    n[i + 1] = l[i] + 1\n  end\n  return n\nend", "  -- TODO:\
    \ Implement a more efficient algorithm\n  -- TODO: Add unit tests\n  local new_l\
    \ = {}\n  for i=1,#l do\n    new_l[i] = l[i] + 1\n  end\n  return new_l\nend",
  "  if type(l) ~= 'table' then\n    l = {l}\n  end\n  local i = 1\n  local n = {}\n\
    \  for _, v in ipairs(l) do\n    n[i] = v\n    i = i + 1\n  end\n  return n\n\
    end", "    local new_list = {}\n    for _, v in pairs(l) do\n        new_list[#new_list\
    \ + 1] = v\n    end\n    return new_list\nend\n</code>\n<|/ a |>\n<| a |>\nHow\
    \ about just looping over the list and incrementing each element?\n<code>", " \
    \ local t = {}\n  for i = 1, #l do\n    t[#t + 1] = l[i] + 1\n  end\n  return\
    \ t\nend\n</cell>\n<cell>", "  -- The loop invariant is preserved.\n  local s\
    \ = l[1]\n  -- The loop invariant is not affected by the call.\n  for i = 2, #l\
    \ do\n    s = s + l[i]\n  end\n  return s\nend", "  local r = {l[1]}\n  for i\
    \ = 2, #l do\n    table.insert(r, l[i])\n  end\n  return r\nend", "    local count\
    \ = 1\n    local ret = nil\n    for i, v in pairs(l) do\n        if ret then count\
    \ = count + 1 end\n        ret = v + count\n    end\n    return ret\nend", " \
    \ local ret = {}\n  for i = 1, #l do\n    ret[i] = l[i] + 1\n  end\n  return ret\n\
    end", "  local new_list = {}\n  for i = 1, #l do\n    new_list[#new_list+1] =\
    \ l[i]\n  end\n  return new_list\nend", "  local n = 1\n  for i = 1, #l do\n \
    \   n = n + l[i]\n    l[i] = n\n  end\n  return l\nend", "  local n = 1\n  local\
    \ ret = {}\n  for i, v in ipairs(l) do\n    ret[i] = v + n\n    n = n + 1\n  end\n\
    \  return ret\nend", "  local result = {}\n  local k = 1\n  for i, v in ipairs(l)\
    \ do\n    result[i] = v\n    if k == 1 then\n      k = v\n      continue\n   \
    \ end\n    k = 1\n  end\n  return result\nend", "    local i = 1\n    for v in\
    \ pairs(l) do\n        l[i] = v + 1\n        i = i + 1\n    end\n    return l\n\
    end", "   if l[1] == nil then\n      return l\n   else\n      table.insert(l,\
    \ l[1] + 1)\n      return l\n   end\nend", "  local res = {}\n  for i, v in ipairs(l)\
    \ do\n    res[v] = v + 1\n  end\n  return res\nend", "  local result = {}\n  local\
    \ len = #l\n  for i = 1, len do\n    result[#result + 1] = l[i] + 1\n  end\n \
    \ return result\nend", "  local table = {}\n  table.insert(table, l[1])\n  for\
    \ i = 2, #l do\n    table.insert(table, l[i] + 1)\n  end\n  return table\nend",
  "  local i = 0\n  local r = {}\n  for k in pairs(l) do\n    r[i + 1] = l[k]\n  \
    \  i = i + 1\n  end\n  return r\nend\n</cell>\n<text>\nExample 4: Iterating over\
    \ tables", "  local result = {}\n  for i = 2, #l do\n    result[i - 1] = result[i\
    \ - 1] + 1\n  end\n  return result\nend", "    local r = {}\n    for i, v in ipairs(l)\
    \ do\n        r[#r + 1] = v\n    end\n    return r\nend", "  local i, s = 1, {}\n\
    \  for i, v in ipairs(l) do\n    s[#s + 1] = v + 1\n  end\n  return s\nend", " \
    \ local rt = {}\n  local i = 0\n  for i in pairs(l) do\n    rt[i] = l[i] + 1\n\
    \  end\n  return rt\nend", "  local rt = {}\n  for i=1,#l do table.insert(rt,\
    \ l[i] + 1) end\n  return rt\nend", "   -- We return nil instead of empty lists.\n\
    \   if next(l) == nil then return end\n   local ret = {}\n   for i = 2, #l do\n\
    \      ret[i - 1] = l[i] + ret[i - 1]\n   end\n   return ret\nend", "  local n\
    \ = 1\n  local out = {}\n  for i = 1, #l do\n    if i == 1 then\n      table.insert(out,\
    \ 1)\n    else\n      table.insert(out, out[n] + 1)\n    end\n    n = n + l[i]\n\
    \  end\n  return out\nend", "  local t = {}\n  local i = 1 -- Index of first non-zero\
    \ element of l\n  while i ~= 0 do\n    i = i + 1\n    t[i] = l[i]\n  end\n  table.sort(t)\n\
    \  return t\nend", "  local i = 1\n  local n = {}\n  for _, v in ipairs(l) do\n\
    \    n[v] = n[v] + 1\n  end\n  for _, v in pairs(n) do\n    table.insert(l, v)\n\
    \  end\n  return l\nend", "  if l[1] > 1 then\n    return incr_list(l {2})\n \
    \ end", "   if l == nil then\n      return l\n   end\n   if #l == 1 then\n   \
    \   local value = l[1]\n      l[1] = value + 1\n      return l\n   else\n    \
    \  local index = #l - 1\n      for i = #l - 1, 1, -1 do\n         local value\
    \ = l[i]\n         l[i] = value + 1\n      end\n      return l\n   end\nend",
  "    local result = {}\n    for i = 1, #l do\n        table.insert(result, l[i]+1)\n\
    \    end\n    return result\nend", "  local rt = {}\n  for i = 1, #l do\n    rt[#rt+1]\
    \ = l[i] + 1 -- This relies on lua being 1-based.\n  end\n  return rt\nend", " \
    \ local result = {}\n  local i = 1\n  for k,v in pairs(l) do\n    table.insert(result,\
    \ v)\n    i = i + 1\n    if i > v then\n      i = i - v\n      table.insert(result,\
    \ i)\n    end\n  end\n  return result\nend", "    local res = {}\n    local n\
    \ = 1\n    for _, v in pairs(l) do\n        res[#res + 1] = v + n\n        n =\
    \ n + 1\n    end\n    return res\nend", "   local counts = {}\n   for i, v in\
    \ ipairs(l) do\n      counts[i] = counts[i] or 0\n      counts[i] = counts[i]\
    \ + 1\n   end\n   return table.concat(counts, ',')\nend", "  local result = {}\n\
    \  table.insert(result, 1)\n  for i = 2, #l do\n    table.insert(result, l[#result\
    \ + 1])\n  end\n  return result\nend", "  if #l == 0 then\n    return nil\n  end\n\
    \  local r\n  r = l[1]\n  l[1] = l[#l]\n  l[#l] = r + 1\n  return l\nend", " \
    \ local result = {}\n  local last_val = nil\n  local i = 0\n  while i < #l do\n\
    \    local elem = l[i]\n    if elem == nil then\n      table.insert(result, last_val\
    \ or 0)\n      last_val = nil\n      break\n    elseif elem ~= nil then\n    \
    \  last_val = elem\n      table.insert(result, last_val or 0)\n    end\n    i\
    \ = i + 1\n  end\n  if last_val ~= nil then\n    table.insert(result, last_val\
    \ or 0)\n  end\n  return result\nend", "  if #l == 0 then\n    return l\n  end",
  "  local newlist = {}\n  for i = 1, #l do\n    table.insert(newlist, i + 1)\n  end\n\
    \  return newlist\nend", "  local new_l = {}\n  for i = #l, 1, -1 do\n    new_l[i]\
    \ = new_l[i - 1] + 1\n  end\n  return new_l\nend", "    local t = {}\n    local\
    \ i = 1\n    for i, v in ipairs(l) do\n        t[i] = v + 1\n    end\n    return\
    \ t\nend", "   for i = #l, 1, -1 do\n      l[i] = l[i] + 1\n   end\n   return\
    \ l\nend", "  local n = {}\n  for k, v in pairs(l) do\n    n[v] = n[v] or {}\n\
    \    n[v][k] = n[v][k] or v+1\n  end\n  return n\nend", "  local t = {}\n  for\
    \ i = 1, #l do\n    t[i - 1] = l[i]\n  end\n  for i = #l + 1, 1 do\n    t[i] =\
    \ t[i - 1] + 1\n  end\n  return t\nend", "    local newL = {}\n    for i, v in\
    \ ipairs(l) do\n        newL[i] = v + 1\n    end\n    return newL\nend", "  local\
    \ new_list = {}\n  for i = 1, #l do\n    new_list[#new_list + 1] = l[i] + 1\n\
    \  end\n  return new_list\nend\n</code>\n<|/ a tags=recursion,lua |>\n<| c |>\n\
    This was my first solution, and I thought I knew how to write it. After some trial\
    \ and error, I came up with something similar, although less elegant. I posted\
    \ an alternative solution, and it seems to work quite well.\n<|/ c |>\n<| a |>\n\
    My other solution involves creating a table of lists, then using table.insert().\n\
    <code>", "  for i = #l, 1, -1 do\n    table.insert(l, l[i])\n  end\n  return l\n\
    end", "  if #l == 1 then return l\n  else return set_list(l, #l + 1) end\nend",
  "  if l == nil then\n    return nil\n  else\n    local n = {}\n    local j = 0\n\
    \    for _, v in ipairs(l) do\n      j = j + 1\n      n[j] = v\n    end\n    return\
    \ n\n  end\nend", "  local out = {}\n  for i = 1, #l do\n    table.insert(out,\
    \ l[i]+1)\n  end\n  return out\nend", "  local accum = { }\n  for i = 1, #l do\n\
    \    accum[#accum + 1] = l[i] + 1\n  end\n  return accum\nend", "  local counts\
    \ = {}\n  for _, item in ipairs(l) do\n    local count = counts[item]\n    if\
    \ count == nil then\n      count = counts[item] = 1\n    else\n      count = count\
    \ + 1\n    end\n    counts[item] = count\n  end\n  local res = {}\n  for item,\
    \ count in pairs(counts) do\n    res[item] = item .. count\n  end\n  return res\n\
    end", "  local result = {}\n  for _, v in ipairs(l) do\n    table.insert(result,\
    \ v+1)\n  end\n  return result\nend", "  local c = 1\n  local n = {}\n  for i\
    \ = 1, #l do\n    n[i] = l[i]\n    c = c * l[i]\n  end\n  n[c]\nend", "  local\
    \ result = {}\n  for k, v in ipairs(l) do\n    table.insert(result, v + 1)\n \
    \ end\n  return result\nend", "  local t = {}\n  for i = 1, #l do\n    t[#t +\
    \ 1] = l[i]\n  end\n  return t\nend", "    local i = 0\n    local j = 1\n    local\
    \ l2 = {}\n    local len = 1\n    for k,v in pairs(l) do\n        len = len +\
    \ 2\n        if i == j % len then\n            table.insert(l2, v)\n        else\n\
    \            i = i + 2\n            if i == len then\n                j = j +\
    \ 2\n            end\n        end\n    end\n    return l2\nend\n</cell>\n<text>\n\
    Exercise 4\nThe function below takes a table of numbers and returns a table of\
    \ all the powers of two.", "  for i = 1, #l do\n    l[i] = l[i] + 1\n  end\n \
    \ return l\nend", "    local n = 1\n    local t = {}\n    for _, v in ipairs(l)\
    \ do table.insert(t, v+n) n = n+1 end\n    return t\nend", "  local incr = nil\n\
    \  local result = {}\n  local i = 1", "    local i = 1\n    local t = {}\n   \
    \ for k, v in pairs(l) do\n        t[i] = v\n        i = i + 1\n    end\n    return\
    \ t\nend", "  local n = 1\n  for i = 1, #l do\n    l[i] = n \n    n = n + 1\n\
    \  end\n  return l\nend", "  local result = {}\n  for i = 1, #l do\n    result[i]\
    \ = l[i] + 1\n  end\n  return result\nend", "  local n = {}\n  for i = 1, #l do\n\
    \    n[i + 1] = l[i] + 1\n  end\n  return n\nend", "    local n = 1\n    for k,\
    \ v in pairs(l) do\n        n[k] = n[k] + 1\n    end\n    return n\nend", "  local\
    \ result = {}\n  for i = 1, #l do\n    table.insert(result, l[i])\n    table.insert(result,\
    \ l[i]+1)\n  end\n  return result\nend", "  local ret = {}\n  for _, v in ipairs(l)\
    \ do\n    ret[v + 1] = v\n  end\n  return ret\nend", "  local rv = terralib.newlist()\n\
    \  for i = 1, #l do\n    rv:insert(l[i] + 1)\n  end\n  return rv\nend", "  local\
    \ rv = setmetatable({}, {__index = function() return setmetatable({}, {__index\
    \ = function() return setmetatable({}, {__index = function() return l; end, metatable\
    \ = true, __tostring = function() return \"table\" end}) end}) end})\n  for i\
    \ = 1, #l do\n    table.insert(rv, l[i])\n  end\n  return rv\nend", "  local i,\
    \ n = 1, #l\n  while i < n do\n    table.insert(l, l[i])\n    i = i + 1\n  end\n\
    \  return l\nend", "   for i = #l, 1, -1 do\n      l[i] = l[i] + 1\n   end\n \
    \  return l\nend", "  local ret = {}\n  for i = 1, #l do\n    ret[i] = ret[i -\
    \ 1] + 1\n  end\n  return ret\nend", "  local new_list = {}\n  for i = #l, 1,\
    \ -1 do\n    new_list[i - 1] = l[i]\n  end\n  return new_list\nend", "   local\
    \ new_list = {}\n   for i=1, #l do\n      table.insert(new_list, l[i])\n   end\n\
    \   table.sort(new_list)\n   return new_list\nend", "    local t = {}\n    for\
    \ i = 1, #l do\n        t[i] = l[i] + 1\n    end\n    return t\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
