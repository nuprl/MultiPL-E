name: HumanEval_134_check_if_last_char_is_a_letter
language: lua
prompt: "-- Create a function that returns true if the last character\n-- of a given\
  \ string is an alphabetical character and is not\n-- a part of a word, and false\
  \ otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n--\
  \ Examples:\n-- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>>\
  \ check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple\
  \ pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal\
  \ function check_if_last_char_is_a_letter(txt)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_if_last_char_is_a_letter\n\
  \    lu.assertEquals(candidate('apple'), false)\n    lu.assertEquals(candidate('apple\
  \ pi e'), true)\n    lu.assertEquals(candidate('eeeee'), false)\n    lu.assertEquals(candidate('A'),\
  \ true)\n    lu.assertEquals(candidate('Pumpkin pie '), false)\n    lu.assertEquals(candidate('Pumpkin\
  \ pie 1'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('eeeee\
  \ e '), false)\n    lu.assertEquals(candidate('apple pie'), false)\n    lu.assertEquals(candidate('apple\
  \ pi e '), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if txt:sub(#txt, #txt) == ' ' then\n    return true\n  end\n  if\
    \ txt:sub(#txt, #txt) == string.byte(string.sub(txt, #txt - 1, #txt))\n  then\n\
    \    return false\n  end\n  return true\nend", "  return string.sub(tx, #txt,\
    \ 1) ~= '\\a' and string.sub(tx, #txt, 1) ~= '\\z'\nend", "   local last_char\
    \ = txt:sub(1,txt:len())\n   return (last_char == alpha_char)\nend", "  local\
    \ last_char = string.sub(txt, string.len(txt) - 1)\n  local last_char_upper =\
    \ string.upper(last_char)\n  local last_char_lower = string.lower(last_char)",
  "\t-- First, remove trailing spaces\n\ttxt = string.gsub(txt, ' $', '')\n\t-- Then,\
    \ remove all remaining space characters\n\t-- but include tabs because some people\
    \ have trouble\n\t-- with them\n\ttxt = string.gsub(txt, '[[:space:]]+', \"\"\
    )\n\t-- Now remove all remaining non-alphabetic characters\n\ttxt = string.gsub(txt,\
    \ '[^A-Za-z]', '')\n\t-- Now just check if the string is a single letter\n\tif\
    \ string.len(txt) == 1 then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\n\
    end", "   if txt == nil then return false end\n   if txt == \"\" then return false\
    \ end\n   if string.len(txt) == 0 then return false end\n   local last_char =\
    \ string.sub(txt, string.len(txt)-1, string.len(txt))\n   return last_char ==\
    \ \" \" or last_char == \"\\n\" or last_char == \"\\r\" or last_char == \"\\t\"\
    \ \nend", "  if txt == '' then return false end\n  local last_char = string.sub(txt,\
    \ -1, 1)\n  local last_char_not_a_word\n  -- Note: word is a group of characters\
    \ separated by space.\n  -- Note: word is a group of characters separated by space.\n\
    \  if #word == 1 then\n    last_char_not_a_word = check_if_last_char_is_not_a_letter(last_char)\n\
    \  else\n    -- Note: word is a group of characters separated by space.\n    --\
    \ Note: word is a group of characters separated by space.\n    last_char_not_a_word\
    \ = check_if_last_char_is_not_a_letter(last_char, word)\n  end\n  return not last_char_not_a_word\n\
    end", "\treturn not (string.match(txt, \"[%w]\"))\nend", "    local txt = txt\
    \ or ''\n    local last = txt:sub(1, #txt)\n    return (last ~= ' ') and\n   \
    \     (last:match('[A-Za-z]') or last:match('[0-9]'))\nend", "  -- if the string\
    \ is empty, return false\n  if txt:len() == 0 then\n    return false\n  end\n\
    \  -- get the last char of the string\n  local last_char = txt:sub(txt:len()-1)\n\
    \  -- if the last char is alphabetic\n  if last_char ~= 'a' and last_char ~= 'A'\
    \ and last_char ~= ' ' then\n    return false\n  end\n  -- if last char is not\
    \ a space\n  return last_char ~= ' '\nend", "   return not txt or string.match(string.sub(txt,\
    \ -1), '.') == nil\nend", "    local words = txt:split(\" \")\n    local last_char\
    \ = words[#words]\n    return ((#last_char) == #txt) and (last_char:match('[A-Za-z]')\
    \ == nil)\nend", "    -- Return true if the last character in the txt string is\n\
    \    -- alphabetical and is not a part of a word.\n    local last_char = txt:sub(1,\
    \ -1)\n    if last_char ~= '' then\n        local word_len = txt:len()\n     \
    \   -- If the last character is a letter and the first word\n        -- is non-empty,\
    \ return true.\n        if last_char ~= 'a' and word_len > 1 then\n          \
    \  return true\n        end\n    end\n    return false\nend", "  local txt = txt\
    \ or ''\n  local last_char = txt:sub(1, #txt)\n  local words = last_char:gsub('\
    \ ', ' ')\n  return words and words:sub(-(#words)+1, #words) == last_char\nend",
  '  return string.sub(txt, -1, -1) == " " and string.sub(txt, -1, -1) == string.sub(txt,
    -1, -1) and string.sub(txt, -1, -1) ~= " " and string.sub(txt, -1, -1) != " "
    and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1)
    != " " and string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and
    string.sub(txt, -1, -1) != " " and string.sub(txt, -1, -1) != " " and string.sub(txt,
    -1, -1) != " " and ', "\tif txt == '' then return false end\n\tlocal last_char\
    \ = txt:sub(1,#txt)\n\treturn last_char == \" \" or\n\t\tlast_char == \"\\n\"\
    \ or\n\t\tlast_char == \"\\t\" or\n\t\tlast_char == \"\\r\" or\n\t\tlast_char\
    \ == nil or\n\t\tlast_char == \"\"\nend", "   return (not string.sub(txt, -1,\
    \ 1) or string.sub(txt, -1, 1) == ' ' or string.sub(txt, -1, 1) ~= '-' or string.sub(txt,\
    \ -1, 1) ~= '_') or string.sub(txt, -1, 1) ~= string.lower(string.sub(txt, -1,\
    \ 1)) -- don't check last char if it's '-', or '_'\nend", "   local words = txt:split(\"\
    \ \"):reverse()\n   for _, word in ipairs(words) do\n      local result = word:sub(#word,\
    \ 1)\n      if result == \"\" then\n         return false\n      elseif result:match(alpha)\
    \ then\n         return true\n      end\n   end\n   return false\nend", "   --\
    \ The last character of a string is just the last character\n   -- -- so we return\
    \ the remainder of the string after the\n   -- last character, and check whether\
    \ it is a letter.\n   -- If the string has fewer than two characters, then the\n\
    \   -- last character is a letter and so is returned.\n   -- Otherwise, we need\
    \ to check if the last character is a\n   -- word character, and if not, we must\
    \ return false.\n   -- In the second case, the last character is a word character\n\
    \   -- so we need to return the remainder of the string after the\n   -- last\
    \ character if it is an alphabetic character, and\n   -- return false otherwise.\
    \  (The string will always be\n   -- two characters long.) For example, in the\
    \ string 'he', we\n   -- cannot return 'e' because it is part of a word, but we\
    \ must\n   -- return 'he'.\n   if #txt < 2 then\n      return txt\n   elseif string.byte(txt:sub(1,\
    \ 2)) == 97 then\n      return txt\n   else\n      local letter = string.byte(txt:sub(1,\
    \ #txt - 1))\n      return letter .. txt:sub(#txt - 1)\n   end\nend", "    return\
    \ not txt:match(\"[^a-z]$\") and txt:sub(1,1) ~= '\\a'\nend", "  if txt == ''\
    \ or txt:sub(1, #txt) ~= ' ' then return false end\n  local last_char = txt:sub(#txt)\n\
    \  for k, v in pairs(alphabet) do\n    if k == last_char then\n      return false\n\
    \    end\n  end\n  return true\nend", "  return (txt:sub(-1, 1, 1):lower() ==\
    \ txt:sub(-1, 1, 1)) \nend", "  if txt ~= '' then\n    return txt:sub(1,#txt)\
    \ ~= ' ' and txt:sub((#txt),#txt) ~= '\\1'\n  end\n  return false\nend", "  return\
    \ txt:sub(-1, -1) == \" \" and txt:sub(-2) == \" \" and txt:sub(-3) == \" \" and\
    \ txt:sub(-4) == \" \" and txt:sub(-5) == \" \" and txt:sub(-6) == \" \" and txt:sub(-7)\
    \ == \" \" and txt:sub(-8) == \" \" and txt:sub(-9) == \" \" and txt:sub(-10)\
    \ == \" \"\nend", "    txt = string.gsub(txt, ' ', ' ')\n    local last_char =\
    \ string.sub(txt, -1)\n    local last_char_is_a_letter = last_char ~= '^[a-zA-Z]+$'\n\
    \    return last_char_is_a_letter\nend", "  if txt ~= '' then\n    return string.sub(txt,\
    \ -1, 1) ~= ' ' and string.sub(txt, -1, 1) ~= '\\'' and\n            string.sub(txt,\
    \ -1, 1) ~= '-'\n  else\n    return false\n  end\nend", "  local words = txt:gsub('\
    \ ', ''):gsub('-', ''):gsub('_', ''):gsub(':', ''):gsub('.', ''):gsub(',', ''):gsub('&',\
    \ ''):gsub('+', ''):gsub('/', ''):gsub('-', ''):gsub('*', ''):gsub('@', ''):gsub('#',\
    \ ''):gsub('?', ''):gsub('%', ''):gsub('!', '')\n  local last_char = words[#words]\n\
    \  -- TODO: add more \"word characters\" here\n  return (last_char == '-' or last_char\
    \ == '_' or last_char == '@' or last_char == '#' or last_char == '?' or last_char\
    \ == '!')\nend", "    if txt == '' or txt:sub(1, #txt) == txt then return false\
    \ end\n    local last_char = txt:sub(1, #txt)\n    local is_letter = false\n \
    \   for _,w in ipairs(word) do\n        if w == last_char then is_letter = true\
    \ break end\n    end\n    return is_letter\nend", "  return string.sub(txt, -1)\
    \ == \" \" and string.sub(t,-1) and string.sub(t,-1, -1) == \" \" \nend", "  if\
    \ txt == nil then\n    return false\n  end\n  local last_char = string.sub(txt,\
    \ 1, string.len(txt))\n  local last_char = string.sub(last_char, -1)\n  return\
    \ string.sub(last_char, -1) ~= '\\a' and string.find(string.sub(txt, 1, string.len(txt)-1),\
    \ ' ') ~= nil\nend", "  return txt:sub( #txt - 1 )==\" \" and txt:sub( #txt -\
    \ 1 )~=\" \"\nend", "    if txt ~= '' then\n        if txt:match('%a') then\n\
    \            return false\n        else\n            local word_match = txt:match('([^\
    \ ])')\n            if word_match == nil then\n                return false\n\
    \            else\n                if word_match:sub(1, 1) ~= '-' then\n     \
    \               return true\n                else\n                    return\
    \ false\n                end\n            end\n        end\n    end\n    return\
    \ false\nend", "   local last = txt:sub( #txt -1 )\n   local lastchar = last:sub(1,\
    \ 1)\n   return lastchar and lastchar ~= 'a'\nend", "  -- Return the length of\
    \ the string minus the last character and\n  -- check it's alphabetical character\n\
    \  if txt ~= '' then\n    local last_char_index = txt:len()\n    local last_char\
    \ = txt:sub(last_char_index - 1, 1)\n    if last_char ~= '' then\n      return\
    \ last_char ~= ' ' and last_char ~= '-' and last_char ~= '_'\n    end\n  end\n\
    \  return false\nend", "\t-- Check for empty string\n\tif txt == '' then return\
    \ false end\n\t-- Check that first character is not a letter\n\tif txt:sub(1,1)\
    \ ~= '' then\n\t\tlocal ch = txt:sub(1,1)\n\t\treturn ch ~= alpha and ch ~= ''\
    \ and ch ~= ' ' and ch ~= '!'\n\tend\n\t-- If not first character is a letter\
    \ then check if last character is a letter\n\tif txt:sub(#txt,1) ~= '' then\n\t\
    \tlocal ch = txt:sub(#txt,1)\n\t\treturn ch ~= alpha and ch ~= '' and ch ~= '\
    \ ' and ch ~= '!'\n\tend\nend", "   -- Check for empty string\n   if not txt then\n\
    \      return false\n   end", "  return txt:sub((#txt), 1):lower() ~= 'a'\nend",
  "    if txt == '' then\n        return false\n    end\n    local last_char = txt:sub(1,\
    \ #txt)\n    local word_separator = ' ' -- Set an arbitrary character to\n   \
    \                            -- separate words\n    if last_char == word_separator\
    \ or last_char == string.char(13) then\n        return false\n    end\n    local\
    \ last_char = string.lower(last_char)\n    local letters = {}\n    for i = 1,\
    \ #last_char do\n        local char = string.lower(string.sub(last_char, i))\n\
    \        if #letters == 0 or char == word_separator then\n            table.insert(letters,\
    \ char)\n        else\n            if #letters == 1 then\n                return\
    \ false\n            end\n            table.insert(letters, true)\n        end\n\
    \    end\n    table.sort(letters)\n    return letters[#letters]\nend", "    if\
    \ txt == nil then\n        return false\n    end\n    return not (string.sub(txt,\
    \ 1, string.len(txt)-1) == ' ' and\n        string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) ~= '')\nend", "  local last_char = string.sub(txt, -1)\n  return\
    \ string.find(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(txt,\
    \ ' ', ''), '.', ''), '!', ''), '?', '.'), '[aeiouy]+$', '') ~= nil\nend\ncheck_if_last_char_is_a_letter\
    \ = check_if_last_char_is_a_letter", "    -- if empty string, return false\n \
    \   if txt == nil then\n        return false\n    end\n    -- if last character\
    \ is a letter, return true\n    if string.sub(txt, string.len(txt)-1, string.len(txt))\
    \ ~= string.sub(txt, 1, string.len(txt)-1) then\n        return true\n    end\n\
    \    -- if last character is a space, return false\n    if string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) ~= ' ' then\n        return false\n    end\n    -- if last\
    \ character is a letter or space, return false\n    if string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) ~= '-' then\n        return false\n    end\n    -- if last\
    \ character is a letter and not a part of a word, return true\n    -- example:\
    \ apple\n    -- >>> check_if_last_char_is_a_letter('apple pie')\n    -- false\n\
    \    -- >>> check_if_last_char_is_a_letter('apple pi e ')\n    -- true\n    --\
    \ >>> check_if_last_char_is_a_letter('apple pi e')\n    -- false\n    -- >>> check_if_last_char_is_a_letter('')\n\
    \    -- false\nend", "  local last_char = string.sub(txt, -1, 1)\n  if last_char\
    \ == '-' or last_char == ' ' then\n    return false\n  elseif last_char == ' '\
    \ then\n    return check_if_last_char_is_a_letter(txt)\n  else\n    return true\n\
    \  end\nend", "  return not ((txt:sub(1, #txt) ~= '\\a')\n    or (txt:sub(1, #txt)\
    \ ~= '\\A')\n    or (txt:sub(1, #txt) ~= '\\b')\n    or (txt:sub(1, #txt) ~= '\\\
    B')\n    or (txt:sub(1, #txt) ~= '\\f')\n    or (txt:sub(1, #txt) ~= '\\F')\n\
    \    or (txt:sub(1, #txt) ~= '\\n')\n    or (txt:sub(1, #txt) ~= '\\r')\n    or\
    \ (txt:sub(1, #txt) ~= '\\t')\n    or (txt:sub(1, #txt) ~= ' '))\nend", "\t--\
    \ Check argument\n\tif not txt or #txt < 1 then\n\t\treturn false\n\tend\n\t--\
    \ Check first char\n\tlocal firstChar = txt:sub(1,1)\n\t-- Check if first char\
    \ is a letter\n\tif firstChar == 'a' or firstChar == 'e' or firstChar == 'i' or\
    \ firstChar == 'o' or firstChar == 'u' then\n\t\treturn true\n\tend\n\t-- Check\
    \ if first char is a space\n\tif firstChar == ' ' then\n\t\treturn true\n\tend\n\
    \t-- Check last char\n\tlocal lastChar = txt:sub((#txt),(#txt))\n\t-- Check if\
    \ last char is only a letter\n\tif lastChar == 'a' or lastChar == 'e' or lastChar\
    \ == 'i' or lastChar == 'o' or lastChar == 'u' then\n\t\treturn true\n\tend\n\t\
    -- Check if last char is a space\n\tif lastChar == ' ' then\n\t\treturn true\n\
    \tend\n\t-- return false\n\treturn false\nend", "  -- Get the last character in\
    \ a string.\n  local last_char = txt:sub(-1)\n  -- If the last character is a\
    \ letter, then return true.\n  return last_char:match(\"^[A-Za-z]$\")\nend", " \
    \ if txt == '' then return false end\n  local last_char = txt:sub(1,1)\n  local\
    \ is_letter = true\n  if last_char:find(\" \") then\n    local words = last_char:gsub('\
    \ ', ' ')\n    local last_word = words[#words]\n    if last_word:match \"^[a-zA-Z]+$\"\
    \ then\n      is_letter = false\n    end\n  end\n  return is_letter\nend", " \
    \  local words = split(txt)\n   if #words > 0 then\n      if words[#words - 1]:sub(1,\
    \ 1) == 'a' or\n         words[#words - 1]:sub(1, 1) == 'e' or\n         words[#words\
    \ - 1]:sub(1, 1) == 'i' or\n         words[#words - 1]:sub(1, 1) == 'o' or\n \
    \        words[#words - 1]:sub(1, 1) == 'u'\n      then\n         return false\n\
    \      end\n   end\n   return true\nend", "  if txt == '' or txt ~= '' or txt\
    \ ~= nil then\n    return false\n  else\n    return txt:match(\"[A-Za-z]+$\")\n\
    \  end\nend", "  return txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt)\
    \ == ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) ==\
    \ ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == '\
    \ ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' '\
    \ or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n\
    \         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n  \
    \       txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n    \
    \     txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n      \
    \   txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n        \
    \ txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1,\
    \ #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt)\
    \ == ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) ==\
    \ ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == '\
    \ ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' '\
    \ or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n\
    \         txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n  \
    \       txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n    \
    \     txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n      \
    \   txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n        \
    \ txt:sub(1, #txt) == ' ' or\n         txt:sub(1, #txt) == ' ' or\n         txt:sub(1,\
    \ #txt) == ' ' or\n         txt:sub(1, #txt) == ", "  return string.sub(txt, 1,\
    \ string.len(txt)-1) == 'a' and\n         not string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) == \"word\"\nend", "  return type(txt) == 'string' and txt:sub(1,\
    \ #txt) == txt and not( string.match(txt, '^[A-Za-z]$') )\nend", "  local last\
    \ = ''\n  for ch in txt:gmatch('[^ ]+') do\n    last = ch\n  end\n  return last\
    \ ~= '\\a'\nend", "    if txt and string.len(txt) > 0 then\n        local last\
    \ = string.sub(txt, -1)\n        return last ~= ' ' and last ~= '\\t' and last\
    \ ~= '\\n' and last ~= '\\r' and last ~= '\\t' and last ~= '\\n';\n    end\nend",
  "   if txt ~= '' then return ((txt:sub(1, #txt))) == txt:sub((#txt), #txt) end\n\
    end", "  -- txt = txt:upper()\n  -- txt = txt:gsub(' ','')\n  -- txt = txt:gsub('.','')\n\
    \  -- txt = txt:gsub(',','')\n  -- txt = txt:gsub(':','')\n  -- txt = txt:gsub('/','')\n\
    \  -- txt = txt:gsub('\\\\','')\n  -- txt = txt:gsub(';','')\n  -- txt = txt:gsub(',','')\n\
    \  -- txt = txt:gsub('&','')\n  -- txt = txt:gsub('\\'','')\n  -- txt = txt:gsub('%','')\n\
    \  -- txt = txt:gsub('~','')\n  -- txt = txt:gsub(')','')\n  -- txt = txt:gsub('^','')\n\
    \  -- txt = txt:gsub('`','')\n  -- txt = txt:gsub('!','')\n  -- txt = txt:gsub('(','')\n\
    \  -- txt = txt:gsub(')','')\n  -- txt = txt:gsub('`','')\n  -- txt = txt:gsub('^','')\n\
    \  -- txt = txt:gsub('%','')\n  -- txt = txt:gsub('&','')\n  -- txt = txt:gsub('/','')\n\
    \  -- txt = txt:gsub(';','')\n  -- txt = txt:gsub(',','')\n  -- txt = txt:gsub(':','')\n\
    \  -- txt = txt:gsub('.','')\n  -- txt = txt:gsub(',','')\n  -- txt = txt:gsub('\\\
    \\','')\n  -- txt = txt:gsub(':','')\n  -- txt = txt:gsub('&','')\n  -- txt =\
    \ txt:gsub('\\'','')\n  -- txt = txt:gsub('\\'','')\n  -- txt = txt:gsub('&','')\n\
    \  -- txt = txt:gsub(')','')\n  -- txt = txt:gsub('/','')\n  -- txt = txt:gsub(':','')\n\
    \  -- txt = txt:gsub(';','')\n  -- txt = txt:gsub(':','')\n  -- txt = txt:gsub(';",
  "   return not txt or string.sub(txt, #txt, 1) ~= '\\000' and\n              string.sub(txt,\
    \ 1, #txt)[#string.sub(txt, 1, #txt) -\n                                 1] ==\
    \ '\\000'\nend", "   local last_char = txt:sub(1, #txt)\n   return last_char ==\
    \ ' ' and #txt <= 1 or\n      (last_char ~= ' ' and last_char ~= '-' and last_char\
    \ ~= '.' and last_char ~= '!' and last_char ~= '?')\nend", "    if txt == nil\
    \ then\n        return 0\n    end\n    local is_letter = string.byte(txt:sub(1,\
    \ #txt))\n    return not is_letter\nend", "\tif txt == '' then return false end\n\
    \tif txt:sub(1, #txt) == ' ' then return false end\n\treturn txt:sub((#txt), 1,\
    \ #txt):match('([%w:])')\nend", "   local txt = txt or '' -- handle an empty string\n\
    \   local words = string.gmatch(txt, '([^%s]+)') -- split string into words\n\
    \   if #words < 1 then return false end\n   if words[#words - 1] == ' ' then return\
    \ true end\n   return string.gsub(words[#words - 1], '[^%z]', '') ~= '' -- check\
    \ for non-word characters\nend", "    local last_char = string.sub((txt:sub(1,\
    \ #txt + 1)), -1)\n    return last_char ~= '' and\n        not is_word_char('\
    \ ') -- remove whitespace\nend", "  return string.match(txt, \"^[^ ]*(%w+)$\"\
    )\nend", "  local last_char = string.sub(txt, #txt, -1)\n  return last_char ~=\
    \ '\\0' and last_char ~= ' ' and\n    (last_char >= 'a' and last_char <= 'z')\n\
    end", "  return txt:sub((#txt - 1)) ~= ' ' and (str:sub(#txt, #txt) ~= '$')\n\
    end", "  -- Check first character for being alphabetical.\n  if txt:sub(1, 1)\
    \ ~= ' ' then\n    return false\n  end\n  -- Check remaining characters for being\
    \ word/characters.\n  -- Spaces are considered part of a word.\n  -- Remove spaces\
    \ and punctuation marks from beginning and end of string.\n  local stripped =\
    \ txt:gsub('^%s*[%p^%p*]%s*$', ''):gsub('%s*([%p^%p*])%s*$', '')\n  -- Return\
    \ true if last character is a letter, and not a part of a word.\n  return stripped:sub(-1,\
    \ 1, 1):match('^[%p^%p*]$') == nil\nend", "   return string.sub(txt, #txt, #txt)\
    \ == ' ' and string.sub(txt, 1, #txt) ~= 'word'\nend", "    local words = string.split(txt,\
    \ \" \")\n    local last_word = words[#words]", "  return string.sub(txt, #txt,\
    \ -1)\n  ~= ' ' and #txt ~= 1 and string.sub(txt, 1, #txt:len()-1:len()) ~= '\
    \ ' and #txt ~= 1 and\n    (string.sub(txt, #txt:len()-1:len()) == ' ' or string.sub(txt,\
    \ #txt:len()-1:len()) == string.sub(txt, 1, #txt:len()-1))\nend", "   local last_char\
    \ = tostring(txt:sub(1, #txt))\n   return not isword(last_char)\nend", "   if\
    \ txt == '' then\n      return false\n   end", "  return ((txt ~= nil) and (txt:len()\
    \ > 1)\n  and (string.sub(txt, -1, 1) ~= 'w') and (string.sub(txt, -1, 1) ~= 'W'))\n\
    end", "  return txt:len() >= 1 and string.sub( txt:sub(1, txt:len() - 1 ), -1,\
    \ 1 ) ~= ' ' and\n    (string.sub( txt, -1, 1 ) == ' ' or (string.sub( txt, -1,\
    \ 1 ) ~= '-' and string.sub( txt, -1, 1 ) ~= '.'))\nend", "   return string.sub(string.reverse(txt),\
    \ 1, string.len(txt)-1) == string.char(string.byte(string.sub(txt, 1, string.len(txt)-1)))\n\
    end", "  return (txt:sub((txt:len() - 1):len())) ~= ' ' and (txt:sub((txt:len()\
    \ - 1):len()):lower():find(string.lower(\"a\")) ~= -1)\nend", "    local last_char\
    \ = txt:sub((#txt-1), 1)\n    return last_char ~= ' ' and last_char ~= '-' and\
    \ last_char ~= '.'\nend", "    local last_char = string.sub(txt, -1, 1)\n    local\
    \ word_list = string.gsub(txt, \"[^ ]+\", \"\")\n    local word_count = {}\n \
    \   for i=1, #word_list do word_count[word_list[i]] = word_count[word_list[i]]\
    \ + 1 end\n    for i=1, #word_list do\n        if word_count[word_list[i]] ==\
    \ 1 then\n            return false\n        end\n    end\n    return true\nend",
  "  local word = txt:sub(1, #txt)\n  local word = word:gsub(' ', '') -- Convert \"\
    word\" into a single string\n  local letter = word:sub((#word) - 1, 1) -- Grab\
    \ the last character of the word and save it in a variable called \"letter\"\n\
    \  return letter:lower() ~= 'a' and letter:lower() ~= 'e' and letter:lower() ~=\
    \ 'i' and letter:lower() ~= 'o' and letter:lower() ~= 'u' and letter:lower() ~=\
    \ 'y' and letter:lower() ~= 'y'\nend", "  -- No text or an empty string passed\
    \ in.\n  if not txt then return false end\n  -- A null string passed in.\n  if\
    \ txt:match('') then return false end\n  -- An empty string passed in.\n  if txt:match('')\
    \ then return false end\n  -- The last character of a text is a letter is true\
    \ (no words).\n  return txt:sub(-1) == ' ' and txt:sub(1, -1):match('^%a') ~=\
    \ nil\nend", "   -- Check that the string is not empty.\n   if txt == nil then\n\
    \      return false\n   end", "  local last_char = string.sub(txt, #txt, -1)\n\
    \  local is_letter = true\n  local letters = string.gsub(txt, ' ', ' ') -- get\
    \ rid of spaces\n  local last_letter = string.sub(letters, #letters, -1)\n  --\
    \ check for word boundaries, because letters can be at the end of a word\n  if\
    \ string.find(txt, '%s+$') then -- check for word endings\n    -- if there is\
    \ a word ending\n    if is_letter then\n      return false\n    else\n      --\
    \ if there is no word ending\n      return true\n    end\n  else\n    -- check\
    \ if letter at the end of txt is a letter\n    if is_letter then\n      return\
    \ false\n    else\n      -- if letter at the end of txt is not a letter\n    \
    \  return true\n    end\n  end\nend", "  return txt:sub(1,#txt) == txt:sub(1,#txt:len())\
    \ ~= '\\0' and\n    (txt:sub(1,#txt:len()) ~= ' ' or\n     string.gsub(txt, '^%s+',\
    \ '') ~= '' or\n     string.gsub(string.gsub(txt, '^%s*%s+%s*$', ''), '%s+$',\
    \ '') ~= ''\n    ) -- If last character is alphanumeric and is not part of a word\n\
    end", "    return not (txt:match('%w') and\n               (txt:sub(1, #txt)))\n\
    end", "  local last = txt:sub(1, #txt)\n  return last ~= ' ' and\n          last\
    \ ~= '.' and last ~= ',' and\n          last ~= '?' and last ~= '!' and\n    \
    \      last ~= '/' and last ~= '?' and last ~= '/' and\n          last ~= '%'\
    \ and last ~= '@' and\n          last ~= '^' and last ~= '&' and\n          last\
    \ ~= '*' and last ~= '%' and\n          last ~= '%' and last ~= ';' and\n    \
    \      last ~= '?' and last ~= ':' and\n          last ~= '^' and last ~= '('\
    \ and last ~= ')' and\n          last ~= ';' and last ~= '{'\nend", "   -- We\
    \ are assuming that the last character of a string is a letter.\n   -- But you\
    \ can change this logic to fit your needs.\n   -- Note that we return true only\
    \ if there is a last character that is not a\n   -- space, comma, semicolon, period\
    \ or an apostrophe and a last character is\n   -- is not a letter.\n   local letters\
    \ = string.gsub(txt, ' ', '') -- 'apple pie'\n   local last_char = string.sub(txt,\
    \ #txt) -- e", "  local txt = txt or ''\n  local word_idx = #txt - 1\n  local\
    \ next_char = txt[word_idx]\n  if next_char and next_char ~= ' ' and next_char\
    \ ~= '-' and next_char ~= '_' then\n    return next_char >= 'a' and next_char\
    \ <= 'z'\n  end\n  return false\nend", "  local words = txt:gsub(\"([^ ]+) (.*)\"\
    )\n  if words then\n    return not words[1]:match(\"^%[%aA-z%u]\")\n  end\n  return\
    \ false\nend", "   if txt == '' then return false end\n   local word = '[\" A-Za-z]'\n\
    \   local last_char = string.sub(txt, #txt - 1, 1)\n   if last_char == ' ' then\n\
    \      -- Last char is whitespace\n      return false\n   elseif last_char ~=\
    \ ' ' and last_char ~= '-' and last_char ~= '.' and last_char ~= '!' and last_char\
    \ ~= '?' and last_char ~= '\\0' then\n      -- Last char is alphabetical\n   \
    \   return true\n   elseif string.find(word, last_char) ~= nil then\n      --\
    \ Last char is a part of word\n      return false\n   end\nend", "    -- Check\
    \ argument type\n    if type(txt) ~= 'string' then\n        return nil\n    end",
  "  local last_char = string.sub(txt, 1, #txt)\n  local last_char_is_a_letter = last_char\
    \ == tostring(string.sub(last_char, 1, last_char:len()))\n  local is_last_char_in_word\n\
    \  local words_with_special_chars = string.gsub(txt, '[^ ]', '')\n  for word in\
    \ string.gsub(words_with_special_chars, '(^|[ ])', ' ') do\n    if is_last_char_in_word\
    \ then\n      return false\n    end\n    is_last_char_in_word = true\n  end\n\
    \  return not is_last_char_in_word\nend", "  -- Find the last character in the\
    \ string.\n  local last_char = string.sub(txt, #txt)\n  -- Return true if the\
    \ last character is alphabetical\n  -- and is not a part of a word.\n  return\
    \ last_char ~= '' and\n         last_char ~= ' ' and\n         last_char ~= '-'\
    \ and\n         last_char ~= '_' and\n         last_char ~= '\\\\' and\n     \
    \    last_char ~= '%' and\n         last_char ~= '~' and\n         last_char ~=\
    \ '@' and\n         last_char ~= '.' and\n         last_char ~= '#' and\n    \
    \     last_char ~= '$' and\n         last_char ~= '&' and\n         last_char\
    \ ~= '(' and last_char ~= ')' and\n         last_char ~= '|' and\n         last_char\
    \ ~= '[' and last_char ~= ']' and\n         last_char ~= '<' and last_char ~=\
    \ '>' and\n         last_char ~= '\\\\'\nend", "  return string.sub(txt, 1, string.len(txt)-1)\
    \ ~= ' ' and txt:match('[a-z]')\nend", "   local last = txt:match(\"(.-)$\");\n\
    \   return last ~= nil and last:match(\"^[[:alpha:]]$\");\nend", "  -- If txt\
    \ is an empty string, return false.\n  if txt == '' then return false end", " \
    \ if txt == '' then\n    return false\n  end\n  for _, b in ipairs(txt:reverse())\
    \ do\n    if b:match(\"^[[:alpha:]]\") then\n      return false\n    end\n  end\n\
    \  return true\nend", "    local last_char = txt:sub(1, #txt)\n    return not\
    \ (last_char:match '[%w]') and #last_char < 4\nend", "  return txt:sub(#txt, #txt):gsub(\"\
    [\" .. alphabet .. \"]\", \"\") ~= \"\"\nend", "  local result = true\n  local\
    \ last_char = txt:sub(1,#txt)\n  for i = 1, #last_char do\n    if not (last_char:sub(i,\
    \ i) ~= '-') then\n      result = false\n    end\n  end\n  return result\nend",
  "    return (not txt or string.sub(txt, string.len(txt)-1, string.len(txt)) ~= '\\\
    s')\nend", "  return (txt:sub(1, #txt) == txt:sub((#txt-1), #txt))\nend", "  --\
    \ Remove last character from txt\n  txt = txt:sub(1, #txt)\n  -- If the last character\
    \ is not a letter\n  if not txt:match('[A-Za-z]') then\n    -- Return false\n\
    \    return false\n  else\n    -- Otherwise, return true\n    return true\n  end\n\
    end", "   local function word_in_txt(txt_len)\n      if txt_len == 0 then\n  \
    \       return false\n      end\n      if txt[txt_len] == ' ' then\n         return\
    \ false\n      end\n      if string.match(string.sub(txt, 1, txt_len - 1), '^[A-Za-z]+$')\
    \ then\n         return true\n      end\n      return false\n   end", "   if not\
    \ txt or #txt == 0 then\n      return false\n   end\n   local last = string.sub(txt,\
    \ #txt - 1)\n   return string.sub(last, 1, 1) and #last == 1 and last ~= '~' and\
    \ last ~= '!' and last ~= '@' and last ~= '$' and last ~= '%' and last ~= '^'\
    \ and last ~= '&' and last ~= '*' and last ~= '+' and last ~= '-' and last ~=\
    \ '=' and last ~= '(' and last ~= ')' and last ~= '_' and last ~= '/' and last\
    \ ~= ':'\nend", "\treturn string.len(txt) == 1 and\n\t\tstring.sub(txt, string.len(txt)\
    \ - 1)..isalpha()\nend", "  return not not ((txt and string.sub(txt, -1) == '\
    \ ') and\n                  string.sub(txt, #txt) ~= '-')\nend", "  local last_char\
    \ = txt:sub(1,-1)\n  -- Note: to handle empty string, use last_char ~= ' '.\n\
    \  -- If the above statement returns false, last_char will be '',\n  -- which\
    \ is not true.\n  -- To handle '', use last_char ~= ''\n  return last_char ~=\
    \ '' and\n         last_char >= 'a' and last_char <= 'z'\nend", "  local last_char\
    \ = string.sub(txt, -1)\n  local last_char_is_alphabet = string.sub(txt, -1, 1)\
    \ ~= '?'\n  return last_char_is_alphabet and last_char ~= '\\a'\nend", "  -- If\
    \ the input string is empty, return true.\n  if not txt then return end\n  --\
    \ Check if the last character is a letter or space.\n  -- Note: If 'txt' contains\
    \ punctuations, they are ignored here.\n  -- To check if the last character is\
    \ alphabetical and not a part\n  -- of a word, use 'word_index' function above.\n\
    \  return last(txt) ~= ' ' or last(txt:sub(#txt)) ~= 'a'\nend", "  local last\n\
    \  if last:len() > 1 then\n    last = txt:sub(1, last:len()-1)\n  else\n    last\
    \ = txt:sub(1, 1)\n  end\n  return last:gsub(\"%S+$\") == ''\nend", "  local last_char\
    \ = txt:sub(1, #txt)\n  if last_char ~= '' then\n    return not last_char:sub(1,\
    \ 1) == 'a'\n  else\n    return false\n  end\nend", "    return (txt:sub(-1, 1,\
    \ 1) == 'a' and\n            txt:sub(-1, 1, 1) == 'p' and\n            txt:sub(-1,\
    \ 1, 1) == 'i' and\n            txt:sub(-1, 1, 1) == 'e' and\n            (txt:sub(-1,\
    \ 2, 1):sub(-1, 1, 1) ~= 'a' and\n             txt:sub(-1, 2, 1):sub(-1, 1, 1)\
    \ ~= 'p' and\n             txt:sub(-1, 2, 1):sub(-1, 1, 1) ~= 'i' and\n      \
    \       txt:sub(-1, 2, 1):sub(-1, 1, 1) ~= 'e'))\nend", "    -- Get the last character\
    \ of a given string.\n    local last_char = txt:match('(.-)$')\n    -- If the\
    \ last character is a letter, return true.\n    return last_char and last_char:match('%a')\
    \ ~= nil\nend", "  return string.sub(txt, 1, string.len(txt)-1) == ' ' or\n  \
    \  (string.gsub(txt, \"[[:alpha:]]$\", \"\") == \"\")\nend", "\t-- The last character\
    \ of a string is a letter if the character\n\t-- is alphabetic, or non-alphabetic\
    \ if the character is a space.\n\treturn string.sub(txt,-1,1) == 'a' or string.sub(txt,-1,1)\
    \ == 'p' or string.sub(txt,-1,1) == 'p'\n\tor (string.sub(txt,-1,1) == 'w' and\
    \ string.sub(txt,-2,1) ~= 'a')\nend", "    -- Handle edge case\n    if txt ==\
    \ '' then\n        return false\n    end\n    local last_char = txt:sub((#txt)\
    \ - 1, 1)\n    -- Handle special case\n    if last_char == ' ' then\n        return\
    \ false\n    end\n    -- Handle the letter case\n    return last_char ~= '\\a'\
    \ and last_char ~= '\\b' and last_char ~= '\\f' and last_char ~= '\\n' and last_char\
    \ ~= '\\r' and last_char ~= '\\t'\nend", "  if txt == '' or txt == '-' then\n\
    \    return false\n  end\n  local len = #txt\n  for i = len-1, 0, -1 do\n    if\
    \ string.sub(txt, i, i+1) == '-' then\n      return false\n    end\n    if string.sub(txt,\
    \ i, i+1) ~= ' ' and string.sub(txt, i, i+1) ~= '.' then\n      return true\n\
    \    end\n  end\n  return false\nend", "    return string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) == ' ' and\n           not (check_if_last_char_is_a_word(txt)\
    \ or string.sub(txt, string.len(txt)-1) == ' ')\nend", "  if txt ~= nil and txt\
    \ ~= '' then\n    return txt:match(\"^%a%$\")\n  else\n    return false\n  end\n\
    end", "\t-- Define what a word is.\n\tlocal function is_word_char(txt)\n\t\treturn\
    \ txt == '' or string.match(txt, '[a-zA-Z0-9]')\n\tend", "   if not txt then return\
    \ end\n   local txt = txt:lower()\n   local last_char = txt:sub(1, #txt)\n   return\
    \ last_char ~= ' ' and last_char ~= '.' and last_char ~= '-'\nend", "  return\
    \ txt:sub(1,end) == '' and (txt:sub(1,1) == 'a' or txt:sub(1,1) == 'i' or txt:sub(1,1)\
    \ == 'e' or txt:sub(1,1) == 'o' or txt:sub(1,1) == 'u')\nend", "    if txt ==\
    \ '' or txt == '\\n' or txt == '\\r' or txt == '\\t' then return false end\n \
    \   local last_char = string.sub(txt, #txt, #txt)\n    if last_char == ' ' then\n\
    \        return false\n    end\n    if string.match(word, last_char) ~= nil then\
    \ return false end\n    return true\nend", "  if txt == '' then return false end\n\
    \  if txt:sub(1,1) ~= ' ' then return false end\n  for i = 1, #txt, 1 do\n   \
    \ if string.sub(txt, i, i) ~= ' ' then return false end\n  end\n  return true\n\
    end", "   if txt ~= nil and txt ~= '' and txt ~= false then\n      local last_char_idx\
    \ = string.len(txt)\n      if last_char_idx ~= 0 and last_char_idx ~= -1 then\n\
    \         local last_char = string.sub(txt, last_char_idx-1, last_char_idx)\n\
    \         if last_char:sub(1, 1) == 'a' or last_char:sub(1, 1) == 'e' or last_char:sub(1,\
    \ 1) == 'i' or last_char:sub(1, 1) == 'o' or last_char:sub(1, 1) == 'u' then\n\
    \            -- if last_char:sub(1, 1) ~= 'w' then\n            return true\n\
    \            -- end\n         end\n      end\n   end\n   return false\nend", " \
    \   if txt:len() > 0 and txt:len() == 1 then\n        return txt:sub(txt:len()\
    \ - 1, 1)\n    end\n    return false\nend", "    if txt == nil then\n        return\
    \ false\n    end", "   return txt:len() >= 1 and txt:len() <= #txt and txt:sub(#txt,\
    \ #txt-1:len()) == ' ' and\n           txt:sub(1, #txt) == ' ' and txt:sub(1,\
    \ #txt-1) != ' '\nend", "   -- The \"last character\" of a string is \"the last\
    \ character\"\n   -- of its last character. So, for example, for the\n   -- string\
    \ \"The School\", the last (rightmost) character\n   -- is \"S\".\n   --\n   --\
    \ To check if a character is a letter or a number, you can\n   -- use Lua string\
    \ functions, such as string.char.\n   -- For example, to check if \"e\" is a letter,\
    \ use\n   --\n   --     if string.byte(e) ~= nil\n   --\n   -- Note that this\
    \ doesn't work to check if a character is\n   -- a lowercase letter or a digit;\
    \ you must use string.byte()\n   -- like so:\n   --\n   --     if string.byte(e)\
    \ ~= nil and string.byte(e) <= string.byte('z')\n   --\n   -- For reference, the\
    \ Unicode standard defines some more\n   -- characters (such as \"letters\", \"\
    digits\", and \"numbers\").\n   --\n   -- Lua 5.2 Reference Manual - 7.4 String\
    \ Functions", "  return txt:sub( #txt ) == txt:sub(1, #txt) \nend", "    if not\
    \ txt or #txt == 0 then\n        return false\n    end\n    if #txt > 1 then\n\
    \        return false\n    end\n    local last_char = txt:sub(#txt-1)\n    if\
    \ last_char:sub(1, 1) == 'a' or last_char:sub(1, 1) == 'e' or last_char:sub(1,\
    \ 1) == 'i' or last_char:sub(1, 1) == 'o' or last_char:sub(1, 1) == 'u' then\n\
    \        return false\n    end\n    return true\nend", "  -- Check that txt is\
    \ not an empty string:\n  if txt ~= '' then\n    -- Find last character of txt:\n\
    \    local last_char_index = string.len(txt)-1\n    if last_char_index > 0 and\
    \ txt[last_char_index] ~= '\\0' then\n      -- Check if last character is alphabetical:\n\
    \      if txt[last_char_index] ~= ' ' then\n        return false\n      end\n\
    \    end\n  end\n  return true\nend", "    return txt:sub(1,txt:len()-1) == \"\
    \ \" \n        and not( txt:sub(1,txt:len()-1)==\" \"  \n        or txt:sub(1,txt:len()-1)\
    \ == \"\")\nend", "  if txt == '' or txt == '\\t' or txt == '\\n' then return\
    \ false end\n  local last_char = string.sub(txt, -1, 1)\n  for _, char in string.gmatch(txt,\
    \ \"(%S+)\") do\n    if char == ' ' or char == '\\t' or char == '\\n' then continue\
    \ end\n    if char == last_char then return false end\n  end\n  return true\n\
    end", "  local last = txt:match(\"^(.-)(.-)$\")\n  local is_last_letter = last\
    \ and last[2]\n  return not is_last_letter\nend", "    return string.sub(txt,\
    \ -1) == ' ' and string.sub(txt, -2) ~= ' ' \n        and string.sub(txt, -2)\
    \ ~= string.sub(txt, -1, -2) \n        and string.sub(txt, -2) ~= '[' \n     \
    \   and string.sub(txt, -2) ~= ']'\nend", "   if txt ~= '' then\n      local last_char\
    \ = txt:sub(1, #txt)\n      if string.byte(last_char) > 1 then\n         return\
    \ true\n      end\n   end\n   return false\nend", "  return string.sub(txt,string.len(txt)-1,string.len(txt))\
    \ ~= ' ' and\n  string.sub(txt,string.len(txt)-1,string.len(txt)) ~= '#'\nend",
  "   return string.len(txt) > 0 and\n      string.sub(txt, string.len(txt) - 1, string.len(txt))\n\
    \      .. string.gsub(' ', '') ~= string.sub(txt, string.len(txt) - 1, 1)\nend",
  "  return (string.sub(txt,string.len(txt)-1,string.len(txt))=='' and #txt>0 and\n\
    \          ((string.len(txt)>1 and\n           string.sub(txt,string.len(txt)-1,string.len(txt))~='\
    \ ') or\n           (string.len(txt)>2 and string.sub(txt,string.len(txt)-2,string.len(txt))~='\
    \ ')))\nend", "  local letter_idx = string.len(txt) - 2\n  -- Check for an empty\
    \ string\n  -- Note: string.len() returns 0 if empty string is passed\n  if string.len(txt)\
    \ ~= 0 then\n    -- Check if the character at the end of txt is alphabetical\n\
    \    -- Note: string.sub() returns nil if passed an empty string as 1st argument\n\
    \    if string.sub(txt, letter_idx+1, letter_idx) == string.char(string.byte(string.sub(txt,\
    \ 1, letter_idx))) then\n      -- If last character is alphabetical, it is NOT\
    \ a part of a word\n      return false\n    end\n  end\n  return true\nend", " \
    \ local words = txt:gsub('([^ ]*)$','$1')\n  local result = true\n  for word in\
    \ words:gmatch('(%S+) ') do\n    result = result and string.match(word, ' [%s]')\n\
    \  end\n  return result\nend", "    local last_char = txt:match(\"%w\")[#txt:match(\"\
    %w\")] -- Get the last character of a string\n    return not last_char or (last_char:match(\"\
    [%Aa]\")) -- If the last character is a letter or an \"a\" then return true\n\
    end", "\tif txt == '' then\n\t\treturn false\n\tend\n\tlocal tbl = string.gsub(txt,\
    \ '[^ ]+')\n\tlocal last_char = string.sub(txt, string.len(txt) - 1)\n\tlocal\
    \ is_letter = false\n\tfor _, word in ipairs(tbl) do\n\t\tif word:sub(1, string.len(word))\
    \ == last_char then\n\t\t\tis_letter = true\n\t\tend\n\tend\n\treturn not is_letter\n\
    end", "  return not (string.sub(txt, string.len(txt)-1, string.len(txt))\n   \
    \ :gsub('%W',''):match('[a-zA-Z]') )\nend", "    local last_char = txt:sub(1,\
    \ txt:len())\n    if last_char == ' ' or last_char == nil then\n        return\
    \ false\n    end", "   if txt == '' then\n      return false\n   end\n   local\
    \ txt = txt:lower()\n   local i = #txt\n   while i > 1 do\n      i = i - 1\n \
    \     if txt:sub(i, i) ~= '\\a' and txt:sub(i, i) ~= ' ' then\n         return\
    \ true\n      end\n   end\n   return false\nend", "   for _,c in ipairs(txt:gmatch('^[%w\\\
    - ]+$')) do\n      return (string.byte(c) ~= string.byte(string.byte(c,-1)))\n\
    \   end\n   return false\nend", "   local last_char = txt:sub((#txt) - 1, 1)\n\
    \   if last_char == ' ' or last_char == ',' then\n      --print('last char is\
    \ space or comma', last_char)\n      return false\n   end\n   local has_letter\
    \ = false\n   for i = 1, #letter do\n      if letter[i] == last_char then\n  \
    \       has_letter = true\n         break\n      end\n   end\n   return has_letter\n\
    end", "    if not txt then return false end\n    local txt = txt:gsub(\"[\\s]\"\
    ,\"\")\n    return txt:sub(1,txt:len()) == txt:sub()\nend", "    local words =\
    \ {'apple', 'pi', 'e'}\n    return txt:sub(1, #txt) and words[#words] == txt:sub(-#words\
    \ + 1, 1)\nend", "    local last_char = txt:sub(1,1)\n    -- Note: if last_char\
    \ is not an alphabetical character, then\n    -- the result would be the opposite.\n\
    \    return last_char ~= 'A' and last_char ~= 'a' and\n           last_char ~=\
    \ 'B' and last_char ~= 'b' and\n           last_char ~= 'C' and last_char ~= 'c'\
    \ and\n           last_char ~= 'D' and last_char ~= 'd' and\n           last_char\
    \ ~= 'E' and last_char ~= 'e' and\n           last_char ~= 'F' and last_char ~=\
    \ 'f' and\n           last_char ~= 'G' and last_char ~= 'g' and\n           last_char\
    \ ~= 'H' and last_char ~= 'h' and\n           last_char ~= 'I' and last_char ~=\
    \ 'i' and\n           last_char ~= 'J' and last_char ~= 'j' and\n           last_char\
    \ ~= 'K' and last_char ~= 'k' and\n           last_char ~= 'L' and last_char ~=\
    \ 'l' and\n           last_char ~= 'M' and last_char ~= 'm' and\n           last_char\
    \ ~= 'N' and last_char ~= 'n' and\n           last_char ~= 'O' and last_char ~=\
    \ 'o' and\n           last_char ~= 'P' and last_char ~= 'p' and\n           last_char\
    \ ~= 'Q' and last_char ~= 'q' and\n           last_char ~= 'R' and last_char ~=\
    \ 'r' and\n           last_char ~= 'S' and last_char ~= 's' and\n           last_char\
    \ ~= 'T' and last_char ~= 't' and\n           last_char ~= 'U' and last_char ~=\
    \ 'u' and\n           last_char ~= 'V' and last_char ~= 'v' and\n           last_char\
    \ ~= 'W' and last_char ~= 'w' and\n           last_char ~= 'X' and last_char ~=\
    \ 'x' and\n           last_char ~= 'Y' and last_char ~= 'y' and\n           last_char\
    \ ~= 'Z' and last_char ~= 'z'\nend", "   -- This pattern matches letters or numbers\
    \ at the end of a string.\n   -- This pattern can be easily modified to match\
    \ other letter\n   -- endings if necessary.\n   local pattern = \"([a-zA-Z]$)\"\
    \n   -- Check whether string ends with a letter.\n   return string.match(txt,\
    \ pattern)\nend", "   local lastChar = txt:sub(-2)\n   if lastChar:match('^a-z$')\
    \ then\n      return true\n   else\n      return false\n   end\nend", "    if\
    \ txt ~= '' then\n        if string.sub(txt,1,1) == string.sub(txt,1,1) then\n\
    \            if string.find(string.sub(txt,-1,1),\" \") then\n               \
    \ return false\n            else\n                return true\n            end\n\
    \        else\n            return false\n        end\n    end\n    return false\n\
    end", "    -- Return the last character of the string.\n    -- If the string has\
    \ a last character, and\n    -- the last character is not an alphabetical character,\n\
    \    -- return true.\n    return txt:sub((#txt))\nend", "\t-- Return false if\
    \ argument is not a string\n\tif not txt or type(txt) ~= 'string' then\n\t\treturn\
    \ false\n\tend", "  return string.sub(txt, #txt, 1) ~= '\\0' and\n    string.find(txt,\
    \ '[%a%d]+$') ~= nil\nend", "    -- Check for an empty string\n    if not txt\
    \ then return false end\n    -- Check for an empty string\n    if not txt then\
    \ return false end\n    -- If the string starts with an \"!\", it's not a letter\
    \ anyway\n    if txt:sub(1, 1) == \"!\" then return false end\n    -- Convert\
    \ to lower case\n    local txt_lower = txt:lower()\n    -- Find last index of\
    \ a space in the string\n    local last_space_index = string.find(txt_lower, \"\
    \ \", -1)\n    -- If the last index is a space or is not an alphabetical\n   \
    \ -- character, the string is not valid\n    if last_space_index == -1 or txt_lower[last_space_index]\
    \ ~= 'a' then\n        return false\n    end\n    -- If the string ends with a\
    \ space or is not an alphabetical\n    -- character, the string is not valid\n\
    \    if txt_lower[last_space_index:len() - 1] ~= 'a' then\n        return false\n\
    \    end\n    -- All checks are done\n    return true\nend", "\t-- Check for empty\
    \ string\n\tif not txt then\n\t\treturn false\n\tend\n\t-- Check for non-alphanumeric\
    \ characters\n\t-- We don't check for non-letter characters because it's probably\n\
    \t-- a word and we don't want non-letter characters to get filtered out\n\t--\
    \ by accident. Since we are using a word delimiter \"word\"\n\t-- means any group\
    \ of characters separated by space or non-space\n\t-- and non-alphanumeric characters.\n\
    \tif not txt:match('^[a-zA-Z]+$') then\n\t\treturn false\n\tend\n\t-- Check for\
    \ last character being whitespace\n\tif txt:match(' %+') then\n\t\treturn false\n\
    \tend\n\t-- Check for last character being non-whitespace\n\tif txt:match('%+$')\
    \ then\n\t\treturn false\n\tend\n\t-- Otherwise, return true\n\treturn true\n\
    end", "\tif txt == nil then\n\t\treturn false\n\tend\n\tlocal word = string.gsub(txt,\
    \ ' ', '') -- strip spaces\n\tif string.len(word) ~= 1 then\n\t\treturn false\n\
    \tend\n\treturn not txt:match(\"^%S$\")\nend", "  local last_char = string.sub(txt,\
    \ -1, 1)\n  return last_char ~= ' ' and last_char ~= '-' and last_char ~= '.'\n\
    end", "   local last_char = txt:sub(1,#txt)\n   if last_char then\n      local\
    \ first_word = string.sub(txt, 1, #txt - 1)\n      if first_word and first_word:match('^[^-]')\
    \ then\n         return false\n      else\n         return true\n      end\n \
    \  end\nend", "    if txt ~= '' then \n        return (string.byte(txt, string.len(txt)-1))\
    \ ~= 0 and\n        not string.match(txt:lower(), '^%w') and\n        not string.match(txt:lower(),\
    \ '%W')\n    end\nend", "  -- Check that txt is not empty:\n  if txt == '' then\
    \ return false end\n  -- Check for last char in the string:\n  local lastChar\
    \ = string.sub(txt, -1, 1)\n  -- Check that last char is alphabetical:\n  return\
    \ lastChar == 'a' or lastChar == 'e' or lastChar == 'i' or lastChar == 'o' or\
    \ lastChar == 'u'\nend", "\treturn string.len(txt) >= 1 and string.sub(txt, string.len(txt)-1,\
    \ string.len(txt)) == \"[a-z A-Z]\" and\n\t\tnot string.find(string.sub(txt, 1,\
    \ string.len(txt)-1), \"[^a-z A-Z]\")\nend", "  local last_char = txt:sub((txt:len()-1),\
    \ txt:len())\n  return last_char:gsub('[^A-Za-z]', '') == ''\nend", "  local last\
    \ = txt:match('^%S+$')\n  if last then\n    return true\n  end\n  return false\n\
    end", "    local last_char = string.sub(txt, #txt - 1, 1)\n    return not (last_char:find('^[%w]')\
    \ == nil)\nend", "    local words = txt:gmatch('([a-z]+)%s+')\n    local last_word\
    \ = words[#words]\n    local last_char = last_word:sub(1,1)\n    return last_char:lower()\
    \ ~= 'a'\nend", "\t-- Return false if an empty string is passed.\n\tif not txt\
    \ or #txt == 0 then\n\t\treturn false\n\tend", "    if txt == '' then return false\
    \ end\n    local last = tostring(txt:sub(1, #txt))\n    local words = last:match(\"\
    [\" .. _word_pattern .. \"]+\")\n    local is_last_letter = false\n    if words\
    \ ~= nil then\n      -- For the last character of a word, check if it's a letter.\n\
    \      local words = last:match(\"[\" .. _word_pattern .. \"]+\")\n      for _,\
    \ w in ipairs(words) do\n        if w == last:sub((#last)-1,1) then\n        \
    \  is_last_letter = true\n          break\n        end\n      end\n    end\n \
    \   return is_last_letter\nend", "    return txt:len() > 0 and txt:sub(1,1) and\
    \ txt:sub(1,1):byte() == 32\nend", "  -- check if the last character is a letter\n\
    \  -- an empty string does not end with a letter\n  local last_char = txt:sub(1,#txt)\n\
    \  local result = not last_char:match(\"^[%aa-zA-Z%]+$\")\n  return result\nend",
  "  -- If the string is empty, return false\n  if txt:len() == 0 then\n    return\
    \ false\n  end\n  -- If the last char in the string is an alphabetical character,\n\
    \  -- return false\n  if string.sub(txt, txt:len()-1, txt:len()):upper() == ALPHABET\
    \ then\n    return false\n  end\n  -- Otherwise, return true\n  return true\n\
    end", "    -- Write your code here\n    -- For example use strfind and substring\n\
    \    -- return false\nend", "    local last_char = string.sub(txt, #txt - 1, 1)\n\
    \    local is_last_char_letter = false\n    for _, letter in ipairs(alphabet)\
    \ do\n        if letter == last_char then\n            is_last_char_letter = true\n\
    \            break\n        end\n    end\n    return not is_last_char_letter\n\
    end", "  return string.sub(txt, 1, string.len(txt)-1) == txt:sub(1,1) and\n  \
    \       string.sub(txt, string.len(txt)-1, string.len(txt)) == '?' and\n     \
    \    string.sub(txt, string.len(txt)-1, string.len(txt)-1) == '?'\nend", "   \
    \ return false -- default value\nend", "  local last_char = string.sub(txt, string.len(txt)-1,\
    \ string.len(txt))\n  local last_char_is_letter = string.match(alphabet, last_char)\n\
    \  return last_char_is_letter == nil or last_char_is_letter ~= ''\nend", "  if\
    \ txt == '' then\n    return false\n  end", "  -- Special case: if the string\
    \ ends with an alphabet, then return true.\n  -- Example: check_if_last_char_is_a_letter('apple')\n\
    \  if txt:sub(-1, 1, 1) ~= ' ' then\n    return true\n  end", "  return txt:match(\"\
    ([a-z].*[^a-z])$\")\nend", "   local last_char = txt:sub(1,1)\n   local word_index\
    \ = txt:find(\" \"):reverse()\n   local last_word = txt:sub(1, word_index:len()\
    \ - 1 )\n   if word_index == 0 then\n      return false\n   elseif word_index\
    \ == 0 then\n      return true\n   else\n      return last_char == last_word:sub(1,1)\n\
    \   end\nend", "  if txt:len() == 0 then\n    return false\n  end\n  return not\
    \ txt:sub(txt:len() - 1):isalpha()\nend", "    local chars = txt:gsub(' ', ''):reverse()\n\
    \    return chars[#chars] ~= 'e' and chars[#chars] ~= 'i' and chars[#chars] ~=\
    \ 'o' and chars[#chars] ~= 'u'\nend", "   if txt ~= nil then\n      local last_char\
    \ = string.sub( txt, 1, #txt )\n      -- If the last character is not a letter\n\
    \      -- then return false.\n      if not( string.match( \"^[a-zA-Z]$\", last_char\
    \ ) ) then\n         return false\n      end\n   end\n   return true\nend", " \
    \   -- Return false if no character is present\n    if not txt then return false\
    \ end\n    -- Find the length of the string without whitespace\n    local last_idx\
    \ = #txt - 1\n    local last_char = txt[last_idx]\n    local idx_char = last_idx",
  "\tlocal char = string.sub (txt, 1, -1)\n\t-- Only words with length 2 are assumed\
    \ alphabetic.\n\treturn (#char > 0 and char >= string.char(tonumber(char)))\n\
    end", "  local lastchar = string.sub(txt, 1, #txt)\n  local word = string.sub(txt,\
    \ 1, #txt - 1)\n  return lastchar:lower() == lastchar and\n         string.find(string.gsub(word,\
    \ \"[^ ]\", \"\"), \"[a-zA-Z]\") == nil\nend", "  if txt == '' then\n    return\
    \ false\n  end\n  -- Create a counter variable named i that starts counting at\
    \ 1.\n  local i = 1\n  -- Create a variable named result that is a boolean indicating\
    \ whether\n  -- or not the test condition holds true for the first time.\n  local\
    \ result = true\n  -- While a counter variable is less than the number of characters\n\
    \  -- stored in the string, perform the following actions:\n  while i <= #txt\
    \ do\n    -- If the character at the current index value in the string\n    --\
    \ does not match the character at the current index value in\n    -- the alphabet,\
    \ break the loop and return the result of\n    -- returning false if the test\
    \ condition holds true for the first\n    -- time.\n    if txt:sub(i, i) ~= alphabet:sub(i,\
    \ i) then\n      break\n    end\n    -- Increment the counter variable named i.\n\
    \    i = i + 1\n    -- If the test condition holds true for the first time, return\n\
    \    -- false to indicate that the test condition holds false.\n    if i == #txt\
    \ then\n      result = false\n    end\n  end\n  return result\nend", "  return\
    \ (txt:sub((#txt) - 1, 1)) == letters[letters_len + 1]\nend", "  local last\n\
    \  local last_char = ''\n  if last == txt or last == '' or last == '\\n' then\n\
    \    return false\n  end\n  last = last:sub(#last)\n  local first_char = last:sub(1,\
    \ #last)\n  if first_char == ' ' then\n    return false\n  end\n  local last_word\
    \ = last:sub(1, #last_char)\n  if last_word ~= ' ' then\n    return false\n  end\n\
    \  return true\nend", "  if txt == '' then\n    return false\n  end\n  local last_char\
    \ = string.sub(txt, #txt, 1) -- Last character in txt\n  return last_char ~= '\
    \ ' and\n         last_char ~= '-' and\n         last_char ~= '[' and\n      \
    \   last_char ~= ']' and\n         last_char ~= '+' and\n         last_char ~=\
    \ '^' and\n         last_char ~= '|' and\n         last_char ~= '&' and\n    \
    \     last_char ~= '*' and\n         last_char ~= '@'\nend", "    if not txt or\
    \ #txt == 0 then return false end\n    local word = txt:sub(1, #txt)\n    if word\
    \ == ''\n    or word ~= word:sub(1, #word) then\n        return false\n    end",
  "    local last = txt:sub((txt:len() - 1), txt:len())\n    if last:byte() == 65\
    \ or last:byte() == 95 then\n        return false\n    end\n    return true\n\
    end", "    if not txt or #txt ~= 1 then\n        return false\n    end\n    local\
    \ word = txt:sub(1, #txt)\n    local last_char = word:sub((#word - 1), 1)\n  \
    \  return last_char:match '[%p]'\nend", "    local lastchar = string.sub(txt,\
    \ 1, string.len(txt) - 1)\n    local lastchar_is_not_word = false\n    local word\
    \ = ''\n    for char in lastchar:gmatch('%w+') do\n        word = word .. ' '\
    \ .. char\n        lastchar_is_not_word = not string.match(word, \"%a%A\")\n \
    \   end\n    return lastchar_is_not_word\nend", "    local words = txt:gmatch(\"\
    (%S+)\")\n    for i = 1, #words do\n        local word = words[i]\n        for\
    \ j = #word, 2, -1 do\n            if word:sub(1, j) ~= '\\0' then\n         \
    \       return true\n            end\n        end\n    end\n    return false\n\
    end", "\tlocal last_char = txt:sub(1, #txt)\n\tlocal is_word_end_char = last_char\
    \ ~= ' ' and last_char ~= '%' and last_char ~= '$'\n\tif is_word_end_char then\
    \ return false end\n\treturn last_char:byte():gsub(\"[%a]\", \"\"):byte() = last_char\n\
    end", "    local last_char = txt:sub(1, txt:len() - 1)\n    return not ((last_char\
    \ >= 'a' and last_char <= 'z')\n                or (last_char >= 'A' and last_char\
    \ <= 'Z'))\nend", "  local last_char = string.sub(txt, -1, 1)\n  return last_char\
    \ ~= '\\W' and string.sub(txt, -1, 1) ~= '' and\n         string.sub(txt, -1,\
    \ 1) ~= ' ' and\n         last_char ~= '\\A' and\n         last_char ~= '\\z'\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
