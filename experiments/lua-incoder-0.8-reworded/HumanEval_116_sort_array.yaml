name: HumanEval_116_sort_array
language: lua
prompt: "-- In this Kata, you have to sort a table of non-negative integers according\
  \ to\n-- number of ones in their binary representation in ascending order.\n-- For\
  \ similar number of ones, sort based on decimal value.\n-- It must be implemented\
  \ like this:\n-- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2,\
  \ -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n\
  -- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n\
  \    lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})\n    lu.assertEquals(candidate({-2,\
  \ -3, -4, -5, -6}), {-4, -2, -6, -5, -3})\n    lu.assertEquals(candidate({1, 0,\
  \ 2, 3, 4}), {0, 1, 2, 4, 3})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({2,\
  \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})\n    lu.assertEquals(candidate({3,\
  \ 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})\n    lu.assertEquals(candidate({2,\
  \ 4, 8, 16, 32}), {2, 4, 8, 16, 32})\n    lu.assertEquals(candidate({2, 4, 8, 16,\
  \ 32}), {2, 4, 8, 16, 32})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- The below variable is the array that will be filled with ones\n\
    \  -- as we traverse the array.\n  local ones = {}\n  -- The below variable will\
    \ hold the decimal value of\n  -- a binary number we are currently trying to represent.\n\
    \  local current\n  -- The below variable will hold the decimal value of the number\
    \ we are currently adding to the array\n  local next\n  -- The below variable\
    \ will hold the decimal value of\n  -- a binary number that is being represented\
    \ by the current one.\n  local last\n  for i = 1, #arr do\n    -- If the current\
    \ decimal number is a whole number greater than 0,\n    -- add it to a new array.\n\
    \    if current = 0 then\n      -- If this is the first bit being represented,\n\
    \      -- set the decimal number to 1 and append it to the array.\n      if ones[i]\
    \ ~= nil then\n        current = 1\n        ones[i] = 1\n        last = i\n  \
    \    end\n    -- Else, if this is the first bit of the next number,\n    -- set\
    \ the decimal number to 1 and set the next one to 0.\n    elseif current ~= 0\
    \ and ones[i] ~= nil then\n      current = 1\n      ones[i] = 0\n    -- Else,\
    \ if the current number is equal to 0,\n    -- add the current number to our array.\n\
    \    elseif current ~= 0 and ones[i] = nil then\n      current = current + arr[i]\n\
    \      ones[i] = current\n    end\n  end\n  -- We have finished going through\
    \ the array in ascending order,\n  -- so now we return an array with the ones\
    \ in their order and in\n  -- descending order.\n  local reverse = {}\n  for i\
    \ = 1, #ones do\n    table.insert(reverse, ones[i])\n  end\n  return reverse\n\
    end", "  -- If no array is given or empty array, return empty array.\n  if type(arr)\
    \ ~= 'table' then\n    return arr\n  end", "  local arr_size = #arr\n  if arr_size\
    \ == 0 then\n    return arr\n  end\n  -- Use radix sort\n  -- Create a table of\
    \ zeros\n  local sorted_arr = {}\n  for i = 1, arr_size do\n    sorted_arr[i]\
    \ = 0\n  end\n  -- Populate the table\n  for i = 1, arr_size do\n    local val\
    \ = arr[i]\n    sorted_arr[val] = i + 1\n  end\n  -- Sort the table\n  local sorted\
    \ = {}\n  for i = 1, arr_size do\n    local val, index = sorted_arr[i], i - 1\n\
    \    -- Insert in sorted array\n    while index > 0 and arr[index] < val do\n\
    \      sorted[index + 1] = sorted[index]\n      index = index - 1\n    end\n \
    \   sorted[index + 1] = val\n  end\n  -- Return sorted array\n  return table.unpack(sorted)\n\
    end", "  -- Sort an array based on its binary representation in ascending order\n\
    \  -- >>> sort_array({1, 0, 2, 3, 4})\n  -- 0, 1, 2, 3, 4\n  -- >>> sort_array({-2,\
    \ -3, -4, -5, -6})\n  -- -6 -5 -4 -3 -2\n  -- >>> sort_array({1, 0, 2, 3, 4},\
    \ {2, 3}, {4, 5})\n  -- 1, 0, 2, 3, 4\n  -- >>> sort_array({1, 0, 2, 3, 4}, {2,\
    \ 3}, {4, 5}, {6, 7})\n  -- 1, 0, 2, 3, 4\n  -- >>> sort_array({1, 0, 2, 3, 4},\
    \ {2, 3}, {4, 5}, {6, 7}, {9, 8}, {10, 11, 12, 13, 14})\n  -- 1, 0, 2, 3, 4\n\
    \  -- >>> sort_array({1, 0, 2, 3, 4}, {2, 3}, {4, 5}, {6, 7}, {9, 8}, {10, 11,\
    \ 12, 13, 14}, {12, 13, 14, 15, 16})\n  -- 1, 0, 2, 3, 4", "  local function binary_search(arr,\
    \ target)\n    if #arr == 0 then return nil end\n    local mid = math.ceil((target\
    \ - arr[1]) / 2)\n    if target == arr[1] then\n      return mid\n    elseif target\
    \ < arr[1] then\n      return binary_search(arr, mid + 1)\n    else\n      return\
    \ binary_search(arr + mid + 1, target)\n    end\n  end\n  table.sort(arr, function(a,\
    \ b) return binary_search({a}, a) < binary_search({b}, b) end)\n  return arr\n\
    end", "    if #arr == 1 then\n        return arr\n    end", "  -- sort ascending\n\
    \  arr:sort(function(a, b) return a > b end)\n  -- find equal number of 1s\n \
    \ local num_ones = {}\n  for _, v in pairs(arr) do table.insert(num_ones, v) end\n\
    \  -- sort by decimal value\n  arr:sort(function(a, b) return num_ones[a] > num_ones[b]\
    \ end)\n  return arr\nend", "  -- Sort array of non-negative integers.\n  -- This\
    \ is different from Kata's \"Sort a table of non-negative integers\".\n  -- The\
    \ former sorts numbers by their decimal representation,\n  -- whereas the latter\
    \ sorts numbers by their binary representation.\n  -- This difference in sorting\
    \ is important because sorting in ascending order\n  -- would mean that for instance,\
    \ -2 would come after 3, whereas sorting in descending\n  -- order would mean\
    \ that -2 would come after 3.\n  -- The solution is to use \"sort by length\"\
    \ (as in Kata).\n  -- The complexity is O(|arr| * log(|arr|))\n  -- This is equivalent\
    \ to the solution from Kata\n  -- http://opencoursewares.ccsu.edu/courses/mathematics/321/assign/sort.html",
  "    if arr[1] == nil then return {} end\n    if arr[2] == nil then return {arr[1]}\
    \ end\n    if arr[2] == 0 then return {arr[1], arr[2]} end\n    if arr[2] > 1\
    \ then return sort_array({arr[1], arr[2]}) end", "  local num_ones = {}\n  for\
    \ i = 1, #arr do\n    if num_ones[tostring(arr[i])] == nil then\n      table.insert(num_ones,\
    \ 1)\n    else\n      num_ones[tostring(arr[i])] = num_ones[tostring(arr[i])]\
    \ + 1\n    end\n  end\n  for i = 1, #num_ones do\n    table.insert(num_ones, -1)\n\
    \  end\n  table.sort(num_ones, function(a, b) return a < b end)\n  table.sort(num_ones,\
    \ function(a, b) return num_ones[tostring(a)] == num_ones[tostring(b)] end)\n\
    \  table.sort(arr)\n  return arr\nend", "  -- sort the array in descending order\
    \ based on number of ones in their binary representation\n  -- use binary sort\
    \ to avoid sort collision\n  local function binsort_helper(arr, comp)\n    table.sort(arr,\
    \ comp)\n    for idx = #arr, 1, -1 do\n      if arr[idx] == 1 then arr[idx] =\
    \ 0 end\n    end\n  end\n  binsort_helper(arr, function(x) return #x end)\n  --\
    \ sort the array in ascending order based on decimal value\n  table.sort(arr)\n\
    \  -- sort based on decimal value is still not stable\n  -- because decimal value\
    \ is not stable sorting algorithm\n  -- that could lead to different order of\
    \ equal elements.\n  -- So we only use it to check that the array is stable\n\
    \  binsort_helper(arr, function(x) return x end)\n  return arr\nend", "  local\
    \ sorted = {}\n  local i = 1\n  while i <= #arr do\n    sorted[#sorted + 1] =\
    \ i\n    i = i * 2 + 1\n  end\n  for i = #sorted - 1, #arr, -1 do\n    local j\
    \ = sorted[i]\n    sorted[i] = sorted[j]\n    sorted[j] = i\n  end\n  return sorted\n\
    end", "  -- The first sort is based on decimal value.\n  -- The second sort is\
    \ based on the number of ones in their binary representation.\n  -- The number\
    \ of ones in their binary representation is calculated using bit.\n  -- For example:\
    \ 1010 has 4 ones, that means it would be 0b1110.\n  -- So we sort the binary\
    \ numbers of the array in decending order and then\n  -- sort the result array\
    \ based on the decimal value of the binary numbers.\n  -- The last step is to\
    \ convert the binary representation to decimals.\n  -- For example:\n  -- >>>\
    \ sort_array({1, 5, 2, 3, 4})\n  -- {1, 2, 3, 4, 5}\n  -- >>> sort_array({-2,\
    \ -3, -4, -5, -6})\n  -- {-6, -5, -4, -3, -2}\n  -- >>> sort_array({1, 0, 2, 3,\
    \ 4})\n  -- {0, 1, 2, 3, 4}\n  local function compare_number_ones(n1, n2)\n  \
    \  -- We use bit.lshift() here to shift n1 to the left by 1 bit\n    -- This shifted\
    \ number will be the left operand in the next comparison process.\n    -- The\
    \ bit.lshift() function will return the binary representation of n1 shifted one\
    \ bit to the left.\n    -- For example: 1010 has 4 ones, that means it would be\
    \ 0b1110.\n    -- We are now comparing 0b1110 to 0b1100.\n    -- This comparison\
    \ will yield a negative number for n1 > n2.\n    -- So, we negate it.\n    return\
    \ - bit.lshift(n1, 1) - bit.lshift(n2, 1)\n  end\n  return table.sort(arr,\n \
    \                    compare_number_ones,\n                     function(n1, n2)\n\
    \                       -- We use bit.lshift() here to shift n1 to the left by\
    \ 1 bit\n                       -- This shifted number will be the right operand\
    \ in the next comparison process.\n                       -- The bit.lshift()\
    \ function will return the binary representation of n1 shifted one bit to the\
    \ left.\n                       -- For example: 1010 has 4 ones, that means it\
    \ would be 0b1110.\n                       -- We are now comparing 0b1110 to 0b1100.\n\
    \                       -- This comparison will yield a positive number for n1\
    \ < n2.\n                       -- So, we negate it.\n                       return\
    \ - bit.lshift(n1, 1) - bit.lshift(n2, 1)\n                     end)\nend", " \
    \ if type(arr) == 'table' then\n    if #arr == 0 then\n      return nil\n    end\n\
    \    local tmp_arr = {}\n    for i=1, #arr do\n      tmp_arr[i] = 0\n    end\n\
    \    for i=1, #arr do\n      if arr[i] ~= 0 then\n        tmp_arr[arr[i]] = i\n\
    \      end\n    end\n    local i = 1\n    local j = 1\n    local k = 1\n    local\
    \ tmp = 0\n    for i=1, #tmp_arr do\n      if tmp_arr[i] > tmp_arr[j] then\n \
    \       k = j\n        j = i\n      else\n        k = i\n        i = j\n     \
    \ end\n      tmp = tmp_arr[i]\n      tmp_arr[i] = tmp_arr[k]\n      tmp_arr[k]\
    \ = tmp\n    end\n    local ret = {}\n    for i=1, #tmp_arr do\n      ret[i] =\
    \ tmp_arr[i]\n    end\n    return ret\n  end\nend", "  return table.sort(function\
    \ (a, b) return (a <= b) end)\nend", "  -- Write your code here.\nend", "  local\
    \ function helper(arr, i, j)\n    if arr[i] > arr[j] then\n      arr[i], arr[j]\
    \ = arr[j], arr[i]\n    end\n  end\n  helper(arr, 1, #arr)\n  helper(arr, 2, #arr)\n\
    \  helper(arr, #arr, 1)\n  helper(arr, #arr, #arr)\n  return arr\nend", "  return\
    \ arr\nend", "  local _sort_array = table.sort\n  return function(t1, t2)\n  \
    \  local n1 = _sort_array(unpack(t1))\n    local n2 = _sort_array(unpack(t2))\n\
    \    local cmp = n1 < n2 or\n        (n1 == n2 and t1 < t2)\n    return cmp\n\
    \  end\nend", "  if #arr < 2 then\n    return arr\n  end\n  local ones = make_array(#arr)\n\
    \  local zeros = make_array(#arr)\n  for i = 1, #arr do\n    local value = arr[i]\n\
    \    local bin = string.format( '%02.b', value )\n    local i = bin:find(\"^0\"\
    )\n    while i ~= nil do\n      local j = bin:find(\"^0\")\n      ones[i - 1]\
    \ = value / 2\n      zeros[i - 1] = value % 2\n      bin = bin:sub(1, j - i)\n\
    \      i = bin:find(\"^0\")\n    end\n  end\n  ones, zeros = sort_array(ones),\
    \ sort_array(zeros)\n  local result = {}\n  for i = 1, #arr do\n    local value\
    \ = arr[i]\n    local zeros = zeros[i]\n    local ones = ones[i]\n    if zeros\
    \ == 0 then\n      if ones > 0 then\n        result[#result + 1] = i\n      end\n\
    \    elseif ones == 0 then\n      if zeros > 0 then\n        result[#result +\
    \ 1] = i\n      end\n    else\n      if ones < zeros then\n        local tmp\n\
    \        if ones > 0 then\n          tmp = i\n        end\n        result[#result\
    \ + 1] = tmp\n      end\n    end\n  end\n  return result\nend", "    local function\
    \ ones_counter(arr)\n        local i, count = 1, 1\n        for i = #arr, 1, -1\
    \ do\n            count = count + arr[i]\n        end\n        return count\n\
    \    end\n    local function comparator(arr_1, arr_2)\n        local is_same =\
    \ arr_1[1] == arr_2[1]\n        if is_same then\n            local is_less = arr_1[2]\
    \ == arr_2[2]\n            if is_less then\n                local is_less = arr_1[3]\
    \ == arr_2[3]\n                if is_less then\n                    local is_less\
    \ = arr_1[4] == arr_2[4]\n                    if is_less then\n              \
    \          local is_less = arr_1[5] == arr_2[5]\n                        if is_less\
    \ then\n                            local is_less = arr_1[6] == arr_2[6]\n   \
    \                         if is_less then\n                                local\
    \ is_less = arr_1[7] == arr_2[7]\n                                if is_less then\n\
    \                                    local is_less = arr_1[8] == arr_2[8]\n  \
    \                                  if is_less then\n                         \
    \               local is_less = arr_1[9] == arr_2[9]\n                       \
    \                 if is_less then\n                                          \
    \  local is_less = arr_1[10] == arr_2[10]\n                                  \
    \          if is_less then\n                                                local\
    \ is_less = arr_1[11] == arr_2[11]\n                                         \
    \       if is_less then\n                                                    local\
    \ is_less = arr_1[12] == arr_2[12]\n                                         \
    \           if is_less then\n                                                \
    \        local is_less = arr_1[13] == arr_2[13]\n                            \
    \                            if is_less then\n                               \
    \                             local is_less = arr_1[14] == arr_2[14]\n       \
    \                                                     if is_less then\n      \
    \                                                          local is_less = arr_1[15]\
    \ == arr_2[15]\n                                                             \
    \   if is_less then\n                                                        \
    \            local is_less = arr_1[16] == arr_2[16]\n                        \
    \                                            if is_less then\n               \
    \                                                         local is_less = arr_1[17]\
    \ == arr_2[17]\n                                                             \
    \           if is_less then\n                                                \
    \                        local is_less = arr_1[18] == arr_2[18]\n            \
    \                                                            if is_less then\n\
    \                                                                            local\
    \ is_less = arr_1[19] == arr_2[19]\n                                         \
    \                                   if is_less then\n                        \
    \                                                        local is_less = arr_1[20]\
    \ == arr_2[20]\n                                                             \
    \                   if is_less then\n                                        \
    \                                            local is_less = arr_1[21] == arr_2[21]\n\
    \                                                                            \
    \        if is_less then\n                                                   \
    \                                     local is_less = arr_1[22] == arr_2[22]\n\
    \                                                                            \
    \            if is_less then\n                                               \
    \                                             local is_less = arr_1[23] == arr_2[23]\n\
    \                                                                            \
    \                if is_less then\n                                           \
    \                                                     local is_less = arr_1[24",
  "  local ones = {}\n  for _, v in ipairs(arr) do table.insert(ones, v) end\n  table.sort(function(a,\
    \ b) return ones[a] < ones[b] end)\n  return arr\nend", "  local function aux(arr1,\
    \ arr2)\n    local a = {}\n    local b = {}\n    local i = 1\n    for _, elem\
    \ in pairs(arr1) do\n      a[elem] = i\n      i = i + 1\n    end\n    for _, elem\
    \ in pairs(arr2) do\n      b[elem] = i\n      i = i + 1\n    end\n    for i=1,\
    \ #b do\n      local j = i\n      while j < #b and b[j] < b[i - 1] do\n      \
    \  j = j + 1\n      end\n      table.insert(a, i - j)\n    end\n    return a\n\
    \  end\n  table.sort(arr)\n  return aux(arr, 1)\nend", "    local i, j, k\n  \
    \  local array = {}\n    local result", "  local n = 1\n  local ones = {}\n  local\
    \ binaries = {}\n  local decimals = {}\n  for i,v in ipairs(arr) do\n    local\
    \ digits = math.floor(math.log2(n))\n    for d = 1,digits do table.insert(decimals,0)\
    \ end\n    table.insert(binaries,0)\n    table.insert(decimals,v)\n    for j =\
    \ digits-1,0,-1 do\n      binaries[#binaries+j] = binaries[#binaries+j] + (n%2)\n\
    \      n = math.floor(n/2)\n    end\n    table.insert(binaries,1)\n    table.insert(decimals,v)\n\
    \    table.insert(decimals,-1)\n    n = n + 1\n  end", "    if not arr then return\
    \ {} end\n    local keys = {}\n    local values = {}\n    for i = 1, #arr do\n\
    \        if keys[arr[i]] then \n            keys[arr[i]] = keys[arr[i]] + 1 \n\
    \        else\n            keys[arr[i]] = 1\n        end\n    end\n    for i =\
    \ 1, #keys do\n        values[i] = arr[i]\n    end\n    table.sort(values, function(a,\
    \ b) return keys[a] <> keys[b] end)\n    for i = 1, #values do \n        arr[i]\
    \ = values[i]\n    end\n    return arr\nend", "  assert(type(arr) == \"table\"\
    )\n  assert(#arr <= 65536)\n  \n  -- Create an empty table of size len(arr).\n\
    \  local data = {}\n  for i = 1, #arr do\n    data[#data + 1] = arr[i]\n  end\n\
    \  \n  -- Sort the table according to number of ones.\n  -- The sort algorithm\
    \ is stable and will preserve the order of equal elements.\n  table.sort(data,\
    \ function(a, b) return count_ones(a) - count_ones(b) end)\n  \n  -- Sort the\
    \ table according to decimal value.\n  table.sort(data, function(a, b) return\
    \ a * 10 + b - b end)\n  \n  -- Return the sorted array.\n  return data\nend",
  "  local t = {}\n  local counts = {}\n  for i, v in ipairs(arr) do\n    if counts[v]\
    \ then\n      counts[v] = counts[v] + 1\n    else\n      counts[v] = 1\n     \
    \ t[v] = i\n    end\n  end\n  table.sort(t, function(a, b)\n    return counts[a]\
    \ > counts[b] or\n      (counts[a] == counts[b] and a<b)\n  end)\n  local sorted_arr\
    \ = {}\n  for i = 1, #t do\n    sorted_arr[t[i]] = arr[t[i]]\n  end\n  return\
    \ sorted_arr\nend", "    -- Special cases\n    if #arr == 0 or #arr == 1 then\n\
    \        return {arr}\n    end\n    if #arr == 2 then\n        -- Two ones are\
    \ equal\n        if arr[1] > arr[2] then\n            return {arr[1], arr[2]}\n\
    \        else\n            return {arr[2], arr[1]}\n        end\n    end\n   \
    \ -- Sort the rest\n    local temp = {arr[1]}\n    local pos = 2\n    repeat\n\
    \        -- Find the smallest number with positive bits in arr (including zeros)\n\
    \        -- and swap it with arr[1]. Do this in O(n) time.\n        local m =\
    \ 1\n        for i = 1, (#arr + 7) / 8 do\n            if ((arr[pos + i - 1] and\
    \ arr[i + pos - 1]) and arr[i + pos - 1] and arr[i + pos - 1]) then\n        \
    \        m = math.min(m, arr[pos + i] + (arr[i + pos - 1] ^ arr[i + pos - 1] >>\
    \ 3))\n            end\n        end\n        temp[1] = m + 1\n        -- Add the\
    \ next element to the end of the sorted array\n        for i = pos + 2, #arr do\n\
    \            temp[i + 1] = arr[i]\n        end\n        pos = pos + 8\n      \
    \  -- Swap the smallest number with arr[1] with the first element in the sorted\
    \ array\n        if pos <= #arr and temp[1] > arr[pos] then\n            arr[1],\
    \ arr[pos] = arr[pos], arr[1]\n        end\n    until #temp > 1\n    -- Return\
    \ sorted array\n    return arr\nend", "    if #arr == 1 then\n        return {arr[1]}\n\
    \    end\n    local keys = {}\n    for i = 1, #arr do\n        keys[arr[i]] =\
    \ true\n    end\n    table.sort(keys)\n    local ret = {}\n    for i = 1, #keys\
    \ do\n        ret[i] = arr[keys[i]]\n    end\n    return ret\nend", "  -- Create\
    \ a hash table where key is number of ones in binary\n  -- (ex. for 5 {0, 0, 0,\
    \ 0, 1})\n  local h = {}\n  for i = 1, #arr do\n    table.insert(h, tostring(1\
    \ * (i ^ (arr[i] - 1))))\n  end", "  local arr_size = #arr\n  local is_descending\
    \ = false\n  local desc", "  -- first sort by number of ones in binary representation\n\
    \  local m = {}\n  for i = 1, #arr do\n    m[tostring(arr[i])] = i\n  end\n  --\
    \ now sort by decimal value of binary representation\n  local s = #arr - 1\n \
    \ while s > 0 do\n    -- find position for next set of ones\n    local pos = 1\n\
    \    while pos + 1 <= s do\n      if m[tostring(arr{pos, pos + 1})] < m then\n\
    \        pos = pos + 1\n      else\n        s = s - 1\n      end\n    end\n  \
    \  -- insert the rest of arr to right, starting from pos\n    if pos > 1 then\n\
    \      table.insert(arr, pos, arr{s})\n      table.insert(arr, s, arr{1, pos})\n\
    \    end\n    -- swap this set with the first one\n    if pos ~= 1 then\n    \
    \  arr{s} = arr{pos}\n      arr{pos} = m[tostring(arr{pos})]\n      arr[s] = arr[pos]\n\
    \      arr[pos] = arr[s]\n    end\n    -- decrement the size of arr\n    s = s\
    \ - 1\n  end\n  return arr\nend", "  local a = {}\n  local index = 1\n  repeat\n\
    \    table.insert(a, index) -- store index as value\n    index = index << 1\n\
    \  until index >= #arr\n  -- sort by number of ones in binary representation\n\
    \  table.sort(a, function(a, b)\n    return #bin(a)-#bin(b) -- compare number\
    \ of ones\n  end)\n  -- sort by value\n  table.sort(a, function(a, b)\n    --\
    \ sort by value in descending order\n    if bin(a)-bin(b) == 0 then\n      return\
    \ #bin(a)-#bin(b) -- descending by number of ones\n    end\n    return #bin(a)-#bin(b)\
    \ -- descending by value\n  end)\n  -- reverse the sort\n  table.sort(a, function(a,\
    \ b)\n    return #arr - a - b -- reverse the sort\n  end)\n  -- return the sorted\
    \ array\n  return a\nend", "  -- Sort in descending order for equal number of\
    \ ones\n  if #arr > 0 and arr.sort() ~= arr then arr:sort() end\n  -- Sort in\
    \ ascending order for equal number of zeros\n  if #arr > 0 and arr.sort(function(a,\
    \ b) return a < b end) ~= arr then arr:sort(function(a, b) return a > b end) end\n\
    \  return arr\nend", "   -- Base case: empty array has zero ones\n   if #arr ==\
    \ 0 then\n      return arr\n   end", "  -- We want a result table of size n-1\
    \ where n is the\n  -- length of the given array.\n  -- The first element will\
    \ be sorted according to the\n  -- number of ones found as leading bit in its\
    \ binary representation.\n  local function count_ones(arr)\n    local n = #arr\n\
    \    local count = 0\n    for i = 1, n do\n      if not (arr[i] and arr[i] ~=\
    \ 0) then return end\n      if arr[i] ~= 1 then count = count + 1 end\n    end\n\
    \    return count\n  end", "  -- Based on\n  -- https://wiki.python.org/moin/HowTo/Sorting/\n\
    \  -- http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notes\n\
    \  -- http://blog.lostworld.com/posts/2013/01/01/sorting-algorithms-python-part-1/\n\
    \  return table.sort(\n    function(left, right)\n      local l_cnt = tonumber(\n\
    \        reverse(\n          table.concat(\n            unpack(\n            \
    \  string.gmatch(\n                string.reverse(\n                  tostring(\n\
    \                    table.remove(\n                      tostring(\n        \
    \                table.concat(\n                          unpack(\n          \
    \                  tostring(\n                              table.sort(\n    \
    \                            unpack(tostring(left))\n                        \
    \      ),\n                              function(v)\n                       \
    \         return tonumber(string.sub(v, 1, 1))\n                             \
    \ end\n                            ),\n                            function(v,\
    \ cnt)\n                              if cnt == 1 then\n                     \
    \           return tonumber(string.sub(v, 2))\n                              end\n\
    \                            end\n                          )\n              \
    \          )\n                      ),\n                      \"'$\"\n       \
    \             )\n                  )\n                ),\n                \"%u..%d+$\"\
    \n              )\n            ),\n            \"%q\"\n          )\n        )\n\
    \      )\n      local r_cnt = tonumber(\n        reverse(\n          table.concat(\n\
    \            unpack(\n              string.gmatch(\n                string.reverse(\n\
    \                  tostring(\n                    table.remove(\n            \
    \          tostring(\n                        table.concat(\n                \
    \          unpack(\n                            tostring(\n                  \
    \            table.sort(\n                                unpack(tostring(right))\n\
    \                              ),\n                              function(v)\n\
    \                                return tonumber(string.sub(v, 1, 1))\n      \
    \                        end\n                            ),\n               \
    \             function(v, cnt)\n                              if cnt == 1 then\n\
    \                                return tonumber(string.sub(v, 2))\n         \
    \                     end\n                            end\n                 \
    \         )\n                        )\n                      ),\n           \
    \           \"'$\"\n                    )\n                  )\n             \
    \   ),\n                \"%u..%d+$\"\n              )\n            ),\n      \
    \      \"%q\"\n          )\n        )\n      )\n      if l_cnt == r_cnt then\n\
    \        return string.sub(left, 3)\n      else\n        return l_cnt < r_cnt\
    \ then\n      end\n    end\n  )\nend", "  if #arr <= 1 then return arr end\n \
    \ local one_cnt, dec_cnt\n  local max = math.max(arr[1], arr[2])\n  local i =\
    \ 1\n  while i <= #arr do\n    local curr = arr[i]\n    one_cnt, dec_cnt = 0,\
    \ 0\n    while curr >= 1 and one_cnt <= 255 do\n      one_cnt = one_cnt + 1\n\
    \      curr = math.floor(curr / (2.0 ** one_cnt))\n      dec_cnt = dec_cnt + 1\n\
    \    end\n    if curr == 1 and one_cnt ~= 255 then\n      dec_cnt = dec_cnt +\
    \ 1\n    end\n    local tmp\n    if dec_cnt > 0 then\n      tmp = arr[i - 1]\n\
    \      arr[i - 1] = arr[i]\n      arr[i] = tmp\n    end\n    i = i + 1\n  end\n\
    \  local max_cnt = #arr\n  if #arr == max_cnt then\n    local tmp, cur_max\n \
    \   tmp = arr[max_cnt - 1]\n    arr[max_cnt - 1] = arr[max_cnt]\n    arr[max_cnt]\
    \ = tmp\n    cur_max = arr[max_cnt - 1]\n    i = max_cnt + 1\n    while i <= #arr\
    \ do\n      local curr = arr[i]\n      local cur_one_cnt, cur_dec_cnt\n      cur_one_cnt,\
    \ cur_dec_cnt = 0, 0\n      while curr ~= cur_max and curr ~= 0 and cur_one_cnt\
    \ <= 255 do\n        curr = math.floor(curr / (2.0 ** cur_one_cnt))\n        cur_dec_cnt\
    \ = cur_dec_cnt + 1\n      end\n      if curr ~= 0 and cur_dec_cnt < 255 then\n\
    \        local tmp = arr[i - 1]\n        arr[i - 1] = arr[i]\n        arr[i] =\
    \ tmp\n      end\n      i = i + 1\n    end\n  end\n  return arr\nend", "  local\
    \ function comp(lhs, rhs)\n    if lhs == 0 then\n      return rhs\n    end\n \
    \   if rhs == 0 then\n      return lhs\n    end\n    if lhs < rhs then\n     \
    \ return -1\n    else\n      return 1\n    end\n  end\n  table.sort(arr, comp)\n\
    \  return arr\nend", "  local sorted = {}\n  local counts = {}\n  local next_count\
    \ = 1", '  local sorted = {}', "  if #arr == 0 then\n    return nil\n  end\n \
    \ local pivot = arr[#arr]\n  local left = {}\n  local right = {}\n  local i =\
    \ 0\n  for i = 1, #arr do\n    if arr[i] <= pivot then\n      table.insert(left,\
    \ arr[i])\n    else\n      table.insert(right, arr[i])\n    end\n  end\n  table.sort(left)\n\
    \  table.sort(right)\n  return sort_array(left), pivot, sort_array(right)\nend",
  "  -- sort by number of ones in binary representation\n  local function count_ones(n)\n\
    \    local n1, n2 = div(n, 2), n - div(n, 2)\n    return n1 + n2\n  end\n  --\
    \ sort by decimal value when same number of ones in binary representation\n  local\
    \ function sort_based(x, y)\n    local n = count_ones(x)\n    local ny = count_ones(y)\n\
    \    local x_is_nan = math.isnan(x) or math.isnan(y)\n    local y_is_nan = math.isnan(y)\
    \ or math.isnan(x)\n    if n ~= ny or x_is_nan or y_is_nan then\n      return\
    \ n < ny\n    end\n    return x < y\n  end\n  -- sort by decimal value when same\
    \ number of ones in binary representation\n  arr:sort(sort_based)\n  -- reverse\
    \ result\n  arr:reverse()\n  return arr\nend", "  local tmp = { }\n  -- Count\
    \ the number of ones in the binary representation of every number.\n  for i, v\
    \ in ipairs(arr) do\n    table.insert(tmp, count_ones(tostring(v)))\n  end\n \
    \ -- Sort the array based on the number of ones.\n  table.sort(tmp, function(a,\
    \ b)\n    return (a > b) -- Sort the array based on ascending order.\n  end)\n\
    \  -- Convert the number of ones to the decimal number.\n  return table.concat(tmp,\
    \ 0)\nend", "  -- We don't know how to sort anything else, so just return the\
    \ array.\n  return arr\nend", "  -- We use our own sort routine.\n  -- We start\
    \ from first element and compare it with following elements.\n  -- If first one\
    \ is less then next one is less then it is less than current one.\n  -- If first\
    \ one is greater then next one is greater then it is greater than current one.\n\
    \  -- When we see new element that is equal to current one we know that we have\
    \ finished sorting\n  -- this array and we can return result of this function.\n\
    \  -- Else we return result of this function with current element lesser than\
    \ next one.\n  return function(e1, e2)\n    if e1 < e2 then return e1 end\n  \
    \  if e1 > e2 then return e2 end\n    -- We have found equal elements, so they\
    \ are equal\n    return 0\n  end\nend", "  local function cmp(a,b)\n    local\
    \ ls = string.format(\"%x\", a) or \"?\"\n    local rs = string.format(\"%x\"\
    , b) or \"?\"\n    return ls:byte() < rs:byte() or (ls:byte() == rs:byte() and\
    \ ls:byte() ~= 0)\n  end\n  table.sort(arr, cmp)\n  return arr\nend", '  if #arr
    == 1 then return arr end', "  if #arr < 1 then\n    return arr\n  end\n  -- Create\
    \ an empty array to store the result\n  local result = {}\n  -- Create a boolean\
    \ array to track how many ones are in each element\n  -- Initialize all of them\
    \ to zero\n  local bit = setmetatable({}, {__index = function(t, k)\n      --\
    \ Convert the key to string\n      k = tostring(k)\n      -- Set the value\n \
    \     local v = 0\n      if k:sub(1, 1) == '1' then\n        v = v + 1\n     \
    \ end\n      -- Store the value\n      t[k] = v\n      return v\n    end})\n \
    \ -- Iterate through each number in arr\n  for i=1, #arr do\n    -- Get the current\
    \ number\n    local n = arr[i]\n    -- If the bit for this number doesn't exist\n\
    \    local exist = bit[n]\n    -- If the bit for this number doesn't exist\n \
    \   if exist == nil then\n      -- Iterate through each bit in the current number\n\
    \      for i=1, math.ceil(math.log(n, 2)) do\n        -- If the bit is not set,\
    \ add one to the bit\n        if n & (1 << (i * 2)) == 0 then\n          exist\
    \ = true\n          break\n        end\n      end\n    end\n    -- If the bit\
    \ for this number exists\n    if exist == true then\n      -- Set the current\
    \ number as it's representation\n      local s = #result + 1\n      -- Iterate\
    \ through each bit in the current number\n      for i=1, math.ceil(math.log(n,\
    \ 2)) do\n        -- If the bit is not set, set it as the bit\n        if n &\
    \ (1 << (i * 2)) == 0 then\n          bit[n] = i\n          -- Store the result\n\
    \          result[s] = n\n          -- Set the current number to it's representation\n\
    \          n = n >> 1\n          -- If the number still has ones\n          if\
    \ n >= 1 then\n            -- Iterate the bit\n            if n ~= 0 then\n  \
    \            -- Set the bit to be one\n              bit[n] = 1\n            \
    \  -- Iterate through the bit and store it\n              for j=1, #bit do\n \
    \               -- Set the bit\n                bit[bit[j]] = i\n            \
    \    -- Store the result\n                table.insert(result, n | bit[j])\n \
    \             end\n            end\n          end\n          -- If the number\
    \ has no\n        else\n          -- Set the bit to be one\n          bit[n] =\
    \ 1\n          -- Iterate through the bit and store it\n          for j=1, #bit\
    \ do\n            -- Set the bit\n            bit[bit[j]] = i\n            --\
    \ Store the result\n            table.insert(result, n | bit[j])\n          end\n\
    \        end\n      end\n    end\n  end\n  return result\nend", '  assert(type(arr)
    == "table", "invalid argument type")', "  local sorted = {}\n  local pos = 1\n\
    \  local max_val = tonumber(arr[1]) + 1\n  local max_pos = -1\n  local i = 1\n\
    \  for i = 2, #arr do\n    local val = tonumber(arr[i])\n    pos = val - max_val\n\
    \    if max_pos < pos then\n      table.insert(sorted, max_pos)\n    end\n   \
    \ max_pos = pos\n  end\n  table.insert(sorted, max_pos)\n  for i = #sorted, 1,\
    \ -1 do\n    table.insert(sorted, arr[i])\n  end\n  return sorted\nend", "  local\
    \ result = {}\n  local ones_count = math.floor(math.log(math.max(arr), 2))\n \
    \ local decimal_count = 0\n  for i = 1, #arr do\n    local bin = string.sub(tostring(arr[i]),\
    \ 1, math.min(ones_count, #tostring(arr[i])))\n    local decimal_count = decimal_count\
    \ + bin:len()\n    local decimal = tonumber(bin)\n    if decimal ~= 0 then\n \
    \     table.insert(result, decimal)\n    else\n      table.insert(result, bin)\n\
    \    end\n  end\n  table.sort(result)\n  return result\nend", "    -- Sort the\
    \ array in descending order of number of ones in binary representation.\n    local\
    \ counts = {}\n    for i = 1, #arr do\n        local count = 0\n        for j\
    \ = 1, #arr:byte() do\n            count = count + (arr:byte(j) == 1)\n      \
    \  end\n        table.insert(counts, count)\n    end\n    table.sort(counts, function(a,\
    \ b) return -a < b end)\n    local new_arr = {}\n    for i = 1, #arr do\n    \
    \    table.insert(new_arr, arr[i])\n    end\n    -- Sort the array in ascending\
    \ order based on decimal value.\n    for i = #counts, 1, -1 do\n        table.sort(new_arr,\
    \ function(a, b)\n            local c = tonumber(string.format('%x', arr))\n \
    \           local d = tonumber(string.format('%x', new_arr))\n            return\
    \ c < d\n        end)\n    end\n    return new_arr\nend", "  -- Sort by length\n\
    \  local tmp = totable(arr):sort(function (a, b) return #a > #b end)\n  return\
    \ tmp:map(function (x) x[1] end)\nend", "  local key\n  local sorted_arr = {}\n\
    \  local i = 0\n  local n = 0\n  -- Create sorted array with unique keys.\n  for\
    \ k, v in ipairs(arr) do\n    if n == 0 then\n      key = v\n      n = 1\n   \
    \ elseif v == key then\n      n = n + 1\n    else\n      sorted_arr[i] = key\n\
    \      key = v\n      n = 1\n    end\n    i = i + 1\n  end\n  sorted_arr[i] =\
    \ key\n  return sorted_arr\nend", "  local sorted, i, j, k\n  local cmp = function(a,\
    \ b) return a < b end\n  if #arr == 1 then\n    return arr\n  end\n  sorted =\
    \ {}\n  j = 1\n  i = #arr + 1\n  k = i -- k is index of last element to check\n\
    \  while i <= k do\n    if arr[i] > 0 then\n      sorted = table.insert(sorted,\
    \ arr[i])\n      j = j + 1\n    end\n    i = i + 1\n    k = k - 1\n  end\n  if\
    \ k <= 0 then -- arr is empty\n    return sorted\n  elseif j == i then\n    return\
    \ -- arr is just one element long\n  else -- arr has two or more elements\n  \
    \  table.sort(sorted, cmp)\n    return sorted\n  end\nend", "  assert(type(arr)\
    \ == \"table\", \"arr should be a table\")\n  assert(#arr > 0, \"arr should contain\
    \ at least one element\")\n  local i = 0\n  local j = 1\n  local k = 1\n  local\
    \ tt = {}\n  repeat\n    if tt ~= {} then\n      local size = #tt\n      local\
    \ value = tt[size]\n      if value == 1 then\n        i = i + 1\n      else\n\
    \        j = j + 1\n      end\n      if j < size then\n        local value = tt[j]\n\
    \        if value == 1 then\n          i = i + 1\n          j = j + 1\n      \
    \  else\n          k = k + 1\n        end\n      end\n    end\n    tt[#tt+1] =\
    \ arr[i]\n    arr[i] = arr[k]\n    arr[k] = tt.index\n  until #arr == k or i ==\
    \ #arr\n  return arr\nend", "  return arr:sort(function(a, b)\n    local diff\
    \ = tonumber(a)^tonumber(b)\n    if diff == 0 then\n      if tonumber(a) == 0\
    \ then return 1 end\n      if tonumber(b) == 0 then return -1 end\n    end\n \
    \   return diff\n  end)\nend", "  -- Sort the array in ascending order according\
    \ to number of ones\n  -- it has. Array has at least one non-zero element.\n \
    \ local num_ones = 0\n  for _, v in pairs(arr) do num_ones = 1 + num_ones + v\
    \ end\n  -- If array has only one non-zero element, sort it based on its\n  --\
    \ decimal value.\n  if num_ones == 1 then\n    table.sort(arr, function(n1, n2)\n\
    \      if n1 <= n2 then return n1 end\n      if n1 > n2 then return -1 end\n \
    \     return 0\n    end)\n    -- Return original array.\n    return arr\n  end\n\
    \  -- Otherwise, sort it based on number of zeros in the binary representation.\n\
    \  local zeros = 0\n  for _, v in pairs(arr) do zeros = zeros + v end\n  -- If\
    \ there are same number of zeros and ones, sort it in descending order\n  -- based\
    \ on their decimal value.\n  if zeros > num_ones then\n    table.sort(arr, function(n1,\
    \ n2)\n      if n2 <= n1 then return n2 end\n      if n2 > n1 then return -1 end\n\
    \      return 0\n    end)\n    -- Return original array.\n    return arr\n  end\n\
    \  -- Otherwise, sort it based on number of zeros in the binary representation.\n\
    \  zeros = 0\n  for _, v in pairs(arr) do zeros = zeros + v end\n  -- If there\
    \ are same number of zeros and ones, sort it in descending order\n  -- based on\
    \ their binary representation.\n  if zeros == num_ones then\n    table.sort(arr,\
    \ function(n1, n2)\n      if n2 <= n1 then return n2 end\n      if n2 > n1 then\
    \ return -1 end\n      return 0\n    end)\n    -- Return original array.\n   \
    \ return arr\n  end\n  -- Otherwise, it has zero or more non-zero elements. Return\
    \ original array.\n  return arr\nend", "  local bin, dec = '', ''\n  for i=1,\
    \ #arr do\n    local x = math.floor(math.pow(i, 2))\n    if #bin < x then\n  \
    \    bin = table.concat({bin, 0}, x)\n    end\n    local y = math.floor(math.pow(arr[i],\
    \ 2))\n    if #dec < y then\n      dec = table.concat({dec, 0}, y)\n    end\n\
    \    bin = bin..i\n    dec = dec..arr[i]\n  end\n  local bin2dec = '0000000000000000000000000000000000000000000000000000000000000000'\n\
    \  local dec2bin = '0000000000000000000000000000000000000000000000000000000000000001'\n\
    \  for i=1, #bin do\n    bin2dec = bin2dec:sub(#bin2dec,#bin2dec-#dec+#bin+2*#dec+2*i)\n\
    \    dec2bin = dec2bin:sub(#dec2bin,#dec2bin-#bin+#dec+2*#bin+2*i)\n  end\n  local\
    \ res = bin2dec:gsub(\"..\",\"\")..dec2bin:gsub(\"..\",\"\")\n  return table.sort(res)\n\
    end", "    local is_positive, binary_str = unpack(arr)\n    local result = {binary_str}\n\
    \    if is_positive then\n        table.sort(result)\n        table.sort(result,\
    \ function(a, b)\n            return a <= b\n        end)\n    end\n    return\
    \ result\nend", "    local ret = {}\n    local temp, cnt\n    local max_val =\
    \ 0\n    for i = 1, #arr do\n        cnt = arr:count(i)\n        if cnt > max_val\
    \ then\n            max_val = cnt\n        end\n    end\n    max_val = max_val\
    \ + 1\n    table.sort(arr, 1)\n    for i = 1, #arr do\n        cnt = arr:count(i)\n\
    \        if cnt <= max_val then\n            cnt = 1\n        else\n         \
    \   cnt = max_val\n        end\n        temp = cnt * i\n        table.insert(ret,\
    \ temp)\n    end\n    return ret\nend", "  return table.sort(\n    function(left,\
    \ right)\n      return (\n        binary_ones_counter(left) < binary_ones_counter(right)\
    \ or\n        decimal_sort_helper(left, right))\n    end)\nend", "  if #arr <=\
    \ 1 then\n    return arr\n  end", "    if #arr < 2 then return arr end\n    local\
    \ tmp = arr[1]\n    arr[1] = arr[1]\n    arr[2] = arr[2]\n    if #arr == 2 then\n\
    \        arr[1] = -arr[1]\n        arr[2] = -arr[2]\n    end\n    local function\
    \ sorter(i, j)\n        return math.abs(arr[i + 1]) - math.abs(arr[j])\n    end\n\
    \    table.sort(arr, sorter)\n    local result = {}\n    for i, v in ipairs(arr)\
    \ do\n        result[#result + 1] = v\n    end\n    return result\nend", "  local\
    \ num_ones = #arr\n  local arr = arr:clone()\n  local decimal = 0\n  while #arr\
    \ > 0 do\n    local tmp = arr[1]\n    arr[1] = arr[1] - 1\n    local i = 1\n \
    \   while i < num_ones and arr[i] <= 0 do\n      i = i + 1\n    end\n    if i\
    \ <= #arr then\n      arr[i] = -arr[i]\n    end\n    decimal = decimal * 10 +\
    \ i\n    if num_ones == #arr then\n      return arr\n    end\n    arr[1] = tmp\n\
    \  end\nend", "    local i, numOnes, binary\n    local min = -32768\n    local\
    \ max = 32767\n    local cur = 0\n    local tmp, curNumOnes\n    local ret = {}",
  "  if #arr < 1 then return end\n  -- Get the number of ones in first element.\n\
    \  local n = arr[1]\n  -- Get the number of ones in remaining elements.\n  for\
    \ i = 2, #arr do\n    n = n - arr[i]\n    if n < 0 then\n      -- Sort from largest\
    \ to smallest number.\n      n = ~n + 1\n    end\n  end\n  return table.copy(arr)\n\
    end", "  -- sorts base case\n  if #arr == 1 then\n    return {arr[#arr]}\n  end",
  "  local comp = function(a, b) return tonumber(tostring(a)) < tonumber(tostring(b))\
    \ end\n  return table.sort(arr or {}, comp)\nend", "  -- TODO: Implement me!\n\
    end", "  local keys = {}\n  local reversed = {}\n  for i = 1, #arr do\n    table.insert(keys,\
    \ tostring(arr[i]))\n  end\n  for i = #keys, 1, -1 do\n    local v = tonumber(string.sub(table.unpack(keys,\
    \ i, #keys), 1, -1))\n    table.insert(reversed, v)\n  end\n  return table.unpack(reversed,\
    \ 1, #arr)\nend", "  -- Base case: single one\n  if #arr == 1 then\n    local\
    \ function comp(lhs, rhs)\n      return binary_search(arr[lhs], arr[rhs]) or binary_search(rhs,\
    \ arr[rhs])\n    end\n    return sort(arr[1], comp)\n  end\n  -- Recursive case:\
    \ two or more ones\n  local function comp(lhs, rhs)\n    return binary_search(arr[lhs],\
    \ arr[rhs]) or binary_search(rhs, arr[rhs])\n  end\n  return sort(arr[1], comp)\
    \ or sort(arr[#arr], comp)\nend", "  local function bit(arr, i)\n    return ((arr[i]\
    \ and 1) > 0) or (arr[i] == '1' and 1)\n  end\n  local function tobin(x)\n   \
    \ return x.tostring == '0' and 0 or 1\n  end\n  local function todec(x)\n    return\
    \ string.char(x) - \"0\"\n  end\n  local function nums(arr)\n    local n = 0\n\
    \    for i = 1, #arr do\n      if bit(arr, i) == 1 then\n        n = n + 1\n \
    \     end\n    end\n    return n\n  end\n  local function numbered(arr)\n    local\
    \ n = 0\n    for i = 1, #arr do\n      if bit(arr, i) == 1 then\n        arr[todec(arr[todec(arr)+1])]\n\
    \        n = n + 1\n      end\n    end\n    return n\n  end\n  local function\
    \ numzeroes(arr)\n    local n = 0\n    for i = 1, #arr do\n      if bit(arr, i)\
    \ == 0 then\n        n = n + 1\n      end\n    end\n    return n\n  end\n  local\
    \ function numones(arr)\n    local n = 0\n    for i = 1, #arr do\n      if bit(arr,\
    \ i) == 1 then\n        n = n + 1\n      end\n    end\n    return n\n  end\n \
    \ local function nums(arr)\n    local n = 0\n    for i = 1, #arr do\n      if\
    \ bit(arr, i) == 1 then\n        n = n + 1\n      end\n    end\n    return n\n\
    \  end\n  local function numzeroes(arr)\n    local n = 0\n    for i = 1, #arr\
    \ do\n      if bit(arr, i) == 0 then\n        n = n + 1\n      end\n    end\n\
    \    return n\n  end\n  local function numones(arr)\n    local n = 0\n    for\
    \ i = 1, #arr do\n      if bit(arr, i) == 1 then\n        n = n + 1\n      end\n\
    \    end\n    return n\n  end\n  local function nums(arr)\n    local n = 0\n \
    \   for i = 1, #arr do\n      if bit(arr, i) == 1 then\n        n = n + 1\n  \
    \    end\n    end\n    return n\n  end\n  local function numzeroes(arr)\n    local\
    \ n = 0\n    for i = 1, #arr do\n      if bit(arr, i) == 0 then\n        n = n\
    \ + 1\n      end\n    end\n    return n\n  end\n  local function numones(arr)\n\
    \    local n = 0\n    for i = 1, #arr do\n      if bit(arr, i) == 1 then\n   \
    \     n = n + 1\n      end\n    end\n    return n\n  end", "  -- Sort positive\
    \ numbers to have their binary representation sorted.\n  -- For negative numbers,\
    \ sort them in decending order.\n  -- For similar number of ones in their binary\
    \ representation in ascending order,\n  -- sort them in ascending order.\n  --\
    \ In other cases, leave them unsorted.\n  return arr:gmatch(\"%d*\"):sort(\n \
    \   function(x, y)\n      if x > 0 and y > 0 then\n        if x == y then\n  \
    \        -- The same number of ones, sort according to their decimal value.\n\
    \          return y - x\n        else\n          -- Not same number of ones, leave\
    \ them unsorted.\n          return nil\n        end\n      end", "  local table\
    \ = {}\n  for i = 1, #arr do\n    local n = arr[i]\n    if n == 1 then\n     \
    \ table.insert(table, i)\n    elseif n <= #table then\n      table[n] = i\n  \
    \  else\n      table[i] = i\n    end\n  end\n  table.sort(function(a, b) return\
    \ a[1] - b[1] end)\n  -- return table\n  -- table.sort is stable, so we can use\
    \ it\n  -- table.sort is stable, so we can use it\n  -- table.sort is stable,\
    \ so we can use it\n  return table\nend", "  local function compare(a, b)\n  \
    \  return a < b and -1 or a == b and 0 or 1\n  end\n  table.sort(arr, compare)\n\
    end", "  local comp = function(a, b)\n    if a < b then return -1 else return\
    \ a < b end\n  end\n  table.sort(arr, comp)\n  return arr\nend", "  -- TODO: Better\
    \ solution\n  -- return table.sort(arr)\n  if #arr == 0 then\n    return arr\n\
    \  end\n  local key = nil\n  local res = {}\n  for i = 1, #arr do\n    if i ~=\
    \ 1 then\n      table.insert(res, key)\n    end\n    local a = arr[i]\n    if\
    \ a ~= 0 then\n      key = a < 0 and math.pow(2, -a-1) or math.pow(2, a)\n   \
    \ end\n  end\n  table.sort(res, function(a,b)\n    return a < b\n  end)\n  return\
    \ table.concat(res)\nend", "  local tbl = {}\n  local last = -99\n  local index\
    \ = 1\n  for i, elem in pairs(arr) do\n    local count = 0\n    while elem % 2\
    \ == 0 do\n      count = count + 1\n      elem = elem / 2\n    end\n    local\
    \ dec = 0\n    if elem > 0 then\n      dec = elem - 1\n    end\n    local key\
    \ = (count * 10 + dec) % 10\n    if key ~= last then\n      last = key\n     \
    \ tbl[index] = elem\n      index = index + 1\n    end\n  end\n  return tbl\nend",
  "  local numones = {}\n  for i = 1, #arr do\n    numones[tostring(arr[i])] = numones[tostring(arr[i])]\
    \ + 1\n  end\n  local result = {}\n  for k in pairs(numones) do\n    table.insert(result,\
    \ tonumber(k))\n  end\n  table.sort(result)\n  return result\nend", "   if #arr\
    \ == 0 then\n      return arr\n   end\n   local largest = 0\n   local result =\
    \ {}\n   for i = 1, #arr do\n      if arr[i] > largest then\n         largest\
    \ = arr[i]\n      end\n      result[i] = largest\n   end\n   table.sort(result)\n\
    \   return result\nend", "  local results = {}\n  local done = {}\n  local pos\
    \ = 0\n  local len = #arr\n  for i = 1, len do\n    done[arr[pos]] = true\n  \
    \  pos = pos + 1\n  end\n  repeat\n    if pos > len then\n      break\n    end\n\
    \    local val = arr[pos]\n    pos = pos + 1\n    table.insert(results, val)\n\
    \    while pos > 0 and done[arr[pos - 1]] do\n      table.insert(results, arr[pos\
    \ - 1])\n      pos = pos - 1\n    end\n  until pos == len\n  table.sort(results)\n\
    \  return results\nend", "  -- The first number must be 1\n  if arr[1] > 0 then\n\
    \    -- Find largest and second largest numbers\n    local largest = arr[#arr]\n\
    \    local second_largest = arr[#arr]\n    -- Iterate over the rest of the numbers\n\
    \    for i = 2, #arr do\n      -- If the current number is 1 large, add it to\
    \ the largest\n      if arr[i] > largest then\n        second_largest = largest\n\
    \        largest = arr[i]\n      -- If the current number is 1 small, add it to\
    \ the second largest\n      elseif arr[i] < largest then\n        second_largest\
    \ = arr[i]\n      -- If current number is the same as largest, swap them\n   \
    \   else\n        largest, second_largest = arr[i], arr[i]\n      end\n    end\n\
    \    -- Swap them if necessary\n    if largest ~= second_largest then\n      arr[#arr],\
    \ arr[#arr + 1] = second_largest, largest\n    end\n  end\n  return arr\nend",
  "    return arr:gmatch(\n        function(x)\n            if x == \"1\" then return\
    \ 1 end\n            if x == \"-1\" then return -1 end\n            return tonumber(x)\n\
    \        end\n    )\nend", "\tlocal function compare_le(a,b)\n\t\tif a < b then\n\
    \t\t\treturn -1\n\t\telseif a > b then\n\t\t\treturn 1\n\t\telse\n\t\t\treturn\
    \ 0\n\t\tend\n\tend", "  -- Sort by number of ones.\n  local count_map = {}\n\
    \  for i = 1, #arr do\n    count_map[arr[i]] = count_map[arr[i]] + 1\n  end\n\
    \  -- Reverse to keep the order\n  count_map = table.reverse(count_map)\n  --\
    \ Sort the array by number of ones.\n  table.sort(arr,\n    function(_,x) return\
    \ count_map[x] end)", "  return arr.sort(function(a, b) return a < b end)\nend",
  "  local n = 0\n  local i = 0\n  local l = {}\n  local j = 1\n  local done = false",
  "    -- Sort the array in descending order of binary representations\n    local\
    \ ones = arr:gsub(\"%d+\", function()\n        local s = ''\n        for i=1,8\
    \ do\n            local v = 0\n            for j=1,8 do\n                v = v\
    \ + (j and arr:sub(i,i) or 0)\n            end\n            s = s .. string.format('%d',\
    \ v) .. '1'\n        end\n        return s\n    end)\n    local tens = arr:gsub(\"\
    %d+\", function()\n        local s = ''\n        for i=1,8 do\n            local\
    \ v = 0\n            for j=1,8 do\n                v = v + (j and arr:sub(i,i)\
    \ or 0)\n            end\n            s = s .. string.format('%d', v) .. '0'\n\
    \        end\n        return s\n    end)\n    local sorted = {}\n    local done\
    \ = {}\n    local i = 1\n    while i ~= #sorted do\n        local el = arr:sub(i,i)\n\
    \        if done[el] then break end\n        sorted[el] = i\n        done[el]\
    \ = true\n        local count = ones:find(el)\n        local dec = 0\n       \
    \ while count ~= 0 do\n            dec = dec + (count-1)\n            count =\
    \ ones:find(dec:sub(-1))\n        end\n        dec = dec * 10\n        if dec\
    \ < 0 then dec = 0 + dec end\n        local decstr = string.format('%d', dec)\n\
    \        local decstr = decstr:gsub('%d+%d%d%d%d%d%d%d%d%d%d', '%d%d%d%d%d%d%d%d%d%d%d%d%d')\n\
    \        local decstr = decstr:gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d', '%d')\n    \
    \    sorted = sorted:insert(decstr, el)\n        i = i + 1\n    end\n    sorted\
    \ = sorted:reverse()\n    return sorted\nend", "  local function compare(lhs,\
    \ rhs)\n    if lhs ~= rhs then\n      return lhs > rhs and 1 or -1\n    end\n\
    \    return 0\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  if #arr\
    \ == 0 then return arr end\n  if #arr == 1 then return {arr[#arr]}\n  local max_ones\
    \ = -math.pow(2,#arr)\n  local min_ones = math.pow(2,#arr)-1\n  local results\
    \ = {}\n  local min_decimal = math.pow(2,#arr)-1\n  for i=#arr, 1, -1 do\n   \
    \ local val = arr[i]\n    if val == 1 then\n      results[i] = arr[i]\n    elseif\
    \ val < 0 then\n      if val > min_ones then\n        local decimal = max_ones\
    \ - val\n        results[i] = decimal\n      end\n      results[i] = -1\n    else\n\
    \      local decimal = val\n      results[i] = decimal\n    end\n  end\n  for\
    \ i=#arr, 2, -1 do\n    local val = results[i]\n    if val > min_decimal then\n\
    \      results[i] = -1\n    end\n  end\n  return results\nend", "  if arr == nil\
    \ then\n    return nil\n  end", "    local function helper(arr, num)\n       \
    \ if num > 1 then\n            for i = 1, num do\n                local max =\
    \ table.max(arr, 1)\n                arr:insert(max)\n            end\n      \
    \  end\n        table.sort(arr) -- sort based on ascending\n        return arr\n\
    \    end", "  -- Write your code here\n  \n  local ones = #arr\n  local decimal\
    \ = 0\n  local decimal_place = 1\n  local decimals = #(arr:gsub(\"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
  "  return {}\nend", "  local i = 0\n  local j = 0\n  local l = #arr\n  -- The first\
    \ pass: count the number of 1s in each array element.\n  -- This takes linear\
    \ time.\n  -- For a long array, this might take O(n) time.\n  for i = 1, l do\n\
    \    arr[i] = arr[i] + 1\n  end\n  for i = 1, l do\n    -- The second pass: sort\
    \ the array elements from lowest to highest value.\n    local tmp = 0\n    local\
    \ max_index = i\n    local max_val = arr[i]\n    for j = i + 1, l do\n      if\
    \ arr[j] > max_val then\n        max_index = j\n        max_val = arr[j]\n   \
    \   end\n    end\n    arr[max_index] = arr[max_index] - 1\n    arr[max_index +\
    \ 1] = arr[max_index] + 1\n  end\n  -- The third pass: return the array in ascending\
    \ order.\n  -- This takes linear time O(n).\n  for i = 1, l do\n    arr[i] = arr[i\
    \ + 1] - 1\n  end\n  return arr\nend", "  local sorted_arr = {}\n  local i = 1\n\
    \  while i ~= #arr do\n    if sorted_arr[i] == nil then\n      sorted_arr[i] =\
    \ arr[i]\n    else\n      if arr[i] < sorted_arr[i] then\n        sorted_arr[i]\
    \ = arr[i]\n      elseif arr[i] > sorted_arr[i] then\n        sorted_arr[i] =\
    \ sorted_arr[i]\n      else\n        -- do nothing\n      end\n    end\n    i\
    \ = i + 1\n  end\n  return sorted_arr\nend", "    if #arr == 1 then\n        return\
    \ arr\n    end\n    local key = {}\n    local arr2 = {}\n    local i = 0\n   \
    \ local count = arr[1]\n    while i < #arr do\n        -- count number of 1 from\
    \ arr[i]\n        for j = i, #arr do\n            if arr[j] == 1 then count =\
    \ count + 1 end\n        end\n        -- set arr2[i]\n        arr2[i] = count\n\
    \        -- update i\n        i = i + 1\n        -- set count\n        count =\
    \ 1\n        -- set j\n        for j = i, #arr do\n            if arr[j] == 1\
    \ then count = count + 1 end\n        end\n        -- set arr[i]\n        arr[i]\
    \ = count\n    end\n    local key = {}\n    local i = 0\n    while i < #arr2 do\n\
    \        table.insert(key, arr2[i])\n        i = i + 1\n    end\n    table.sort(key)\n\
    \    local res\n    for i = 1, #key do\n        table.insert(res, arr[key[i]])\n\
    \    end\n    return res\nend", "    local i = 0\n    local j = 0\n    local temp\
    \ = 1\n    local count = #arr\n    local tmp = {0}\n    repeat\n        if i ==\
    \ 0 then\n            i = count - 1\n            j = count\n            temp =\
    \ 1\n        elseif arr[i] < arr[j] then\n            i = i + 1\n            if\
    \ i == count then\n                break\n            end\n        else\n    \
    \        j = j + 1\n            if j == count then\n                break\n  \
    \          end\n        end\n        if i == j then\n            temp = 1\n  \
    \      else\n            temp = temp * 2\n        end\n    until arr[i] ~= 1\n\
    \    repeat\n        if j > i then\n            arr[i - 1], arr[j] = arr[j], arr[i\
    \ - 1]\n            i = i - 1\n            j = j - 1\n            if j > i then\n\
    \                arr[i - 1], arr[j] = arr[j], arr[i - 1]\n                i =\
    \ i - 1\n            end\n            if i == j then\n                break\n\
    \            end\n        end\n        if i == count then\n            break\n\
    \        end\n    until i > j\n    return arr\nend", "  if arr == nil then return\
    \ nil end\n  local len = #arr\n  if len == 1 then return arr end\n  local arr\
    \ = setmetatable({}, { __index = arr })\n  for i = 1, len do\n    arr[i] = tonumber(arr[i])\n\
    \  end\n  arr.sorted = false\n  arr.key = nil\n  for i = 1, len do\n    if arr[i]\
    \ == 0 then\n      if tonumber(arr[i]) == tonumber(arr[i - 1]) then\n        arr[i]\
    \ = tonumber(arr[i - 1])\n      else\n        arr[arr.key] = arr[i]\n        arr.key\
    \ = i\n      end\n    end\n  end\n  -- Sorting ends here\n  if arr.key == nil\
    \ then\n    for i = 1, len do\n      arr[i] = arr[arr.key]\n    end\n  end\n \
    \ return arr\nend", "  assert(arr:len() > 0)\n  local is_zero = false\n  local\
    \ is_one = false\n  local is_last = false\n  local is_less = false\n  local is_sorted\
    \ = false\n  local last = arr:len()\n  while last > 1 do\n    if arr[last] ==\
    \ 1 then\n      arr[last] = -1\n      is_zero = is_zero or arr[last] == 0\n  \
    \    is_one = is_one or arr[last] == 1\n      is_last = is_last or arr[last] ==\
    \ last\n      assert(last > 1)\n      assert(is_last and arr[last - 1] == 0)\n\
    \      arr[last - 1] = -1\n      last -= 1\n    end\n    if is_zero then\n   \
    \   is_zero = false\n      is_last = is_last or arr[last] == last\n      arr[last]\
    \ = 0\n    elseif is_one then\n      is_one = false\n      is_last = is_last or\
    \ arr[last] == last\n      arr[last] = 1\n    elseif is_last then\n      is_last\
    \ = false\n      is_less = arr[last] > arr[last-1]\n      arr[last], arr[last-1]\
    \ = arr[last-1], arr[last]\n      if is_less then\n        arr[last], arr[last-1]\
    \ = arr[last-1], arr[last]\n      end\n    end\n    if is_less then\n      is_less\
    \ = false\n    end\n    is_sorted = is_sorted or arr[last] == last\n  end\n  assert(last\
    \ == 1 and arr[1] == 0)\n  assert(is_sorted, \"not sorted\")\n  return arr\nend",
  "    local i = 0\n    local j = 0\n    local l = #arr\n    local tmp", "  if #arr\
    \ == 0 then\n    return arr\n  end", "  -- sort ascending array elements\n  --\
    \ return nil if array is already sorted\n  if not is_sorted_array(arr) then\n\
    \    local count = count_ones(arr)\n    local index = 0\n    local swapped\n \
    \   local result = {}\n    while index < #arr and #result == 0 do\n      if count[index]\
    \ > 0 then\n        result[index] = arr[index]\n        count = count - arr[index]\n\
    \        if count == 0 then\n          arr[index] = 0\n          break\n     \
    \   end\n      end\n      index = index + 1\n    end\n    \n    -- sort decending\n\
    \    if #result > 0 then\n      index = 1\n      swapped = 0\n      repeat\n \
    \       if result[index] > arr[swapped] then\n          result[index], arr[swapped]\
    \ = arr[swapped], result[index]\n          index = index + 1\n        end\n  \
    \      swapped = swapped + 1\n      until swapped < #result\n      arr[swapped]\
    \ = arr[#result]\n      arr[#result] = 0\n    end\n  else\n    -- array is already\
    \ sorted\n  end\n  \n  return result\nend", "    local s = #arr\n    table.sort(arr,\
    \ function(t1, t2)\n        local s1 = t1 ~= 0\n        local s2 = t2 ~= 0\n \
    \       if s1 then\n            return s2\n        else\n            return t2\
    \ - t1\n        end\n    end)\n    return arr\nend", "  local ones = {}\n  local\
    \ decs = {}\n  -- Create table of zeros and ones to sort table of\n  -- the number\
    \ of ones in their binary representation\n  -- Initialize number of ones to 0\n\
    \  for i = 1, 8 do\n    ones[i] = 0\n  end\n  -- Initialize table of decimal values\
    \ of non-negative integers\n  -- from 1 to 2^(n-1).\n  for i = 1, 8 do\n    decs[i]\
    \ = 0\n  end\n  -- Iterate through tables of non-negative integers\n  for _, i\
    \ in pairs(arr) do\n    -- If number is negative or zero, skip it.\n    if i <\
    \ 0 then\n      continue\n    end\n    -- Get the binary representation of number\n\
    \    local bin_rep = debitii(i)\n    -- Increment number of ones in number's binary\
    \ representation\n    for j = 1, 8 do\n      ones[j] += bin_rep(j)\n    end\n\
    \    -- Get decimal representation of number\n    decs[i] = decs[i] + bin_rep(7)\
    \ - bin_rep(6)\n  end\n  -- Sort numbers in ascending order by number of ones\n\
    \  table.sort(ones)\n  -- Iterate through sorted numbers in ascending order\n\
    \  for i, _ in pairs(ones) do\n    -- Sort numbers in descending order by decimal\
    \ value\n    table.sort(decs, function(a, b)\n      if a > b then\n        return\
    \ -1\n      elseif a < b then\n        return 1\n      else\n        return 0\n\
    \      end\n    end)\n    -- Replace numbers in ascending order by decimal value\n\
    \    decs[i] = decs[i] + 1\n  end\n  -- Return array of sorted non-negative integers\n\
    \  return decs\nend", "   -- Convert array to binary string.\n   -- This can be\
    \ done with string.rep:\n   -- http://www.lua.org/pil/1.4.1/manual.html#3.4\n\
    \   -- str = (str:rep(\"1\", length))\n   -- Convert string to array of bits.\n\
    \   local bin = {}\n   for i = 1, #arr do\n      local binStr = \"\"\n      for\
    \ j = 1, 8 do\n\t local bit = string.byte(str, i, j)\n\t binStr = binStr..(bin:sub(1,\
    \ #bin)..bit)\n\t bin:insert(bit)\n      end\n      bin[#bin+1] = binStr\n   end",
  "  if #arr < 2 then\n    return arr\n  end\n  local maxi = math.max(arr:map(function(a)\
    \ return a end))\n  local maxv = 1\n  local minv = maxi + 1\n  local result =\
    \ {}\n  repeat\n    local i = -1\n    repeat\n      i = i + 1\n      local v =\
    \ arr[i]\n      if v < 0 then\n        break\n      end\n      local v = v - minv\n\
    \      if v > maxv then\n        maxv = v\n      end\n    until i == #arr\n  \
    \  table.insert(result, maxv + minv)\n  until maxi == #arr + 1\n  return result\n\
    end", "  local map = {}\n  local counts = {}", "  -- Initialize variables.\n \
    \ local nOnes, i, iMax = 0, 0, 0", "  if #arr == 1 then\n    return arr\n  end\n\
    \  local i, j, k, l = 1, #arr, #arr, 1, 0\n  local res = {arr[1]}\n  for i = 2,\
    \ #arr do\n    while l < k do\n      local m = math.pow(256, l)\n      if not\
    \ m or m < arr[i] then\n        j = k\n        k = l\n      else\n        j =\
    \ l\n      end\n      l = l + 1\n      local tmp = res[j]\n      res[j] = arr[i]\n\
    \      res[i] = tmp\n    end\n    k = k + 1\n    l = l + 1\n  end\n  return res\n\
    end", "  -- Sort arr by number of ones\n  local function count_ones(num)\n   \
    \ if num == nil then return 0 end\n    local count = 0\n    while num ~= 0 do\n\
    \      num = math.floor(num / 2)\n      count = count + 1\n    end\n    return\
    \ count\n  end\n  local num_ones = count_ones(arr[1])\n  local last_pos = 0\n\
    \  local pos = 0\n  for i = 2, #arr do\n    local num_ones_now = count_ones(arr[i])\n\
    \    if num_ones_now < num_ones then\n      table.insert(arr[last_pos:pos], arr[i])\n\
    \      last_pos = pos\n      pos = i\n    else\n      arr[pos] = arr[i]\n    \
    \  pos = pos + 1\n    end\n  end\n  table.insert(arr[last_pos:pos], arr[i])\n\
    \  return arr\nend", "    if arr then\n        local counts = {}\n        for\
    \ _, v in ipairs(arr) do\n            counts[v] = counts[v] or 0\n           \
    \ counts[v] = counts[v] + 1\n        end\n        for i = 1, #counts do\n    \
    \        counts[i] = counts[i] / 2\n        end\n        for _, v in pairs(counts)\
    \ do\n            counts[v] = v\n        end\n        table.sort(counts)\n   \
    \     for _, v in pairs(counts) do\n            arr[v] = v\n        end\n    end\n\
    \    return arr\nend", "  -- TODO: You should not use sort, because it is not\
    \ stable\n  -- This is not the place to implement a stable sort\n  -- Use merge\
    \ sort or another stable sort instead\n  -- ...\nend", "  -- The original array.\n\
    \  local arr = arr or {}", "  -- If number of ones is 0, then sort on decending\
    \ order.\n  if #arr == 0 then\n    return arr\n  end", "  local function get_zero_idxs(arr,\
    \ is_zero_vector, start_idx)\n    local zero_idxs = {}\n    local last_idx = start_idx\n\
    \    for i = start_idx, #arr do\n      if is_zero_vector[i] then\n        table.insert(zero_idxs,\
    \ last_idx)\n        last_idx = i + 1\n      end\n    end\n    return zero_idxs\n\
    \  end\n  local zero_idxs = get_zero_idxs(arr, unpack(reverse(arr)))\n  -- For\
    \ each zero vector, get all non-zero vectors until that zero vector is found.\n\
    \  -- We assume there is at least one non-zero vector, otherwise it's impossible\n\
    \  -- to sort an array without ones\n  local function next_non_zero_idxs(arr,\
    \ last_idx)\n    local zero_idxs = get_zero_idxs(arr, unpack(arr[last_idx:end]),\
    \ last_idx)\n    local non_zero_idxs = {}\n    for _, idxs in ipairs(zero_idxs)\
    \ do\n      local new_last_idx = last_idx\n      for _, idx in ipairs(idxs) do\n\
    \        table.insert(non_zero_idxs, new_last_idx)\n        new_last_idx = idx\
    \ + last_idx\n      end\n    end\n    table.sort(non_zero_idxs)\n    return non_zero_idxs\n\
    \  end\n  local non_zero_idxs = next_non_zero_idxs(arr, #arr)\n  -- For each non-zero\
    \ vector, sort the vectors in ascending order of their decimal values\n  -- This\
    \ algorithm is also called the Lomuto partition\n  -- It can be easily deduced\
    \ that the minimum number of partitions is log2(#zero_idxs)\n  local function\
    \ next_partitions(arr, zero_idxs, non_zero_idxs, last_idx)\n    local partitions\
    \ = {}\n    local last_non_zero_vector_idx = last_idx\n    for _, idxs in ipairs(non_zero_idxs)\
    \ do\n      local min_max_idxs = arr[idxs:last_idx+1]\n      local min_max_idxs_len\
    \ = #min_max_idxs\n      local partition = {}\n      table.insert(partition, min_max_idxs[1])\n\
    \      table.insert(partition, min_max_idxs[min_max_idxs_len])\n      partitions\
    \ = table.concat(partitions, partition, \" \")\n      last_non_zero_vector_idx\
    \ = idxs + last_non_zero_vector_idx\n    end\n    table.sort(partitions)\n   \
    \ return partitions\n  end\n  local partitions = next_partitions(arr, zero_idxs,\
    \ non_zero_idxs, #arr)\n  -- Return the partitioned array\n  return table.concat(partitions,\
    \ \" \")\nend", "  local sorted_array = {}\n  local size = #arr\n  for i = 1,\
    \ size do\n    local num_ones = 0\n    local decimal_value = 0\n    for j = 1,\
    \ #arr do\n      if arr[j] == 1 then\n        num_ones = num_ones + 1\n      else\n\
    \        decimal_value = decimal_value + arr[j]\n      end\n    end\n    decimal_value\
    \ = decimal_value / num_ones\n    table.insert(sorted_array, decimal_value)\n\
    \  end\n  table.sort(sorted_array)\n  return sorted_array\nend", "  local n =\
    \ 0\n  -- O(n) solution by counting ones in binary representation\n  -- O(n*log(n))\
    \ solution by counting ones in decimal representation\n  -- O(n) solution by counting\
    \ ones in decimal representation\n  -- O(n) solution by counting ones in binary\
    \ representation\n  for _, v in ipairs(arr) do\n    n = n + (v <= 0)\n  end\n\
    \  n = math.floor(n)\n  local k = {}\n  local v = 0\n  local m = #arr + 1\n  local\
    \ i = 1\n  while i <= n do\n    -- O(n) solution by counting ones in binary representation\n\
    \    for _ = i, m do\n      v = v + (arr[i] <= 0)\n    end\n    k = k + v\n  \
    \  v = 0\n    i = i + 1\n  end\n  -- O(n) solution by counting ones in decimal\
    \ representation\n  local r = {arr[1]}\n  for i = 2, m do\n    local a = arr[i]\n\
    \    for j = #r + 1, i, -1 do\n      local t = r[j]\n      r[j] = a\n      a =\
    \ t\n    end\n    r[i] = a\n  end\n  return r\nend", "  assert(#arr > 0, \"sort_array\
    \ called with an empty array\")\n  if #arr == 1 then\n    return arr\n  end\n\
    \  local t = {}\n  local i = 1\n  while i < #arr do\n    local n = #arr\n    while\
    \ i < n do\n      local m = i\n      while i + 1 < n and arr[i + 2] < arr[i] do\n\
    \        m = i + 1\n      end\n      if m < i then\n        t[#t + 1] = arr[i]\n\
    \        i = m\n      else\n        t[#t + 1] = arr[i + 1]\n        i = i + 1\n\
    \      end\n    end\n  end\n  return t\nend", "    local function helper(arr,\
    \ i, max)\n        -- Base case\n        if i == max then\n            table.sort(arr)\n\
    \            return\n        end\n        -- Find the first 1 before the first\
    \ 0\n        local pos = i + 1\n        while pos < max and arr[pos] == 0 do\n\
    \            pos = pos + 1\n        end\n        -- Move the first 1 forward\n\
    \        for j = i + 1, pos do\n            arr[j - 1], arr[j] = arr[j], arr[j\
    \ - 1]\n        end\n        helper(arr, pos + 1, max)\n    end\n    helper(arr,\
    \ 1, #arr)\n    return arr\nend", "    local t = {}\n    local i = 0\n    for\
    \ _ in arr:gmatch(\"%d*\") do\n        table.insert(t, i)\n        i = i + 1\n\
    \    end\n    table.sort(t)\n    return table.unpack(arr, table.unpack(t))\nend",
  "  return arr:sort(function (a, b)\n    local a_ones = a:tonumber() * (1 << (a +\
    \ 1):bitshift())\n    local b_ones = b:tonumber() * (1 << (b + 1):bitshift())\n\
    \    local a_num = a_ones >= b_ones\n    if a_num then\n      return a_ones -\
    \ b_ones\n    else\n      return b_ones - a_ones\n    end\n  end)\nend", "  --\
    \ This code solves the problem using sort.\n  --\n  -- The first step is to determine\
    \ all positions that need\n  -- sorting.\n  local positions = {}\n  local num_ones\
    \ = 2\n  for i = 1, #arr do\n    while num_ones and arr[i - num_ones] ~= 0 do\n\
    \      table.insert(positions, i - num_ones)\n      num_ones = num_ones - 1\n\
    \    end\n    num_ones = math.floor(math.log(num_ones, 2))\n  end", "  local tbl\
    \ = {}\n  local res = {}\n  for i = 1,#arr do\n    tbl[i] = #tbl\n  end\n  for\
    \ i = 2,#arr do\n    local tl = tbl[#tbl]\n    tbl[#tbl] = i\n    for j = 1,i\
    \ do\n      if tbl[tl] ~= tbl[#tbl] then\n        tl = tbl[tl]\n      end\n  \
    \    tbl[tl] = i\n    end\n    tbl[i] = tl\n  end\n  for i = 1,#arr do\n    res[#res+1]\
    \ = arr[i]\n  end\n  return res\nend", "   local tbl = {}\n   local res = {}\n\
    \   for i = 1, #arr do\n      local n = 0\n      local s = arr[i]\n      while\
    \ s and s > 1 do\n         n = n + 1\n         s = s >> 1\n      end\n      tbl[i]\
    \ = n\n   end\n   table.sort(tbl, function(a, b) return tbl[a] > tbl[b] end)\n\
    \   for i, v in ipairs(tbl) do\n      table.insert(res, arr[i])\n   end\n   return\
    \ res\nend", "  local function swap(i, j)\n    local t = arr[i]\n    arr[i] =\
    \ arr[j]\n    arr[j] = t\n  end", "  local function binary_search(a, x, lo, hi)\n\
    \    while lo < hi do\n      local mid = math.floor((lo + hi) / 2)\n      if a[mid]\
    \ < x then\n        lo = mid + 1 -- search smaller element\n      elseif a[mid]\
    \ > x then\n        hi = mid -- search larger element\n      else\n        return\
    \ mid\n      end\n    end\n    return lo\n  end", "  local arr = arr:sort()\n\
    \  -- sort by number of ones in binary representation\n  -- sort by decimal value\
    \ of number\n  -- sort by negative numbers before positive ones\n  return arr\n\
    end", "  return table.sort(\n    function(x, y)\n      -- Number of ones in binary\
    \ representation of x\n      local binx = tostring(x)\n      local cx = 1\n  \
    \    for i = 1, #binx do\n        if binx[i] == '1' then\n          cx = cx +\
    \ 1\n        end\n      end\n      -- Number of ones in binary representation\
    \ of y\n      local biny = tostring(y)\n      local cy = 1\n      for i = 1, #biny\
    \ do\n        if biny[i] == '1' then\n          cy = cy + 1\n        end\n   \
    \   end\n      -- Compare their binary representation\n      if cx > cy then\n\
    \        return 1\n      elseif cx < cy then\n        return -1\n      else\n\
    \        return 0\n      end\n    end\n  , arr\n  )\nend", "  -- Create a dictionary\
    \ of all ones\n  local ones = {}\n  for i = 1,#arr do\n    if ones[tostring(arr[i])]\
    \ == nil then\n      ones[tostring(arr[i])] = true\n    end\n  end\n  -- Create\
    \ a list of all ones\n  local ones_list = {}\n  for k,v in pairs(ones) do\n  \
    \  ones_list[k] = true\n  end\n  -- Sort the dictionary by number of ones\n  table.sort(ones_list,\
    \ function(a,b) return #a>#b end)\n  -- Sort the array by number of ones\n  for\
    \ i = 1,#arr do\n    if ones_list[tostring(arr[i])] == nil then\n      table.insert(arr,\
    \ arr[i])\n    end\n  end\n  -- Return the sorted array\n  return arr\nend", " \
    \   local function sort_pairs(arr)\n        table.sort(arr, function(a, b)\n \
    \           if a < b then\n                return -1\n            elseif a > b\
    \ then\n                return 1\n            else\n                return 0\n\
    \            end\n        end)\n    end\n    if type(arr) == \"table\" then\n\
    \        if type(arr.__index) == \"function\" then\n            -- arr is table\
    \ like object, so just return it\n            return arr\n        end\n      \
    \  sort_pairs(arr) -- sort elements in arr using sort_pairs\n    end\nend", " \
    \   if #arr == 1 then\n        return arr\n    end\n    local sorted = {}\n  \
    \  local cur = 0\n    local cur2 = 0\n    local n = 1\n    local m = #arr\n  \
    \  local flag = true\n    for i = 1, m do\n        flag = flag and arr[cur] ~=\
    \ 0\n        if flag then\n            sorted[#sorted + 1] = arr[cur]\n      \
    \      cur = cur + n\n            n = 1\n        else\n            n = n * 2\n\
    \            flag = true\n        end\n    end\n    sorted[#sorted + 1] = arr[cur]\n\
    \    return sorted\nend", "  local t = {}\n  local i = 0\n  for _ in arr do\n\
    \    t[i] = 0\n    i = i + 1\n  end\n  for _, v in ipairs(arr) do\n    t[v] =\
    \ t[v] + 1\n  end\n  for i = 2, #t do\n    if t[i] == 0 then\n      t[i] = t[i\
    \ - 1] + 1\n    elseif t[i] > t[i - 1] then\n      t[i] = t[i - 1] + 1\n    else\n\
    \      t[i] = t[i]\n    end\n  end\n  return table.unpack(t)\nend", "    local\
    \ res = {}\n    for idx = 1,#arr do\n        local bin = bin(arr[idx])\n     \
    \   local bin_len = #bin\n        if bin_len == 2 then\n            local ones_count\
    \ = tonumber(bin[1])\n            if ones_count ~= 0 then\n                res[#res+1]\
    \ = arr[idx]\n            end\n        else\n            local dec = decbin(bin)\n\
    \            if dec ~= \"\" then\n                local count = tonumber(dec)\n\
    \                if count ~= 0 then\n                    res[#res+1] = arr[idx]\n\
    \                end\n            end\n        end\n    end\n    return table.sort(res)\n\
    end", "  local tmp, tmp2\n  local len = #arr\n  local res = make_list(len)\n \
    \ local pos\n  local result\n  local pos2\n  local pos3\n  local pos4\n  for pos\
    \ = 1, len do\n    tmp2 = arr[pos]\n    pos3 = pos\n    pos = pos\n    local num1\
    \ = 0\n    local num2 = 0\n    while pos3 <= len do\n      if tmp2 == arr[pos3]\
    \ then\n        num1 = num1 + 1\n      elseif tmp2 > arr[pos3] then\n        num2\
    \ = num2 + 1\n      end\n      pos3 = pos3 + 1\n    end\n    if num1 > num2 then\n\
    \      result = result + tmp2\n      pos2 = pos3\n    elseif num1 < num2 then\n\
    \      result = result + tmp2\n    else\n      pos2 = pos3\n    end\n    pos4\
    \ = pos\n    while pos4 > 0 and pos4 > pos2 do\n      res[pos] = res[pos4-1]\n\
    \      pos = pos - 1\n      pos4 = pos4 - 1\n    end\n  end\n  while pos ~= 0\
    \ do\n    res[pos] = arr[pos]\n    pos = pos - 1\n  end\n  return res\nend", " \
    \ -- We want to sort elements using binary search, but there are few elements\n\
    \  -- that repeat themselves more than once.\n  -- This means that we can't just\
    \ use \"for val in arr\", as this will\n  -- skip repeated elements.\n  local\
    \ sorted_vals = {}\n  local max_val = nil\n  for idx, val in ipairs(arr) do\n\
    \    if max_val == nil then\n      max_val = val\n    else\n      if max_val <\
    \ val then\n        -- Swap max_val and val\n        local tmp, max_val = val,\
    \ max_val\n        max_val, val = val, max_val\n        arr[idx], arr[idx] = tmp,\
    \ max_val\n      end\n    end\n  end", "  if #arr == 1 then\n    return {arr[1]}\n\
    \  end\n  local ones = {}\n  local zeros = {}\n  for i = 1, #arr do\n    local\
    \ k = math.floor(math.log2(arr[i]))\n    if arr[i] >= 2^k then\n      table.insert(ones,\
    \ i)\n    else\n      table.insert(zeros, i)\n    end\n  end\n  table.sort(zeros,\
    \ function(a, b)\n    return math.fmod(b - a, 2) - math.fmod(a - b, 2)\n  end)\n\
    \  table.sort(ones, function(a, b)\n    return math.fmod(b - a, 2) - math.fmod(a\
    \ - b, 2)\n  end)\n  local results = {}\n  for i = 1, #ones do\n    table.insert(results,\
    \ arr[ones[i]])\n  end\n  for i = 1, #zeros do\n    table.insert(results, arr[zeros[i]])\n\
    \  end\n  return results\nend", "   for i = 1,#arr do\n      local ones = arr:bitCount(i)\n\
    \      if ones > arr[i-1] then\n         arr[i], arr[ones] = arr[ones], arr[i]\n\
    \      end\n   end\n   return arr\nend", "  local n = #arr\n  local i = 1\n  local\
    \ m = 0\n  local curr = arr[1]\n  while i <= n do\n    local next_curr = arr[i]\n\
    \    local diff = next_curr - curr\n    if diff == 0 then\n      m = m + 1\n \
    \   elseif diff > 0 then\n      m = m + 1\n      i = i\n    elseif diff < 0 then\n\
    \      i = i + 1\n      curr = next_curr\n    end\n  end\n  if m == 0 then\n \
    \   return arr\n  end\n  table.sort(arr, function(x, y)\n    if x ~= y then\n\
    \      if x > y then\n        return 1\n      else\n        return -1\n      end\n\
    \    end\n  end)\n  -- If the original array had even number of elements,\n  --\
    \ then the last element should be the last in the sorted\n  -- array.\n  if n\
    \ % 2 == 1 then\n    table.insert(arr, arr[#arr])\n  end\n  return arr\nend",
  "  local function compare(x, y)\n    -- If x has greater number of ones, return\
    \ 1\n    if x > y then\n      return 1\n    end\n    -- If y has greater number\
    \ of ones, return -1\n    if x > y then\n      return -1\n    end\n    -- If x\
    \ has equal number of ones and y has equal number of ones, sort based on decimal\
    \ value\n    if x == y then\n      return x\n    end\n    -- If x has equal number\
    \ of ones and y has greater number of ones, sort based on decimal value\n    if\
    \ x < y then\n      return -1\n    end\n    -- If x has greater number of ones\
    \ and y has equal number of ones, sort based on decimal value\n    return 1\n\
    \  end\n  table.sort(arr, compare)\n  return arr\nend", "  local s = { }\n  local\
    \ j = 1\n  for i = 1, #arr do\n    table.insert(s, 0)\n    while j > 0 and arr[i]\
    \ > 1 do\n      table.insert(s, arr[j])\n      arr[j] = arr[i]\n      j = (j -\
    \ 1) / 2\n    end\n    table.insert(s, arr[j])\n    arr[j] = arr[i]\n    j = j\
    \ + 1\n  end\n  return arr\nend", "    local function one_in_a_row(bitmap)\n \
    \       local sorted_bitmap = table.empty\n        for i = 1, #bitmap do\n   \
    \         if bitmap[i] > 0 then\n                table.insert(sorted_bitmap, i)\n\
    \            end\n        end\n        return sorted_bitmap\n    end", "  return\
    \ table.sort(\n    arr,\n    function(x, y)\n      if x == y then\n        return\
    \ 0\n      end", "  assert(type(arr) == 'table')\n  local function compare(arr1,\
    \ arr2)\n    local ones = 0\n    for i = 1, #arr1 do\n      if arr1[i] == 1 then\
    \ ones = ones + 1 end\n    end\n    ones = math.pow(10, math.ceil(math.log10(ones)))\n\
    \    local sort1 = math.floor(ones * math.pow(10, math.floor(math.log10(#arr1))))\n\
    \    local sort2 = math.floor(ones * math.pow(10, math.floor(math.log10(#arr2))))\n\
    \    if #arr1 <= #arr2 then\n      return sort1\n    else\n      return sort2\n\
    \    end\n  end\n  return table.sort(arr, compare)\nend", "  return arr:sort(function(a,\
    \ b) return (num_bits(a) > num_bits(b)) end)\nend", "  -- Sort base on number\
    \ of ones\n  -- Sort base on decimal value\n  -- Sort base on value\n  local function\
    \ ones(x)\n    return #string.format(\"%#b\"):format(x) % 2 ~= '0'\n  end\n  return\
    \ table.sort(\n    arr,\n    function(a, b)\n      if type(a) ~= 'number' or type(b)\
    \ ~= 'number' then return nil end\n      if a == b then return 0 end\n      if\
    \ ones(a) == ones(b) then\n        return tonumber(string.format(\"%2.d\", a))\
    \ > tonumber(string.format(\"%2.d\", b))\n      else\n        return tonumber(string.format(\"\
    %2.d\", a)) < tonumber(string.format(\"%2.d\", b))\n      end\n    end\n  )\n\
    end", "  -- Convert to binary representation.\n  local binary_table = arr:map(function(x)\n\
    \    return string.char(x)\n  end)\n  table.sort(binary_table)\n  -- Convert back\
    \ to decimal representation.\n  local decimal_table = binary_table:map(function(x)\n\
    \    return string.byte(x)\n  end)\n  -- Remove duplicate values.\n  table.sort(decimal_table)\n\
    \  -- Return sorted array.\n  return decimal_table\nend", "    return table.sort(\n\
    \        function(t1, t2)\n            if t1.ones == t2.ones then\n          \
    \      return t1.value - t2.value\n            else\n                return t1.ones\
    \ - t2.ones\n            end\n        end,\n        arr\n    )\nend", "    if\
    \ type(arr) ~= 'table' then\n        print('ERROR: function should recieve a table!')\n\
    \        return\n    end", '  if arr == nil then return end', "  local sorted_table\
    \ = {}\n  local i = 0\n  local max_num_zeros = -math.floor(math.log10(#arr))\n\
    \  local num_zeros = 0\n  while i < #arr do\n    local num = arr[i]\n    num_zeros\
    \ = num_zeros + math.abs(num)\n    if num == 0 then\n      num_zeros = num_zeros\
    \ - 1\n      if num_zeros < max_num_zeros then\n        i = i + 1\n      else\n\
    \        sorted_table[i] = arr[i]\n        i, num_zeros = i + 1, 0\n      end\n\
    \    else\n      i = i + 1\n    end\n  end\n  return sorted_table\nend", "   \
    \ local function sort(i, last)\n        if i == last then\n            return\
    \ {}\n        else\n            local last = arr[i]\n            local count =\
    \ 0\n            for j = i+1,last do\n                if arr[j] == last then\n\
    \                    count = count + 1\n                elseif arr[j] > last then\n\
    \                    break\n                else\n                    count =\
    \ count + 1\n                end\n            end\n            \n            if\
    \ count <= 1 then\n                return {last = arr[i]}\n            else\n\
    \                local half = count / 2\n                return {last = arr[i],\
    \ sort(i, half), sort(half, last)}\n            end\n        end\n    end\n  \
    \  \n    return sort(1, #arr)\nend", "  -- Your code here\n  -- return arr\nend\n\
    print(sort_array({1, 5, 2, 3, 4})) -- Sort the array\nprint(sort_array({-2, -3,\
    \ -4, -5, -6})) -- Sort the array\nprint(sort_array({1, 0, 2, 3, 4})) -- Sort\
    \ the array\n</cell>\n<cell>", "  local num_ones = {}\n  for i = 1, #arr do\n\
    \    -- Count number of 1's in binary representation of i\n    local bin = math.floor(i):bitpos(2)\n\
    \    local ones = bin:lshift(1) -- Shift 1's of i to the left so we have one less\
    \ bit to count.\n    -- Store in dictionary\n    if not num_ones[ones] then\n\
    \      num_ones[ones] = 1\n    else\n      num_ones[ones] += 1\n    end\n  end\n\
    \  -- Sort based on number of ones\n  table.sort(num_ones)\n  -- Sort based on\
    \ number of ones in descending order\n  table.sort(num_ones, function(a,b)\n \
    \   if a > b then\n      return 1\n    elseif b > a then\n      return -1\n  \
    \  else\n      return 0\n    end\n  end)\n  -- Return sorted array\n  -- >>> sort_array({1,\
    \ 5, 2, 3, 4})\n  -- {1, 2, 3, 4, 5}\n  -- >>> sort_array({-2, -3, -4, -5, -6})\n\
    \  -- {-6, -5, -4, -3, -2}\n  -- >>> sort_array({1, 0, 2, 3, 4})\n  -- {0, 1,\
    \ 2, 3, 4}\n  return map(1, num_ones)\nend", "  if #arr == 0 then\n    return\
    \ nil\n  end\n  local n = 0\n  local max = 0\n  local m = 1\n  local t = {}\n\
    \  for i = 1, #arr do\n    if arr[i] < 0 then\n      arr[i] = -arr[i]\n      arr[i]\
    \ = arr[i]^m\n    else\n      n = n + 1\n      m = m << 1\n      if m > max then\n\
    \        max = m\n      end\n    end\n    t[i] = arr[i]\n  end\n  table.sort(t)\n\
    \  arr[t[1]] = t[1]\n  arr[t[n]] = t[n]\n  for i = 2, #t do\n    arr[t[i]] = t[i-1]\n\
    \  end\n  return arr\nend", "  local function helper(arr)\n    local t = {}\n\
    \    for _, val in ipairs(arr) do\n      if val == 1 then\n        table.insert(t,\
    \ val)\n      else\n        table.insert(t, val * 10)\n      end\n    end\n  \
    \  table.sort(t)\n  end\n  if #arr == 0 then\n    return {}\n  end\n  helper(arr)\n\
    \  return arr\nend", "  -- sort\n  table.sort(arr)\n  -- swap 0 and 1 to the end\n\
    \  local len = #arr\n  for i = 1, len do\n    local j = len - i - 1\n    if arr[j]\
    \ == 0 and arr[j + 1] == 1 then\n      table.move(arr, j, j + 2)\n      arr[j]\
    \ = arr[j + 1]\n      arr[j + 1] = 1\n    end\n  end\n  -- reverse the order of\
    \ the rest\n  for i = 1, len do\n    if arr[i] == 0 then\n      local j = len\
    \ - i - 1\n      table.move(arr, j, j + 1)\n      arr[j] = arr[j + 1]\n      arr[j\
    \ + 1] = 0\n    end\n  end\n  return arr\nend", "  local sorted_arr = {}\n  --\
    \ Sort from biggest to smallest\n  for i = #arr, 1, -1 do\n    sorted_arr[#sorted_arr\
    \ + 1] = arr[i]\n  end\n  return sorted_arr\nend", "  return arr:map(function(x)\n\
    \    local a = x:bit()\n    local b = 1\n    for i = 2, 32 do\n      if a then\
    \ break end\n      b = b << 1\n    end\n    return b * 10 + a\n  end)\nend", " \
    \ -- sorts arrays in place\n  arr:sort()", "  local key\n  local output = {}\n\
    \  for key, value in pairs(arr) do\n    table.insert(output, value)\n  end", " \
    \ local function compare(a, b)\n    if a < b then\n      return -1\n    else if\
    \ a == b then\n      return 0\n    else\n      return 1\n    end\n  end", "  if\
    \ #arr == 1 then\n    return arr\n  elseif #arr == 2 then\n    return arr.sort(function(a,\
    \ b) return a == b end)\n  elseif #arr % 2 == 0 then\n    return arr.sort(function(a,\
    \ b) return a < b end)\n  else\n    return arr.sort(function(a, b) return a >\
    \ b end)\n  end\nend", "  local len = #arr\n  local half = math.floor(len / 2)\n\
    \  if len % 2 == 0 then\n    table.sort(arr,\n      function(_, i)\n        return\
    \ arr[i] <= arr[half] and arr[half] or arr[i] >= arr[half] and arr[half] or arr[i]\n\
    \      end)\n  else\n    table.sort(arr,\n      function(_, i)\n        return\
    \ arr[i] <= arr[half] and arr[half] or arr[i] >= arr[half] and arr[half] or arr[i]\n\
    \      end)\n  end\n  return arr\nend\n</code>\nAnd this is my solution:\n<code>",
  "    -- start by sorting the array\n    for index = #arr, 1, -1 do\n        -- store\
    \ current value\n        local tmp = arr[index]\n        -- get number of 1's\
    \ in current value\n        local count_ones = dec2bin(tmp):len()\n        --\
    \ check if binary representation has same amount of 1's\n        if count_ones\
    \ ~= 1 then\n            -- get number of 1's\n            local count_zeros =\
    \ count_ones - 1\n            -- if count_zeros is bigger than 0, reverse current\
    \ value\n            if count_zeros ~= 0 then\n                -- swap current\
    \ value\n                arr[index] = dec2bin(tmp):reverse():reverse()\n     \
    \       else\n                -- reverse current value\n                arr[index]\
    \ = dec2bin(tmp):reverse()\n            end\n        else\n            -- swap\
    \ current value\n            arr[index] = dec2bin(tmp)\n        end\n    end\n\
    \    -- return sorted array\n    return arr\nend", "  -- Create array to store\
    \ numbers to be sorted\n  local t = {}\n  for k,v in pairs(arr) do\n    -- Get\
    \ number of ones in binary representation of v\n    local n = v\n    while n and\
    \ n ~= 0 do\n      n = n >> 1\n    end\n    -- If no one in binary representation,\
    \ put it in v\n    if n == 0 then\n      t[k] = v\n    end\n  end\n  -- Sort t\
    \ based on number of ones in binary representation\n  table.sort(t, function(a,b)\
    \ return count_ones(a) < count_ones(b) end)\n  -- Put numbers in arr back to their\
    \ original positions\n  local i = 1\n  for k,v in pairs(t) do\n    arr[i] = v\n\
    \    i = i + 1\n  end\n  return arr\nend", "  local num_ones = 0\n  local num_negative\
    \ = 0\n  local num_zeros = 0\n  local num_sorted_zeros = 0\n  local sorted_zeros\
    \ = {}\n  -- Count the number of ones\n  for _, el in pairs(arr) do\n    local\
    \ is_positive = el:byte() >= 0\n    local is_zero = el:byte() ~= 0\n    if is_positive\
    \ then\n      num_ones = num_ones + 1\n    elseif is_zero then\n      num_zeros\
    \ = num_zeros + 1\n    else\n      num_negative = num_negative + 1\n    end\n\
    \  end\n  -- Sort the array in descending order when number of ones are equal\n\
    \  if num_ones == num_zeros then\n    -- The array is all zeros\n    if num_negative\
    \ > 0 then\n      -- The array has negative numbers in it\n      sorted_zeros\
    \ = arr:reverse()\n    else\n      -- The array has only positive numbers in it\n\
    \      sorted_zeros = {}\n      num_zeros = num_ones\n    end\n  else\n    --\
    \ Sort the array in descending order when number of ones are different\n    --\
    \ Sort the array by descending order when number of ones are equal\n    if num_ones\
    \ > num_zeros then\n      -- The array has more ones\n      sorted_zeros = arr:reverse()\n\
    \    else\n      -- The array has fewer ones\n      sorted_zeros = {}\n      num_zeros\
    \ = num_ones\n    end\n    -- Sort the array by descending order when number of\
    \ negatives are equal\n    if num_negative > 0 then\n      -- The array has more\
    \ negatives\n      sorted_zeros = sorted_zeros:reverse()\n    end\n  end\n  return\
    \ sorted_zeros\nend", "  -- Build a binary tree of positive and negative numbers\n\
    \  local function build_tree(arr)\n    if #arr == 0 then return {} end", "   \
    \ local i, j = 2, 1\n    while i < #arr do\n        local m = i - 1\n        while\
    \ j > 0 and m < #arr and arr[m] == 0 do\n            m = m + 1\n        end\n\
    \        arr[i], arr[m] = arr[m], arr[i]\n        i = m + 1\n        j = math.abs(arr[i\
    \ - 1])\n    end\nend\n</code>\nI tested the solution against a larger set of\
    \ tests provided by Wikipedia.\n<|/ a tags=sorting,lua |>\n<| c |>\nThanks for\
    \ the detailed answer, which also helped me to understand my mistake.\n<|/ c |>\n\
    <| a dscore=1 |>\nThere are some problems with your code:", "    if arr == nil\
    \ then\n        return nil\n    end\n    local n = #arr\n    local i, j, l, h,\
    \ t\n    local table = {}\n    local num_one = 0\n    for i = 1, n do\n      \
    \  t = arr[i]\n        if t == 1 then\n            num_one = num_one + 1\n   \
    \     else\n            num_one = 0\n        end\n        table.insert(table,\
    \ t)\n    end\n    if num_one == 1 then\n        table.sort(function(a, b) return\
    \ a - b end)\n    else\n        table.sort(function(a, b) return num_one - num_one_to_power[#num_one_to_power]\
    \ end)\n    end\n    table.insert(table, -1)\n    table.sort(function(a, b) return\
    \ a[#a] - b[#b] end)\n    return table\nend", "  -- Write your code here\n  --\
    \ Hint: You need to use \"select\" statement, which is used to choose value from\
    \ one table or another.\n  -- For more details see \"select\" statement documentation:\n\
    \  -- https://www.lua.org/pil/3.3.html\n  return nil\nend", '  if #arr < 2 then
    return arr end', "  -- sort by number of ones in their binary representation in\
    \ ascending order\n  -- For similar number of ones, sort based on decimal value\n\
    \  -- We compare the decimal values by comparing the binary representation and\
    \ if they match, that's the result.\n  local function comp(a, b)\n    -- Convert\
    \ to binary string representation\n    local bin_a = base10.decimal(a)\n    local\
    \ bin_b = base10.decimal(b)\n    -- Compare the binary representations and if\
    \ they match, return the result\n    return bin_a < bin_b and -1 or bin_a > bin_b\
    \ and 1 or 0\n  end\n  -- Sort array in ascending order\n  table.sort(arr, comp)\n\
    \  return arr\nend", "  -- We start with a naive implementation of O(n^2) algorithm:\n\
    \  -- We start iterating from the 1st element of arr, and compare each element\
    \ with each other.\n  -- At the same time, we record how many ones are in each\
    \ bin\n  -- In a second pass, we sort the bins by descending number of ones.\n\
    \  -- Then, we return the resulting list\n  local counts = {}\n  for i = 1, #arr\
    \ do\n    local bin = string.char(arr[i])\n    counts[bin] = counts[bin] or 0\n\
    \    counts[bin] = counts[bin] + 1\n  end\n  local bins = #counts\n  table.sort(counts)\n\
    \  for i = 0, bins do\n    if counts[i] == 0 then\n      break\n    end\n  end\n\
    \  local result = {}\n  for i = 1, bins do\n    local bin = string.char(arr[i])\n\
    \    result[#result+1] = bin\n  end\n  return result\nend", "  local results =\
    \ {}\n  local i = 1", "  local t = {}\n  local i = 1\n  -- We use binary search\
    \ for sorted array\n  for i = #arr, 1, -1 do\n    table.insert(t, tonumber(tostring(arr[i])))\n\
    \  end\n  -- Binary search begins\n  i = #arr\n  while i > 0 do\n    -- We check\
    \ if current number is lower than median\n    if t[i] < t[math.floor((i-1)/2)]\
    \ then\n      -- If so, swap it with median number\n      t[math.floor((i-1)/2)],\
    \ t[i] = t[i], t[math.floor((i-1)/2)] -- This line is just to replace last two\
    \ elements instead of deleting them\n    end\n    -- Remove element from array\n\
    \    arr[i] = arr[i-1]\n    i = i -1\n  end\n  return t\nend", "    local function\
    \ comparator(a, b)\n        local n1, n2 = tonumber(a), tonumber(b)\n        if\
    \ n1 < n2 then return -1 else return 1 end\n    end\n    table.sort(arr, comparator)\n\
    \    return arr\nend", "  if #arr <= 0 then\n    return arr\n  end\n  local results\
    \ = {}\n  for i = 2, #arr do\n    local ones_count = #arr - i\n    local decimal_count\
    \ = math.floor(math.log(ones_count, 2) - 1)\n    table.insert(results, (decimal_count\
    \ - 1) * math.pow(10, decimal_count) + ones_count)\n  end\n  table.sort(results,\
    \ function (a, b)\n    if a <= b then\n      return false\n    else\n      return\
    \ true\n    end\n  end)\n  return results\nend", "  -- arr is empty or has only\
    \ 0s or 1s\n  if #arr <= 1 then\n    return arr\n  else\n    -- Use count vector\
    \ to count number of ones in arr\n    local counts = table.new_with_copy(arr)\n\
    \    for i = 1, #arr do\n      counts[arr[i]] = counts[arr[i]] + 1\n    end",
  "  if #arr == 0 then\n    return arr\n  end\n  if #arr == 1 then\n    return {arr[1]}\n\
    \  end\n  local max_value = 2^31 - 1\n  local min_index = 1\n  local max_index\
    \ = 1\n  local i, j, tmp\n  for i = 2, #arr do\n    local value = arr[i]\n   \
    \ if value < 0 then\n      value = -value - 1\n    end\n    j = i - 1\n    while\
    \ j > 0 and value < arr[j] do\n      arr[j] = arr[j - 1]\n      j = j - 1\n  \
    \  end\n    arr[j] = value\n    if value == 0 then\n      min_index = min_index\
    \ + 1\n      max_index = max_index + 1\n    else\n      min_index = min_index\
    \ + value\n      max_index = max_index + value\n    end\n  end\n  tmp = {}\n \
    \ for i = min_index, 1, -1 do\n    table.insert(tmp, arr[i])\n  end\n  table.sort(tmp)\n\
    \  for i = 1, #tmp do\n    arr[i] = tmp[i - 1]\n  end\n  return arr\nend", " \
    \ -- sort by binary length\n  arr.sort(function(a,b) return bit.lt(a, b) end)\n\
    \  -- sort by decimal length\n  arr.sort(function(a,b) return bit.lt(tonumber(tostring(b)),\
    \ tonumber(tostring(a))) end)\n  -- return result\n  return arr\nend", "  -- Convert\
    \ to array and sort in-place.\n  arr:gsub('.', function(num)\n    local s = tonumber(num)\n\
    \    if not s then return nil end\n    if s ~= 0 and s ~= 1 then return nil end\n\
    \    return num\n  end)\n  arr.sort()", "    local sort_arr = {}\n    local i\
    \ = 1\n    for elem in arr do\n        if elem[1] <= 0 then\n            table.insert(sort_arr,\
    \ i - 1)\n            i = i + 1\n        else\n            table.insert(sort_arr,\
    \ elem[1])\n        end\n    end\n    return sort_arr\nend", "  -- For simplicity\
    \ of implementation, sort keys in decreasing order.\n  -- This also simplifies\
    \ algorithm to O(log(N) instead of N).\n  table.sort(arr, function(a, b)\n   \
    \ if a > b then return 1 end\n    if a < b then return -1 end\n    -- Otherwise,\
    \ sort keys numerically.\n    return a\n  end)\n  return arr\nend", "  local ones\
    \ = {}\n  local zeros = {}\n  for i = 1, #arr do\n    if arr[i] ~= 0 then\n  \
    \    table.insert(zeros, i)\n    else\n      table.insert(ones, i)\n    end\n\
    \  end\n  table.sort(zeros, compare)\n  table.sort(ones, compare)\n  table.sort(ones,\
    \ compare)\n  local i, sum, index = {}, 0, 1\n  repeat\n    if table.remove(i)~=0\
    \ then\n      sum = sum + index\n    end\n    table.insert(i, sum)\n    index\
    \ = index + 1\n  until #zeros == 0\n  table.sort(ones, compare)\n  table.sort(zeros,\
    \ compare)\n  table.insert(arr, table.concat(zeros, 1))\n  return arr\nend", " \
    \ local function cmp(a, b)\n    if a == 0 then return a else b end\n    return\
    \ a<b and -1 or 1\n  end\n  table.sort(arr, cmp)\n  return arr\nend", "  return\
    \ table.sort(\n    arr,\n    function(a, b)\n      if a['bits'] > b['bits'] then\n\
    \        return true\n      elseif a['bits'] < b['bits'] then\n        return\
    \ false\n      elseif a['decimal'] > b['decimal'] then\n        return true\n\
    \      elseif a['decimal'] < b['decimal'] then\n        return false\n      else\n\
    \        return a['number'] > b['number']\n      end\n    end\n  )\nend", "  local\
    \ function sort(x)\n    local i = x\n    local j = 1\n    while true do\n    \
    \  i = i * 2 + j\n      j = j + 1\n      if i > #arr then break end\n      local\
    \ tmp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = tmp\n    end\n  end\n  sort(arr[1],\
    \ arr[2])\n  sort(arr[2], arr[3])\n  sort(arr[3], arr[4])\n  sort(arr[4], arr[5])\n\
    \  sort(arr[5], arr[6])\n  sort(arr[6], arr[1])\n  return arr\nend", "  local\
    \ n = #arr\n  -- Create dictionary for counting number of ones in binary representation.\n\
    \  local ones = setmetatable({}, {__mode=\"k\"})\n  for i = 1, n do\n    ones[twos(arr[i])]\
    \ = ones[twos(arr[i])] + 1\n  end\n  -- Create dictionary for sorting.\n  local\
    \ result = {}\n  local sorted = {}\n  for i = 2, n do\n    sorted[arr[i]] = i\n\
    \  end\n  for i = 1, n do\n    -- Get index for minimal value.\n    local index\
    \ = sorted[arr[i]]\n    local val = arr[i]\n    -- Insert that value into result\
    \ table.\n    result[index] = val\n    -- And move the rest of elements after\
    \ it to correct position.\n    for j = i + 1, n do\n      table.insert(sorted,\
    \ arr[j])\n    end\n  end\n  -- Return result table.\n  return result\nend", " \
    \ if arr == nil then return nil end\n  local function bin2dec(bin)\n    local\
    \ dec, i = 0, 0\n    for n in string.gmatch(bin, \"%d+\") do\n      dec = dec\
    \ + (n and n or 0) * power2\n      i = i + 1\n    end\n    return dec\n  end\n\
    \  -- arr is guaranteed to have at least one element.\n  local bin = arr[1]\n\
    \  -- The second element must be binary representation of positive integer,\n\
    \  -- so all positive integers in arr are binary representations of positive\n\
    \  -- integers.\n  if string.sub(bin, 1, 1) == \"1\" then\n    local dec = bin2dec(bin)\n\
    \    local arr2 = {}\n    local i = 1\n    repeat arr2[i] = arr[i - 1] until i\
    \ <= #arr\n    table.sort(arr2, function(a, b)\n      -- If there is more than\
    \ one ones in binary representation\n      -- then we sort based on decimal value.\n\
    \      if string.sub(bin, i - 1, i) == \"1\" then\n        return dec - bin2dec(a)\n\
    \      end\n      return bin2dec(a) - bin2dec(b)\n    end)\n  end\n  return arr\n\
    end", "    local comp = function(a, b) return a < b end\n    local sort = table.sort\
    \ or function(t) table.sort(t) end\n    return sort(comp, arr)\nend", "  -- Initialize\
    \ sorted array and binary count for each number.\n  -- For example, for array\
    \ {1, 3, 6, 4, 5}, count = {1, 3, 1, 3, 2}.\n  -- First, populate sorted array\
    \ with all possible binary representation.\n  local sorted_arr = {}\n  for i =\
    \ 1, #arr do\n    local count = 0\n    sorted_arr[#sorted_arr + 1] = i\n    for\
    \ j = 1, #arr do\n      if arr[j] == i then\n        count = count + 1\n     \
    \ else\n        break\n      end\n    end\n    sorted_arr[#sorted_arr + 1] = count\n\
    \  end", "  if #arr == 0 then return arr end\n  local tmp = {}\n  for _, i in\
    \ ipairs(arr) do\n    table.insert(tmp, i)\n  end\n  table.sort(tmp, function(a,\
    \ b)\n    return tonumber(string.format(\"%#011b\", a)) < tonumber(string.format(\"\
    %#011b\", b))\n  end)\n  local result = {unpack(tmp, 1, math.min(#tmp, 8))}\n\
    \  table.sort(result)\n  return result\nend", "  -- Base case\n  if #arr == 1\
    \ then\n    return arr\n  else\n    local pivot = math.ceil(math.log2(math.abs(arr[#arr])))\n\
    \    local pivot = arr[pivot]\n    local left = {}\n    local right = {}\n   \
    \ for i = 1, #arr do\n      if i < pivot then\n        table.insert(left, arr[i])\n\
    \      elseif i == pivot then\n        table.insert(left, pivot)\n      else\n\
    \        table.insert(right, arr[i])\n      end\n    end\n    return sort_array(left)\
    \ + sort_array(right)\n  end\nend", "    local function cmp(v)\n        local\
    \ vbin = v and bit.rshift(v, 1)\n        if vbin and vbin == 1 then\n        \
    \    return v\n        end\n        return tonumber(tostring(v))\n    end", " \
    \   if #arr == 0 then\n        return {}\n    end\n    local n = #arr\n    local\
    \ t = {n}\n    for i = 1, n do\n        t[i] = 0\n    end\n    for i = 1, n do\n\
    \        t[tobits(arr[i])] = i\n    end\n    table.sort(t, function(a, b)\n  \
    \      return t[a] - t[b]\n    end)\n    local ret = [1]\n    for i = 1, n do\n\
    \        ret[#ret + 1] = arr[t[i]]\n    end\n    return ret\nend", "  -- Sort\
    \ by number of ones\n  local n = #arr\n  for i = 2, n do\n    local n1 = arr[i]\n\
    \    local n2 = arr[i-1]\n    if n1 > n2 then\n      arr[i] = n2\n      arr[i-1]\
    \ = n1 -- swap\n    end\n  end\n  -- Sort by value\n  -- This part is tricky\n\
    \  -- Note that arr[i] = arr[i] < arr[i+1] returns true\n  -- if arr[i] is less\
    \ than arr[i+1].\n  --\n  -- In our case, we assume that the values are sorted\
    \ in ascending order\n  -- because it is easy to implement.\n  local i = 1\n \
    \ while i <= n do\n    local j = i\n    local k = n - 1\n    while k >= 0 do\n\
    \      if arr[j] < arr[k] then\n        arr[j], arr[k] = arr[k], arr[j]\n    \
    \    j = k\n      elseif arr[j] == arr[k] then\n        k = k - 1\n      else\n\
    \        break\n      end\n    end\n    i = j + 1\n  end\n  return arr\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
